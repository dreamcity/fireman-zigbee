###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    19/Mar/2013  19:57:44 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \hal\target\CC2430EB\hal_key.c                     #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\. #
#                          .\..\..\Tools\CC2430DB\f8wEndev.cfg" (-DCPU32MHZ   #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_OPT_FFD=0 -DBLINK_LEDS "-DCONST=const        #
#                          __code" -DGENERIC=__generic) -f "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\Tools #
#                          \CC2430DB\f8wConfig.cfg" (-DSECURE=0               #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\hal\targ #
#                          et\CC2430EB\hal_key.c" -D CC2430EB -D AXD_END -D   #
#                          AXD_END_B -D NWK_AUTO_POLL -D REFLECTOR -D         #
#                          xZTOOL_P1 -D xMT_TASK -D xMT_ZDO_FUNC -D           #
#                          xLCD_SUPPORTED=DEBUG -D xPOWER_SAVING -lC          #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\cc2430-zstack-adxl345\CC2430DB\ENDD #
#                          evice2EB\List\" -lA "C:\Texas                      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\ENDDevice2EB\L #
#                          ist\" --diag_suppress Pe001,Pa010 --diag_remark    #
#                          pe550 -o "C:\Texas Instruments\ZStack-1.4.3-1.2.1\ #
#                          Projects\zstack\Samples\cc2430-zstack-adxl345\CC24 #
#                          30DB\ENDDevice2EB\Obj\" -e --require_prototypes    #
#                          -z2 --no_cse --no_unroll --no_inline               #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs 8  #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\" #
#                           -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Proje #
#                          cts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\ #
#                          ..\SOURCE\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\Drivers\"   #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\. #
#                          .\..\..\ZMAIN\TI2430DB\" -I "C:\Texas              #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MT\" -I "C:\Texas                      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\INCLUDE\" -I "C:\Texas             #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\TARGET\CC2430EB\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\OSAL\INCLUDE\" -I "C:\Texas            #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\AF\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\NWK\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SEC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SYS\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\ZDO\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\ZMAC\F8W\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\ZMAC\" -I "C:\Texas                    #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SADDR\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SDATA\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\INCLUDE\" -I "C:\Texas             #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\HIGH_LEVEL\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\LOW_LEVEL\SRF03\SINGLE_CHIP\" -I   #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          4.0 Evaluation version\8051\INC\" -I "C:\Program   #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\CC2430DB\ENDDe #
#                          vice2EB\List\hal_key.lst                           #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\CC2430DB\ENDDe #
#                          vice2EB\Obj\hal_key.r51                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\hal\target\CC2430EB\hal_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2007-11-07 11:54:17 -0800 (Wed, 07 Nov 2007) $
      4            Revision:       $Revision: 15885 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 state of the previous poll and will only return a non-zero
     44                 value if the key state changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key state is not remembered.  This
     52                 means that KeyRead() will return the current state of the keys
     53                 (not a change in state of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high state to a low state.  This transition is typically clean.  The
     62                 duration of the low state is around 200ms.  When the signal returns
     63                 to the high state, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81           *                                            INCLUDES
     82           **************************************************************************************************/
     83          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x89
   \   unsigned char volatile __sfr P0IFG
   \                     P0IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8c
   \   unsigned char volatile __sfr PICTL
   \                     PICTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1
     84          #include "hal_defs.h"
     85          #include "hal_types.h"
     86          #include "hal_drivers.h"
     87          #include "hal_adc.h"
     88          #include "hal_key.h"
     89          #include "osal.h"
     90          
     91          /**************************************************************************************************
     92           *                                              MACROS
     93           **************************************************************************************************/
     94          
     95          /**************************************************************************************************
     96           *                                            CONSTANTS
     97           **************************************************************************************************/
     98          #define HAL_KEY_BIT0   0x01
     99          #define HAL_KEY_BIT1   0x02
    100          #define HAL_KEY_BIT2   0x04
    101          #define HAL_KEY_BIT3   0x08
    102          #define HAL_KEY_BIT4   0x10
    103          #define HAL_KEY_BIT5   0x20
    104          #define HAL_KEY_BIT6   0x40
    105          #define HAL_KEY_BIT7   0x80
    106          
    107          #define HAL_KEY_RISING_EDGE   0
    108          #define HAL_KEY_FALLING_EDGE  1
    109          
    110          #define HAL_KEY_PDUP2           0x80
    111          #define HAL_KEY_PDUP1           0x40
    112          #define HAL_KEY_PDUP0           0x20
    113          
    114          #define HAL_KEY_DEBOUNCE_VALUE  25
    115          #define HAL_KEY_POLLING_VALUE   100
    116          
    117          
    118          #if defined (HAL_BOARD_CC2430DB)
    119            #define HAL_KEY_SW_6_ENABLE
    120            #define HAL_KEY_SW_6_PORT     P0                      /* Port location of SW1 */
    121            #define HAL_KEY_SW_6_BIT      HAL_KEY_BIT1            /* Bit location of SW1 */
    122            #define HAL_KEY_SW_6_SEL      P0SEL                   /* Port Select Register for SW1 */
    123            #define HAL_KEY_SW_6_DIR      P0DIR                   /* Port Direction Register for SW1 */
    124            #define HAL_KEY_SW_6_IEN      IEN1                    /* Interrupt Enable Register for SW1 */
    125            #define HAL_KEY_SW_6_IENBIT   HAL_KEY_BIT5            /* Interrupt Enable bit for SW1 */
    126            #define HAL_KEY_SW_6_EDGE     HAL_KEY_RISING_EDGE     /* Type of interrupt for SW1 */
    127            #define HAL_KEY_SW_6_EDGEBIT  HAL_KEY_BIT0            /* EdgeType enable bit SW1 */
    128            #define HAL_KEY_SW_6_ICTL     PICTL                   /* Port Interrupt Control for SW1 */
    129            #define HAL_KEY_SW_6_ICTLBIT  HAL_KEY_BIT3            /* Interrupt enable bit for SW1 */
    130            #define HAL_KEY_SW_6_PXIFG    P0IFG                   /* Port Interrupt Flag for SW1 */
    131          
    132            #define HAL_KEY_JOYSTICK_ENABLE
    133            #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    134          
    135            #define HAL_KEY_SW_5_ENABLE   /* 2430DB - SW5 is enabled based on key interrupt enable or not - see config */
    136            #define HAL_KEY_SW_5_PORT     P2                      /* Port location of SW5 */
    137            #define HAL_KEY_SW_5_BIT      HAL_KEY_BIT0            /* Bit location of SW5 */
    138            #define HAL_KEY_SW_5_SEL      P2SEL                   /* Port Select Register for SW5 */
    139            #define HAL_KEY_SW_5_DIR      P2DIR                   /* Port Direction Register for SW5 */
    140            #define HAL_KEY_SW_5_INP      P2INP                   /* Port Input Mode Register for SW5 */
    141            #define HAL_KEY_SW_5_IEN      IEN2                    /* Interrupt Enable Register for SW5 */
    142            #define HAL_KEY_SW_5_IENBIT   HAL_KEY_BIT1            /* Interrupt Enable bit for SW5 */
    143            #define HAL_KEY_SW_5_EDGE     HAL_KEY_FALLING_EDGE    /* Type of interrupt for SW5 */
    144            #define HAL_KEY_SW_5_EDGEBIT  HAL_KEY_BIT2            /* EdgeType enable bit SW5 */
    145            #define HAL_KEY_SW_5_ICTL     PICTL                   /* Port Interrupt Control for SW5 */
    146            #define HAL_KEY_SW_5_ICTLBIT  HAL_KEY_BIT5            /* Interrupt enable bit for SW5 */
    147            #define HAL_KEY_SW_5_PXIFG    P2IFG                   /* Port Interrupt Flag for SW5 */
    148          
    149            #define HAL_KEY_P0INT_LOW_USED    HAL_KEY_SW_6_BIT    /* P0 can only be enabled/disabled as group of high or low nibble */
    150            #define HAL_KEY_POINT_HIGH_USED   0                   /* P0 can only be enabled/disabled as group of high or low nibble */
    151          #endif
    152          
    153          #if defined (HAL_BOARD_CC2430EB) || defined (HAL_BOARD_CC2430BB)
    154            #define HAL_KEY_SW_6_ENABLE
    155            #define HAL_KEY_SW_6_PORT     P0                      /* Port location of SW1 */
    156            #define HAL_KEY_SW_6_BIT      HAL_KEY_BIT1            /* Bit location of SW1 */
    157            #define HAL_KEY_SW_6_SEL      P0SEL                   /* Port Select Register for SW1 */
    158            #define HAL_KEY_SW_6_DIR      P0DIR                   /* Port Direction Register for SW1 */
    159            #define HAL_KEY_SW_6_IEN      IEN1                    /* Interrupt Enable Register for SW1 */
    160            #define HAL_KEY_SW_6_IENBIT   HAL_KEY_BIT5            /* Interrupt Enable bit for SW1 */
    161            #define HAL_KEY_SW_6_EDGE     HAL_KEY_RISING_EDGE     /* Type of interrupt for SW1 */
    162            #define HAL_KEY_SW_6_EDGEBIT  HAL_KEY_BIT0            /* EdgeType enable bit SW1 */
    163            #define HAL_KEY_SW_6_ICTL     PICTL                   /* Port Interrupt Control for SW1 */
    164            #define HAL_KEY_SW_6_ICTLBIT  HAL_KEY_BIT3            /* Interrupt enable bit for SW1 */
    165            #define HAL_KEY_SW_6_PXIFG    P0IFG                   /* Port Interrupt Flag for SW1 */
    166          
    167            #define HAL_KEY_P0INT_LOW_USED    HAL_KEY_SW_6_BIT    /* P0 can only be enabled/disabled as group of high or low nibble */
    168          #endif
    169          
    170          #if defined (HAL_BOARD_CC2430BB)
    171            #define HAL_KEY_POINT_HIGH_USED  0
    172          #endif
    173          
    174          #if defined (HAL_BOARD_CC2430EB)
    175            #define HAL_KEY_JOYSTICK_ENABLE
    176            #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    177          
    178            #define HAL_KEY_SW_5_ENABLE
    179            #define HAL_KEY_SW_5_PORT     P0                      /* Port location of SW5 */
    180            #define HAL_KEY_SW_5_BIT      HAL_KEY_BIT5            /* Bit location of SW5 */
    181            #define HAL_KEY_SW_5_SEL      P0SEL                   /* Port Select Register for SW5 */
    182            #define HAL_KEY_SW_5_DIR      P0DIR                   /* Port Direction Register for SW5 */
    183            #define HAL_KEY_SW_5_INP      P0INP                   /* Port Input Mode Register for SW5 */
    184            #define HAL_KEY_SW_5_IEN      IEN1                    /* Interrupt Enable Register for SW5 */
    185            #define HAL_KEY_SW_5_IENBIT   HAL_KEY_BIT5            /* Interrupt Enable bit for SW5 */
    186            #define HAL_KEY_SW_5_EDGE     HAL_KEY_RISING_EDGE     /* Type of interrupt for SW5 */
    187            #define HAL_KEY_SW_5_EDGEBIT  HAL_KEY_BIT2            /* EdgeType enable bit SW5 */
    188            #define HAL_KEY_SW_5_ICTL     PICTL                   /* Port Interrupt Control for SW5 */
    189            #define HAL_KEY_SW_5_ICTLBIT  HAL_KEY_BIT4            /* Interrupt enable bit for SW5 */
    190            #define HAL_KEY_SW_5_PXIFG    P0IFG                   /* Port Interrupt Flag for SW5 */
    191          
    192            #define HAL_KEY_POINT_HIGH_USED   HAL_KEY_SW_5_BIT    /* P0 can only be enabled/disabled as group of high or low nibble */
    193          #endif
    194          
    195          /**************************************************************************************************
    196           *                                            TYPEDEFS
    197           **************************************************************************************************/
    198          
    199          
    200          /**************************************************************************************************
    201           *                                        GLOBAL VARIABLES
    202           **************************************************************************************************/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    203          static uint8 halKeySavedKeys;     /* used to store previous key state in polling mode */
   \                     halKeySavedKeys:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    204          static halKeyCBack_t pHalKeyProcessFunction;
   \                     pHalKeyProcessFunction:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    205          bool Hal_KeyIntEnable;            /* interrupt enable/disable flag */
   \                     Hal_KeyIntEnable:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    206          uint8 halSaveIntKey;              /* used by ISR to save state of interrupt-driven keys */
   \                     halSaveIntKey:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    207          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    208          static uint8 HalKeyConfigured;
   \                     HalKeyConfigured:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    209          
    210          /**************************************************************************************************
    211           *                                        FUNCTIONS - Local
    212           **************************************************************************************************/
    213          void halProcessKeyInterrupt (void);
    214          
    215          
    216          /**************************************************************************************************
    217           *                                        FUNCTIONS - API
    218           **************************************************************************************************/
    219          /**************************************************************************************************
    220           * @fn      HalKeyInit
    221           *
    222           * @brief   Initilize Key Service
    223           *
    224           * @param   none
    225           *
    226           * @return  None
    227           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    228          void HalKeyInit( void )
   \                     HalKeyInit:
    229          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    230          #if (HAL_KEY == TRUE)
    231            /* Initialize previous key to 0 */
    232            halKeySavedKeys = 0;
   \   000004   7400         MOV     A,#0x0
   \   000006   90....       MOV     DPTR,#halKeySavedKeys
   \   000009   F0           MOVX    @DPTR,A
    233          
    234          #if defined (HAL_KEY_SW_6_ENABLE)
    235            HAL_KEY_SW_6_SEL &= ~(HAL_KEY_SW_6_BIT);    /* Set pin function to GPIO */
   \   00000A   53F3FD       ANL     0xf3,#0xfd
    236            HAL_KEY_SW_6_DIR &= ~(HAL_KEY_SW_6_BIT);    /* Set pin direction to Input */
   \   00000D   53FDFD       ANL     0xfd,#0xfd
    237          #endif
    238          
    239          #if defined (HAL_KEY_SW_5_ENABLE)
    240            HAL_KEY_SW_5_SEL &= ~(HAL_KEY_SW_5_BIT);    /* Set pin function to GPIO */
   \   000010   53F3DF       ANL     0xf3,#0xdf
    241            HAL_KEY_SW_5_DIR &= ~(HAL_KEY_SW_5_BIT);    /* Set pin direction to Input */
   \   000013   53FDDF       ANL     0xfd,#0xdf
    242            HAL_KEY_SW_5_INP |= HAL_KEY_SW_5_BIT;       /* Set pin input mode to tri-state */
   \   000016   438F20       ORL     0x8f,#0x20
    243          #endif
    244          
    245            /* Initialize callback function */
    246            pHalKeyProcessFunction  = NULL;
   \   000019   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00001C   7400         MOV     A,#0x0
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   A3           INC     DPTR
   \   000020   7400         MOV     A,#0x0
   \   000022   F0           MOVX    @DPTR,A
    247          
    248            /* Start with key is not configured */
    249            HalKeyConfigured = FALSE;
   \   000023   7400         MOV     A,#0x0
   \   000025   90....       MOV     DPTR,#HalKeyConfigured
   \   000028   F0           MOVX    @DPTR,A
    250          #endif /* HAL_KEY */
    251          }
   \   000029   D083         POP     DPH
   \   00002B   D082         POP     DPL
   \   00002D   02....       LJMP    ?BRET
   \   000030                REQUIRE P0INP
   \   000030                REQUIRE P0SEL
   \   000030                REQUIRE P0DIR
    252          
    253          /**************************************************************************************************
    254           * @fn      HalKeyConfig
    255           *
    256           * @brief   Configure the Key serivce
    257           *
    258           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    259           *          cback - pointer to the CallBack function
    260           *
    261           * @return  None
    262           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    263          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
   \                     HalKeyConfig:
    264          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   8A..         MOV     ?V0 + 0,R2
   \   000008   8B..         MOV     ?V0 + 1,R3
    265          #if (HAL_KEY == TRUE)
    266            /* Enable/Disable Interrupt or */
    267            Hal_KeyIntEnable = interruptEnable;
   \   00000A   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   00000D   F0           MOVX    @DPTR,A
    268          
    269            /* Register the callback fucntion */
    270            pHalKeyProcessFunction = cback;
   \   00000E   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   000011   E5..         MOV     A,?V0 + 0
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   E5..         MOV     A,?V0 + 1
   \   000017   F0           MOVX    @DPTR,A
    271          
    272            /* Determine if interrupt is enable or not */
    273            if (Hal_KeyIntEnable)
   \   000018   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   602C         JZ      ??HalKeyConfig_0
    274            {
    275          
    276              /*
    277                 Work around for CC2430DB when interrupt is enabled and SW5 (center joystick)
    278                 is used. This SW5 uses P2 which also has debug lines connected to it. This
    279                 causes contant interruption on P2INT_VECTOR. Disable the usage of P2 interrupt
    280                 will stop this problem.
    281              */
    282              #if defined (HAL_BOARD_CC2430DB)
    283                #undef HAL_KEY_SW_5_ENABLE                      /* Dis-allow SW5 when key interrupt is enable */
    284              #endif
    285          
    286          #if defined (HAL_KEY_SW_5_ENABLE)
    287              PICTL &= ~(HAL_KEY_SW_5_EDGEBIT);                 /* Set rising or falling edge */
   \   00001E   538CFB       ANL     0x8c,#0xfb
    288            #if (HAL_KEY_SW_5_EDGE == HAL_KEY_FALLING_EDGE)
    289              PICTL |= HAL_KEY_SW_5_EDGEBIT;
    290            #endif
    291              HAL_KEY_SW_5_ICTL |= HAL_KEY_SW_5_ICTLBIT;        /* Set interrupt enable bit */
   \   000021   438C10       ORL     0x8c,#0x10
    292              HAL_KEY_SW_5_IEN |= HAL_KEY_SW_5_IENBIT;
   \   000024   D2BD         SETB    0xb8.5
    293              HAL_KEY_SW_5_PXIFG = ~(HAL_KEY_SW_5_BIT);        /* Clear any pending interrupts */
   \   000026   7589DF       MOV     0x89,#-0x21
    294          #endif
    295          
    296          #if defined (HAL_KEY_SW_6_ENABLE)
    297              PICTL &= ~(HAL_KEY_SW_6_EDGEBIT);                 /* Set rising or falling edge */
   \   000029   538CFE       ANL     0x8c,#0xfe
    298            #if (HAL_KEY_SW_6_EDGE == HAL_KEY_FALLING_EDGE)
    299              PICTL |= HAL_KEY_SW_6_EDGEBIT;
    300            #endif
    301              HAL_KEY_SW_6_ICTL |= HAL_KEY_SW_6_ICTLBIT;        /* Set interrupt enable bit */
   \   00002C   438C08       ORL     0x8c,#0x8
    302              HAL_KEY_SW_6_IEN |= HAL_KEY_SW_6_IENBIT;
   \   00002F   D2BD         SETB    0xb8.5
    303              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT);        /* Clear any pending interrupts */
   \   000031   7589FD       MOV     0x89,#-0x3
    304          #endif
    305          
    306              /* Do this only after the hal_key is configured - to work with sleep stuff */
    307              if (HalKeyConfigured == TRUE)
   \   000034   90....       MOV     DPTR,#HalKeyConfigured
   \   000037   E0           MOVX    A,@DPTR
   \   000038   6401         XRL     A,#0x1
   \   00003A   7028         JNZ     ??HalKeyConfig_1
    308              {
    309                osal_stop_timerEx( Hal_TaskID, HAL_KEY_EVENT);  /* Cancel polling if active */
   \   00003C                ; Setup parameters for call to function osal_stop_timerEx
   \   00003C   7A01         MOV     R2,#0x1
   \   00003E   7B00         MOV     R3,#0x0
   \   000040   90....       MOV     DPTR,#Hal_TaskID
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F9           MOV     R1,A
   \   000045   12....       LCALL   ??osal_stop_timerEx?relay
   \   000048   801A         SJMP    ??HalKeyConfig_1
    310              }
    311            }
    312            else    /* Interrupts NOT enabled */
    313            {
    314          
    315              /*
    316                 Work around for CC2430DB when interrupt is enabled and SW5 (center joystick)
    317                 is used. This SW5 uses P2 which also has debug lines connected to it. This
    318                 causes contant interruption on P2INT_VECTOR. Disable the usage of P2 interrupt
    319                 will stop this problem.
    320              */
    321              #if defined (HAL_BOARD_CC2430DB)
    322                #define HAL_KEY_SW_5_ENABLE                     /* Allow SW5 only when key interrupt is disable */
    323              #endif
    324          
    325          #if defined (HAL_KEY_SW_6_ENABLE)
    326              HAL_KEY_SW_6_ICTL &= ~(HAL_KEY_SW_6_ICTLBIT);     /* Clear interrupt enable bit */
   \                     ??HalKeyConfig_0:
   \   00004A   538CF7       ANL     0x8c,#0xf7
    327              HAL_KEY_SW_6_IEN &= ~(HAL_KEY_SW_6_IENBIT);
   \   00004D   C2BD         CLR     0xb8.5
    328          #endif
    329          
    330          #if defined (HAL_KEY_SW_5_ENABLE)
    331              HAL_KEY_SW_5_ICTL &= ~(HAL_KEY_SW_5_ICTLBIT);     /* Clear interrupt enable bit */
   \   00004F   538CEF       ANL     0x8c,#0xef
    332              HAL_KEY_SW_5_IEN &= ~(HAL_KEY_SW_5_IENBIT);
   \   000052   C2BD         CLR     0xb8.5
    333          #endif
    334              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_POLLING_VALUE);    /* Kick off polling */
   \   000054                ; Setup parameters for call to function osal_start_timerEx
   \   000054   7C64         MOV     R4,#0x64
   \   000056   7D00         MOV     R5,#0x0
   \   000058   7A01         MOV     R2,#0x1
   \   00005A   7B00         MOV     R3,#0x0
   \   00005C   90....       MOV     DPTR,#Hal_TaskID
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   F9           MOV     R1,A
   \   000061   12....       LCALL   ??osal_start_timerEx?relay
    335            }
    336          
    337            /* Key now is configured */
    338            HalKeyConfigured = TRUE;
   \                     ??HalKeyConfig_1:
   \   000064   7401         MOV     A,#0x1
   \   000066   90....       MOV     DPTR,#HalKeyConfigured
   \   000069   F0           MOVX    @DPTR,A
    339          #endif /* HAL_KEY */
    340          }
   \   00006A   7F02         MOV     R7,#0x2
   \   00006C   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00006F                REQUIRE P0IFG
   \   00006F                REQUIRE PICTL
   \   00006F                REQUIRE _A_IEN1
    341          
    342          /**************************************************************************************************
    343           * @fn      HalKeyRead
    344           *
    345           * @brief   Read the current value of a key
    346           *
    347           * @param   None
    348           *
    349           * @return  keys - current keys status
    350           **************************************************************************************************/
    351          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    352          uint8 HalKeyRead ( void )
   \                     HalKeyRead:
    353          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    354          
    355            uint8 keys = 0;
   \   000005   75..00       MOV     ?V0 + 0,#0x0
    356          
    357          #if (HAL_KEY == TRUE)
    358          
    359          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    360            uint8 ksave0 = 0;
   \   000008   7E00         MOV     R6,#0x0
    361            uint8 ksave1;
    362            uint8 adc;
    363          #endif
    364          
    365          #if defined (HAL_KEY_SW_6_ENABLE)
    366            if (!(HAL_KEY_SW_6_PORT & HAL_KEY_SW_6_BIT))    /* Key is active low */
   \   00000A   A281         MOV     C,0x80.1
   \   00000C   4007         JC      ??HalKeyRead_0
    367            {
    368              keys |= HAL_KEY_SW_6;
   \   00000E   D3           SETB    C
   \   00000F   E5..         MOV     A,?V0 + 0
   \   000011   92E5         MOV     0xE0 /* A   */.5,C
   \   000013   F5..         MOV     ?V0 + 0,A
    369            }
    370          #endif
    371          #if defined (HAL_KEY_SW_5_ENABLE)
    372            if (HAL_KEY_SW_5_PORT & HAL_KEY_SW_5_BIT)       /* Key is active high */
   \                     ??HalKeyRead_0:
   \   000015   A285         MOV     C,0x80.5
   \   000017   5007         JNC     ??HalKeyRead_1
    373            {
    374              keys |= HAL_KEY_SW_5;
   \   000019   D3           SETB    C
   \   00001A   E5..         MOV     A,?V0 + 0
   \   00001C   92E2         MOV     0xE0 /* A   */.2,C
   \   00001E   F5..         MOV     ?V0 + 0,A
    375            }
    376          #endif
    377          
    378          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    379          /*
    380          *  The joystick control is encoded as an analog voltage.  Keep on reading
    381          *  the ADC until two consecutive key decisions are the same.
    382          */
    383          
    384            do
    385            {
    386              ksave1 = ksave0;    /* save previouse key reading */
   \                     ??HalKeyRead_1:
   \   000020   EE           MOV     A,R6
   \   000021   FF           MOV     R7,A
    387          
    388              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
   \   000022                ; Setup parameters for call to function HalAdcRead
   \   000022   7A01         MOV     R2,#0x1
   \   000024   7906         MOV     R1,#0x6
   \   000026   12....       LCALL   ??HalAdcRead?relay
   \   000029   EA           MOV     A,R2
   \   00002A   F5..         MOV     ?V0 + 1,A
    389          
    390              if  (CHVER == 0x01)
   \   00002C   90DF60       MOV     DPTR,#-0x20a0
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   6401         XRL     A,#0x1
   \   000032   704E         JNZ     ??HalKeyRead_2
    391              {
    392                /* Rev B */
    393                if ((adc >= 90) && (adc <= 100))
   \   000034   E5..         MOV     A,?V0 + 1
   \   000036   C3           CLR     C
   \   000037   945A         SUBB    A,#0x5a
   \   000039   400F         JC      ??HalKeyRead_3
   \   00003B   E5..         MOV     A,?V0 + 1
   \   00003D   C3           CLR     C
   \   00003E   9465         SUBB    A,#0x65
   \   000040   5008         JNC     ??HalKeyRead_3
    394                {
    395                   ksave0 |= HAL_KEY_UP;
   \   000042   D3           SETB    C
   \   000043   EE           MOV     A,R6
   \   000044   92E0         MOV     0xE0 /* A   */.0,C
   \   000046   FE           MOV     R6,A
   \   000047   02....       LJMP    ??HalKeyRead_4 & 0xFFFF
    396                }
    397                else if ((adc >= 75) && (adc <= 85))
   \                     ??HalKeyRead_3:
   \   00004A   E5..         MOV     A,?V0 + 1
   \   00004C   C3           CLR     C
   \   00004D   944B         SUBB    A,#0x4b
   \   00004F   400E         JC      ??HalKeyRead_5
   \   000051   E5..         MOV     A,?V0 + 1
   \   000053   C3           CLR     C
   \   000054   9456         SUBB    A,#0x56
   \   000056   5007         JNC     ??HalKeyRead_5
    398                {
    399                  ksave0 |= HAL_KEY_RIGHT;
   \   000058   D3           SETB    C
   \   000059   EE           MOV     A,R6
   \   00005A   92E1         MOV     0xE0 /* A   */.1,C
   \   00005C   FE           MOV     R6,A
   \   00005D   806E         SJMP    ??HalKeyRead_4
    400                }
    401                else if ((adc >= 45) && (adc <= 55))
   \                     ??HalKeyRead_5:
   \   00005F   E5..         MOV     A,?V0 + 1
   \   000061   C3           CLR     C
   \   000062   942D         SUBB    A,#0x2d
   \   000064   400E         JC      ??HalKeyRead_6
   \   000066   E5..         MOV     A,?V0 + 1
   \   000068   C3           CLR     C
   \   000069   9438         SUBB    A,#0x38
   \   00006B   5007         JNC     ??HalKeyRead_6
    402                {
    403                  ksave0 |= HAL_KEY_LEFT;
   \   00006D   D3           SETB    C
   \   00006E   EE           MOV     A,R6
   \   00006F   92E3         MOV     0xE0 /* A   */.3,C
   \   000071   FE           MOV     R6,A
   \   000072   8059         SJMP    ??HalKeyRead_4
    404                }
    405                else if (adc <= 10)
   \                     ??HalKeyRead_6:
   \   000074   E5..         MOV     A,?V0 + 1
   \   000076   C3           CLR     C
   \   000077   940B         SUBB    A,#0xb
   \   000079   5052         JNC     ??HalKeyRead_4
    406                {
    407                  ksave0 |= HAL_KEY_DOWN;
   \   00007B   D3           SETB    C
   \   00007C   EE           MOV     A,R6
   \   00007D   92E4         MOV     0xE0 /* A   */.4,C
   \   00007F   FE           MOV     R6,A
   \   000080   804B         SJMP    ??HalKeyRead_4
    408                }
    409                else if ((adc >= 101) && (adc <= 115))
    410                {
    411                }
    412              }
    413              else
    414              {
    415                 /* Rev C */
    416                if ((adc >= 90)  && (adc <= 104))
   \                     ??HalKeyRead_2:
   \   000082   E5..         MOV     A,?V0 + 1
   \   000084   C3           CLR     C
   \   000085   945A         SUBB    A,#0x5a
   \   000087   400E         JC      ??HalKeyRead_7
   \   000089   E5..         MOV     A,?V0 + 1
   \   00008B   C3           CLR     C
   \   00008C   9469         SUBB    A,#0x69
   \   00008E   5007         JNC     ??HalKeyRead_7
    417                {
    418                   ksave0 |= HAL_KEY_UP;
   \   000090   D3           SETB    C
   \   000091   EE           MOV     A,R6
   \   000092   92E0         MOV     0xE0 /* A   */.0,C
   \   000094   FE           MOV     R6,A
   \   000095   8036         SJMP    ??HalKeyRead_4
    419                }
    420                else if ((adc >= 75)  && (adc <= 89))
   \                     ??HalKeyRead_7:
   \   000097   E5..         MOV     A,?V0 + 1
   \   000099   C3           CLR     C
   \   00009A   944B         SUBB    A,#0x4b
   \   00009C   400E         JC      ??HalKeyRead_8
   \   00009E   E5..         MOV     A,?V0 + 1
   \   0000A0   C3           CLR     C
   \   0000A1   945A         SUBB    A,#0x5a
   \   0000A3   5007         JNC     ??HalKeyRead_8
    421                {
    422                  ksave0 |= HAL_KEY_RIGHT;
   \   0000A5   D3           SETB    C
   \   0000A6   EE           MOV     A,R6
   \   0000A7   92E1         MOV     0xE0 /* A   */.1,C
   \   0000A9   FE           MOV     R6,A
   \   0000AA   8021         SJMP    ??HalKeyRead_4
    423                }
    424                else if ((adc >= 45)  && (adc <= 56))
   \                     ??HalKeyRead_8:
   \   0000AC   E5..         MOV     A,?V0 + 1
   \   0000AE   C3           CLR     C
   \   0000AF   942D         SUBB    A,#0x2d
   \   0000B1   400E         JC      ??HalKeyRead_9
   \   0000B3   E5..         MOV     A,?V0 + 1
   \   0000B5   C3           CLR     C
   \   0000B6   9439         SUBB    A,#0x39
   \   0000B8   5007         JNC     ??HalKeyRead_9
    425                {
    426                  ksave0 |= HAL_KEY_LEFT;
   \   0000BA   D3           SETB    C
   \   0000BB   EE           MOV     A,R6
   \   0000BC   92E3         MOV     0xE0 /* A   */.3,C
   \   0000BE   FE           MOV     R6,A
   \   0000BF   800C         SJMP    ??HalKeyRead_4
    427                }
    428                else if (adc <= 10)
   \                     ??HalKeyRead_9:
   \   0000C1   E5..         MOV     A,?V0 + 1
   \   0000C3   C3           CLR     C
   \   0000C4   940B         SUBB    A,#0xb
   \   0000C6   5005         JNC     ??HalKeyRead_4
    429                {
    430                  ksave0 |= HAL_KEY_DOWN;
   \   0000C8   D3           SETB    C
   \   0000C9   EE           MOV     A,R6
   \   0000CA   92E4         MOV     0xE0 /* A   */.4,C
   \   0000CC   FE           MOV     R6,A
    431                }
    432                else if ((adc >= 105) && (adc <= 121))
    433                {
    434                }
    435              }
    436          
    437            } while (ksave0 != ksave1);
   \                     ??HalKeyRead_4:
   \   0000CD   EF           MOV     A,R7
   \   0000CE   6E           XRL     A,R6
   \   0000CF   6003         JZ      $+5
   \   0000D1   02....       LJMP    ??HalKeyRead_1 & 0xFFFF
    438          
    439            keys |= ksave0;
   \   0000D4   EE           MOV     A,R6
   \   0000D5   42..         ORL     ?V0 + 0,A
    440          
    441          #endif
    442          
    443          #endif /* HAL_KEY */
    444          
    445            return keys;
   \   0000D7   A9..         MOV     R1,?V0 + 0
   \   0000D9   7F02         MOV     R7,#0x2
   \   0000DB   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   0000DE                REQUIRE _A_P0
    446          
    447          }
    448          
    449          
    450          /**************************************************************************************************
    451           * @fn      HalKeyPoll
    452           *
    453           * @brief   Called by hal_driver to poll the keys
    454           *
    455           * @param   None
    456           *
    457           * @return  None
    458           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    459          void HalKeyPoll (void)
   \                     HalKeyPoll:
    460          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    461          #if (HAL_KEY == TRUE)
    462          
    463            uint8 keys = 0;
   \   000005   75..00       MOV     ?V0 + 0,#0x0
    464          
    465          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    466            uint8 ksave0 = 0;
   \   000008   7E00         MOV     R6,#0x0
    467            uint8 ksave1;
    468            uint8 adc;
    469          #endif
    470          
    471            /*
    472            *  If interrupts are enabled, get the status of the interrupt-driven keys from 'halSaveIntKey'
    473            *  which is updated by the key ISR.  If Polling, read these keys directly.
    474            */
    475          #if defined (HAL_KEY_SW_6_ENABLE)
    476            if (!(HAL_KEY_SW_6_PORT & HAL_KEY_SW_6_BIT))    /* Key is active low */
   \   00000A   A281         MOV     C,0x80.1
   \   00000C   4007         JC      ??HalKeyPoll_0
    477            {
    478              keys |= HAL_KEY_SW_6;
   \   00000E   D3           SETB    C
   \   00000F   E5..         MOV     A,?V0 + 0
   \   000011   92E5         MOV     0xE0 /* A   */.5,C
   \   000013   F5..         MOV     ?V0 + 0,A
    479            }
    480          #endif
    481          #if defined (HAL_KEY_SW_5_ENABLE)
    482            if (HAL_KEY_SW_5_PORT & HAL_KEY_SW_5_BIT)       /* Key is active high */
   \                     ??HalKeyPoll_0:
   \   000015   A285         MOV     C,0x80.5
   \   000017   5007         JNC     ??HalKeyPoll_1
    483            {
    484              keys |= HAL_KEY_SW_5;
   \   000019   D3           SETB    C
   \   00001A   E5..         MOV     A,?V0 + 0
   \   00001C   92E2         MOV     0xE0 /* A   */.2,C
   \   00001E   F5..         MOV     ?V0 + 0,A
    485            }
    486          #endif
    487          
    488          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    489          /*
    490          *  The joystick control is encoded as an analog voltage.  Keep on reading
    491          *  the ADC until two consecutive key decisions are the same.
    492          */
    493          
    494            do
    495            {
    496              ksave1 = ksave0;    /* save previouse key reading */
   \                     ??HalKeyPoll_1:
   \   000020   EE           MOV     A,R6
   \   000021   FF           MOV     R7,A
    497          
    498              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
   \   000022                ; Setup parameters for call to function HalAdcRead
   \   000022   7A01         MOV     R2,#0x1
   \   000024   7906         MOV     R1,#0x6
   \   000026   12....       LCALL   ??HalAdcRead?relay
   \   000029   EA           MOV     A,R2
   \   00002A   F5..         MOV     ?V0 + 1,A
    499          
    500              if  (CHVER == 0x01)
   \   00002C   90DF60       MOV     DPTR,#-0x20a0
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   6401         XRL     A,#0x1
   \   000032   704E         JNZ     ??HalKeyPoll_2
    501              {
    502                /* Rev B */
    503                if ((adc >= 90) && (adc <= 100))
   \   000034   E5..         MOV     A,?V0 + 1
   \   000036   C3           CLR     C
   \   000037   945A         SUBB    A,#0x5a
   \   000039   400F         JC      ??HalKeyPoll_3
   \   00003B   E5..         MOV     A,?V0 + 1
   \   00003D   C3           CLR     C
   \   00003E   9465         SUBB    A,#0x65
   \   000040   5008         JNC     ??HalKeyPoll_3
    504                {
    505                   ksave0 |= HAL_KEY_UP;
   \   000042   D3           SETB    C
   \   000043   EE           MOV     A,R6
   \   000044   92E0         MOV     0xE0 /* A   */.0,C
   \   000046   FE           MOV     R6,A
   \   000047   02....       LJMP    ??HalKeyPoll_4 & 0xFFFF
    506                }
    507                else if ((adc >= 75) && (adc <= 85))
   \                     ??HalKeyPoll_3:
   \   00004A   E5..         MOV     A,?V0 + 1
   \   00004C   C3           CLR     C
   \   00004D   944B         SUBB    A,#0x4b
   \   00004F   400E         JC      ??HalKeyPoll_5
   \   000051   E5..         MOV     A,?V0 + 1
   \   000053   C3           CLR     C
   \   000054   9456         SUBB    A,#0x56
   \   000056   5007         JNC     ??HalKeyPoll_5
    508                {
    509                  ksave0 |= HAL_KEY_RIGHT;
   \   000058   D3           SETB    C
   \   000059   EE           MOV     A,R6
   \   00005A   92E1         MOV     0xE0 /* A   */.1,C
   \   00005C   FE           MOV     R6,A
   \   00005D   806E         SJMP    ??HalKeyPoll_4
    510                }
    511                else if ((adc >= 45) && (adc <= 55))
   \                     ??HalKeyPoll_5:
   \   00005F   E5..         MOV     A,?V0 + 1
   \   000061   C3           CLR     C
   \   000062   942D         SUBB    A,#0x2d
   \   000064   400E         JC      ??HalKeyPoll_6
   \   000066   E5..         MOV     A,?V0 + 1
   \   000068   C3           CLR     C
   \   000069   9438         SUBB    A,#0x38
   \   00006B   5007         JNC     ??HalKeyPoll_6
    512                {
    513                  ksave0 |= HAL_KEY_LEFT;
   \   00006D   D3           SETB    C
   \   00006E   EE           MOV     A,R6
   \   00006F   92E3         MOV     0xE0 /* A   */.3,C
   \   000071   FE           MOV     R6,A
   \   000072   8059         SJMP    ??HalKeyPoll_4
    514                }
    515                else if (adc <= 10)
   \                     ??HalKeyPoll_6:
   \   000074   E5..         MOV     A,?V0 + 1
   \   000076   C3           CLR     C
   \   000077   940B         SUBB    A,#0xb
   \   000079   5052         JNC     ??HalKeyPoll_4
    516                {
    517                  ksave0 |= HAL_KEY_DOWN;
   \   00007B   D3           SETB    C
   \   00007C   EE           MOV     A,R6
   \   00007D   92E4         MOV     0xE0 /* A   */.4,C
   \   00007F   FE           MOV     R6,A
   \   000080   804B         SJMP    ??HalKeyPoll_4
    518                }
    519                else if ((adc >= 101) && (adc <= 115))
    520                {
    521                }
    522              }
    523              else
    524              {
    525                 /* Rev C */
    526                if ((adc >= 90)  && (adc <= 104))
   \                     ??HalKeyPoll_2:
   \   000082   E5..         MOV     A,?V0 + 1
   \   000084   C3           CLR     C
   \   000085   945A         SUBB    A,#0x5a
   \   000087   400E         JC      ??HalKeyPoll_7
   \   000089   E5..         MOV     A,?V0 + 1
   \   00008B   C3           CLR     C
   \   00008C   9469         SUBB    A,#0x69
   \   00008E   5007         JNC     ??HalKeyPoll_7
    527                {
    528                   ksave0 |= HAL_KEY_UP;
   \   000090   D3           SETB    C
   \   000091   EE           MOV     A,R6
   \   000092   92E0         MOV     0xE0 /* A   */.0,C
   \   000094   FE           MOV     R6,A
   \   000095   8036         SJMP    ??HalKeyPoll_4
    529                }
    530                else if ((adc >= 75)  && (adc <= 89))
   \                     ??HalKeyPoll_7:
   \   000097   E5..         MOV     A,?V0 + 1
   \   000099   C3           CLR     C
   \   00009A   944B         SUBB    A,#0x4b
   \   00009C   400E         JC      ??HalKeyPoll_8
   \   00009E   E5..         MOV     A,?V0 + 1
   \   0000A0   C3           CLR     C
   \   0000A1   945A         SUBB    A,#0x5a
   \   0000A3   5007         JNC     ??HalKeyPoll_8
    531                {
    532                  ksave0 |= HAL_KEY_RIGHT;
   \   0000A5   D3           SETB    C
   \   0000A6   EE           MOV     A,R6
   \   0000A7   92E1         MOV     0xE0 /* A   */.1,C
   \   0000A9   FE           MOV     R6,A
   \   0000AA   8021         SJMP    ??HalKeyPoll_4
    533                }
    534                else if ((adc >= 45)  && (adc <= 56))
   \                     ??HalKeyPoll_8:
   \   0000AC   E5..         MOV     A,?V0 + 1
   \   0000AE   C3           CLR     C
   \   0000AF   942D         SUBB    A,#0x2d
   \   0000B1   400E         JC      ??HalKeyPoll_9
   \   0000B3   E5..         MOV     A,?V0 + 1
   \   0000B5   C3           CLR     C
   \   0000B6   9439         SUBB    A,#0x39
   \   0000B8   5007         JNC     ??HalKeyPoll_9
    535                {
    536                  ksave0 |= HAL_KEY_LEFT;
   \   0000BA   D3           SETB    C
   \   0000BB   EE           MOV     A,R6
   \   0000BC   92E3         MOV     0xE0 /* A   */.3,C
   \   0000BE   FE           MOV     R6,A
   \   0000BF   800C         SJMP    ??HalKeyPoll_4
    537                }
    538                else if (adc <= 10)
   \                     ??HalKeyPoll_9:
   \   0000C1   E5..         MOV     A,?V0 + 1
   \   0000C3   C3           CLR     C
   \   0000C4   940B         SUBB    A,#0xb
   \   0000C6   5005         JNC     ??HalKeyPoll_4
    539                {
    540                  ksave0 |= HAL_KEY_DOWN;
   \   0000C8   D3           SETB    C
   \   0000C9   EE           MOV     A,R6
   \   0000CA   92E4         MOV     0xE0 /* A   */.4,C
   \   0000CC   FE           MOV     R6,A
    541                }
    542                else if ((adc >= 105) && (adc <= 121))
    543                {
    544                }
    545              }
    546          
    547          
    548            } while (ksave0 != ksave1);
   \                     ??HalKeyPoll_4:
   \   0000CD   EF           MOV     A,R7
   \   0000CE   6E           XRL     A,R6
   \   0000CF   6003         JZ      $+5
   \   0000D1   02....       LJMP    ??HalKeyPoll_1 & 0xFFFF
    549          
    550            keys |= ksave0;
   \   0000D4   EE           MOV     A,R6
   \   0000D5   42..         ORL     ?V0 + 0,A
    551          
    552          #endif
    553          
    554            /* Exit if polling and no keys have changed */
    555            if (!Hal_KeyIntEnable)
   \   0000D7   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   700E         JNZ     ??HalKeyPoll_10
    556            {
    557              if (keys == halKeySavedKeys)
   \   0000DD   90....       MOV     DPTR,#halKeySavedKeys
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   65..         XRL     A,?V0 + 0
   \   0000E3   602A         JZ      ??HalKeyPoll_11
    558              {
    559                return;
    560              }
    561              halKeySavedKeys = keys;     /* Store the current keys for comparation next time */
   \   0000E5   E5..         MOV     A,?V0 + 0
   \   0000E7   90....       MOV     DPTR,#halKeySavedKeys
   \   0000EA   F0           MOVX    @DPTR,A
    562            }
    563          
    564            /* Invoke Callback if new keys were depressed */
    565            if (keys && (pHalKeyProcessFunction))
   \                     ??HalKeyPoll_10:
   \   0000EB   E5..         MOV     A,?V0 + 0
   \   0000ED   6020         JZ      ??HalKeyPoll_11
   \   0000EF   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   0000F2   E0           MOVX    A,@DPTR
   \   0000F3   6400         XRL     A,#0x0
   \   0000F5   7004         JNZ     ??HalKeyPoll_12
   \   0000F7   A3           INC     DPTR
   \   0000F8   E0           MOVX    A,@DPTR
   \   0000F9   6400         XRL     A,#0x0
   \                     ??HalKeyPoll_12:
   \   0000FB   6012         JZ      ??HalKeyPoll_11
    566            {
    567              (pHalKeyProcessFunction) (keys, HAL_KEY_STATE_NORMAL);
   \   0000FD                ; Setup parameters for indirect call
   \   0000FD   7A00         MOV     R2,#0x0
   \   0000FF   A9..         MOV     R1,?V0 + 0
   \   000101   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   000104   E0           MOVX    A,@DPTR
   \   000105   F8           MOV     R0,A
   \   000106   A3           INC     DPTR
   \   000107   E0           MOVX    A,@DPTR
   \   000108   F583         MOV     DPH,A
   \   00010A   8882         MOV     DPL,R0
   \   00010C   12....       LCALL   ?CALL_IND
   \                     ??HalKeyPoll_11:
   \   00010F   7F02         MOV     R7,#0x2
   \   000111   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000114                REQUIRE _A_P0
    568            }
    569          
    570          #endif /* HAL_KEY */
    571          
    572          }
    573          
    574          
    575          /**************************************************************************************************
    576           * @fn      halProcessKeyInterrupt
    577           *
    578           * @brief   Checks to see if it's a valid key interrupt, saves interrupt driven key states for
    579           *          processing by HalKeyRead(), and debounces keys by scheduling HalKeyRead() 25ms later.
    580           *
    581           * @param
    582           *
    583           * @return
    584           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    585          void halProcessKeyInterrupt (void)
   \                     halProcessKeyInterrupt:
    586          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    587          
    588          #if (HAL_KEY == TRUE)
    589          
    590            bool    valid=FALSE;
   \   000005   7E00         MOV     R6,#0x0
    591          
    592          #if defined (HAL_KEY_SW_6_ENABLE)
    593            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)      /* Interrupt Flag has been set */
   \   000007   E589         MOV     A,0x89
   \   000009   A2E1         MOV     C,0xE0 /* A   */.1
   \   00000B   5005         JNC     ??halProcessKeyInterrupt_0
    594            {
    595              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT);    /* Clear Interrupt Flag */
   \   00000D   7589FD       MOV     0x89,#-0x3
    596              valid = TRUE;
   \   000010   7E01         MOV     R6,#0x1
    597            }
    598          #endif
    599          
    600          #if defined (HAL_KEY_SW_5_ENABLE)
    601            if (HAL_KEY_SW_5_PXIFG & HAL_KEY_SW_5_BIT)      /* Interrupt Flag has been set */
   \                     ??halProcessKeyInterrupt_0:
   \   000012   E589         MOV     A,0x89
   \   000014   A2E5         MOV     C,0xE0 /* A   */.5
   \   000016   5005         JNC     ??halProcessKeyInterrupt_1
    602            {
    603              HAL_KEY_SW_5_PXIFG = ~(HAL_KEY_SW_5_BIT);    /* Clear Interrupt Flag */
   \   000018   7589DF       MOV     0x89,#-0x21
    604              valid = TRUE;
   \   00001B   7E01         MOV     R6,#0x1
    605            }
    606          #endif
    607          
    608            if (valid)
   \                     ??halProcessKeyInterrupt_1:
   \   00001D   EE           MOV     A,R6
   \   00001E   6010         JZ      ??halProcessKeyInterrupt_2
    609            {
    610              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_DEBOUNCE_VALUE);
   \   000020                ; Setup parameters for call to function osal_start_timerEx
   \   000020   7C19         MOV     R4,#0x19
   \   000022   7D00         MOV     R5,#0x0
   \   000024   7A01         MOV     R2,#0x1
   \   000026   7B00         MOV     R3,#0x0
   \   000028   90....       MOV     DPTR,#Hal_TaskID
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F9           MOV     R1,A
   \   00002D   12....       LCALL   ??osal_start_timerEx?relay
    611            }
    612          #endif /* HAL_KEY */
    613          }
   \                     ??halProcessKeyInterrupt_2:
   \   000030   7F01         MOV     R7,#0x1
   \   000032   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000035                REQUIRE P0IFG
    614          
    615          /**************************************************************************************************
    616           * @fn      HalKeyEnterSleep
    617           *
    618           * @brief  - Get called to enter sleep mode
    619           *
    620           * @param
    621           *
    622           * @return
    623           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    624          void HalKeyEnterSleep ( void )
   \                     HalKeyEnterSleep:
    625          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    626            /* Sleep!!! Note that HAL_KEY_SW_5 is shared with CTS pin of RS-232.
    627             * It was set to tri-state during active state. It needs to be pulled-up.
    628             */
    629          #if defined (HAL_KEY_SW_5_ENABLE)
    630            HAL_KEY_SW_5_INP &= ~HAL_KEY_SW_5_BIT;       /* Set pin input mode to pull-up */
   \   000000   538FDF       ANL     0x8f,#0xdf
    631          #endif
    632          }
   \   000003   02....       LJMP    ?BRET
   \   000006                REQUIRE P0INP
    633          
    634          /**************************************************************************************************
    635           * @fn      HalKeyExitSleep
    636           *
    637           * @brief   - Get called when sleep is over
    638           *
    639           * @param
    640           *
    641           * @return  - return saved keys
    642           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    643          uint8 HalKeyExitSleep ( void )
   \                     HalKeyExitSleep:
    644          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    645            /* Wakeup!!! Note that HAL_KEY_SW_5 is shared with CTS pin of RS-232.
    646             * It was pulled up during sleep. It needs to be set to tri-state during active state.
    647             */
    648          #if defined (HAL_KEY_SW_5_ENABLE)
    649            HAL_KEY_SW_5_INP |= HAL_KEY_SW_5_BIT;       /* Set pin input mode to tri-state */
   \   000004   438F20       ORL     0x8f,#0x20
    650          #endif
    651          
    652            /* Wake up and read keys */
    653            return ( HalKeyRead () );
   \   000007                ; Setup parameters for call to function HalKeyRead
   \   000007   12....       LCALL   ??HalKeyRead?relay
   \   00000A   D083         POP     DPH
   \   00000C   D082         POP     DPL
   \   00000E   02....       LJMP    ?BRET
   \   000011                REQUIRE P0INP
    654          }
    655          
    656          /***************************************************************************************************
    657           *                                    INTERRUPT SERVICE ROUTINE
    658           ***************************************************************************************************/
    659          
    660          /**************************************************************************************************
    661           * @fn      halKeyPort0Isr
    662           *
    663           * @brief   Port0 ISR
    664           *
    665           * @param
    666           *
    667           * @return
    668           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    669          HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
   \                     halKeyPort0Isr:
    670          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    671            /* P0IF is cleared by HW for CHVER < REV_E */
    672          
    673            halProcessKeyInterrupt();
   \   000007                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000007   12....       LCALL   ??halProcessKeyInterrupt?relay
    674          
    675            if( CHVER >= REV_E )
   \   00000A   90DF60       MOV     DPTR,#-0x20a0
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   C3           CLR     C
   \   00000F   9404         SUBB    A,#0x4
   \   000011   4005         JC      ??halKeyPort0Isr_0
    676            {
    677              /* Make sure that we clear all enabled, but unused P0IFG bits.
    678               * For P0 we can only enable or disable high or low nibble, not bit by
    679               * bit. For P1 and P2 enabling of single bits are possible, therefore
    680               * will not any unused pins generate interrupts on P1 or P2.
    681               * We could have checked for low and high nibble in P0, but this
    682               * isn't necessary as long as we only clear unused pin interrupts.
    683               */
    684              P0IFG = (HAL_KEY_P0INT_LOW_USED | HAL_KEY_POINT_HIGH_USED);
   \   000013   758922       MOV     0x89,#0x22
    685              P0IF = 0;
   \   000016   C2C5         CLR     0xc0.5
    686              CLEAR_SLEEP_MODE();
    687            }
    688          }
   \                     ??halKeyPort0Isr_0:
   \   000018   7F01         MOV     R7,#0x1
   \   00001A   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   00001D                REQUIRE P0IFG
   \   00001D                REQUIRE _A_IRCON
    689          
    690          /**************************************************************************************************
    691           * @fn      halKeyPort1Isr
    692           *
    693           * @brief   Port1 ISR
    694           *
    695           * @param
    696           *
    697           * @return
    698           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    699          HAL_ISR_FUNCTION( halKeyPort1Isr, P1INT_VECTOR )
   \                     halKeyPort1Isr:
    700          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    701            if( CHVER <= REV_D )
   \   000007   90DF60       MOV     DPTR,#-0x20a0
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   C3           CLR     C
   \   00000C   9404         SUBB    A,#0x4
   \   00000E   5002         JNC     ??halKeyPort1Isr_0
    702            {
    703              P1IF = 0;
   \   000010   C2EB         CLR     0xe8.3
    704            }
    705          
    706            halProcessKeyInterrupt();
   \                     ??halKeyPort1Isr_0:
   \   000012                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000012   12....       LCALL   ??halProcessKeyInterrupt?relay
    707          
    708            if( CHVER >= REV_E )
   \   000015   90DF60       MOV     DPTR,#-0x20a0
   \   000018   E0           MOVX    A,@DPTR
   \   000019   C3           CLR     C
   \   00001A   9404         SUBB    A,#0x4
   \   00001C   4002         JC      ??halKeyPort1Isr_1
    709            {
    710              P1IF = 0;
   \   00001E   C2EB         CLR     0xe8.3
    711              CLEAR_SLEEP_MODE();
    712            }
    713          }
   \                     ??halKeyPort1Isr_1:
   \   000020   7F01         MOV     R7,#0x1
   \   000022   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000025                REQUIRE _A_IRCON2
    714          
    715          /**************************************************************************************************
    716           * @fn      halKeyPort2Isr
    717           *
    718           * @brief   Port2 ISR
    719           *
    720           * @param
    721           *
    722           * @return
    723           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    724          HAL_ISR_FUNCTION( halKeyPort2Isr, P2INT_VECTOR )
   \                     halKeyPort2Isr:
    725          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    726            if( CHVER <= REV_D )
   \   000007   90DF60       MOV     DPTR,#-0x20a0
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   C3           CLR     C
   \   00000C   9404         SUBB    A,#0x4
   \   00000E   5002         JNC     ??halKeyPort2Isr_0
    727            {
    728              P2IF = 0;
   \   000010   C2E8         CLR     0xe8.0
    729            }
    730          
    731            halProcessKeyInterrupt();
   \                     ??halKeyPort2Isr_0:
   \   000012                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000012   12....       LCALL   ??halProcessKeyInterrupt?relay
    732          
    733            if( CHVER >= REV_E )
   \   000015   90DF60       MOV     DPTR,#-0x20a0
   \   000018   E0           MOVX    A,@DPTR
   \   000019   C3           CLR     C
   \   00001A   9404         SUBB    A,#0x4
   \   00001C   4002         JC      ??halKeyPort2Isr_1
    734            {
    735              P2IF = 0;
   \   00001E   C2E8         CLR     0xe8.0
    736              CLEAR_SLEEP_MODE();
    737            }
    738          }
   \                     ??halKeyPort2Isr_1:
   \   000020   7F01         MOV     R7,#0x1
   \   000022   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000025                REQUIRE _A_IRCON2

   \                                 In  segment INTVEC, offset 0x33, root
   \                     `??halKeyPort2Isr??INTVEC 51`:
   \   000033   02....       LJMP       (halKeyPort2Isr)

   \                                 In  segment INTVEC, offset 0x6b, root
   \                     `??halKeyPort0Isr??INTVEC 107`:
   \   00006B   02....       LJMP       (halKeyPort0Isr)

   \                                 In  segment INTVEC, offset 0x7b, root
   \                     `??halKeyPort1Isr??INTVEC 123`:
   \   00007B   02....       LJMP       (halKeyPort1Isr)

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halProcessKeyInterrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halProcessKeyInterrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyEnterSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyEnterSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyExitSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyExitSleep
    739          
    740          /**************************************************************************************************
    741          **************************************************************************************************/
    742          
    743          
    744          

   Maximum stack usage in bytes:

     Function                    ISTACK PSTACK XSTACK
     --------                    ------ ------ ------
     HalKeyConfig                    0      0     10
       -> osal_stop_timerEx          0      0     20
       -> osal_start_timerEx         0      0     20
     HalKeyEnterSleep                0      0      0
     HalKeyExitSleep                 2      0      0
       -> HalKeyRead                 4      0      0
     HalKeyInit                      2      0      0
     HalKeyPoll                      0      0     10
       -> HalAdcRead                 0      0     20
     HalKeyRead                      0      0     10
       -> HalAdcRead                 0      0     20
     halKeyPort0Isr                 15      0      0
       -> halProcessKeyInterrupt    30      0      0
     halKeyPort1Isr                 15      0      0
       -> halProcessKeyInterrupt    30      0      0
     halKeyPort2Isr                 15      0      0
       -> halProcessKeyInterrupt    30      0      0
     halProcessKeyInterrupt          0      0      9
       -> osal_start_timerEx         0      0     18


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _A_P0                             1
     P0IFG                             1
     PICTL                             1
     P0INP                             1
     _A_IEN1                           1
     _A_IRCON                          1
     _A_IRCON2                         1
     P0SEL                             1
     P0DIR                             1
     halKeySavedKeys                   1
     pHalKeyProcessFunction            2
     Hal_KeyIntEnable                  1
     halSaveIntKey                     1
     HalKeyConfigured                  1
     HalKeyInit                       48
     HalKeyConfig                    111
     HalKeyRead                      222
     HalKeyPoll                      276
     halProcessKeyInterrupt           53
     HalKeyEnterSleep                  6
     HalKeyExitSleep                  17
     halKeyPort0Isr                   29
     halKeyPort1Isr                   37
     halKeyPort2Isr                   37
     ??halKeyPort2Isr??INTVEC 51       3
     ??halKeyPort0Isr??INTVEC 107      3
     ??halKeyPort1Isr??INTVEC 123      3
     ??HalKeyInit?relay                6
     ??HalKeyConfig?relay              6
     ??HalKeyRead?relay                6
     ??HalKeyPoll?relay                6
     ??halProcessKeyInterrupt?relay    6
     ??HalKeyEnterSleep?relay          6
     ??HalKeyExitSleep?relay           6

 
 733 bytes in segment BANKED_CODE
  42 bytes in segment BANK_RELAYS
   9 bytes in segment INTVEC
 103 bytes in segment NEAR_CODE
   9 bytes in segment SFR_AN
   6 bytes in segment XDATA_Z
 
 878 bytes of CODE  memory (+ 9 bytes shared)
   0 bytes of DATA  memory (+ 9 bytes shared)
   6 bytes of XDATA memory

Errors: none
Warnings: none

///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR 8051 C/C++ Compiler V7.30B/W32                   19/Mar/2013  19:57:42 /
// Copyright 2004-2007 IAR Systems. All rights reserved.                      /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data                                              /
//    Dptr setup         =  1,16                                              /
//    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Component /
//                          s\mac\low_level\srf03\mac_rx.c                    /
//    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Proje /
//                          cts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB /
//                          \..\..\..\Tools\CC2430DB\f8wEndev.cfg"            /
//                          (-DCPU32MHZ -DFORCE_MAC_NEAR -DROOT=__near_func   /
//                          -DMAC_OPT_FFD=0 -DBLINK_LEDS "-DCONST=const       /
//                          __code" -DGENERIC=__generic) -f "C:\Texas         /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\Too /
//                          ls\CC2430DB\f8wConfig.cfg" (-DSECURE=0            /
//                          -DDEFAULT_CHANLIST=0x00000800                     /
//                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3  /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20          /
//                          -DNWK_MAX_BINDING_ENTRIES=10                      /
//                          -DMAX_BINDING_CLUSTER_IDS=5                       /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   /
//                          0x0A, 0x0C, 0x0D}" -DRFD_RCVC_ALWAYS_ON=FALSE     /
//                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100           /
//                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440  /
//                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Componen /
//                          ts\mac\low_level\srf03\mac_rx.c" -D CC2430EB -D   /
//                          AXD_END -D AXD_END_B -D NWK_AUTO_POLL -D          /
//                          REFLECTOR -D xZTOOL_P1 -D xMT_TASK -D             /
//                          xMT_ZDO_FUNC -D xLCD_SUPPORTED=DEBUG -D           /
//                          xPOWER_SAVING -lC "C:\Texas                       /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\ENDDevice2EB /
//                          \List\" -lA "C:\Texas Instruments\ZStack-1.4.3-1. /
//                          2.1\Projects\zstack\Samples\cc2430-zstack-adxl345 /
//                          \CC2430DB\ENDDevice2EB\List\" --diag_suppress     /
//                          Pe001,Pa010 --diag_remark pe550 -o "C:\Texas      /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\ENDDevice2EB /
//                          \Obj\" -e --require_prototypes -z2 --no_cse       /
//                          --no_unroll --no_inline --no_code_motion          /
//                          --no_tbaa --debug --core=plain --dptr=16,1        /
//                          --data_model=large --code_model=banked            /
//                          --calling_convention=xdata_reentrant              /
//                          --place_constants=data --nr_virtual_regs 8 -I     /
//                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects /
//                          \zstack\Samples\cc2430-zstack-adxl345\CC2430DB\"  /
//                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Proje /
//                          cts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB /
//                          \..\SOURCE\" -I "C:\Texas                         /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\Drivers\" /
//                           -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Proj /
//                          ects\zstack\Samples\cc2430-zstack-adxl345\CC2430D /
//                          B\..\..\..\ZMAIN\TI2430DB\" -I "C:\Texas          /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\MT\" -I "C:\Texas                   /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\HAL\INCLUDE\" -I "C:\Texas          /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\HAL\TARGET\CC2430EB\" -I "C:\Texas  /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas       /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\OSAL\INCLUDE\" -I "C:\Texas         /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\STACK\AF\" -I "C:\Texas             /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\STACK\NWK\" -I "C:\Texas            /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\STACK\SEC\" -I "C:\Texas            /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\STACK\SYS\" -I "C:\Texas            /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\STACK\ZDO\" -I "C:\Texas            /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\ZMAC\F8W\" -I "C:\Texas             /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\ZMAC\" -I "C:\Texas                 /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\SERVICES\SADDR\" -I "C:\Texas       /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\SERVICES\SDATA\" -I "C:\Texas       /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\MAC\INCLUDE\" -I "C:\Texas          /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\MAC\HIGH_LEVEL\" -I "C:\Texas       /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas  /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\MAC\LOW_LEVEL\SRF03\SINGLE_CHIP\"   /
//                          -I "C:\Program Files\IAR Systems\Embedded         /
//                          Workbench 4.0 Evaluation version\8051\INC\" -I    /
//                          "C:\Program Files\IAR Systems\Embedded Workbench  /
//                          4.0 Evaluation version\8051\INC\CLIB\"            /
//    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ /
//                          zstack\Samples\cc2430-zstack-adxl345\CC2430DB\END /
//                          Device2EB\List\mac_rx.s51                         /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME mac_rx

        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ??macRxPromiscuousMode?relay
        EXTERN ??rxAddrIsr?relay
        EXTERN ??rxDiscardFrame?relay
        EXTERN ??rxDiscardIsr?relay
        EXTERN ??rxDone?relay
        EXTERN ??rxFcsIsr?relay
        EXTERN ??rxHaltCleanupFinalStep?relay
        EXTERN ??rxPayloadIsr?relay
        EXTERN ??rxPostRxUpdates?relay
        EXTERN ??rxPrepPayload?relay
        EXTERN ??rxStartIsr?relay
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?CALL_IND
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?L_MOV_TO_X
        EXTERN ?V0
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN __INIT_XDATA_Z

        PUBLIC ??macRxAckTxDoneCallback?relay
        FUNCTION ??macRxAckTxDoneCallback?relay,0203H
        PUBLIC ??macRxHaltCleanup?relay
        FUNCTION ??macRxHaltCleanup?relay,0203H
        PUBLIC ??macRxInit?relay
        FUNCTION ??macRxInit?relay,0203H
        PUBLIC ??macRxPromiscuousMode?relay
        FUNCTION ??macRxPromiscuousMode?relay,0203H
        PUBLIC ??macRxRadioPowerUpInit?relay
        FUNCTION ??macRxRadioPowerUpInit?relay,0203H
        PUBLIC ??macRxThresholdIsr?relay
        FUNCTION ??macRxThresholdIsr?relay,0203H
        PUBLIC ??macRxTxReset?relay
        FUNCTION ??macRxTxReset?relay,0203H
        FUNCTION ??rxAddrIsr?relay,0203H
        FUNCTION ??rxDiscardFrame?relay,0203H
        FUNCTION ??rxDiscardIsr?relay,0203H
        FUNCTION ??rxDone?relay,0203H
        FUNCTION ??rxFcsIsr?relay,0203H
        FUNCTION ??rxHaltCleanupFinalStep?relay,0203H
        FUNCTION ??rxPayloadIsr?relay,0203H
        FUNCTION ??rxPostRxUpdates?relay,0203H
        FUNCTION ??rxPrepPayload?relay,0203H
        FUNCTION ??rxStartIsr?relay,0203H
        PUBWEAK RFIF
        PUBWEAK RFIM
        PUBWEAK RFST
        PUBWEAK S1CON
        PUBWEAK _A_IEN0
        PUBLIC macRxAckTxDoneCallback
        FUNCTION macRxAckTxDoneCallback,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macRxActive
        PUBLIC macRxFilter
        PUBLIC macRxHaltCleanup
        FUNCTION macRxHaltCleanup,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macRxInit
        FUNCTION macRxInit,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macRxOutgoingAckFlag
        PUBLIC macRxPromiscuousMode
        FUNCTION macRxPromiscuousMode,021203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 9, STACK
        PUBLIC macRxRadioPowerUpInit
        FUNCTION macRxRadioPowerUpInit,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macRxThresholdIsr
        FUNCTION macRxThresholdIsr,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macRxTxReset
        FUNCTION macRxTxReset,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        FUNCTION rxAddrIsr,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        FUNCTION rxDiscardFrame,021203H
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION rxDiscardIsr,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 16, STACK
        FUNCTION rxDone,021203H
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION rxFcsIsr,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 9, STACK
        FUNCTION rxHaltCleanupFinalStep,021203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION rxPayloadIsr,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        FUNCTION rxPostRxUpdates,021203H
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION rxPrepPayload,0203H
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION rxStartIsr,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 17, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP DATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource SP:8, PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
macRxHardDisable    SYMBOL "macRxHardDisable"
macDataRxMemFree    SYMBOL "macDataRxMemFree"
halAssertHandler    SYMBOL "halAssertHandler"
macCspForceTxDoneIfPending SYMBOL "macCspForceTxDoneIfPending"
macMemReadRxFifo    SYMBOL "macMemReadRxFifo"
macRadioComputeLQI  SYMBOL "macRadioComputeLQI"
macTxAckReceivedCallback SYMBOL "macTxAckReceivedCallback"
macTxAckNotReceivedCallback SYMBOL "macTxAckNotReceivedCallback"
macDataRxMemAlloc   SYMBOL "macDataRxMemAlloc"
macRxCheckPendingCallback SYMBOL "macRxCheckPendingCallback"
macMcuOverflowCapture SYMBOL "macMcuOverflowCapture"
macMcuTimerCapture  SYMBOL "macMcuTimerCapture"
sAddrExtCpy         SYMBOL "sAddrExtCpy"
macRxOffRequest     SYMBOL "macRxOffRequest"
macRxCompleteCallback SYMBOL "macRxCompleteCallback"
macRadioUpdateTxPower SYMBOL "macRadioUpdateTxPower"
macTxStartQueuedFrame SYMBOL "macTxStartQueuedFrame"
??halAssertHandler?relay SYMBOL "?relay", halAssertHandler
??macCspForceTxDoneIfPending?relay SYMBOL "?relay", macCspForceTxDoneIfPending
??macDataRxMemAlloc?relay SYMBOL "?relay", macDataRxMemAlloc
??macDataRxMemFree?relay SYMBOL "?relay", macDataRxMemFree
??macMcuOverflowCapture?relay SYMBOL "?relay", macMcuOverflowCapture
??macMcuTimerCapture?relay SYMBOL "?relay", macMcuTimerCapture
??macMemReadRxFifo?relay SYMBOL "?relay", macMemReadRxFifo
??macRadioComputeLQI?relay SYMBOL "?relay", macRadioComputeLQI
??macRadioUpdateTxPower?relay SYMBOL "?relay", macRadioUpdateTxPower
??macRxCheckPendingCallback?relay SYMBOL "?relay", macRxCheckPendingCallback
??macRxCompleteCallback?relay SYMBOL "?relay", macRxCompleteCallback
??macRxHardDisable?relay SYMBOL "?relay", macRxHardDisable
??macRxOffRequest?relay SYMBOL "?relay", macRxOffRequest
??macTxAckNotReceivedCallback?relay SYMBOL "?relay", macTxAckNotReceivedCallback
??macTxAckReceivedCallback?relay SYMBOL "?relay", macTxAckReceivedCallback
??macTxStartQueuedFrame?relay SYMBOL "?relay", macTxStartQueuedFrame
??sAddrExtCpy?relay SYMBOL "?relay", sAddrExtCpy
macRxAckTxDoneCallback SYMBOL "macRxAckTxDoneCallback"
??macRxAckTxDoneCallback?relay SYMBOL "?relay", macRxAckTxDoneCallback
macRxHaltCleanup    SYMBOL "macRxHaltCleanup"
??macRxHaltCleanup?relay SYMBOL "?relay", macRxHaltCleanup
macRxInit           SYMBOL "macRxInit"
??macRxInit?relay   SYMBOL "?relay", macRxInit
macRxPromiscuousMode SYMBOL "macRxPromiscuousMode"
??macRxPromiscuousMode?relay SYMBOL "?relay", macRxPromiscuousMode
macRxRadioPowerUpInit SYMBOL "macRxRadioPowerUpInit"
??macRxRadioPowerUpInit?relay SYMBOL "?relay", macRxRadioPowerUpInit
macRxThresholdIsr   SYMBOL "macRxThresholdIsr"
??macRxThresholdIsr?relay SYMBOL "?relay", macRxThresholdIsr
macRxTxReset        SYMBOL "macRxTxReset"
??macRxTxReset?relay SYMBOL "?relay", macRxTxReset

        EXTERN macRxHardDisable
        FUNCTION macRxHardDisable,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macDataRxMemFree
        FUNCTION macDataRxMemFree,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN halAssertHandler
        FUNCTION halAssertHandler,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macCspForceTxDoneIfPending
        FUNCTION macCspForceTxDoneIfPending,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macMemReadRxFifo
        FUNCTION macMemReadRxFifo,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macRadioComputeLQI
        FUNCTION macRadioComputeLQI,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macTxAckReceivedCallback
        FUNCTION macTxAckReceivedCallback,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macTxAckNotReceivedCallback
        FUNCTION macTxAckNotReceivedCallback,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macDataRxMemAlloc
        FUNCTION macDataRxMemAlloc,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macRxCheckPendingCallback
        FUNCTION macRxCheckPendingCallback,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macMcuOverflowCapture
        FUNCTION macMcuOverflowCapture,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macMcuTimerCapture
        FUNCTION macMcuTimerCapture,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN sAddrExtCpy
        FUNCTION sAddrExtCpy,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macRxOffRequest
        FUNCTION macRxOffRequest,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macRxCompleteCallback
        FUNCTION macRxCompleteCallback,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macRadioUpdateTxPower
        FUNCTION macRadioUpdateTxPower,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN macTxStartQueuedFrame
        FUNCTION macTxStartQueuedFrame,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN ??halAssertHandler?relay
        FUNCTION ??halAssertHandler?relay,00H
        EXTERN ??macCspForceTxDoneIfPending?relay
        FUNCTION ??macCspForceTxDoneIfPending?relay,00H
        EXTERN ??macDataRxMemAlloc?relay
        FUNCTION ??macDataRxMemAlloc?relay,00H
        EXTERN ??macDataRxMemFree?relay
        FUNCTION ??macDataRxMemFree?relay,00H
        EXTERN ??macMcuOverflowCapture?relay
        FUNCTION ??macMcuOverflowCapture?relay,00H
        EXTERN ??macMcuTimerCapture?relay
        FUNCTION ??macMcuTimerCapture?relay,00H
        EXTERN ??macMemReadRxFifo?relay
        FUNCTION ??macMemReadRxFifo?relay,00H
        EXTERN ??macRadioComputeLQI?relay
        FUNCTION ??macRadioComputeLQI?relay,00H
        EXTERN ??macRadioUpdateTxPower?relay
        FUNCTION ??macRadioUpdateTxPower?relay,00H
        EXTERN ??macRxCheckPendingCallback?relay
        FUNCTION ??macRxCheckPendingCallback?relay,00H
        EXTERN ??macRxCompleteCallback?relay
        FUNCTION ??macRxCompleteCallback?relay,00H
        EXTERN ??macRxHardDisable?relay
        FUNCTION ??macRxHardDisable?relay,00H
        EXTERN ??macRxOffRequest?relay
        FUNCTION ??macRxOffRequest?relay,00H
        EXTERN ??macTxAckNotReceivedCallback?relay
        FUNCTION ??macTxAckNotReceivedCallback?relay,00H
        EXTERN ??macTxAckReceivedCallback?relay
        FUNCTION ??macTxAckReceivedCallback?relay,00H
        EXTERN ??macTxStartQueuedFrame?relay
        FUNCTION ??macTxStartQueuedFrame?relay,00H
        EXTERN ??sAddrExtCpy?relay
        FUNCTION ??sAddrExtCpy?relay,00H
        EXTERN macRxOnFlag
        EXTERN macTxActive
        EXTERN pMacDataTx

// C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\mac\low_level\srf03\mac_rx.c
//    1 /**************************************************************************************************
//    2   Filename:       mac_rx.c
//    3   Revised:        $Date: 2007-10-29 22:38:47 -0700 (Mon, 29 Oct 2007) $
//    4   Revision:       $Revision: 15812 $
//    5 
//    6   Description:    Describe the purpose and contents of the file.
//    7 
//    8 
//    9   Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com. 
//   38 **************************************************************************************************/
//   39 
//   40 /* ------------------------------------------------------------------------------------------------
//   41  *                                          Includes
//   42  * ------------------------------------------------------------------------------------------------
//   43  */
//   44 
//   45 /* hal */
//   46 #include "hal_defs.h"
//   47 #include "hal_types.h"
//   48 
//   49 /* high-level */
//   50 #include "mac_high_level.h"
//   51 #include "mac_spec.h"
//   52 
//   53 /* exported low-level */
//   54 #include "mac_low_level.h"
//   55 
//   56 /* low-level specific */
//   57 #include "mac_rx.h"
//   58 #include "mac_tx.h"
//   59 #include "mac_rx_onoff.h"
//   60 #include "mac_radio.h"
//   61 
//   62 /* target specific */
//   63 #include "mac_radio_defs.h"

        ASEGN SFR_AN:DATA:NOROOT,091H
// unsigned char volatile __sfr RFIM
RFIM:
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,09bH
// unsigned char volatile __sfr S1CON
S1CON:
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0a8H
// union <unnamed> volatile __sfr _A_IEN0
_A_IEN0:
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0e1H
// unsigned char volatile __sfr RFST
RFST:
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0e9H
// unsigned char volatile __sfr RFIF
RFIF:
        DS 1
//   64 
//   65 /* debug */
//   66 #include "mac_assert.h"
//   67 
//   68 
//   69 /* ------------------------------------------------------------------------------------------------
//   70  *                                            Defines
//   71  * ------------------------------------------------------------------------------------------------
//   72  */
//   73 #define MAX_PAYLOAD_BYTES_READ_PER_INTERRUPT   16   /* adjustable to tune performance */
//   74 
//   75 /* receive FIFO bytes needed to start a valid receive (see function rxStartIsr for details) */
//   76 #define RX_THRESHOLD_START_LEN    (MAC_PHY_PHR_LEN        +  \ 
//   77                                    MAC_FCF_FIELD_LEN      +  \ 
//   78                                    MAC_SEQ_NUM_FIELD_LEN  +  \ 
//   79                                    MAC_FCS_FIELD_LEN)
//   80 
//   81 /* maximum size of addressing fields (note: command frame identifier processed as part of address) */
//   82 #define MAX_ADDR_FIELDS_LEN  ((MAC_EXT_ADDR_FIELD_LEN + MAC_PAN_ID_FIELD_LEN) * 2)
//   83 
//   84 /* addressing mode reserved value */
//   85 #define ADDR_MODE_RESERVERED  1
//   86 
//   87 /* length of command frame identifier */
//   88 #define CMD_FRAME_ID_LEN      1
//   89 
//   90 /* packet size mask is equal to the maximum value */
//   91 #define PHY_PACKET_SIZE_MASK  0x7F
//   92 
//   93 /* value for promiscuous off, must not conflict with other mode variants from separate include files */
//   94 #define PROMISCUOUS_MODE_OFF  0x00
//   95 
//   96 /* bit of proprietary FCS format that indicates if the CRC is OK */
//   97 #define PROPRIETARY_FCS_CRC_OK_BIT  0x80
//   98 
//   99 /* dummy length value for unused entry in lookup table */
//  100 #define DUMMY_LEN   0xBE
//  101 
//  102 /* value for rxThresholdIntState */
//  103 #define RX_THRESHOLD_INT_STATE_INACTIVE   0
//  104 #define RX_THRESHOLD_INT_STATE_ACTIVE     1
//  105 #define RX_THRESHOLD_INT_STATE_RESET      2
//  106 
//  107 
//  108 /* ------------------------------------------------------------------------------------------------
//  109  *                                             Macros
//  110  * ------------------------------------------------------------------------------------------------
//  111  */
//  112 #define MEM_ALLOC(x)   macDataRxMemAlloc(x)
//  113 #define MEM_FREE(x)    macDataRxMemFree((uint8 *)x)
//  114 
//  115 /*
//  116  *  Macro for encoding frame control information into internal flags format.
//  117  *  Parameter is pointer to the frame.  NOTE!  If either the internal frame
//  118  *  format *or* the specification changes, this macro will need to be modified.
//  119  */
//  120 #define INTERNAL_FCF_FLAGS(p)  ((((p)[1] >> 4) & 0x03) | ((p)[0] & 0x78))
//  121 
//  122 /*
//  123  *  The radio replaces the actual FCS with different information.  This proprietary FCS is
//  124  *  the same length as the original and includes:
//  125  *    1) the RSSI value
//  126  *    2) the average correlation value (used for LQI)
//  127  *    3) a CRC passed bit
//  128  *
//  129  *  These macros decode the proprietary FCS.  The macro parameter is a pointer to the two byte FCS.
//  130  */
//  131 #define PROPRIETARY_FCS_RSSI(p)                 ((int8)((p)[0]))
//  132 #define PROPRIETARY_FCS_CRC_OK(p)               ((p)[1] & PROPRIETARY_FCS_CRC_OK_BIT)
//  133 #define PROPRIETARY_FCS_CORRELATION_VALUE(p)    ((p)[1] & ~PROPRIETARY_FCS_CRC_OK_BIT)
//  134 
//  135 
//  136 /* ------------------------------------------------------------------------------------------------
//  137  *                                       Global Variables
//  138  * ------------------------------------------------------------------------------------------------
//  139  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  140 uint8 macRxActive;
macRxActive:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  141 uint8 macRxFilter;
macRxFilter:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  142 uint8 macRxOutgoingAckFlag;
macRxOutgoingAckFlag:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  143 
//  144 
//  145 /* ------------------------------------------------------------------------------------------------
//  146  *                                       Local Constants
//  147  * ------------------------------------------------------------------------------------------------
//  148  */

        RSEG CODE_C:CODE:REORDER:NOROOT(0)
        DATA
//  149 static const uint8 CODE macRxAddrLen[] =
macRxAddrLen:
        DB 0, 190, 4, 10
//  150 {
//  151   0,                                                /* no address */
//  152   DUMMY_LEN,                                        /* reserved */
//  153   MAC_PAN_ID_FIELD_LEN + MAC_SHORT_ADDR_FIELD_LEN,  /* short address + pan id */
//  154   MAC_PAN_ID_FIELD_LEN + MAC_EXT_ADDR_FIELD_LEN     /* extended address + pan id */
//  155 };
//  156 
//  157 
//  158 /* ------------------------------------------------------------------------------------------------
//  159  *                                       Local Prototypes
//  160  * ------------------------------------------------------------------------------------------------
//  161  */
//  162 static void rxHaltCleanupFinalStep(void);
//  163 
//  164 static void rxStartIsr(void);
//  165 static void rxAddrIsr(void);
//  166 static void rxPayloadIsr(void);
//  167 static void rxDiscardIsr(void);
//  168 static void rxFcsIsr(void);
//  169 
//  170 static void rxPrepPayload(void);
//  171 static void rxDiscardFrame(void);
//  172 static void rxDone(void);
//  173 static void rxPostRxUpdates(void);
//  174 
//  175 
//  176 /* ------------------------------------------------------------------------------------------------
//  177  *                                         Local Variables
//  178  * ------------------------------------------------------------------------------------------------
//  179  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  180 static void    (* pFuncRxState)(void);
pFuncRxState:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  181 static macRx_t  * pRxBuf;
pRxBuf:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  182 

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  183 static uint8  rxBuf[MAC_PHY_PHR_LEN + MAC_FCF_FIELD_LEN + MAC_SEQ_NUM_FIELD_LEN];
rxBuf:
        DS 4
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  184 static uint8  rxUnreadLen;
rxUnreadLen:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  185 static uint8  rxNextLen;
rxNextLen:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  186 static uint8  rxPayloadLen;
rxPayloadLen:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  187 static uint8  rxFilter;
rxFilter:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  188 static uint8  rxPromiscuousMode;
rxPromiscuousMode:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  189 static uint8  rxIsrActiveFlag;
rxIsrActiveFlag:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  190 static uint8  rxResetFlag;
rxResetFlag:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  191 
//  192 
//  193 /**************************************************************************************************
//  194  * @fn          macRxInit
//  195  *
//  196  * @brief       Initialize receive variable states.
//  197  *
//  198  * @param       none
//  199  *
//  200  * @return      none
//  201  **************************************************************************************************
//  202  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  203 void macRxInit(void)
macRxInit:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function macRxInit
//  204 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  205   macRxFilter          = RX_FILTER_OFF;
        MOV     A,#0x0
        MOV     DPTR,#macRxFilter
        MOVX    @DPTR,A
//  206   rxPromiscuousMode    = PROMISCUOUS_MODE_OFF;
        MOV     A,#0x0
        MOV     DPTR,#rxPromiscuousMode
        MOVX    @DPTR,A
//  207   pRxBuf               = NULL; /* required for macRxReset() to function correctly */
        MOV     DPTR,#pRxBuf
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  208   macRxActive          = MAC_RX_ACTIVE_NO_ACTIVITY;
        MOV     A,#0x0
        MOV     DPTR,#macRxActive
        MOVX    @DPTR,A
//  209   pFuncRxState         = &rxStartIsr;
        MOV     DPTR,#pFuncRxState
        MOV     A,#(??rxStartIsr?relay & 0xff)
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((??rxStartIsr?relay >> 8) & 0xff)
        MOVX    @DPTR,A
//  210   macRxOutgoingAckFlag = 0;
        MOV     A,#0x0
        MOV     DPTR,#macRxOutgoingAckFlag
        MOVX    @DPTR,A
//  211   rxIsrActiveFlag      = 0;
        MOV     A,#0x0
        MOV     DPTR,#rxIsrActiveFlag
        MOVX    @DPTR,A
//  212   rxResetFlag          = 0;
        MOV     A,#0x0
        MOV     DPTR,#rxResetFlag
        MOVX    @DPTR,A
//  213 }
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock0
//  214 
//  215 
//  216 /**************************************************************************************************
//  217  * @fn          macRxRadioPowerUpInit
//  218  *
//  219  * @brief       Initialization for after radio first powers up.
//  220  *
//  221  * @param       none
//  222  *
//  223  * @return      none
//  224  **************************************************************************************************
//  225  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  226 void macRxRadioPowerUpInit(void)
macRxRadioPowerUpInit:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function macRxRadioPowerUpInit
//  227 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  228   /* set threshold at initial value */
//  229   MAC_RADIO_SET_RX_THRESHOLD(RX_THRESHOLD_START_LEN);
        MOV     A,#0x5
        MOV     DPTR,#-0x20b1
        MOVX    @DPTR,A
//  230 
//  231   /* clear any accidental threshold interrupt that happened as part of power up sequence */
//  232   MAC_RADIO_CLEAR_RX_THRESHOLD_INTERRUPT_FLAG();
        MOV     0xe9,#-0x21
//  233 
//  234   /* enable threshold interrupts */
//  235   MAC_RADIO_ENABLE_RX_THRESHOLD_INTERRUPT();
        ORL     0x91,#0x20
//  236 }
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock1
        REQUIRE RFIM
        REQUIRE RFIF
//  237 
//  238 
//  239 /**************************************************************************************************
//  240  * @fn          macRxTxReset
//  241  *
//  242  * @brief       Reset the receive state.
//  243  *
//  244  * @param       none
//  245  *
//  246  * @return      none
//  247  **************************************************************************************************
//  248  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  249 void macRxTxReset(void)
macRxTxReset:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function macRxTxReset
//  250 {
        FUNCALL macRxTxReset, macRxHardDisable
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL macRxTxReset, macRxPromiscuousMode
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  251   /* forces receiver off, cleans up by calling macRxHaltCleanup() and macTxHaltCleanup() */
//  252   macRxHardDisable();
        ; Setup parameters for call to function macRxHardDisable
        LCALL   ??macRxHardDisable?relay
//  253 
//  254   /*
//  255    *   Note : transmit does not require any reset logic
//  256    *          beyond what macRxHardDisable() provides.
//  257    */
//  258 
//  259   /* restore deault filter mode to off */
//  260   macRxFilter = RX_FILTER_OFF;
        MOV     A,#0x0
        MOV     DPTR,#macRxFilter
        MOVX    @DPTR,A
//  261 
//  262   /* return promiscuous mode to default off state */
//  263   macRxPromiscuousMode(MAC_PROMISCUOUS_MODE_OFF);
        ; Setup parameters for call to function macRxPromiscuousMode
        MOV     R1,#0x0
        LCALL   ??macRxPromiscuousMode?relay
//  264 }
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock2
//  265 
//  266 
//  267 /**************************************************************************************************
//  268  * @fn          macRxHaltCleanup
//  269  *
//  270  * @brief       Cleanup up the receive logic after receiver is forced off.
//  271  *
//  272  * @param       none
//  273  *
//  274  * @return      none
//  275  **************************************************************************************************
//  276  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  277 void macRxHaltCleanup(void)
macRxHaltCleanup:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function macRxHaltCleanup
//  278 {
        FUNCALL macRxHaltCleanup, rxHaltCleanupFinalStep
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  279   rxResetFlag = 1;
        MOV     A,#0x1
        MOV     DPTR,#rxResetFlag
        MOVX    @DPTR,A
//  280   if (!rxIsrActiveFlag)
        MOV     DPTR,#rxIsrActiveFlag
        MOVX    A,@DPTR
        JNZ     ??macRxHaltCleanup_0
//  281   {
//  282     rxHaltCleanupFinalStep();
        ; Setup parameters for call to function rxHaltCleanupFinalStep
        LCALL   ??rxHaltCleanupFinalStep?relay
//  283     rxResetFlag = 0;
        MOV     A,#0x0
        MOV     DPTR,#rxResetFlag
        MOVX    @DPTR,A
//  284   }
//  285 }
??macRxHaltCleanup_0:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock3
//  286 
//  287 
//  288 /*=================================================================================================
//  289  * @fn          rxHaltCleanupFinalStep
//  290  *
//  291  * @brief       Required cleanup if receiver is halted in the middle of a receive.
//  292  *
//  293  * @param       none
//  294  *
//  295  * @return      none
//  296  *=================================================================================================
//  297  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  298 static void rxHaltCleanupFinalStep(void)
rxHaltCleanupFinalStep:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function rxHaltCleanupFinalStep
//  299 {
        FUNCALL rxHaltCleanupFinalStep, macDataRxMemFree
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxHaltCleanupFinalStep, rxPostRxUpdates
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  300   /* cancel any upcoming ACK transmit complete callback */
//  301   MAC_RADIO_CANCEL_ACK_TX_DONE_CALLBACK();
        ANL     0x91,#0xbf
//  302 
//  303   /* set start of frame threshold */
//  304   MAC_RADIO_SET_RX_THRESHOLD(RX_THRESHOLD_START_LEN);
        MOV     A,#0x5
        MOV     DPTR,#-0x20b1
        MOVX    @DPTR,A
//  305 
//  306   /* flush the receive FIFO */
//  307   MAC_RADIO_FLUSH_RX_FIFO();
        MOV     0xe1,#-0x1a
        MOV     0xe1,#-0x1a
//  308 
//  309   /* clear any receive interrupt that happened to squeak through */
//  310   MAC_RADIO_CLEAR_RX_THRESHOLD_INTERRUPT_FLAG();
        MOV     0xe9,#-0x21
//  311 
//  312   /* if data buffer has been allocated, free it */
//  313   if (pRxBuf != NULL)
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        XRL     A,#0x0
        JNZ     ??rxHaltCleanupFinalStep_0
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
??rxHaltCleanupFinalStep_0:
        JZ      ??rxHaltCleanupFinalStep_1
//  314   {
//  315     MEM_FREE((uint8 *) pRxBuf);
        ; Setup parameters for call to function macDataRxMemFree
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??macDataRxMemFree?relay
//  316   }
//  317   pRxBuf = NULL; /* needed to indicate buffer is no longer allocated */
??rxHaltCleanupFinalStep_1:
        MOV     DPTR,#pRxBuf
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  318 
//  319   pFuncRxState = &rxStartIsr;
        MOV     DPTR,#pFuncRxState
        MOV     A,#(??rxStartIsr?relay & 0xff)
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((??rxStartIsr?relay >> 8) & 0xff)
        MOVX    @DPTR,A
//  320 
//  321   /* if receive was active, perform the post receive updates */
//  322   if (macRxActive || macRxOutgoingAckFlag)
        MOV     DPTR,#macRxActive
        MOVX    A,@DPTR
        JNZ     ??rxHaltCleanupFinalStep_2
        MOV     DPTR,#macRxOutgoingAckFlag
        MOVX    A,@DPTR
        JZ      ??rxHaltCleanupFinalStep_3
//  323   {
//  324     macRxActive = MAC_RX_ACTIVE_NO_ACTIVITY;
??rxHaltCleanupFinalStep_2:
        MOV     A,#0x0
        MOV     DPTR,#macRxActive
        MOVX    @DPTR,A
//  325     macRxOutgoingAckFlag = 0;
        MOV     A,#0x0
        MOV     DPTR,#macRxOutgoingAckFlag
        MOVX    @DPTR,A
//  326     
//  327     rxPostRxUpdates();
        ; Setup parameters for call to function rxPostRxUpdates
        LCALL   ??rxPostRxUpdates?relay
//  328   }
//  329 }
??rxHaltCleanupFinalStep_3:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock4
        REQUIRE RFIM
        REQUIRE RFST
        REQUIRE RFIF
//  330 
//  331 
//  332 /**************************************************************************************************
//  333  * @fn          macRxThresholdIsr
//  334  *
//  335  * @brief       Interrupt service routine called when bytes in FIFO reach threshold value.
//  336  *              It implements a state machine for receiving a packet.
//  337  *
//  338  * @param       none
//  339  *
//  340  * @return      none
//  341  **************************************************************************************************
//  342  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  343 void macRxThresholdIsr(void)
macRxThresholdIsr:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function macRxThresholdIsr
//  344 {
        FUNCALL macRxThresholdIsr, rxHaltCleanupFinalStep
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  345   /* if currently reseting, do not execute receive ISR logic */
//  346   if (rxResetFlag)
        MOV     DPTR,#rxResetFlag
        MOVX    A,@DPTR
        JNZ     ??macRxThresholdIsr_0
//  347   {
//  348     return;
//  349   }
//  350   
//  351   /*
//  352    *  Call the function that handles the current receive state.
//  353    *  A flag is set for the duration of the call to indicate
//  354    *  the ISR is executing.  This is necessary for the reset
//  355    *  logic so it does not perform a reset in the middle of
//  356    *  executing the ISR.
//  357    */
//  358   rxIsrActiveFlag = 1;
        MOV     A,#0x1
        MOV     DPTR,#rxIsrActiveFlag
        MOVX    @DPTR,A
//  359   (*pFuncRxState)();
        ; Setup parameters for indirect call
        MOV     DPTR,#pFuncRxState
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        LCALL   ?CALL_IND
//  360   rxIsrActiveFlag = 0;
        MOV     A,#0x0
        MOV     DPTR,#rxIsrActiveFlag
        MOVX    @DPTR,A
//  361   
//  362   /* if a reset occurred during the ISR, peform cleanup here */
//  363   if (rxResetFlag)
        MOV     DPTR,#rxResetFlag
        MOVX    A,@DPTR
        JZ      ??macRxThresholdIsr_0
//  364   {
//  365     rxHaltCleanupFinalStep();
        ; Setup parameters for call to function rxHaltCleanupFinalStep
        LCALL   ??rxHaltCleanupFinalStep?relay
//  366     rxResetFlag = 0;
        MOV     A,#0x0
        MOV     DPTR,#rxResetFlag
        MOVX    @DPTR,A
??macRxThresholdIsr_0:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock5
//  367   }
//  368 }
//  369 
//  370 
//  371 /*=================================================================================================
//  372  * @fn          rxStartIsr
//  373  *
//  374  * @brief       First ISR state for receiving a packet - compute packet length, allocate
//  375  *              buffer, initialize buffer.  Acknowledgements are handled immediately without
//  376  *              allocating a buffer.
//  377  *
//  378  * @param       none
//  379  *
//  380  * @return      none
//  381  *=================================================================================================
//  382  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  383 static void rxStartIsr(void)
rxStartIsr:
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function rxStartIsr
//  384 {
        FUNCALL rxStartIsr, halAssertHandler
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, rxPostRxUpdates
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, macCspForceTxDoneIfPending
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, macMemReadRxFifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, rxDone
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, macMemReadRxFifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, halAssertHandler
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, macRadioComputeLQI
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, macTxAckReceivedCallback
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, macTxAckNotReceivedCallback
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, rxDone
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, macTxAckNotReceivedCallback
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, rxDiscardFrame
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, rxDone
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, rxDiscardFrame
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, macDataRxMemAlloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, rxDiscardFrame
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, macRxCheckPendingCallback
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, macMcuOverflowCapture
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, macMcuTimerCapture
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxStartIsr, rxPrepPayload
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xf
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 15)
        ; Saved register size: 15
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 17)
//  385   uint8  addrLen;
//  386   uint8  ackWithPending;
//  387   uint8  dstAddrMode;
//  388   uint8  srcAddrMode;
//  389 
//  390   MAC_ASSERT(!macRxActive); /* receive on top of receive */
        MOV     DPTR,#macRxActive
        MOVX    A,@DPTR
        JZ      ??rxStartIsr_0
        ; Setup parameters for call to function halAssertHandler
        LCALL   ??halAssertHandler?relay
//  391 
//  392   /* indicate rx is active */
//  393   macRxActive = MAC_RX_ACTIVE_STARTED;
??rxStartIsr_0:
        MOV     A,#-0x7f
        MOV     DPTR,#macRxActive
        MOVX    @DPTR,A
//  394 
//  395   /*
//  396    *  For bullet proof functionality, need to see if the receiver was just turned off.
//  397    *  The logic to request turning off the receiver, disables interrupts and then checks
//  398    *  the value of macRxActive.  If it is TRUE, the receiver will not be turned off.
//  399    *
//  400    *  There is a small hole though.  It's possible to attempt turning off the receiver
//  401    *  in the window from when the receive interrupt fires and the point where macRxActive
//  402    *  is set to TRUE.  To plug this hole, the on/off status must be tested *after*
//  403    *  macRxActive has been set.  If the receiver is off at this point, there is nothing
//  404    *  in the RX fifo and the receive is simply aborted.
//  405    *
//  406    *  Also, there are some considerations in case a hard disable just happened.  Usually,
//  407    *  the receiver will just be off at this point after a hard disable.  The check described
//  408    *  above will account for this case too.  However, if a hard disable were immediately
//  409    *  followed by an enable, the receiver would be on.  To catch this case, the receive
//  410    *  FIFO is also tested to see if it is empty.  Recovery is identical to the other cases.
//  411    */
//  412   if (!macRxOnFlag || MAC_RADIO_RX_FIFO_IS_EMPTY())
        MOV     DPTR,#macRxOnFlag
        MOVX    A,@DPTR
        JZ      ??rxStartIsr_1
        MOV     DPTR,#-0x209e
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.3
        JC      ??rxStartIsr_2
        MOV     DPTR,#-0x209e
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.2
        JC      ??rxStartIsr_2
//  413   {
//  414     /* reset active flag */
//  415     macRxActive = MAC_RX_ACTIVE_NO_ACTIVITY;
??rxStartIsr_1:
        MOV     A,#0x0
        MOV     DPTR,#macRxActive
        MOVX    @DPTR,A
//  416 
//  417     /*
//  418      *  To be absolutely bulletproof, must make sure no transmit queue'ed up during
//  419      *  the tiny, tiny window when macRxActive was not zero.
//  420      */
//  421     rxPostRxUpdates();
        ; Setup parameters for call to function rxPostRxUpdates
        LCALL   ??rxPostRxUpdates?relay
//  422 
//  423     /* return immediately from here */
//  424     return;
        LJMP    ??rxStartIsr_3 & 0xFFFF
//  425   }
//  426       
//  427   /*
//  428    *  If interrupts are held off for too long it's possible the previous "transmit done"
//  429    *  callback is pending.  If this is the case, it needs to be completed before
//  430    *  continuing with the receive logic.
//  431    */
//  432   MAC_RADIO_FORCE_TX_DONE_IF_PENDING();
??rxStartIsr_2:
        ; Setup parameters for call to function macCspForceTxDoneIfPending
        LCALL   ??macCspForceTxDoneIfPending?relay
//  433   
//  434   /*
//  435    *  It's possible receive logic is still waiting for confirmation of an ACK that went out
//  436    *  for the previous receive.  This is OK but the callback needs to be canceled at this point.
//  437    *  That callback execute receive cleanup logic that will run at the completion
//  438    *  of *this* receive.  Also, it is important the flag for the outgoing ACK to be cleared.
//  439    */
//  440   MAC_RADIO_CANCEL_ACK_TX_DONE_CALLBACK();
        ANL     0x91,#0xbf
//  441   macRxOutgoingAckFlag = 0;
        MOV     A,#0x0
        MOV     DPTR,#macRxOutgoingAckFlag
        MOVX    @DPTR,A
//  442 
//  443   /*
//  444    *  Make a module-local copy of macRxFilter.  This prevents the selected
//  445    *  filter from changing in the middle of a receive.
//  446    */
//  447   rxFilter = macRxFilter;
        MOV     DPTR,#macRxFilter
        MOVX    A,@DPTR
        MOV     DPTR,#rxFilter
        MOVX    @DPTR,A
//  448 
//  449   /*-------------------------------------------------------------------------------
//  450    *  Read initial frame information from FIFO.
//  451    *
//  452    *   This code is not triggered until the following are in the RX FIFO:
//  453    *     frame length          - one byte containing length of MAC frame (excludes this field)
//  454    *     frame control field   - two bytes defining frame type, addressing fields, control flags
//  455    *     sequence number       - one byte unique sequence identifier
//  456    *     additional two bytes  - these bytes are available in case the received frame is an ACK,
//  457    *                             if so, the frame can be verified and responded to immediately,
//  458    *                             if not an ACK, these bytes will be processed normally
//  459    */
//  460 
//  461   /* read frame length, frame control field, and sequence number from FIFO */
//  462   MAC_RADIO_READ_RX_FIFO(rxBuf, MAC_PHY_PHR_LEN + MAC_FCF_FIELD_LEN + MAC_SEQ_NUM_FIELD_LEN);
        ; Setup parameters for call to function macMemReadRxFifo
        MOV     R1,#0x4
        MOV     R2,#(rxBuf & 0xff)
        MOV     R3,#((rxBuf >> 8) & 0xff)
        LCALL   ??macMemReadRxFifo?relay
//  463 
//  464   /* bytes to read from FIFO equals frame length minus length of MHR fields just read from FIFO */
//  465   rxUnreadLen = (rxBuf[0] & PHY_PACKET_SIZE_MASK) - MAC_FCF_FIELD_LEN - MAC_SEQ_NUM_FIELD_LEN;
        MOV     DPTR,#rxBuf
        MOVX    A,@DPTR
        ANL     A,#0x7f
        ADD     A,#-0x3
        MOV     DPTR,#rxUnreadLen
        MOVX    @DPTR,A
//  466 
//  467   /*
//  468    *  Workaround for chip bug.  The receive buffer can sometimes be corrupted by hardware.
//  469    *  This usually occurs under heavy traffic.  If a corrupted receive buffer is detected
//  470    *  the entire receive buffer is flushed.
//  471    *
//  472    *  In the case that this workaround is not needed, an assert is used to make sure the
//  473    *  receive length field is not corrupted.  This is important because a corrupted receive
//  474    *  length field is utterly fatal and, if not caught here, extremely hard to track down.
//  475    */
//  476 #ifdef MAC_RADIO_RXBUFF_CHIP_BUG
//  477   if ((rxUnreadLen > (MAC_A_MAX_PHY_PACKET_SIZE - MAC_FCF_FIELD_LEN - MAC_SEQ_NUM_FIELD_LEN)) ||
//  478       (MAC_FRAME_TYPE(&rxBuf[1]) > MAC_FRAME_TYPE_MAX_VALID))
        MOV     DPTR,#rxUnreadLen
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x7d
        JNC     ??rxStartIsr_4
        MOV     DPTR,#(rxBuf + 1)
        MOVX    A,@DPTR
        ANL     A,#0x7
        CLR     C
        SUBB    A,#0x4
        JC      ??rxStartIsr_5
//  479   {
//  480     MAC_RADIO_FLUSH_RX_FIFO();
??rxStartIsr_4:
        MOV     0xe1,#-0x1a
        MOV     0xe1,#-0x1a
//  481     rxDone();
        ; Setup parameters for call to function rxDone
        LCALL   ??rxDone?relay
//  482     return;
        LJMP    ??rxStartIsr_3 & 0xFFFF
//  483   }
//  484 #else
//  485   /* radio supplied a corrupted receive buffer length */
//  486   MAC_ASSERT(rxUnreadLen <= (MAC_A_MAX_PHY_PACKET_SIZE - MAC_FCF_FIELD_LEN - MAC_SEQ_NUM_FIELD_LEN));
//  487 #endif
//  488   
//  489 
//  490 
//  491   /*-------------------------------------------------------------------------------
//  492    *  Process ACKs.
//  493    *
//  494    *  If this frame is an ACK, process it immediately and exit from here.
//  495    *  If this frame is not an ACK and transmit is listening for an ACK, let
//  496    *  the transmit logic know an non-ACK was received so transmit can complete.
//  497    *
//  498    *  In promiscuous mode ACKs are treated like any other frame.
//  499    */
//  500   if ((MAC_FRAME_TYPE(&rxBuf[1]) == MAC_FRAME_TYPE_ACK) && (rxPromiscuousMode == PROMISCUOUS_MODE_OFF))
??rxStartIsr_5:
        MOV     DPTR,#(rxBuf + 1)
        MOVX    A,@DPTR
        ANL     A,#0x7
        XRL     A,#0x2
        JZ      $+5
        LJMP    ??rxStartIsr_6 & 0xFFFF
        MOV     DPTR,#rxPromiscuousMode
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??rxStartIsr_6 & 0xFFFF
//  501   {
//  502     uint8 fcsBuf[MAC_FCF_FIELD_LEN];
//  503     /*
//  504      *  There are guaranteed to be two unread bytes in the FIFO.  By defintion, for ACK frames
//  505      *  these two bytes will be the FCS.
//  506      */
//  507 
//  508     /* read FCS from FIFO (threshold set so bytes are guaranteed to be there) */
//  509     MAC_RADIO_READ_RX_FIFO(fcsBuf, MAC_FCS_FIELD_LEN);
        ; Setup parameters for call to function macMemReadRxFifo
        MOV     R1,#0x2
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??macMemReadRxFifo?relay
//  510     
//  511     /* see if transmit is listening for an ACK */
//  512     if (macTxActive == MAC_TX_ACTIVE_LISTEN_FOR_ACK)
        MOV     DPTR,#macTxActive
        MOVX    A,@DPTR
        XRL     A,#0x86
        JZ      $+5
        LJMP    ??rxStartIsr_7 & 0xFFFF
//  513     {
//  514       MAC_ASSERT(pMacDataTx != NULL); /* transmit buffer must be present */
        MOV     DPTR,#pMacDataTx
        MOVX    A,@DPTR
        XRL     A,#0x0
        JNZ     ??rxStartIsr_8
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
??rxStartIsr_8:
        JNZ     ??rxStartIsr_9
        ; Setup parameters for call to function halAssertHandler
        LCALL   ??halAssertHandler?relay
//  515 
//  516       /* record link quality metrics for the receive ACK */
//  517       {
//  518         int8 rssiDbm;
//  519         uint8 corr;
//  520 
//  521         rssiDbm = PROPRIETARY_FCS_RSSI(fcsBuf) + MAC_RADIO_RSSI_OFFSET;
??rxStartIsr_9:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,#-0x2d
        MOV     ?V0 + 1,A
//  522         corr = PROPRIETARY_FCS_CORRELATION_VALUE(fcsBuf);
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ANL     A,#0x7f
        MOV     ?V0 + 0,A
//  523     
//  524         pMacDataTx->internal.mpduLinkQuality = macRadioComputeLQI(rssiDbm, corr);
        ; Setup parameters for call to function macRadioComputeLQI
        MOV     R2,?V0 + 0
        MOV     R1,?V0 + 1
        LCALL   ??macRadioComputeLQI?relay
        MOV     A,R1
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#pMacDataTx
        MOVX    A,@DPTR
        ADD     A,#0x14
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  525         pMacDataTx->internal.correlation = corr;
        MOV     DPTR,#pMacDataTx
        MOVX    A,@DPTR
        ADD     A,#0x15
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
//  526         pMacDataTx->internal.rssi= rssiDbm;
        MOV     DPTR,#pMacDataTx
        MOVX    A,@DPTR
        ADD     A,#0x16
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
//  527       }
//  528 
//  529       /*
//  530        *  An ACK was received so transmit logic needs to know.  If the FCS failed,
//  531        *  the transmit logic still needs to know.  In that case, treat the frame
//  532        *  as a non-ACK to complete the active transmit.
//  533        */
//  534       if (PROPRIETARY_FCS_CRC_OK(fcsBuf))
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.7
        JNC     ??rxStartIsr_10
//  535       {
//  536         /* call transmit logic to indicate ACK was received */
//  537         macTxAckReceivedCallback(MAC_SEQ_NUMBER(&rxBuf[1]), MAC_FRAME_PENDING(&rxBuf[1]));
        ; Setup parameters for call to function macTxAckReceivedCallback
        MOV     DPTR,#(rxBuf + 1)
        MOVX    A,@DPTR
        ANL     A,#0x10
        MOV     R2,A
        MOV     DPTR,#(rxBuf + 3)
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??macTxAckReceivedCallback?relay
        SJMP    ??rxStartIsr_7
//  538       }
//  539       else
//  540       {
//  541         macTxAckNotReceivedCallback();
??rxStartIsr_10:
        ; Setup parameters for call to function macTxAckNotReceivedCallback
        LCALL   ??macTxAckNotReceivedCallback?relay
//  542       }
//  543     }
//  544       
//  545     /* receive is done, exit from here */
//  546     rxDone();
??rxStartIsr_7:
        ; Setup parameters for call to function rxDone
        LCALL   ??rxDone?relay
//  547     return;
        LJMP    ??rxStartIsr_3 & 0xFFFF
//  548   }
//  549   else if (macTxActive == MAC_TX_ACTIVE_LISTEN_FOR_ACK)
??rxStartIsr_6:
        MOV     DPTR,#macTxActive
        MOVX    A,@DPTR
        XRL     A,#0x86
        JNZ     ??rxStartIsr_11
//  550   {
//  551     macTxAckNotReceivedCallback();
        ; Setup parameters for call to function macTxAckNotReceivedCallback
        LCALL   ??macTxAckNotReceivedCallback?relay
//  552   }
//  553 
//  554   /*-------------------------------------------------------------------------------
//  555    *  Apply filtering.
//  556    *
//  557    *  For efficiency, see if filtering is even 'on' before processing.  Also test
//  558    *  to make sure promiscuous mode is disabled.  If promiscuous mode is enabled,
//  559    *  do not apply filtering.
//  560    */
//  561   if ((rxFilter != RX_FILTER_OFF) && !rxPromiscuousMode)
??rxStartIsr_11:
        MOV     DPTR,#rxFilter
        MOVX    A,@DPTR
        JZ      ??rxStartIsr_12
        MOV     DPTR,#rxPromiscuousMode
        MOVX    A,@DPTR
        JNZ     ??rxStartIsr_12
//  562   {
//  563     if (/* filter all frames */
//  564          (rxFilter == RX_FILTER_ALL) ||
//  565 
//  566          /* filter non-beacon frames */
//  567          ((rxFilter == RX_FILTER_NON_BEACON_FRAMES) &&
//  568           (MAC_FRAME_TYPE(&rxBuf[1]) != MAC_FRAME_TYPE_BEACON)) ||
//  569 
//  570          /* filter non-command frames */
//  571          ((rxFilter == RX_FILTER_NON_COMMAND_FRAMES) &&
//  572           ((MAC_FRAME_TYPE(&rxBuf[1]) != MAC_FRAME_TYPE_COMMAND))))
        MOV     DPTR,#rxFilter
        MOVX    A,@DPTR
        XRL     A,#0x1
        JZ      ??rxStartIsr_13
        MOV     DPTR,#rxFilter
        MOVX    A,@DPTR
        XRL     A,#0x2
        JNZ     ??rxStartIsr_14
        MOV     DPTR,#(rxBuf + 1)
        MOVX    A,@DPTR
        ANL     A,#0x7
        JNZ     ??rxStartIsr_13
??rxStartIsr_14:
        MOV     DPTR,#rxFilter
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??rxStartIsr_12
        MOV     DPTR,#(rxBuf + 1)
        MOVX    A,@DPTR
        ANL     A,#0x7
        XRL     A,#0x3
        JZ      ??rxStartIsr_12
//  573     {
//  574       /* discard rest of frame */
//  575       rxDiscardFrame();
??rxStartIsr_13:
        ; Setup parameters for call to function rxDiscardFrame
        LCALL   ??rxDiscardFrame?relay
//  576       return;
        LJMP    ??rxStartIsr_3 & 0xFFFF
//  577     }
//  578   }
//  579 
//  580   /*-------------------------------------------------------------------------------
//  581    *  Compute length of addressing fields.  Compute payload length.
//  582    */
//  583 
//  584   /* decode addressing modes */
//  585   dstAddrMode = MAC_DEST_ADDR_MODE(&rxBuf[1]);
??rxStartIsr_12:
        MOV     DPTR,#(rxBuf + 2)
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        ANL     A,#0x3f
        ANL     A,#0x3
        MOV     ?V0 + 4,A
//  586   srcAddrMode = MAC_SRC_ADDR_MODE(&rxBuf[1]);
        MOV     DPTR,#(rxBuf + 2)
        MOVX    A,@DPTR
        SWAP    A
        RRC     A
        RRC     A
        ANL     A,#0x3
        MOV     R7,A
//  587 
//  588   /*
//  589    *  Workaround for chip bug.  The receive buffer can sometimes be corrupted by hardware.
//  590    *  This usually occurs under heavy traffic.  If a corrupted receive buffer is detected
//  591    *  the entire receive buffer is flushed.
//  592    */
//  593 #ifdef MAC_RADIO_RXBUFF_CHIP_BUG
//  594   if ((srcAddrMode == ADDR_MODE_RESERVERED) || (dstAddrMode == ADDR_MODE_RESERVERED))
        MOV     A,#0x1
        XRL     A,R7
        JZ      ??rxStartIsr_15
        MOV     A,#0x1
        XRL     A,?V0 + 4
        JNZ     ??rxStartIsr_16
//  595   {
//  596     MAC_RADIO_FLUSH_RX_FIFO();
??rxStartIsr_15:
        MOV     0xe1,#-0x1a
        MOV     0xe1,#-0x1a
//  597     rxDone();
        ; Setup parameters for call to function rxDone
        LCALL   ??rxDone?relay
//  598     return;
        LJMP    ??rxStartIsr_3 & 0xFFFF
//  599   }
//  600 #endif
//  601 
//  602   /*
//  603    *  Compute the addressing field length.  A lookup table based on addressing
//  604    *  mode is used for efficiency.  If the source address is present and the
//  605    *  frame is intra-PAN, the PAN Id is not repeated.  In this case, the address
//  606    *  length is adjusted to match the smaller length.
//  607    */
//  608   addrLen = macRxAddrLen[dstAddrMode] + macRxAddrLen[srcAddrMode];
??rxStartIsr_16:
        MOV     ?V0 + 0,R7
        MOV     ?V0 + 1,#0x0
        MOV     A,?V0 + 0
        ADD     A,#(macRxAddrLen & 0xff)
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#((macRxAddrLen >> 8) & 0xff)
        MOV     DPH,A
        CLR     A
        MOVC    A,@A+DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,#0x0
        MOV     A,?V0 + 0
        ADD     A,#(macRxAddrLen & 0xff)
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#((macRxAddrLen >> 8) & 0xff)
        MOV     DPH,A
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R2,A
        POP     A
        CFI CFA_SP SP+0
        ADD     A,R2
        MOV     R6,A
//  609   if ((srcAddrMode != SADDR_MODE_NONE) && MAC_INTRA_PAN(&rxBuf[1]))
        MOV     A,R7
        JZ      ??rxStartIsr_17
        MOV     DPTR,#(rxBuf + 1)
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.6
        JNC     ??rxStartIsr_17
//  610   {
//  611     addrLen -= MAC_PAN_ID_FIELD_LEN;
        DEC     R6
        DEC     R6
//  612   }
//  613 
//  614   /*
//  615    *  If there are not enough unread bytes to include the computed address
//  616    *  plus FCS field, the frame is corrupted and must be discarded.
//  617    */
//  618   if ((addrLen + MAC_FCS_FIELD_LEN) > rxUnreadLen)
??rxStartIsr_17:
        MOV     DPTR,#rxUnreadLen
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     ?V0 + 0,R6
        MOV     ?V0 + 1,#0x0
        MOV     A,#0x2
        ADD     A,?V0 + 0
        MOV     R0,A
        MOV     A,#0x0
        ADDC    A,?V0 + 1
        MOV     R1,A
        CLR     C
        MOV     A,R2
        SUBB    A,R0
        MOV     A,R3
        SUBB    A,R1
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??rxStartIsr_18
//  619   {
//  620     /* discard frame and exit */
//  621     rxDiscardFrame();
        ; Setup parameters for call to function rxDiscardFrame
        LCALL   ??rxDiscardFrame?relay
//  622     return;
        LJMP    ??rxStartIsr_3 & 0xFFFF
//  623   }
//  624 
//  625   /* payload length is equal to unread bytes minus address length, minus the FCS */
//  626   rxPayloadLen = rxUnreadLen - addrLen - MAC_FCS_FIELD_LEN;
??rxStartIsr_18:
        MOV     DPTR,#rxUnreadLen
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R6
        ADD     A,#-0x2
        MOV     DPTR,#rxPayloadLen
        MOVX    @DPTR,A
//  627 
//  628   /*-------------------------------------------------------------------------------
//  629    *  Allocate memory for the incoming frame.
//  630    */
//  631   pRxBuf = (macRx_t *) MEM_ALLOC(sizeof(macRx_t) + rxPayloadLen);
        ; Setup parameters for call to function macDataRxMemAlloc
        MOV     DPTR,#rxPayloadLen
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#0x32
        ADD     A,R0
        MOV     R2,A
        MOV     A,#0x0
        ADDC    A,R1
        MOV     R3,A
        LCALL   ??macDataRxMemAlloc?relay
        MOV     DPTR,#pRxBuf
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  632   if (pRxBuf == NULL)
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        XRL     A,#0x0
        JNZ     ??rxStartIsr_19
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
??rxStartIsr_19:
        JNZ     ??rxStartIsr_20
//  633   {
//  634     /* buffer allocation failed, discard the frame and exit*/
//  635     rxDiscardFrame();
        ; Setup parameters for call to function rxDiscardFrame
        LCALL   ??rxDiscardFrame?relay
//  636     return;
        LJMP    ??rxStartIsr_3 & 0xFFFF
//  637   }
//  638 
//  639   /*-------------------------------------------------------------------------------
//  640    *  Set up to process ACK request.  Do not ACK if in promiscuous mode.
//  641    */
//  642   ackWithPending = 0;
??rxStartIsr_20:
        MOV     ?V0 + 5,#0x0
//  643   if (!rxPromiscuousMode)
        MOV     DPTR,#rxPromiscuousMode
        MOVX    A,@DPTR
        JNZ     ??rxStartIsr_21
//  644   {
//  645     macRxOutgoingAckFlag = MAC_ACK_REQUEST(&rxBuf[1]);
        MOV     DPTR,#(rxBuf + 1)
        MOVX    A,@DPTR
        ANL     A,#0x20
        MOV     DPTR,#macRxOutgoingAckFlag
        MOVX    @DPTR,A
//  646   }
//  647 
//  648   /*-------------------------------------------------------------------------------
//  649    *  Process any ACK request.
//  650    */
//  651   if (macRxOutgoingAckFlag)
??rxStartIsr_21:
        MOV     DPTR,#macRxOutgoingAckFlag
        MOVX    A,@DPTR
        JZ      ??rxStartIsr_22
//  652   {
//  653     halIntState_t  s;
//  654 
//  655     /*
//  656      *  This critical section ensures that the callback ISR is initiated within time
//  657      *  to guarantee correlation with the strobe.
//  658      */
//  659     HAL_ENTER_CRITICAL_SECTION(s);
        MOV     C,0xa8.7
        CLR     A
        MOV     0xE0 /* A   */.0,C
        MOV     ?V0 + 6,A
        CLR     0xa8.7
//  660 
//  661     if ((MAC_FRAME_TYPE(&rxBuf[1]) == MAC_FRAME_TYPE_COMMAND) && macRxCheckPendingCallback())
        MOV     DPTR,#(rxBuf + 1)
        MOVX    A,@DPTR
        ANL     A,#0x7
        XRL     A,#0x3
        JNZ     ??rxStartIsr_23
        ; Setup parameters for call to function macRxCheckPendingCallback
        LCALL   ??macRxCheckPendingCallback?relay
        MOV     A,R1
        JZ      ??rxStartIsr_23
//  662     {
//  663       MAC_RADIO_TX_ACK_PEND();
        MOV     0xe1,#-0x17
//  664       ackWithPending = MAC_RX_FLAG_ACK_PENDING;
        MOV     ?V0 + 5,#0x4
        SJMP    ??rxStartIsr_24
//  665     }
//  666     else
//  667     {
//  668       /* send ACK */
//  669       MAC_RADIO_TX_ACK();
??rxStartIsr_23:
        MOV     0xe1,#-0x18
//  670     }
//  671 
//  672     /* request a callback to macRxAckTxDoneCallback() when the ACK transmit has finished */
//  673     MAC_RADIO_REQUEST_ACK_TX_DONE_CALLBACK();
??rxStartIsr_24:
        MOV     C,0xa8.7
        CLR     A
        MOV     0xE0 /* A   */.0,C
        CLR     0xa8.7
        MOV     0xe9,#-0x41
        MOV     0x9b,#0x0
        MOV     0xe9,#-0x1
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
        ORL     0x91,#0x40
//  674     HAL_EXIT_CRITICAL_SECTION(s);
        MOV     A,?V0 + 6
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
//  675   }
//  676 
//  677  /*-------------------------------------------------------------------------------
//  678   *  Populate the receive buffer going up to high-level.
//  679   */
//  680 
//  681   /* configure the payload buffer */
//  682   pRxBuf->msdu.p = (uint8 *) (pRxBuf + 1);
??rxStartIsr_22:
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x32
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  683   pRxBuf->msdu.len = rxPayloadLen;
        MOV     DPTR,#rxPayloadLen
        MOVX    A,@DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  684 
//  685   /* set internal values */
//  686   pRxBuf->mac.srcAddr.addrMode  = srcAddrMode;
        MOV     A,R7
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x1a
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  687   pRxBuf->mac.dstAddr.addrMode  = dstAddrMode;
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x23
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
//  688   pRxBuf->mac.timestamp         = MAC_RADIO_BACKOFF_CAPTURE();
        ; Setup parameters for call to function macMcuOverflowCapture
        LCALL   ??macMcuOverflowCapture?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x24
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_TO_X
//  689   pRxBuf->mac.timestamp2        = MAC_RADIO_TIMER_CAPTURE();
        ; Setup parameters for call to function macMcuTimerCapture
        LCALL   ??macMcuTimerCapture?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x28
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
//  690   pRxBuf->internal.frameType    = MAC_FRAME_TYPE(&rxBuf[1]);
        MOV     DPTR,#(rxBuf + 1)
        MOVX    A,@DPTR
        ANL     A,#0x7
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  691   pRxBuf->mac.dsn               = MAC_SEQ_NUMBER(&rxBuf[1]);
        MOV     DPTR,#(rxBuf + 3)
        MOVX    A,@DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x31
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  692   pRxBuf->internal.flags        = INTERNAL_FCF_FLAGS(&rxBuf[1]) | ackWithPending;
        MOV     DPTR,#(rxBuf + 1)
        MOVX    A,@DPTR
        ANL     A,#0x78
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#(rxBuf + 2)
        MOVX    A,@DPTR
        SWAP    A
        ANL     A,#0xf
        ANL     A,#0x3
        MOV     R2,A
        POP     A
        CFI CFA_SP SP+0
        ORL     A,R2
        ORL     A,?V0 + 5
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  693   pRxBuf->sec.securityLevel     = MAC_SEC_LEVEL_NONE;
        MOV     A,#0x0
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0xf
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  694 
//  695   /*-------------------------------------------------------------------------------
//  696    *  If the processing the addressing fields does not require more bytes from
//  697    *  the FIFO go directly address processing function.  Otherwise, configure
//  698    *  interrupt to jump there once bytes are received.
//  699    */
//  700   if (addrLen == 0)
        MOV     A,R6
        JNZ     ??rxStartIsr_25
//  701   {
//  702     /* no addressing fields to read, prepare for payload interrupts */
//  703     pFuncRxState = &rxPayloadIsr;
        MOV     DPTR,#pFuncRxState
        MOV     A,#(??rxPayloadIsr?relay & 0xff)
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((??rxPayloadIsr?relay >> 8) & 0xff)
        MOVX    @DPTR,A
//  704     rxPrepPayload();
        ; Setup parameters for call to function rxPrepPayload
        LCALL   ??rxPrepPayload?relay
        SJMP    ??rxStartIsr_3
//  705   }
//  706   else
//  707   {
//  708     /* need to read and process addressing fields, prepare for address interrupt */
//  709     rxNextLen = addrLen;
??rxStartIsr_25:
        MOV     A,R6
        MOV     DPTR,#rxNextLen
        MOVX    @DPTR,A
//  710     MAC_RADIO_SET_RX_THRESHOLD(rxNextLen);
        MOV     DPTR,#rxNextLen
        MOVX    A,@DPTR
        ADD     A,#-0x1
        MOV     DPTR,#-0x20b1
        MOVX    @DPTR,A
//  711     pFuncRxState = &rxAddrIsr;
        MOV     DPTR,#pFuncRxState
        MOV     A,#(??rxAddrIsr?relay & 0xff)
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((??rxAddrIsr?relay >> 8) & 0xff)
        MOVX    @DPTR,A
??rxStartIsr_3:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 15)
        MOV     R7,#0x7
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock6
        REQUIRE _A_IEN0
        REQUIRE RFIM
        REQUIRE S1CON
        REQUIRE RFST
        REQUIRE RFIF
//  712   }
//  713 }
//  714 
//  715 
//  716 /*=================================================================================================
//  717  * @fn          rxAddrIsr
//  718  *
//  719  * @brief       Receive ISR state for decoding address.  Reads and stores the address information
//  720  *              from the incoming packet.
//  721  *
//  722  * @param       none
//  723  *
//  724  * @return      none
//  725  *=================================================================================================
//  726  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  727 static void rxAddrIsr(void)
rxAddrIsr:
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function rxAddrIsr
//  728 {
        FUNCALL rxAddrIsr, halAssertHandler
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxAddrIsr, macMemReadRxFifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxAddrIsr, sAddrExtCpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxAddrIsr, sAddrExtCpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxAddrIsr, rxPrepPayload
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 20
        MOV     A,#-0x14
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 30)
//  729   uint8 buf[MAX_ADDR_FIELDS_LEN];
//  730   uint8 dstAddrMode;
//  731   uint8 srcAddrMode;
//  732   uint8  * p;
//  733 
//  734   MAC_ASSERT(rxNextLen != 0); /* logic assumes at least one address byte in buffer */
        MOV     DPTR,#rxNextLen
        MOVX    A,@DPTR
        JNZ     ??rxAddrIsr_0
        ; Setup parameters for call to function halAssertHandler
        LCALL   ??halAssertHandler?relay
//  735 
//  736   /*  read out address fields into local buffer in one shot */
//  737   MAC_RADIO_READ_RX_FIFO(buf, rxNextLen);
??rxAddrIsr_0:
        ; Setup parameters for call to function macMemReadRxFifo
        MOV     DPTR,#rxNextLen
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??macMemReadRxFifo?relay
//  738 
//  739   /* set pointer to buffer with addressing fields */
//  740   p = buf;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R6,DPL
        MOV     R7,DPH
//  741 
//  742   /* destination address */
//  743   dstAddrMode = MAC_DEST_ADDR_MODE(&rxBuf[1]);
        MOV     DPTR,#(rxBuf + 2)
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        ANL     A,#0x3f
        ANL     A,#0x3
        MOV     ?V0 + 0,A
//  744   if (dstAddrMode != SADDR_MODE_NONE)
        MOV     A,?V0 + 0
        JNZ     $+5
        LJMP    ??rxAddrIsr_1 & 0xFFFF
//  745   {
//  746     pRxBuf->mac.srcPanId = pRxBuf->mac.dstPanId = BUILD_UINT16(p[0], p[1]);
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R0
        ADD     A,R2
        MOV     R0,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R1,A
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x2c
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x2a
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  747     p += MAC_PAN_ID_FIELD_LEN;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
//  748     if (dstAddrMode == SADDR_MODE_EXT)
        MOV     A,#0x3
        XRL     A,?V0 + 0
        JNZ     ??rxAddrIsr_2
//  749     {
//  750       sAddrExtCpy(pRxBuf->mac.dstAddr.addr.extAddr, p);
        ; Setup parameters for call to function sAddrExtCpy
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x1b
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??sAddrExtCpy?relay
//  751       p += MAC_EXT_ADDR_FIELD_LEN;
        MOV     A,R6
        ADD     A,#0x8
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
        SJMP    ??rxAddrIsr_1
//  752     }
//  753     else
//  754     {
//  755       pRxBuf->mac.dstAddr.addr.shortAddr = BUILD_UINT16(p[0], p[1]);
??rxAddrIsr_2:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R0
        ADD     A,R2
        MOV     R2,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R3,A
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x1b
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  756       p += MAC_SHORT_ADDR_FIELD_LEN;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
//  757     }
//  758   }
//  759 
//  760   /* sources address */
//  761   srcAddrMode = MAC_SRC_ADDR_MODE(&rxBuf[1]);
??rxAddrIsr_1:
        MOV     DPTR,#(rxBuf + 2)
        MOVX    A,@DPTR
        SWAP    A
        RRC     A
        RRC     A
        ANL     A,#0x3
        MOV     ?V0 + 1,A
//  762   if (srcAddrMode != SADDR_MODE_NONE)
        MOV     A,?V0 + 1
        JNZ     $+5
        LJMP    ??rxAddrIsr_3 & 0xFFFF
//  763   {
//  764     if (!(pRxBuf->internal.flags & MAC_RX_FLAG_INTRA_PAN))
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.6
        JC      ??rxAddrIsr_4
//  765     {
//  766       pRxBuf->mac.srcPanId = BUILD_UINT16(p[0], p[1]);
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R0
        ADD     A,R2
        MOV     R2,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R3,A
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x2a
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  767       p += MAC_PAN_ID_FIELD_LEN;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
//  768     }
//  769     if (srcAddrMode == SADDR_MODE_EXT)
??rxAddrIsr_4:
        MOV     A,#0x3
        XRL     A,?V0 + 1
        JNZ     ??rxAddrIsr_5
//  770     {
//  771       sAddrExtCpy(pRxBuf->mac.srcAddr.addr.extAddr, p);
        ; Setup parameters for call to function sAddrExtCpy
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??sAddrExtCpy?relay
        SJMP    ??rxAddrIsr_3
//  772     }
//  773     else
//  774     {
//  775       pRxBuf->mac.srcAddr.addr.shortAddr = BUILD_UINT16(p[0], p[1]);
??rxAddrIsr_5:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R0
        ADD     A,R2
        MOV     R2,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R3,A
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x12
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  776     }
//  777   }
//  778 
//  779   /*-------------------------------------------------------------------------------
//  780    *  Prepare for payload interrupts.
//  781    */
//  782   pFuncRxState = &rxPayloadIsr;
??rxAddrIsr_3:
        MOV     DPTR,#pFuncRxState
        MOV     A,#(??rxPayloadIsr?relay & 0xff)
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((??rxPayloadIsr?relay >> 8) & 0xff)
        MOVX    @DPTR,A
//  783   rxPrepPayload();
        ; Setup parameters for call to function rxPrepPayload
        LCALL   ??rxPrepPayload?relay
//  784 }
        MOV     A,#0x14
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock7
//  785 
//  786 
//  787 /*=================================================================================================
//  788  * @fn          rxPrepPayload
//  789  *
//  790  * @brief       Common code to prepare for the payload ISR.
//  791  *
//  792  * @param       none
//  793  *
//  794  * @return      none
//  795  *=================================================================================================
//  796  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  797 static void rxPrepPayload(void)
rxPrepPayload:
        CFI Block cfiBlock8 Using cfiCommon0
        CFI Function rxPrepPayload
//  798 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  799   if (rxPayloadLen == 0)
        MOV     DPTR,#rxPayloadLen
        MOVX    A,@DPTR
        JNZ     ??rxPrepPayload_0
//  800   {
//  801     MAC_RADIO_SET_RX_THRESHOLD(MAC_FCS_FIELD_LEN);
        MOV     A,#0x1
        MOV     DPTR,#-0x20b1
        MOVX    @DPTR,A
//  802     pFuncRxState = &rxFcsIsr;
        MOV     DPTR,#pFuncRxState
        MOV     A,#(??rxFcsIsr?relay & 0xff)
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((??rxFcsIsr?relay >> 8) & 0xff)
        MOVX    @DPTR,A
        SJMP    ??rxPrepPayload_1
//  803   }
//  804   else
//  805   {
//  806     rxNextLen = MIN(rxPayloadLen, MAX_PAYLOAD_BYTES_READ_PER_INTERRUPT);
??rxPrepPayload_0:
        MOV     DPTR,#rxPayloadLen
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x10
        JNC     ??rxPrepPayload_2
        MOV     DPTR,#rxPayloadLen
        MOVX    A,@DPTR
        MOV     R2,A
        SJMP    ??rxPrepPayload_3
??rxPrepPayload_2:
        MOV     R2,#0x10
??rxPrepPayload_3:
        MOV     A,R2
        MOV     DPTR,#rxNextLen
        MOVX    @DPTR,A
//  807     MAC_RADIO_SET_RX_THRESHOLD(rxNextLen);
        MOV     DPTR,#rxNextLen
        MOVX    A,@DPTR
        ADD     A,#-0x1
        MOV     DPTR,#-0x20b1
        MOVX    @DPTR,A
//  808   }
//  809 }
??rxPrepPayload_1:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock8
//  810 
//  811 
//  812 /*=================================================================================================
//  813  * @fn          rxPayloadIsr
//  814  *
//  815  * @brief       Receive ISR state for reading out and storing the packet payload.
//  816  *
//  817  * @param       none
//  818  *
//  819  * @return      none
//  820  *=================================================================================================
//  821  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  822 static void rxPayloadIsr(void)
rxPayloadIsr:
        CFI Block cfiBlock9 Using cfiCommon0
        CFI Function rxPayloadIsr
//  823 {
        FUNCALL rxPayloadIsr, macMemReadRxFifo
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxPayloadIsr, rxPrepPayload
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  824   MAC_RADIO_READ_RX_FIFO(pRxBuf->msdu.p, rxNextLen);
        ; Setup parameters for call to function macMemReadRxFifo
        MOV     DPTR,#rxNextLen
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??macMemReadRxFifo?relay
//  825   pRxBuf->msdu.p += rxNextLen;
        MOV     DPTR,#rxNextLen
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  826   rxPayloadLen -= rxNextLen;
        MOV     DPTR,#rxNextLen
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#rxPayloadLen
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R2
        MOVX    @DPTR,A
//  827 
//  828   rxPrepPayload();
        ; Setup parameters for call to function rxPrepPayload
        LCALL   ??rxPrepPayload?relay
//  829 }
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock9
//  830 
//  831 
//  832 /*=================================================================================================
//  833  * @fn          rxFcsIsr
//  834  *
//  835  * @brief       Receive ISR state for handling the FCS.
//  836  *
//  837  * @param       none
//  838  *
//  839  * @return      none
//  840  *=================================================================================================
//  841  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  842 static void rxFcsIsr(void)
rxFcsIsr:
        CFI Block cfiBlock10 Using cfiCommon0
        CFI Function rxFcsIsr
//  843 {
        FUNCALL rxFcsIsr, macMemReadRxFifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxFcsIsr, macRxOffRequest
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxFcsIsr, macRadioComputeLQI
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxFcsIsr, macRxCompleteCallback
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxFcsIsr, macDataRxMemFree
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxFcsIsr, rxDone
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
//  844   uint8 crcOK;
//  845 
//  846   /* read FCS, rxBuf is now available storage */
//  847   MAC_RADIO_READ_RX_FIFO(rxBuf, MAC_FCS_FIELD_LEN);
        ; Setup parameters for call to function macMemReadRxFifo
        MOV     R1,#0x2
        MOV     R2,#(rxBuf & 0xff)
        MOV     R3,#((rxBuf >> 8) & 0xff)
        LCALL   ??macMemReadRxFifo?relay
//  848 
//  849   /*
//  850    *  The FCS has actually been replaced within the radio by a proprietary version of the FCS.
//  851    *  This proprietary FCS is two bytes (same length as the real FCS) and contains:
//  852    *    1) the RSSI value
//  853    *    2) the average correlation value (used for LQI)
//  854    *    3) a CRC passed bit
//  855    */
//  856 
//  857   /* save the "CRC-is-OK" status */
//  858   crcOK = PROPRIETARY_FCS_CRC_OK(rxBuf);
        MOV     DPTR,#(rxBuf + 1)
        MOVX    A,@DPTR
        ANL     A,#0x80
        MOV     R6,A
//  859 
//  860   /*
//  861    *  See if the frame should be passed up to high-level MAC.  If the CRC is OK, the
//  862    *  the frame is always passed up.  Frames with a bad CRC are also passed up *if*
//  863    *  a special variant of promiscuous mode is active.
//  864    */
//  865   if (crcOK || (rxPromiscuousMode == MAC_PROMISCUOUS_MODE_WITH_BAD_CRC))
        MOV     A,R6
        JNZ     ??rxFcsIsr_0
        MOV     DPTR,#rxPromiscuousMode
        MOVX    A,@DPTR
        XRL     A,#0x2
        JZ      $+5
        LJMP    ??rxFcsIsr_1 & 0xFFFF
//  866   {
//  867     int8 rssiDbm;
//  868     uint8 corr;
//  869 
//  870     /*
//  871      *  As power saving optimization, set state variable to indicate physical receive
//  872      *  has completed and then request turning of the receiver.  This means the receiver
//  873      *  can be off (if other conditions permit) during execution of the callback function.
//  874      *
//  875      *  The receiver will be requested to turn off once again at the end of the receive
//  876      *  logic.  There is no harm in doing this.
//  877      */
//  878     macRxActive = MAC_RX_ACTIVE_DONE;
??rxFcsIsr_0:
        MOV     A,#0x2
        MOV     DPTR,#macRxActive
        MOVX    @DPTR,A
//  879     macRxOffRequest();
        ; Setup parameters for call to function macRxOffRequest
        LCALL   ??macRxOffRequest?relay
//  880     
//  881     /* decode RSSI and correlation values */
//  882     rssiDbm = PROPRIETARY_FCS_RSSI(rxBuf) + MAC_RADIO_RSSI_OFFSET;
        MOV     DPTR,#rxBuf
        MOVX    A,@DPTR
        ADD     A,#-0x2d
        MOV     R7,A
//  883     corr = PROPRIETARY_FCS_CORRELATION_VALUE(rxBuf);
        MOV     DPTR,#(rxBuf + 1)
        MOVX    A,@DPTR
        ANL     A,#0x7f
        MOV     ?V0 + 0,A
//  884     
//  885     /* record parameters that get passed up to high-level */
//  886     pRxBuf->internal.flags |= crcOK;
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ORL     A,R6
        MOVX    @DPTR,A
//  887     pRxBuf->mac.mpduLinkQuality = macRadioComputeLQI(rssiDbm, corr);
        ; Setup parameters for call to function macRadioComputeLQI
        MOV     R2,?V0 + 0
        MOV     A,R7
        MOV     R1,A
        LCALL   ??macRadioComputeLQI?relay
        MOV     A,R1
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x2e
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  888     pRxBuf->mac.rssi = rssiDbm;
        MOV     A,R7
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x30
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  889     pRxBuf->mac.correlation = corr;
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x2f
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
//  890 
//  891     /* set the MSDU pointer to point at start of data */
//  892     pRxBuf->msdu.p = (uint8 *) (pRxBuf + 1);
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        ADD     A,#0x32
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R2
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  893     
//  894     /* finally... execute callback function */
//  895     macRxCompleteCallback(pRxBuf);
        ; Setup parameters for call to function macRxCompleteCallback
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??macRxCompleteCallback?relay
//  896     pRxBuf = NULL; /* needed to indicate buffer is no longer allocated */
        MOV     DPTR,#pRxBuf
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??rxFcsIsr_2
//  897   }
//  898   else
//  899   {
//  900     /*
//  901      *  The CRC is bad so no ACK was sent.  Cancel any callback and clear the flag.
//  902      *  (It's OK to cancel the outgoing ACK even if an ACK was not requested.  It's
//  903      *  slightly more efficient to do so.)
//  904      */
//  905     MAC_RADIO_CANCEL_ACK_TX_DONE_CALLBACK();
??rxFcsIsr_1:
        ANL     0x91,#0xbf
//  906     macRxOutgoingAckFlag = 0;
        MOV     A,#0x0
        MOV     DPTR,#macRxOutgoingAckFlag
        MOVX    @DPTR,A
//  907 
//  908     /* the CRC failed so the packet must be discarded */
//  909     MEM_FREE((uint8 *) pRxBuf);
        ; Setup parameters for call to function macDataRxMemFree
        MOV     DPTR,#pRxBuf
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??macDataRxMemFree?relay
//  910     pRxBuf = NULL;  /* needed to indicate buffer is no longer allocated */
        MOV     DPTR,#pRxBuf
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  911   }
//  912 
//  913   /* reset threshold level, reset receive state, and complete receive logic */
//  914   MAC_RADIO_SET_RX_THRESHOLD(RX_THRESHOLD_START_LEN);
??rxFcsIsr_2:
        MOV     A,#0x5
        MOV     DPTR,#-0x20b1
        MOVX    @DPTR,A
//  915   pFuncRxState = &rxStartIsr;
        MOV     DPTR,#pFuncRxState
        MOV     A,#(??rxStartIsr?relay & 0xff)
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((??rxStartIsr?relay >> 8) & 0xff)
        MOVX    @DPTR,A
//  916   rxDone();
        ; Setup parameters for call to function rxDone
        LCALL   ??rxDone?relay
//  917 }
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock10
        REQUIRE RFIM
//  918 
//  919 
//  920 /*=================================================================================================
//  921  * @fn          rxDone
//  922  *
//  923  * @brief       Common exit point for receive.
//  924  *
//  925  * @param       none
//  926  *
//  927  * @return      none
//  928  *=================================================================================================
//  929  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  930 static void rxDone(void)
rxDone:
        CFI Block cfiBlock11 Using cfiCommon0
        CFI Function rxDone
//  931 {
        FUNCALL rxDone, rxPostRxUpdates
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  932   /* if the receive FIFO has overflowed, flush it here */
//  933   if (MAC_RADIO_RX_FIFO_HAS_OVERFLOWED())
        MOV     DPTR,#-0x209e
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.2
        JNC     ??rxDone_0
        MOV     DPTR,#-0x209e
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.3
        JC      ??rxDone_0
//  934   {
//  935     MAC_RADIO_FLUSH_RX_FIFO();
        MOV     0xe1,#-0x1a
        MOV     0xe1,#-0x1a
//  936   }
//  937 
//  938   /* mark receive as inactive */
//  939   macRxActive = MAC_RX_ACTIVE_NO_ACTIVITY;
??rxDone_0:
        MOV     A,#0x0
        MOV     DPTR,#macRxActive
        MOVX    @DPTR,A
//  940 
//  941   /* if there is no outgoing ACK, run the post receive updates */
//  942   if (!macRxOutgoingAckFlag)
        MOV     DPTR,#macRxOutgoingAckFlag
        MOVX    A,@DPTR
        JNZ     ??rxDone_1
//  943   {
//  944     rxPostRxUpdates();
        ; Setup parameters for call to function rxPostRxUpdates
        LCALL   ??rxPostRxUpdates?relay
//  945   }
//  946 }
??rxDone_1:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock11
        REQUIRE RFST
//  947 
//  948 
//  949 /**************************************************************************************************
//  950  * @fn          macRxAckTxDoneCallback
//  951  *
//  952  * @brief       Function called when the outoing ACK has completed transmitting.
//  953  *
//  954  * @param       none
//  955  *
//  956  * @return      none
//  957  **************************************************************************************************
//  958  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  959 void macRxAckTxDoneCallback(void)
macRxAckTxDoneCallback:
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function macRxAckTxDoneCallback
//  960 {
        FUNCALL macRxAckTxDoneCallback, rxPostRxUpdates
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  961   macRxOutgoingAckFlag = 0;
        MOV     A,#0x0
        MOV     DPTR,#macRxOutgoingAckFlag
        MOVX    @DPTR,A
//  962 
//  963   /*
//  964    *  With certain interrupt priorities and timing conditions, it is possible this callback
//  965    *  could be executed before the primary receive logic completes.  To prevent this, the
//  966    *  post updates are only executed if receive logic is no longer active.  In the case the
//  967    *  post updates are not executed here, they will execute when the main receive logic
//  968    *  completes.
//  969    */  
//  970   if (!macRxActive)
        MOV     DPTR,#macRxActive
        MOVX    A,@DPTR
        JNZ     ??macRxAckTxDoneCallback_0
//  971   {
//  972     rxPostRxUpdates();
        ; Setup parameters for call to function rxPostRxUpdates
        LCALL   ??rxPostRxUpdates?relay
//  973   }
//  974 }
??macRxAckTxDoneCallback_0:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock12
//  975 
//  976 
//  977 /*=================================================================================================
//  978  * @fn          rxPostRxUpdates
//  979  *
//  980  * @brief       Updates that need to be performed once receive is complete.
//  981  *
//  982  *              It is not fatal to execute this function if somehow receive is active.  Under
//  983  *              certain timing/interrupt conditions a new receive may have started before this
//  984  *              function executes.  This should happen very rarely (if it happens at all) and
//  985  *              would cause no problems.
//  986  *
//  987  * @param       none
//  988  *
//  989  * @return      none
//  990  *=================================================================================================
//  991  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  992 static void rxPostRxUpdates(void)
rxPostRxUpdates:
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function rxPostRxUpdates
//  993 {
        FUNCALL rxPostRxUpdates, macRxOffRequest
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxPostRxUpdates, macRadioUpdateTxPower
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxPostRxUpdates, macTxStartQueuedFrame
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  994   /* turn off receiver if permitted */
//  995   macRxOffRequest();
        ; Setup parameters for call to function macRxOffRequest
        LCALL   ??macRxOffRequest?relay
//  996   
//  997   /* update the transmit power, update may have been blocked by transmit of outgoing ACK */
//  998   macRadioUpdateTxPower();
        ; Setup parameters for call to function macRadioUpdateTxPower
        LCALL   ??macRadioUpdateTxPower?relay
//  999   
// 1000   /* initiate and transmit that was queued during receive */
// 1001   macTxStartQueuedFrame();
        ; Setup parameters for call to function macTxStartQueuedFrame
        LCALL   ??macTxStartQueuedFrame?relay
// 1002 }
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock13
// 1003 
// 1004 
// 1005 /*=================================================================================================
// 1006  * @fn          rxDiscardFrame
// 1007  *
// 1008  * @brief       Initializes for discarding a packet.  Must be called before ACK is strobed.
// 1009  *
// 1010  * @param       none
// 1011  *
// 1012  * @return      none
// 1013  *=================================================================================================
// 1014  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1015 static void rxDiscardFrame(void)
rxDiscardFrame:
        CFI Block cfiBlock14 Using cfiCommon0
        CFI Function rxDiscardFrame
// 1016 {
        FUNCALL rxDiscardFrame, halAssertHandler
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxDiscardFrame, rxDone
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1017   MAC_ASSERT(pFuncRxState == &rxStartIsr); /* illegal state for calling discard frame function */
        MOV     DPTR,#pFuncRxState
        MOVX    A,@DPTR
        XRL     A,#(??rxStartIsr?relay & 0xff)
        JNZ     ??rxDiscardFrame_0
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#((??rxStartIsr?relay >> 8) & 0xff)
??rxDiscardFrame_0:
        JZ      ??rxDiscardFrame_1
        ; Setup parameters for call to function halAssertHandler
        LCALL   ??halAssertHandler?relay
// 1018 
// 1019   if (rxUnreadLen == 0)
??rxDiscardFrame_1:
        MOV     DPTR,#rxUnreadLen
        MOVX    A,@DPTR
        JNZ     ??rxDiscardFrame_2
// 1020   {
// 1021     rxDone();
        ; Setup parameters for call to function rxDone
        LCALL   ??rxDone?relay
        SJMP    ??rxDiscardFrame_3
// 1022   }
// 1023   else
// 1024   {
// 1025     rxNextLen = MIN(rxUnreadLen, MAX_PAYLOAD_BYTES_READ_PER_INTERRUPT);
??rxDiscardFrame_2:
        MOV     DPTR,#rxUnreadLen
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x10
        JNC     ??rxDiscardFrame_4
        MOV     DPTR,#rxUnreadLen
        MOVX    A,@DPTR
        MOV     R2,A
        SJMP    ??rxDiscardFrame_5
??rxDiscardFrame_4:
        MOV     R2,#0x10
??rxDiscardFrame_5:
        MOV     A,R2
        MOV     DPTR,#rxNextLen
        MOVX    @DPTR,A
// 1026     MAC_RADIO_SET_RX_THRESHOLD(rxNextLen);
        MOV     DPTR,#rxNextLen
        MOVX    A,@DPTR
        ADD     A,#-0x1
        MOV     DPTR,#-0x20b1
        MOVX    @DPTR,A
// 1027     pFuncRxState = &rxDiscardIsr;
        MOV     DPTR,#pFuncRxState
        MOV     A,#(??rxDiscardIsr?relay & 0xff)
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((??rxDiscardIsr?relay >> 8) & 0xff)
        MOVX    @DPTR,A
// 1028   }
// 1029 }
??rxDiscardFrame_3:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock14
// 1030 
// 1031 
// 1032 /*=================================================================================================
// 1033  * @fn          rxDiscardIsr
// 1034  *
// 1035  * @brief       Receive ISR state for discarding a packet.
// 1036  *
// 1037  * @param       none
// 1038  *
// 1039  * @return      none
// 1040  *=================================================================================================
// 1041  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1042 static void rxDiscardIsr(void)
rxDiscardIsr:
        CFI Block cfiBlock15 Using cfiCommon0
        CFI Function rxDiscardIsr
// 1043 {
        FUNCALL rxDiscardIsr, macMemReadRxFifo
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL rxDiscardIsr, rxDone
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 16
        MOV     A,#-0x10
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
// 1044   uint8 buf[MAX_PAYLOAD_BYTES_READ_PER_INTERRUPT];
// 1045 
// 1046   MAC_RADIO_READ_RX_FIFO(buf, rxNextLen);
        ; Setup parameters for call to function macMemReadRxFifo
        MOV     DPTR,#rxNextLen
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??macMemReadRxFifo?relay
// 1047   rxUnreadLen -= rxNextLen;
        MOV     DPTR,#rxNextLen
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#rxUnreadLen
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R2
        MOVX    @DPTR,A
// 1048 
// 1049   /* read out and discard bytes until all bytes of packet are disposed of */
// 1050   if (rxUnreadLen != 0)
        MOV     DPTR,#rxUnreadLen
        MOVX    A,@DPTR
        JZ      ??rxDiscardIsr_0
// 1051   {
// 1052     if (rxUnreadLen < MAX_PAYLOAD_BYTES_READ_PER_INTERRUPT)
        MOV     DPTR,#rxUnreadLen
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x10
        JNC     ??rxDiscardIsr_1
// 1053     {
// 1054       rxNextLen = rxUnreadLen;
        MOV     DPTR,#rxUnreadLen
        MOVX    A,@DPTR
        MOV     DPTR,#rxNextLen
        MOVX    @DPTR,A
// 1055       MAC_RADIO_SET_RX_THRESHOLD(rxNextLen);
        MOV     DPTR,#rxNextLen
        MOVX    A,@DPTR
        ADD     A,#-0x1
        MOV     DPTR,#-0x20b1
        MOVX    @DPTR,A
        SJMP    ??rxDiscardIsr_1
// 1056     }
// 1057   }
// 1058   else
// 1059   {
// 1060     /* reset threshold level, reset receive state, and complete receive logic */
// 1061     MAC_RADIO_SET_RX_THRESHOLD(RX_THRESHOLD_START_LEN);
??rxDiscardIsr_0:
        MOV     A,#0x5
        MOV     DPTR,#-0x20b1
        MOVX    @DPTR,A
// 1062     pFuncRxState = &rxStartIsr;
        MOV     DPTR,#pFuncRxState
        MOV     A,#(??rxStartIsr?relay & 0xff)
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((??rxStartIsr?relay >> 8) & 0xff)
        MOVX    @DPTR,A
// 1063     rxDone();
        ; Setup parameters for call to function rxDone
        LCALL   ??rxDone?relay
// 1064   }
// 1065 }
??rxDiscardIsr_1:
        MOV     A,#0x10
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 XSP16+0
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock15
// 1066 
// 1067 
// 1068 /**************************************************************************************************
// 1069  * @fn          macRxPromiscuousMode
// 1070  *
// 1071  * @brief       Sets promiscuous mode - enabling or disabling it.
// 1072  *
// 1073  * @param       none
// 1074  *
// 1075  * @return      none
// 1076  **************************************************************************************************
// 1077  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1078 void macRxPromiscuousMode(uint8 mode)
macRxPromiscuousMode:
        CFI Block cfiBlock16 Using cfiCommon0
        CFI Function macRxPromiscuousMode
// 1079 {
        FUNCALL macRxPromiscuousMode, halAssertHandler
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
// 1080   rxPromiscuousMode = mode;
        MOV     A,R6
        MOV     DPTR,#rxPromiscuousMode
        MOVX    @DPTR,A
// 1081 
// 1082   if (rxPromiscuousMode == MAC_PROMISCUOUS_MODE_OFF)
        MOV     DPTR,#rxPromiscuousMode
        MOVX    A,@DPTR
        JNZ     ??macRxPromiscuousMode_0
// 1083   {
// 1084       MAC_RADIO_TURN_ON_RX_FRAME_FILTERING();
        MOV     DPTR,#-0x20fe
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.3
        MOVX    @DPTR,A
        SJMP    ??macRxPromiscuousMode_1
// 1085   }
// 1086   else
// 1087   {
// 1088     MAC_ASSERT((mode == MAC_PROMISCUOUS_MODE_WITH_BAD_CRC)   ||
// 1089                (mode == MAC_PROMISCUOUS_MODE_COMPLIANT));  /* invalid mode */
??macRxPromiscuousMode_0:
        MOV     A,#0x2
        XRL     A,R6
        JZ      ??macRxPromiscuousMode_2
        MOV     A,#0x1
        XRL     A,R6
        JZ      ??macRxPromiscuousMode_2
        ; Setup parameters for call to function halAssertHandler
        LCALL   ??halAssertHandler?relay
// 1090 
// 1091     MAC_RADIO_TURN_OFF_RX_FRAME_FILTERING();
??macRxPromiscuousMode_2:
        MOV     DPTR,#-0x20fe
        MOVX    A,@DPTR
        CLR     0xE0 /* A   */.3
        MOVX    @DPTR,A
// 1092   }
// 1093 }
??macRxPromiscuousMode_1:
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock16

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??macRxInit?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    macRxInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??macRxRadioPowerUpInit?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    macRxRadioPowerUpInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??macRxTxReset?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    macRxTxReset

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??macRxHaltCleanup?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    macRxHaltCleanup

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rxHaltCleanupFinalStep?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    rxHaltCleanupFinalStep

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??macRxThresholdIsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    macRxThresholdIsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rxStartIsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    rxStartIsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rxAddrIsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    rxAddrIsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rxPrepPayload?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    rxPrepPayload

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rxPayloadIsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    rxPayloadIsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rxFcsIsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    rxFcsIsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rxDone?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    rxDone

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??macRxAckTxDoneCallback?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    macRxAckTxDoneCallback

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rxPostRxUpdates?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    rxPostRxUpdates

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rxDiscardFrame?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    rxDiscardFrame

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rxDiscardIsr?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    rxDiscardIsr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??macRxPromiscuousMode?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    macRxPromiscuousMode

        END
// 1094 
// 1095 
// 1096 
// 1097 /**************************************************************************************************
// 1098  *                                  Compile Time Integrity Checks
// 1099  **************************************************************************************************
// 1100  */
// 1101 
// 1102 /* check for changes to the spec that would affect the source code */
// 1103 #if ((MAC_A_MAX_PHY_PACKET_SIZE   !=  0x7F )   ||  \ 
// 1104      (MAC_FCF_FIELD_LEN           !=  2    )   ||  \ 
// 1105      (MAC_FCF_FRAME_TYPE_POS      !=  0    )   ||  \ 
// 1106      (MAC_FCF_FRAME_PENDING_POS   !=  4    )   ||  \ 
// 1107      (MAC_FCF_ACK_REQUEST_POS     !=  5    )   ||  \ 
// 1108      (MAC_FCF_INTRA_PAN_POS       !=  6    )   ||  \ 
// 1109      (MAC_FCF_DST_ADDR_MODE_POS   !=  10   )   ||  \ 
// 1110      (MAC_FCF_FRAME_VERSION_POS   !=  12   )   ||  \ 
// 1111      (MAC_FCF_SRC_ADDR_MODE_POS   !=  14   ))
// 1112 #error "ERROR!  Change to the spec that requires modification of source code."
// 1113 #endif
// 1114 
// 1115 /* check for changes to the internal flags format */
// 1116 #if ((MAC_RX_FLAG_VERSION      !=  0x03)  ||  \ 
// 1117      (MAC_RX_FLAG_ACK_PENDING  !=  0x04)  ||  \ 
// 1118      (MAC_RX_FLAG_SECURITY     !=  0x08)  ||  \ 
// 1119      (MAC_RX_FLAG_PENDING      !=  0x10)  ||  \ 
// 1120      (MAC_RX_FLAG_ACK_REQUEST  !=  0x20)  ||  \ 
// 1121      (MAC_RX_FLAG_INTRA_PAN    !=  0x40))
// 1122 #error "ERROR!  Change to the internal RX flags format.  Requires modification of source code."
// 1123 #endif
// 1124 
// 1125 /* validate CRC OK bit optimization */
// 1126 #if (MAC_RX_FLAG_CRC_OK != PROPRIETARY_FCS_CRC_OK_BIT)
// 1127 #error "ERROR!  Optimization relies on these bits having the same position."
// 1128 #endif
// 1129 
// 1130 #if (MAC_RX_ACTIVE_NO_ACTIVITY != 0x00)
// 1131 #error "ERROR! Zero is reserved value of macRxActive. Allows boolean operations, e.g !macRxActive."
// 1132 #endif
// 1133 
// 1134 #if (MAC_PROMISCUOUS_MODE_OFF != 0x00)
// 1135 #error "ERROR! Zero is reserved value of rxPromiscuousMode. Allows boolean operations, e.g !rxPromiscuousMode."
// 1136 #endif
// 1137 
// 1138 
// 1139 /**************************************************************************************************
// 1140 */
// 
// 2 490 bytes in segment BANKED_CODE
//   102 bytes in segment BANK_RELAYS
//     4 bytes in segment CODE_C
//     5 bytes in segment SFR_AN
//    18 bytes in segment XDATA_Z
// 
// 2 596 bytes of CODE  memory
//     0 bytes of DATA  memory (+ 5 bytes shared)
//    18 bytes of XDATA memory
//
//Errors: none
//Warnings: none

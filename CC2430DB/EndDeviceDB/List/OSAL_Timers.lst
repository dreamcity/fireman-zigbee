###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    20/Dec/2012  21:41:00 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \osal\common\OSAL_Timers.c                         #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\..\..\..\Tools\C #
#                          C2430DB\f8wEndev.cfg" (-DCPU32MHZ                  #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_OPT_FFD=0 -DBLINK_LEDS "-DCONST=const        #
#                          __code" -DGENERIC=__generic) -f "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wCo #
#                          nfig.cfg" (-DSECURE=0 -DDEFAULT_CHANLIST=0x0000080 #
#                          0 -DZDAPP_CONFIG_PAN_ID=0xFFFF                     #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\osal\com #
#                          mon\OSAL_Timers.c" -D CC2430DB -D NWK_AUTO_POLL    #
#                          -D REFLECTOR -D xZTOOL_P2 -D xMT_TASK -D           #
#                          xMT_ZDO_FUNC -D xLCD_SUPPORTED=DEBUG -D            #
#                          xPOWER_SAVING -lC "C:\Texas                        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\EndDeviceDB\List\" -lA        #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\EndDeviceDB\List\"  #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550    #
#                          -o "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\EndDeviceDB\Obj\ #
#                          " -e --require_prototypes -z9 --no_code_motion     #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\SOURCE\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\Drivers\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\ZMAIN\TI2430DB\" -I  #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MT\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\HAL #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\TARGET\CC2430DB\" -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\OSA #
#                          L\INCLUDE\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\AF\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2. #
#                          1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\.. #
#                          \..\..\COMPONENTS\STACK\NWK\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\SEC\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\STACK\SYS\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\ZDO\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\ZMAC\F8W\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\ZMA #
#                          C\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Pr #
#                          ojects\zstack\Samples\AXDApp\CC2430DB\..\..\..\..\ #
#                          ..\COMPONENTS\SERVICES\SADDR\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\SER #
#                          VICES\SDATA\" -I "C:\Texas                         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\HIGH_LEVEL\" -I           #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \LOW_LEVEL\SRF03\SINGLE_CHIP\" -I "C:\Program      #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\" -I "C:\Program       #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\EndDeviceDB\List\OSA #
#                          L_Timers.lst                                       #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\EndDeviceDB\Obj\OSAL #
#                          _Timers.r51                                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\osal\common\OSAL_Timers.c
      1          /**************************************************************************************************
      2            Filename:       OSAL_Timers.c
      3            Revised:        $Date: 2007-10-28 18:43:04 -0700 (Sun, 28 Oct 2007) $
      4            Revision:       $Revision: 15800 $
      5          
      6            Description:    OSAL Timer definition and manipulation functions.
      7          
      8          
      9            Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "ZComDef.h"
     45          #include "OnBoard.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     46          #include "OSAL.h"
     47          #include "OSAL_Timers.h"
     48          #include "hal_timer.h"
     49          
     50          /*********************************************************************
     51           * MACROS
     52           */
     53          
     54          /*********************************************************************
     55           * CONSTANTS
     56           */
     57          
     58          /*********************************************************************
     59           * TYPEDEFS
     60           */
     61          
     62          typedef struct
     63          {
     64            void *next;
     65            UINT16 timeout;
     66            UINT16 event_flag;
     67            byte task_id;
     68          } osalTimerRec_t;
     69          
     70          /*********************************************************************
     71           * GLOBAL VARIABLES
     72           */
     73          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     74          osalTimerRec_t *timerHead;
   \                     timerHead:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     75          uint32 tmr_count;          // Amount of time per tick - in micro-sec
   \                     tmr_count:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     76          uint16 tmr_decr_time;      // Decr_Time for system timer
   \                     tmr_decr_time:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     77          byte timerActive;          // Flag if hw timer active
   \                     timerActive:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     78          
     79          /*********************************************************************
     80           * EXTERNAL VARIABLES
     81           */
     82          
     83          /*********************************************************************
     84           * EXTERNAL FUNCTIONS
     85           */
     86          
     87          /*********************************************************************
     88           * LOCAL VARIABLES
     89           */
     90          // Milliseconds since last reboot

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     91          static uint32 osal_systemClock;
   \                     osal_systemClock:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
     92          
     93          /*********************************************************************
     94           * LOCAL FUNCTION PROTOTYPES
     95           */
     96          osalTimerRec_t  *osalAddTimer( byte task_id, UINT16 event_flag, UINT16 timeout );
     97          osalTimerRec_t *osalFindTimer( byte task_id, uint16 event_flag );
     98          void osalDeleteTimer( osalTimerRec_t *rmTimer );
     99          static void osalTimerUpdate( uint16 time );
    100          
    101          void osal_timer_activate( byte turn_on );
    102          void osal_timer_hw_setup( byte turn_on );
    103          void osal_set_timer_interrupt( byte turn_on );
    104          void osal_retune_timers( void );
    105          
    106          /*********************************************************************
    107           * FUNCTIONS
    108           *********************************************************************/
    109          
    110          /*********************************************************************
    111           * @fn      osalTimerInit
    112           *
    113           * @brief   Initialization for the OSAL Timer System.
    114           *
    115           * @param   none
    116           *
    117           * @return
    118           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    119          void osalTimerInit( void )
   \                     osalTimerInit:
    120          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    121            // Initialize the rollover modulo
    122            tmr_count = TICK_TIME;
   \   000005   90....       MOV     DPTR,#__Constant_3e8
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   12....       LCALL   ?L_MOV_X
   \   00000D   90....       MOV     DPTR,#tmr_count
   \   000010   78..         MOV     R0,#?V0 + 0
   \   000012   12....       LCALL   ?L_MOV_TO_X
    123            tmr_decr_time = TIMER_DECR_TIME;
   \   000015   90....       MOV     DPTR,#tmr_decr_time
   \   000018   7401         MOV     A,#0x1
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   E4           CLR     A
   \   00001D   F0           MOVX    @DPTR,A
    124          
    125            // Initialize the system timer
    126            osal_timer_activate( false );
   \   00001E                ; Setup parameters for call to function osal_timer_activate
   \   00001E   F9           MOV     R1,A
   \   00001F   12....       LCALL   ??osal_timer_activate?relay
    127            timerActive = false;
   \   000022   E4           CLR     A
   \   000023   90....       MOV     DPTR,#timerActive
   \   000026   F0           MOVX    @DPTR,A
    128          
    129            osal_systemClock = 0;
   \   000027   90....       MOV     DPTR,#__Constant_0
   \   00002A   78..         MOV     R0,#?V0 + 0
   \   00002C   12....       LCALL   ?L_MOV_X
   \   00002F   90....       MOV     DPTR,#osal_systemClock
   \   000032   78..         MOV     R0,#?V0 + 0
   \   000034   12....       LCALL   ?L_MOV_TO_X
    130          }
   \   000037   02....       LJMP    ?Subroutine3 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    131          
    132          /*********************************************************************
    133           * @fn      osalAddTimer
    134           *
    135           * @brief   Add a timer to the timer list.
    136           *          Ints must be disabled.
    137           *
    138           * @param   task_id
    139           * @param   event_flag
    140           * @param   timeout
    141           *
    142           * @return  osalTimerRec_t * - pointer to newly created timer
    143           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    144          osalTimerRec_t * osalAddTimer( byte task_id, UINT16 event_flag, UINT16 timeout )
   \                     osalAddTimer:
    145          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   8A..         MOV     ?V0 + 0,R2
   \   000009   8B..         MOV     ?V0 + 1,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
    146            osalTimerRec_t *newTimer;
    147            osalTimerRec_t *srchTimer;
    148          
    149            // Look for an existing timer first
    150            newTimer = osalFindTimer( task_id, event_flag );
   \   00000F                ; Setup parameters for call to function osalFindTimer
   \   00000F   12....       LCALL   ??osalFindTimer?relay
    151            if ( newTimer )
   \   000012   EA           MOV     A,R2
   \   000013   7001         JNZ     ??osalAddTimer_0
   \   000015   EB           MOV     A,R3
   \                     ??osalAddTimer_0:
   \   000016   600D         JZ      ??osalAddTimer_1
    152            {
    153              // Timer is found - update it.
    154              newTimer->timeout = timeout;
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   EE           MOV     A,R6
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   EF           MOV     A,R7
   \                     ??osalAddTimer_2:
   \   000022   F0           MOVX    @DPTR,A
   \   000023   8065         SJMP    ??osalAddTimer_3
    155          
    156              return ( newTimer );
    157            }
    158            else
    159            {
    160              // New Timer
    161              newTimer = osal_mem_alloc( sizeof( osalTimerRec_t ) );
   \                     ??osalAddTimer_1:
   \   000025                ; Setup parameters for call to function osal_mem_alloc
   \   000025   7A07         MOV     R2,#0x7
   \   000027   7B00         MOV     R3,#0x0
   \   000029   12....       LCALL   ??osal_mem_alloc?relay
    162          
    163              if ( newTimer )
   \   00002C   EA           MOV     A,R2
   \   00002D   7001         JNZ     ??osalAddTimer_4
   \   00002F   EB           MOV     A,R3
   \                     ??osalAddTimer_4:
   \   000030   6054         JZ      ??osalAddTimer_5
    164              {
    165                // Fill in new timer
    166                newTimer->task_id = task_id;
   \   000032   8A82         MOV     DPL,R2
   \   000034   8B83         MOV     DPH,R3
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   E5..         MOV     A,?V0 + 2
   \   00003E   F0           MOVX    @DPTR,A
    167                newTimer->event_flag = event_flag;
   \   00003F   8A82         MOV     DPL,R2
   \   000041   8B83         MOV     DPH,R3
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   E5..         MOV     A,?V0 + 0
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   E5..         MOV     A,?V0 + 1
   \   00004D   F0           MOVX    @DPTR,A
    168                newTimer->timeout = timeout;
   \   00004E   8A82         MOV     DPL,R2
   \   000050   8B83         MOV     DPH,R3
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   EE           MOV     A,R6
   \   000055   F0           MOVX    @DPTR,A
   \   000056   A3           INC     DPTR
   \   000057   EF           MOV     A,R7
   \   000058   F0           MOVX    @DPTR,A
    169                newTimer->next = (void *)NULL;
   \   000059   8A82         MOV     DPL,R2
   \   00005B   8B83         MOV     DPH,R3
   \   00005D   E4           CLR     A
   \   00005E   F0           MOVX    @DPTR,A
   \   00005F   A3           INC     DPTR
   \   000060   F0           MOVX    @DPTR,A
    170          
    171                // Does the timer list already exist
    172                if ( timerHead == NULL )
   \   000061   90....       MOV     DPTR,#timerHead
   \   000064   E0           MOVX    A,@DPTR
   \   000065   7002         JNZ     ??osalAddTimer_6
   \   000067   A3           INC     DPTR
   \   000068   E0           MOVX    A,@DPTR
   \                     ??osalAddTimer_6:
   \   000069   90....       MOV     DPTR,#timerHead
   \                     ??osalAddTimer_7:
   \   00006C   7006         JNZ     ??osalAddTimer_8
    173                {
    174                  // Start task list
    175                  timerHead = newTimer;
   \   00006E   EA           MOV     A,R2
   \   00006F   F0           MOVX    @DPTR,A
   \   000070   A3           INC     DPTR
   \   000071   EB           MOV     A,R3
   \   000072   80AE         SJMP    ??osalAddTimer_2
    176                }
    177                else
    178                {
    179                  // Add it to the end of the timer list
    180                  srchTimer = timerHead;
    181          
    182                  // Stop at the last record
    183                  while ( srchTimer->next )
    184                    srchTimer = srchTimer->next;
   \                     ??osalAddTimer_8:
   \   000074   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000077   8882         MOV     DPL,R0
   \   000079   8983         MOV     DPH,R1
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   7002         JNZ     ??osalAddTimer_9
   \   00007E   A3           INC     DPTR
   \   00007F   E0           MOVX    A,@DPTR
   \                     ??osalAddTimer_9:
   \   000080   8882         MOV     DPL,R0
   \   000082   8983         MOV     DPH,R1
   \   000084   80E6         SJMP    ??osalAddTimer_7
    185          
    186                  // Add to the list
    187                  srchTimer->next = newTimer;
    188                }
    189          
    190                return ( newTimer );
    191              }
    192              else
    193                return ( (osalTimerRec_t *)NULL );
   \                     ??osalAddTimer_5:
   \   000086   7A00         MOV     R2,#0x0
   \   000088   7B00         MOV     R3,#0x0
   \                     ??osalAddTimer_3:
   \   00008A   7F06         MOV     R7,#0x6
   \   00008C   02....       LJMP    ?BANKED_LEAVE_XDATA
    194            }
    195          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    196          
    197          /*********************************************************************
    198           * @fn      osalFindTimer
    199           *
    200           * @brief   Find a timer in a timer list.
    201           *          Ints must be disabled.
    202           *
    203           * @param   task_id
    204           * @param   event_flag
    205           *
    206           * @return  osalTimerRec_t *
    207           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    208          osalTimerRec_t *osalFindTimer( byte task_id, uint16 event_flag )
   \                     osalFindTimer:
    209          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    210            osalTimerRec_t *srchTimer;
    211          
    212            // Head of the timer list
    213            srchTimer = timerHead;
   \   000005   90....       MOV     DPTR,#timerHead
   \   000008   8004         SJMP    ??osalFindTimer_0
    214          
    215            // Stop when found or at the end
    216            while ( srchTimer )
    217            {
    218              if ( srchTimer->event_flag == event_flag &&
    219                   srchTimer->task_id == task_id )
    220                break;
    221          
    222              // Not this one, check another
    223              srchTimer = srchTimer->next;
   \                     ??osalFindTimer_1:
   \   00000A   8C82         MOV     DPL,R4
   \   00000C   8D83         MOV     DPH,R5
   \                     ??osalFindTimer_0:
   \   00000E   12....       LCALL   ??Subroutine0_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000011   EC           MOV     A,R4
   \   000012   7001         JNZ     ??osalFindTimer_2
   \   000014   ED           MOV     A,R5
   \                     ??osalFindTimer_2:
   \   000015   601F         JZ      ??osalFindTimer_3
   \   000017   8C82         MOV     DPL,R4
   \   000019   8D83         MOV     DPH,R5
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6A           XRL     A,R2
   \   000021   7003         JNZ     ??osalFindTimer_4
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6B           XRL     A,R3
   \                     ??osalFindTimer_4:
   \   000026   70E2         JNZ     ??osalFindTimer_1
   \   000028   8C82         MOV     DPL,R4
   \   00002A   8D83         MOV     DPH,R5
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   69           XRL     A,R1
   \   000034   70D4         JNZ     ??osalFindTimer_1
    224            }
    225          
    226            return ( srchTimer );
   \                     ??osalFindTimer_3:
   \   000036   EC           MOV     A,R4
   \   000037   FA           MOV     R2,A
   \   000038   ED           MOV     A,R5
   \   000039   FB           MOV     R3,A
   \   00003A                REQUIRE ?Subroutine4
   \   00003A                ; // Fall through to label ?Subroutine4
    227          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \                     ??Subroutine0_0:
   \   000004   E0           MOVX    A,@DPTR
   \   000005   FC           MOV     R4,A
   \   000006   A3           INC     DPTR
   \   000007   E0           MOVX    A,@DPTR
   \   000008   FD           MOV     R5,A
   \   000009   22           RET
    228          
    229          /*********************************************************************
    230           * @fn      osalDeleteTimer
    231           *
    232           * @brief   Delete a timer from a timer list.
    233           *          Ints must be disabled.
    234           *
    235           * @param   table
    236           * @param   rmTimer
    237           *
    238           * @return  none
    239           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    240          void osalDeleteTimer( osalTimerRec_t *rmTimer )
   \                     osalDeleteTimer:
    241          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    242            osalTimerRec_t *srchTimer;
    243          
    244            // Does the timer list really exist
    245            if ( (timerHead != NULL) && rmTimer )
   \   000005   90....       MOV     DPTR,#timerHead
   \   000008   E0           MOVX    A,@DPTR
   \   000009   7002         JNZ     ??osalDeleteTimer_0
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \                     ??osalDeleteTimer_0:
   \   00000D   605C         JZ      ??osalDeleteTimer_1
   \   00000F   EA           MOV     A,R2
   \   000010   7001         JNZ     ??osalDeleteTimer_2
   \   000012   EB           MOV     A,R3
   \                     ??osalDeleteTimer_2:
   \   000013   6056         JZ      ??osalDeleteTimer_1
    246            {
    247              // Add it to the end of the timer list
    248              srchTimer = timerHead;
   \   000015   90....       MOV     DPTR,#timerHead
   \   000018   12....       LCALL   ?Subroutine2 & 0xFFFF
    249          
    250              // First element?
    251              if ( srchTimer == rmTimer )
   \                     ??CrossCallReturnLabel_7:
   \   00001B   EA           MOV     A,R2
   \   00001C   68           XRL     A,R0
   \   00001D   7002         JNZ     ??osalDeleteTimer_3
   \   00001F   EB           MOV     A,R3
   \   000020   69           XRL     A,R1
   \                     ??osalDeleteTimer_3:
   \   000021   7014         JNZ     ??CrossCallReturnLabel_8
    252              {
    253                timerHead = rmTimer->next;
   \   000023   8A82         MOV     DPL,R2
   \   000025   8B83         MOV     DPH,R3
   \   000027   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00002A   E8           MOV     A,R0
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
   \   00002D   E9           MOV     A,R1
   \   00002E   8037         SJMP    ??osalDeleteTimer_4
    254                osal_mem_free( rmTimer );
    255              }
    256              else
    257              {
    258                // Stop when found or at the end
    259                while ( srchTimer->next && srchTimer->next != rmTimer )
    260                  srchTimer = srchTimer->next;
   \                     ??osalDeleteTimer_5:
   \   000030   8882         MOV     DPL,R0
   \   000032   8983         MOV     DPH,R1
   \   000034   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000037   8882         MOV     DPL,R0
   \   000039   8983         MOV     DPH,R1
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   7002         JNZ     ??osalDeleteTimer_6
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \                     ??osalDeleteTimer_6:
   \   000040   600B         JZ      ??osalDeleteTimer_7
   \   000042   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000045   EA           MOV     A,R2
   \   000046   6C           XRL     A,R4
   \   000047   7002         JNZ     ??osalDeleteTimer_8
   \   000049   EB           MOV     A,R3
   \   00004A   6D           XRL     A,R5
   \                     ??osalDeleteTimer_8:
   \   00004B   70E3         JNZ     ??osalDeleteTimer_5
    261          
    262                // Found?
    263                if ( srchTimer->next == rmTimer )
   \                     ??osalDeleteTimer_7:
   \   00004D   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000050   EA           MOV     A,R2
   \   000051   6C           XRL     A,R4
   \   000052   7002         JNZ     ??osalDeleteTimer_9
   \   000054   EB           MOV     A,R3
   \   000055   6D           XRL     A,R5
   \                     ??osalDeleteTimer_9:
   \   000056   7013         JNZ     ??osalDeleteTimer_1
    264                {
    265                  // Fix pointers
    266                  srchTimer->next = rmTimer->next;
   \   000058   8A82         MOV     DPL,R2
   \   00005A   8B83         MOV     DPH,R3
   \   00005C   12....       LCALL   ??Subroutine0_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   00005F   8882         MOV     DPL,R0
   \   000061   8983         MOV     DPH,R1
   \   000063   EC           MOV     A,R4
   \   000064   F0           MOVX    @DPTR,A
   \   000065   A3           INC     DPTR
   \   000066   ED           MOV     A,R5
   \                     ??osalDeleteTimer_4:
   \   000067   F0           MOVX    @DPTR,A
    267          
    268                  // Deallocate the timer struct memory
    269                  osal_mem_free( rmTimer );
   \   000068                ; Setup parameters for call to function osal_mem_free
   \   000068   12....       LCALL   ??osal_mem_free?relay
    270                }
    271              }
    272            }
    273          }
   \                     ??osalDeleteTimer_1:
   \   00006B   80..         SJMP    ?Subroutine4

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   90....       MOV     DPTR,#timerHead
   \   000008   22           RET
    274          
    275          /*********************************************************************
    276           * @fn      osal_start_timerEx
    277           *
    278           * @brief
    279           *
    280           *   This function is called to start a timer to expire in n mSecs.
    281           *   When the timer expires, the calling task will get the specified event.
    282           *
    283           * @param   byte taskID - task id to set timer for
    284           * @param   UINT16 event_id - event to be notified with
    285           * @param   UNINT16 timeout_value - in milliseconds.
    286           *
    287           * @return  ZSUCCESS, or NO_TIMER_AVAIL.
    288           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    289          byte osal_start_timerEx( byte taskID, UINT16 event_id, UINT16 timeout_value )
   \                     osal_start_timerEx:
    290          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    291            halIntState_t intState;
    292            osalTimerRec_t *newTimer;
    293          
    294            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   92E0         MOV     0xE0 /* A   */.0,C
   \   00000A   F5..         MOV     ?V0 + 0,A
   \   00000C   C2AF         CLR     0xa8.7
    295          
    296            // Add timer
    297            newTimer = osalAddTimer( taskID, event_id, timeout_value );
   \   00000E                ; Setup parameters for call to function osalAddTimer
   \   00000E   12....       LCALL   ??osalAddTimer?relay
   \   000011   8A..         MOV     ?V0 + 2,R2
   \   000013   8B..         MOV     ?V0 + 3,R3
   \   000015   AE..         MOV     R6,?V0 + 2
   \   000017   AF..         MOV     R7,?V0 + 3
    298            if ( newTimer )
   \   000019   EE           MOV     A,R6
   \   00001A   7001         JNZ     ??osal_start_timerEx_0
   \   00001C   EF           MOV     A,R7
   \                     ??osal_start_timerEx_0:
   \   00001D   600B         JZ      ??osal_start_timerEx_1
    299            {
    300          #ifdef POWER_SAVING
    301              // Update timer registers
    302              osal_retune_timers();
    303              (void)timerActive;
    304          #endif
    305              // Does the timer need to be started?
    306              if ( timerActive == FALSE )
   \   00001F   90....       MOV     DPTR,#timerActive
   \   000022   E0           MOVX    A,@DPTR
   \   000023   7005         JNZ     ??osal_start_timerEx_1
    307              {
    308                osal_timer_activate( TRUE );
   \   000025                ; Setup parameters for call to function osal_timer_activate
   \   000025   7901         MOV     R1,#0x1
   \   000027   12....       LCALL   ??osal_timer_activate?relay
    309              }
    310            }
    311          
    312            HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \                     ??osal_start_timerEx_1:
   \   00002A   E5..         MOV     A,?V0 + 0
   \   00002C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00002E   92AF         MOV     0xa8.7,C
    313          
    314            return ( (newTimer != NULL) ? ZSUCCESS : NO_TIMER_AVAIL );
   \   000030   EE           MOV     A,R6
   \   000031   7001         JNZ     ??osal_start_timerEx_2
   \   000033   EF           MOV     A,R7
   \                     ??osal_start_timerEx_2:
   \   000034   6004         JZ      ??osal_start_timerEx_3
   \   000036   7900         MOV     R1,#0x0
   \   000038   8002         SJMP    ??osal_start_timerEx_4
   \                     ??osal_start_timerEx_3:
   \   00003A   790C         MOV     R1,#0xc
   \                     ??osal_start_timerEx_4:
   \   00003C   80..         SJMP    ?Subroutine3
   \   00003E                REQUIRE _A_IEN0
    315          }
    316          
    317          /*********************************************************************
    318           * @fn      osal_stop_timerEx
    319           *
    320           * @brief
    321           *
    322           *   This function is called to stop a timer that has already been started.
    323           *   If ZSUCCESS, the function will cancel the timer and prevent the event
    324           *   associated with the timer from being set for the calling task.
    325           *
    326           * @param   byte task_id - task id of timer to stop
    327           * @param   UINT16 event_id - identifier of the timer that is to be stopped
    328           *
    329           * @return  ZSUCCESS or INVALID_EVENT_ID
    330           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    331          byte osal_stop_timerEx( byte task_id, UINT16 event_id )
   \                     osal_stop_timerEx:
    332          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    333            halIntState_t intState;
    334            osalTimerRec_t *foundTimer;
    335          
    336            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   92E0         MOV     0xE0 /* A   */.0,C
   \   00000A   F5..         MOV     ?V0 + 0,A
   \   00000C   C2AF         CLR     0xa8.7
    337          
    338            // Find the timer to stop
    339            foundTimer = osalFindTimer( task_id, event_id );
   \   00000E                ; Setup parameters for call to function osalFindTimer
   \   00000E   12....       LCALL   ??osalFindTimer?relay
   \   000011   8A..         MOV     ?V0 + 2,R2
   \   000013   8B..         MOV     ?V0 + 3,R3
   \   000015   AE..         MOV     R6,?V0 + 2
   \   000017   AF..         MOV     R7,?V0 + 3
    340            if ( foundTimer )
   \   000019   EE           MOV     A,R6
   \   00001A   7001         JNZ     ??osal_stop_timerEx_0
   \   00001C   EF           MOV     A,R7
   \                     ??osal_stop_timerEx_0:
   \   00001D   6003         JZ      ??osal_stop_timerEx_1
    341            {
    342              osalDeleteTimer( foundTimer );
   \   00001F                ; Setup parameters for call to function osalDeleteTimer
   \   00001F   12....       LCALL   ??osalDeleteTimer?relay
    343          
    344          #ifdef POWER_SAVING
    345              osal_retune_timers();
    346          #endif
    347            }
    348          
    349            HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \                     ??osal_stop_timerEx_1:
   \   000022   E5..         MOV     A,?V0 + 0
   \   000024   A2E0         MOV     C,0xE0 /* A   */.0
   \   000026   92AF         MOV     0xa8.7,C
    350          
    351            return ( (foundTimer != NULL) ? ZSUCCESS : INVALID_EVENT_ID );
   \   000028   EE           MOV     A,R6
   \   000029   7001         JNZ     ??osal_stop_timerEx_2
   \   00002B   EF           MOV     A,R7
   \                     ??osal_stop_timerEx_2:
   \   00002C   6004         JZ      ??osal_stop_timerEx_3
   \   00002E   7900         MOV     R1,#0x0
   \   000030   8002         SJMP    ??osal_stop_timerEx_4
   \                     ??osal_stop_timerEx_3:
   \   000032   7907         MOV     R1,#0x7
   \                     ??osal_stop_timerEx_4:
   \   000034   80..         SJMP    ?Subroutine3
   \   000036                REQUIRE _A_IEN0
    352          }
    353          
    354          /*********************************************************************
    355           * @fn      osal_get_timeoutEx
    356           *
    357           * @brief
    358           *
    359           * @param   byte task_id - task id of timer to check
    360           * @param   UINT16 event_id - identifier of timer to be checked
    361           *
    362           * @return  Return the timer's tick count if found, zero otherwise.
    363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    364          UINT16 osal_get_timeoutEx( byte task_id, UINT16 event_id )
   \                     osal_get_timeoutEx:
    365          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    366            halIntState_t intState;
    367            uint16 rtrn = 0;
   \   000005   7E00         MOV     R6,#0x0
   \   000007   7F00         MOV     R7,#0x0
    368            osalTimerRec_t *tmr;
    369          
    370            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000009   A2AF         MOV     C,0xa8.7
   \   00000B   E4           CLR     A
   \   00000C   92E0         MOV     0xE0 /* A   */.0,C
   \   00000E   F5..         MOV     ?V0 + 0,A
   \   000010   C2AF         CLR     0xa8.7
    371          
    372            tmr = osalFindTimer( task_id, event_id );
   \   000012                ; Setup parameters for call to function osalFindTimer
   \   000012   12....       LCALL   ??osalFindTimer?relay
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
    373          
    374            if ( tmr )
   \   000019   E582         MOV     A,DPL
   \   00001B   7002         JNZ     ??osal_get_timeoutEx_0
   \   00001D   E583         MOV     A,DPH
   \                     ??osal_get_timeoutEx_0:
   \   00001F   6007         JZ      ??osal_get_timeoutEx_1
    375            {
    376              rtrn = tmr->timeout;
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   FE           MOV     R6,A
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FF           MOV     R7,A
    377            }
    378          
    379            HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \                     ??osal_get_timeoutEx_1:
   \   000028   E5..         MOV     A,?V0 + 0
   \   00002A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00002C   92AF         MOV     0xa8.7,C
    380          
    381            return rtrn;
   \   00002E   EE           MOV     A,R6
   \   00002F   FA           MOV     R2,A
   \   000030   EF           MOV     A,R7
   \   000031   FB           MOV     R3,A
   \   000032                REQUIRE ?Subroutine3
   \   000032                REQUIRE _A_IEN0
   \   000032                ; // Fall through to label ?Subroutine3
    382          }
    383          
    384          /*********************************************************************
    385           * @fn      osal_timer_activate
    386           *
    387           * @brief
    388           *
    389           *   Turns the hardware timer on or off
    390           *
    391           * @param  byte turn_on - false - turn off, true - turn on
    392           *
    393           * @return  none
    394           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    395          void osal_timer_activate( byte turn_on )
   \                     osal_timer_activate:
    396          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    397            osal_timer_hw_setup( turn_on );
   \   000007                ; Setup parameters for call to function osal_timer_hw_setup
   \   000007   12....       LCALL   ??osal_timer_hw_setup?relay
    398            timerActive = turn_on;
   \   00000A   EE           MOV     A,R6
   \   00000B   90....       MOV     DPTR,#timerActive
   \   00000E   F0           MOVX    @DPTR,A
    399          }
   \   00000F   02....       LJMP    ?Subroutine4 & 0xFFFF
    400          
    401          /*********************************************************************
    402           * @fn      osal_timer_num_active
    403           *
    404           * @brief
    405           *
    406           *   This function counts the number of active timers.
    407           *
    408           * @return  byte - number of timers
    409           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    410          byte osal_timer_num_active( void )
   \                     osal_timer_num_active:
    411          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    412            halIntState_t intState;
    413            byte num_timers = 0;
   \   000004   7900         MOV     R1,#0x0
    414            osalTimerRec_t *srchTimer;
    415          
    416            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000006   A2AF         MOV     C,0xa8.7
   \   000008   E4           CLR     A
   \   000009   92E0         MOV     0xE0 /* A   */.0,C
   \   00000B   FC           MOV     R4,A
   \   00000C   C2AF         CLR     0xa8.7
    417          
    418            // Head of the timer list
    419            srchTimer = timerHead;
   \   00000E   90....       MOV     DPTR,#timerHead
   \   000011   8001         SJMP    ??osal_timer_num_active_0
    420          
    421            // Count timers in the list
    422            while ( srchTimer != NULL )
    423            {
    424              num_timers++;
   \                     ??osal_timer_num_active_1:
   \   000013   09           INC     R1
    425              srchTimer = srchTimer->next;
   \                     ??osal_timer_num_active_0:
   \   000014   E0           MOVX    A,@DPTR
   \   000015   FA           MOV     R2,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FB           MOV     R3,A
   \   000019   8A82         MOV     DPL,R2
   \   00001B   8B83         MOV     DPH,R3
    426            }
   \   00001D   E582         MOV     A,DPL
   \   00001F   7002         JNZ     ??osal_timer_num_active_2
   \   000021   E583         MOV     A,DPH
   \                     ??osal_timer_num_active_2:
   \   000023   70EE         JNZ     ??osal_timer_num_active_1
    427          
    428            HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \   000025   EC           MOV     A,R4
   \   000026   A2E0         MOV     C,0xE0 /* A   */.0
   \   000028   92AF         MOV     0xa8.7,C
    429          
    430            return num_timers;
   \   00002A                REQUIRE ?Subroutine5
   \   00002A                REQUIRE _A_IEN0
   \   00002A                ; // Fall through to label ?Subroutine5
    431          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    432          
    433          /*********************************************************************
    434           * @fn      osal_timer_hw_setup
    435           *
    436           * @brief
    437           *
    438           *   Setup the timer hardware.
    439           *
    440           * @param  byte turn_on
    441           *
    442           * @return  void
    443           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    444          void osal_timer_hw_setup( byte turn_on )
   \                     osal_timer_hw_setup:
    445          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    446            if (turn_on)
   \   000005   E9           MOV     A,R1
   \   000006   6017         JZ      ??osal_timer_hw_setup_0
    447            {
    448              HalTimerStart (OSAL_TIMER, tmr_count );
   \   000008                ; Setup parameters for call to function HalTimerStart
   \   000008   90....       MOV     DPTR,#tmr_count
   \   00000B   78..         MOV     R0,#?V0 + 0
   \   00000D   12....       LCALL   ?L_MOV_X
   \   000010   AA..         MOV     R2,?V0 + 0
   \   000012   AB..         MOV     R3,?V0 + 1
   \   000014   AC..         MOV     R4,?V0 + 2
   \   000016   AD..         MOV     R5,?V0 + 3
   \   000018   7902         MOV     R1,#0x2
   \   00001A   12....       LCALL   ??HalTimerStart?relay
   \   00001D   8005         SJMP    ??osal_timer_hw_setup_1
    449            }
    450            else
    451            {
    452              HalTimerStop (OSAL_TIMER);
   \                     ??osal_timer_hw_setup_0:
   \   00001F                ; Setup parameters for call to function HalTimerStop
   \   00001F   7902         MOV     R1,#0x2
   \   000021   12....       LCALL   ??HalTimerStop?relay
    453            }
    454          }
   \                     ??osal_timer_hw_setup_1:
   \   000024   80..         SJMP    ?Subroutine3
    455          
    456          #if defined( POWER_SAVING )
    457          /*********************************************************************
    458           * @fn      osal_sleep_timers
    459           *
    460           * @brief
    461           *
    462           *   This function will enable interrupts if timers are running.
    463           *
    464           * @param  none
    465           *
    466           * @return  none
    467           */
    468          void osal_sleep_timers( void )
    469          {
    470          #ifndef TIMER_INT
    471            if ( osal_timer_num_active() )
    472              osal_set_timer_interrupt( TRUE );
    473          #endif
    474          }
    475          
    476          /*********************************************************************
    477           * @fn      osal_unsleep_timers
    478           *
    479           * @brief
    480           *
    481           *   This function will disable interrupts if timers are running.
    482           *
    483           * @param  none
    484           *
    485           * @return  none
    486           */
    487          void osal_unsleep_timers( void )
    488          {
    489          #ifndef TIMER_INT
    490            osal_set_timer_interrupt( FALSE );
    491          #endif
    492          }
    493          #endif
    494          
    495          /*********************************************************************
    496           * @fn      osal_set_timer_interrupt
    497           *
    498           * @brief
    499           *
    500           *   Setup the timer hardware interrupt.
    501           *
    502           * @param  byte turn_on
    503           *
    504           * @return  void
    505           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    506          void osal_set_timer_interrupt( byte turn_on )
   \                     osal_set_timer_interrupt:
    507          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    508            // Enable or disable timer interrupts
    509            HalTimerInterruptEnable ( OSAL_TIMER, HAL_TIMER_CH_MODE_OUTPUT_COMPARE, turn_on);
   \   000004                ; Setup parameters for call to function HalTimerInterruptEnable
   \   000004   E9           MOV     A,R1
   \   000005   FB           MOV     R3,A
   \   000006   7A02         MOV     R2,#0x2
   \   000008   7902         MOV     R1,#0x2
   \   00000A   12....       LCALL   ??HalTimerInterruptEnable?relay
    510          }
   \   00000D   80..         SJMP    ?Subroutine5
    511          
    512          /*********************************************************************
    513           * @fn      osalTimerUpdate
    514           *
    515           * @brief   Update the timer structures for a timer tick.
    516           *
    517           * @param   none
    518           *
    519           * @return  none
    520           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    521          static void osalTimerUpdate( uint16 updateTime )
   \                     osalTimerUpdate:
    522          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
    523            halIntState_t intState;
    524            osalTimerRec_t *srchTimer;
    525            osalTimerRec_t *prevTimer;
    526            osalTimerRec_t *saveTimer;
    527          
    528            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   00000E   A2AF         MOV     C,0xa8.7
   \   000010   E4           CLR     A
   \   000011   92E0         MOV     0xE0 /* A   */.0,C
   \   000013   85..82       MOV     DPL,?XSP + 0
   \   000016   85..83       MOV     DPH,?XSP + 1
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   C2AF         CLR     0xa8.7
    529          
    530            // Update the system time
    531            osal_systemClock += updateTime;
   \   00001C   8A..         MOV     ?V0 + 4,R2
   \   00001E   8B..         MOV     ?V0 + 5,R3
   \   000020   75..00       MOV     ?V0 + 6,#0x0
   \   000023   75..00       MOV     ?V0 + 7,#0x0
   \   000026   90....       MOV     DPTR,#osal_systemClock
   \   000029   78..         MOV     R0,#?V0 + 4
   \   00002B   12....       LCALL   ?L_ADD_TO_X
    532          
    533            // Look for open timer slot
    534            if ( timerHead != NULL )
   \   00002E   90....       MOV     DPTR,#timerHead
   \   000031   E0           MOVX    A,@DPTR
   \   000032   7002         JNZ     ??osalTimerUpdate_0
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \                     ??osalTimerUpdate_0:
   \   000036   7003         JNZ     $+5
   \   000038   02....       LJMP    ??osalTimerUpdate_1 & 0xFFFF
    535            {
    536              // Add it to the end of the timer list
    537              srchTimer = timerHead;
   \   00003B   90....       MOV     DPTR,#timerHead
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   FE           MOV     R6,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   FF           MOV     R7,A
    538              prevTimer = (void *)NULL;
   \   000043   75..00       MOV     ?V0 + 2,#0x0
   \   000046   75..00       MOV     ?V0 + 3,#0x0
    539          
    540              // Look for open timer slot
    541              while ( srchTimer )
    542              {
    543                // Decrease the correct amount of time
    544                if (srchTimer->timeout <= updateTime)
   \                     ??osalTimerUpdate_2:
   \   000049   8E82         MOV     DPL,R6
   \   00004B   8F83         MOV     DPH,R7
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000052   C3           CLR     C
   \   000053   E5..         MOV     A,?V0 + 0
   \   000055   98           SUBB    A,R0
   \   000056   E5..         MOV     A,?V0 + 1
   \   000058   99           SUBB    A,R1
   \   000059   400C         JC      ??osalTimerUpdate_3
    545                  srchTimer->timeout = 0;
   \   00005B   8E82         MOV     DPL,R6
   \   00005D   8F83         MOV     DPH,R7
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   E4           CLR     A
   \   000062   F0           MOVX    @DPTR,A
   \   000063   A3           INC     DPTR
   \   000064   F0           MOVX    @DPTR,A
   \   000065   8021         SJMP    ??osalTimerUpdate_4
    546                else
    547                  srchTimer->timeout = srchTimer->timeout - updateTime;
   \                     ??osalTimerUpdate_3:
   \   000067   EE           MOV     A,R6
   \   000068   2402         ADD     A,#0x2
   \   00006A   F8           MOV     R0,A
   \   00006B   EF           MOV     A,R7
   \   00006C   3400         ADDC    A,#0x0
   \   00006E   F9           MOV     R1,A
   \   00006F   8882         MOV     DPL,R0
   \   000071   8983         MOV     DPH,R1
   \   000073   C3           CLR     C
   \   000074   E0           MOVX    A,@DPTR
   \   000075   95..         SUBB    A,?V0 + 0
   \   000077   F0           MOVX    @DPTR,A
   \   000078   A3           INC     DPTR
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   95..         SUBB    A,?V0 + 1
   \   00007C   F0           MOVX    @DPTR,A
    548          
    549                // When timeout, execute the task
    550                if ( srchTimer->timeout == 0 )
   \   00007D   8882         MOV     DPL,R0
   \   00007F   8983         MOV     DPH,R1
   \   000081   E0           MOVX    A,@DPTR
   \   000082   7002         JNZ     ??osalTimerUpdate_5
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \                     ??osalTimerUpdate_5:
   \   000086   7053         JNZ     ??osalTimerUpdate_6
    551                {
    552                  osal_set_event( srchTimer->task_id, srchTimer->event_flag );
   \                     ??osalTimerUpdate_4:
   \   000088                ; Setup parameters for call to function osal_set_event
   \   000088   8E82         MOV     DPL,R6
   \   00008A   8F83         MOV     DPH,R7
   \   00008C   A3           INC     DPTR
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   E0           MOVX    A,@DPTR
   \   000091   FA           MOV     R2,A
   \   000092   A3           INC     DPTR
   \   000093   E0           MOVX    A,@DPTR
   \   000094   FB           MOV     R3,A
   \   000095   8E82         MOV     DPL,R6
   \   000097   8F83         MOV     DPH,R7
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   A3           INC     DPTR
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   F9           MOV     R1,A
   \   0000A1   12....       LCALL   ??osal_set_event?relay
    553          
    554                  // Take out of list
    555                  if ( prevTimer == NULL )
   \   0000A4   E5..         MOV     A,?V0 + 2
   \   0000A6   7002         JNZ     ??osalTimerUpdate_7
   \   0000A8   E5..         MOV     A,?V0 + 3
   \                     ??osalTimerUpdate_7:
   \   0000AA   8E82         MOV     DPL,R6
   \   0000AC   8F83         MOV     DPH,R7
   \   0000AE   7005         JNZ     ??osalTimerUpdate_8
    556                    timerHead = srchTimer->next;
   \   0000B0   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000B3   8009         SJMP    ??osalTimerUpdate_9
    557                  else
    558                    prevTimer->next = srchTimer->next;
   \                     ??osalTimerUpdate_8:
   \   0000B5   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   0000B8   85..82       MOV     DPL,?V0 + 2
   \   0000BB   85..83       MOV     DPH,?V0 + 3
   \                     ??osalTimerUpdate_9:
   \   0000BE   E8           MOV     A,R0
   \   0000BF   F0           MOVX    @DPTR,A
   \   0000C0   A3           INC     DPTR
   \   0000C1   E9           MOV     A,R1
   \   0000C2   F0           MOVX    @DPTR,A
    559          
    560                  // Next
    561                  saveTimer = srchTimer->next;
   \   0000C3   8E82         MOV     DPL,R6
   \   0000C5   8F83         MOV     DPH,R7
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   F5..         MOV     ?V0 + 4,A
   \   0000CA   A3           INC     DPTR
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   F5..         MOV     ?V0 + 5,A
    562          
    563                  // Free memory
    564                  osal_mem_free( srchTimer );
   \   0000CE                ; Setup parameters for call to function osal_mem_free
   \   0000CE   EE           MOV     A,R6
   \   0000CF   FA           MOV     R2,A
   \   0000D0   EF           MOV     A,R7
   \   0000D1   FB           MOV     R3,A
   \   0000D2   12....       LCALL   ??osal_mem_free?relay
    565          
    566                  srchTimer = saveTimer;
   \   0000D5   AE..         MOV     R6,?V0 + 4
   \   0000D7   AF..         MOV     R7,?V0 + 5
   \   0000D9   800D         SJMP    ??osalTimerUpdate_10
    567                }
    568                else
    569                {
    570                  // Get next
    571                  prevTimer = srchTimer;
   \                     ??osalTimerUpdate_6:
   \   0000DB   8E..         MOV     ?V0 + 2,R6
   \   0000DD   8F..         MOV     ?V0 + 3,R7
    572                  srchTimer = srchTimer->next;
   \   0000DF   8E82         MOV     DPL,R6
   \   0000E1   8F83         MOV     DPH,R7
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   FE           MOV     R6,A
   \   0000E5   A3           INC     DPTR
   \   0000E6   E0           MOVX    A,@DPTR
   \   0000E7   FF           MOV     R7,A
    573                }
    574              }
   \                     ??osalTimerUpdate_10:
   \   0000E8   EE           MOV     A,R6
   \   0000E9   7001         JNZ     ??osalTimerUpdate_11
   \   0000EB   EF           MOV     A,R7
   \                     ??osalTimerUpdate_11:
   \   0000EC   6003         JZ      $+5
   \   0000EE   02....       LJMP    ??osalTimerUpdate_2 & 0xFFFF
    575          
    576          #ifdef POWER_SAVING
    577              osal_retune_timers();
    578          #endif
    579            }
    580          
    581            HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \                     ??osalTimerUpdate_1:
   \   0000F1   85..82       MOV     DPL,?XSP + 0
   \   0000F4   85..83       MOV     DPH,?XSP + 1
   \   0000F7   E0           MOVX    A,@DPTR
   \   0000F8   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000FA   92AF         MOV     0xa8.7,C
    582          }
   \   0000FC   7401         MOV     A,#0x1
   \   0000FE   12....       LCALL   ?DEALLOC_XSTACK8
   \   000101   7F08         MOV     R7,#0x8
   \   000103   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000106                REQUIRE _A_IEN0
    583          
    584          /*********************************************************************
    585           * @fn      osal_update_timers
    586           *
    587           * @brief   Update the timer structures for timer ticks.
    588           *
    589           * @param   none
    590           *
    591           * @return  none
    592           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    593          void osal_update_timers( void )
   \                     osal_update_timers:
    594          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    595            osalTimerUpdate( tmr_decr_time );
   \   000004                ; Setup parameters for call to function osalTimerUpdate
   \   000004   90....       MOV     DPTR,#tmr_decr_time
   \   000007   E0           MOVX    A,@DPTR
   \   000008   FA           MOV     R2,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FB           MOV     R3,A
   \   00000C   12....       LCALL   ??osalTimerUpdate?relay
    596          }
   \   00000F   02....       LJMP    ?Subroutine5 & 0xFFFF
    597          
    598          #ifdef POWER_SAVING
    599          /*********************************************************************
    600           * @fn      osal_adjust_timers
    601           *
    602           * @brief   Update the timer structures for elapsed ticks.
    603           *
    604           * @param   none
    605           *
    606           * @return  none
    607           *********************************************************************/
    608          void osal_adjust_timers( void )
    609          {
    610            uint16 eTime;
    611          
    612            if ( timerHead != NULL )
    613            {
    614              // Compute elapsed time (msec)
    615              eTime = TimerElapsed() /  TICK_COUNT;
    616          
    617              if ( eTime )
    618                osalTimerUpdate( eTime );
    619            }
    620          }
    621          #endif
    622          
    623          #ifdef POWER_SAVING
    624          /*********************************************************************
    625           * @fn      osal_retune_timers
    626           *
    627           * @brief
    628           *
    629           *   Adjust CPU sleep time to the lowest timeout value. If the timeout
    630           *   value is more then RETUNE_THRESHOLD, then the sleep time will be
    631           *   RETUNE_THRESHOLD.
    632           *
    633           * @param   none
    634           *
    635           * @return  none
    636           *********************************************************************/
    637          void osal_retune_timers( void )
    638          {
    639            halIntState_t intState;
    640            uint16 nextTimeout;
    641          
    642            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
    643          
    644            // Next occuring timeout
    645            nextTimeout = osal_next_timeout();
    646          
    647            // Make sure timer counter can handle it
    648            if ( !nextTimeout || (nextTimeout > RETUNE_THRESHOLD) )
    649              nextTimeout = RETUNE_THRESHOLD;
    650          
    651            if (nextTimeout != tmr_decr_time)
    652            {
    653              // Stop the clock
    654              osal_timer_activate( FALSE );
    655          
    656              // Alter the rolling time
    657              tmr_decr_time = nextTimeout;
    658              tmr_count = (uint32)nextTimeout * TICK_TIME;
    659          
    660              // Restart the clock
    661              osal_timer_activate( TRUE );
    662            }
    663          
    664            HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
    665          }
    666          
    667          /*********************************************************************
    668           * @fn      osal_next_timeout
    669           *
    670           * @brief
    671           *
    672           *   Search timer table to return the lowest timeout value. If the
    673           *   timer list is empty, then the returned timeout will be zero.
    674           *
    675           * @param   none
    676           *
    677           * @return  none
    678           *********************************************************************/
    679          uint16 osal_next_timeout( void )
    680          {
    681            uint16 nextTimeout;
    682            osalTimerRec_t *srchTimer;
    683          
    684            if ( timerHead != NULL )
    685            {
    686              // Head of the timer list
    687              srchTimer = timerHead;
    688              nextTimeout = OSAL_TIMERS_MAX_TIMEOUT;
    689          
    690              // Look for the next timeout timer
    691              while ( srchTimer != NULL )
    692              {
    693                if (srchTimer->timeout < nextTimeout)
    694                {
    695                  nextTimeout = srchTimer->timeout;
    696                }
    697                // Check next timer
    698                srchTimer = srchTimer->next;
    699              }
    700            }
    701            else
    702            {
    703              // No timers
    704              nextTimeout = 0;
    705            }
    706          
    707            return ( nextTimeout );
    708          }
    709          #endif // POWER_SAVING
    710          
    711          /*********************************************************************
    712           * @fn      osal_GetSystemClock()
    713           *
    714           * @brief   Read the local system clock.
    715           *
    716           * @param   none
    717           *
    718           * @return  local clock in milliseconds
    719           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    720          uint32 osal_GetSystemClock( void )
   \                     osal_GetSystemClock:
    721          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    722            return ( osal_systemClock );
   \   000005   90....       MOV     DPTR,#osal_systemClock
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   12....       LCALL   ?L_MOV_X
   \   00000D   AA..         MOV     R2,?V0 + 0
   \   00000F   AB..         MOV     R3,?V0 + 1
   \   000011   AC..         MOV     R4,?V0 + 2
   \   000013   AD..         MOV     R5,?V0 + 3
   \   000015   02....       LJMP    ?Subroutine3 & 0xFFFF
    723          }

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_3e8:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_3e8>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_3e8>`:
   \   000000   E8030000     DD 1000

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_0:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_0>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_0>`:
   \   000000   00000000     DD 0

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osalTimerInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osalTimerInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osalAddTimer?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osalAddTimer

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osalFindTimer?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osalFindTimer

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osalDeleteTimer?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osalDeleteTimer

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_start_timerEx?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_start_timerEx

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_stop_timerEx?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_stop_timerEx

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_get_timeoutEx?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_get_timeoutEx

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_timer_activate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_timer_activate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_timer_num_active?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_timer_num_active

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_timer_hw_setup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_timer_hw_setup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_set_timer_interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_set_timer_interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osalTimerUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osalTimerUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_update_timers?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_update_timers

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_GetSystemClock?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_GetSystemClock
    724          
    725          /*********************************************************************
    726          *********************************************************************/

   Maximum stack usage in bytes:

     Function                     ISTACK PSTACK XSTACK
     --------                     ------ ------ ------
     osalAddTimer                     1      0     26
       -> osalFindTimer               0      0     28
       -> osal_mem_alloc              0      0     28
     osalDeleteTimer                  0      0     21
       -> osal_mem_free               0      0     18
       -> osal_mem_free               0      0     18
     osalFindTimer                    0      0     23
     osalTimerInit                    0      0     12
       -> osal_timer_activate         0      0     24
     osalTimerUpdate                  1      0     17
       -> osal_set_event              0      0     34
       -> osal_mem_free               0      0     34
     osal_GetSystemClock              0      0     12
     osal_get_timeoutEx               0      0     12
       -> osalFindTimer               0      0     24
     osal_set_timer_interrupt         2      0      0
       -> HalTimerInterruptEnable     4      0      0
     osal_start_timerEx               0      0     12
       -> osalAddTimer                0      0     24
       -> osal_timer_activate         0      0     24
     osal_stop_timerEx                0      0     12
       -> osalFindTimer               0      0     24
       -> osalDeleteTimer             0      0     24
     osal_timer_activate              0      0     21
       -> osal_timer_hw_setup         0      0     18
     osal_timer_hw_setup              0      0     21
       -> HalTimerStart               0      0     24
       -> HalTimerStop                0      0     24
     osal_timer_num_active            2      0      0
     osal_update_timers               2      0      0
       -> osalTimerUpdate             4      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _A_IEN0                           1
     timerHead                         2
     tmr_count                         4
     tmr_decr_time                     2
     timerActive                       1
     osal_systemClock                  4
     osalTimerInit                    58
     ?Subroutine3                      5
     osalAddTimer                    143
     ?Subroutine2                      6
     osalFindTimer                    58
     ?Subroutine4                      5
     ?Subroutine0                     10
     osalDeleteTimer                 109
     ?Subroutine1                      9
     osal_start_timerEx               62
     osal_stop_timerEx                54
     osal_get_timeoutEx               50
     osal_timer_activate              18
     osal_timer_num_active            42
     ?Subroutine5                      7
     osal_timer_hw_setup              38
     osal_set_timer_interrupt         15
     osalTimerUpdate                 262
     osal_update_timers               18
     osal_GetSystemClock              24
     __Constant_3e8                    4
     ?<Initializer for __Constant_3e8>
                                       4
     __Constant_0                      4
     ?<Initializer for __Constant_0>
                                       4
     ??osalTimerInit?relay             6
     ??osalAddTimer?relay              6
     ??osalFindTimer?relay             6
     ??osalDeleteTimer?relay           6
     ??osal_start_timerEx?relay        6
     ??osal_stop_timerEx?relay         6
     ??osal_get_timeoutEx?relay        6
     ??osal_timer_activate?relay       6
     ??osal_timer_num_active?relay     6
     ??osal_timer_hw_setup?relay       6
     ??osal_set_timer_interrupt?relay
                                       6
     ??osalTimerUpdate?relay           6
     ??osal_update_timers?relay        6
     ??osal_GetSystemClock?relay       6

 
 993 bytes in segment BANKED_CODE
  84 bytes in segment BANK_RELAYS
   1 byte  in segment SFR_AN
   8 bytes in segment XDATA_I
   8 bytes in segment XDATA_ID
  13 bytes in segment XDATA_Z
 
 1 077 bytes of CODE  memory (+ 8 bytes shared)
     0 bytes of DATA  memory (+ 1 byte  shared)
    13 bytes of XDATA memory (+ 8 bytes shared)

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    20/Dec/2012  21:41:05 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \hal\target\CC2430DB\hal_adc.c                     #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\..\..\..\Tools\C #
#                          C2430DB\f8wEndev.cfg" (-DCPU32MHZ                  #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_OPT_FFD=0 -DBLINK_LEDS "-DCONST=const        #
#                          __code" -DGENERIC=__generic) -f "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wCo #
#                          nfig.cfg" (-DSECURE=0 -DDEFAULT_CHANLIST=0x0000080 #
#                          0 -DZDAPP_CONFIG_PAN_ID=0xFFFF                     #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\hal\targ #
#                          et\CC2430DB\hal_adc.c" -D CC2430DB -D              #
#                          NWK_AUTO_POLL -D REFLECTOR -D xZTOOL_P2 -D         #
#                          xMT_TASK -D xMT_ZDO_FUNC -D xLCD_SUPPORTED=DEBUG   #
#                          -D xPOWER_SAVING -lC "C:\Texas                     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\EndDeviceDB\List\" -lA        #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\EndDeviceDB\List\"  #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550    #
#                          -o "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\EndDeviceDB\Obj\ #
#                          " -e --require_prototypes -z9 --no_code_motion     #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\SOURCE\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\Drivers\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\ZMAIN\TI2430DB\" -I  #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MT\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\HAL #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\TARGET\CC2430DB\" -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\OSA #
#                          L\INCLUDE\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\AF\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2. #
#                          1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\.. #
#                          \..\..\COMPONENTS\STACK\NWK\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\SEC\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\STACK\SYS\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\ZDO\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\ZMAC\F8W\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\ZMA #
#                          C\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Pr #
#                          ojects\zstack\Samples\AXDApp\CC2430DB\..\..\..\..\ #
#                          ..\COMPONENTS\SERVICES\SADDR\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\SER #
#                          VICES\SDATA\" -I "C:\Texas                         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\HIGH_LEVEL\" -I           #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \LOW_LEVEL\SRF03\SINGLE_CHIP\" -I "C:\Program      #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\" -I "C:\Program       #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\EndDeviceDB\List\hal #
#                          _adc.lst                                           #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\EndDeviceDB\Obj\hal_ #
#                          adc.r51                                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\hal\target\CC2430DB\hal_adc.c
      1          /**************************************************************************************************
      2            Filename:       hal_adc.c
      3            Revised:        $Date: 2007-11-01 08:44:53 -0700 (Thu, 01 Nov 2007) $
      4            Revision:       $Revision: 15821 $
      5          
      6            Description:    This file contains the interface to the HAL ADC.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /**************************************************************************************************
     41           *                                           INCLUDES
     42           **************************************************************************************************/
     43          #include  "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x88
   \   union <unnamed> volatile __sfr _A_TCON
   \                     _A_TCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb5
   \   unsigned char volatile __sfr ADCCON2
   \                     ADCCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb6
   \   unsigned char volatile __sfr ADCCON3
   \                     ADCCON3:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xba
   \   unsigned char volatile __sfr ADCL
   \                     ADCL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr ADCH
   \                     ADCH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf2
   \   unsigned char volatile __sfr ADCCFG
   \                     ADCCFG:
   \   000000                DS 1
     44          #include  "hal_defs.h"
     45          #include  "hal_types.h"
     46          #include  "hal_adc.h"
     47          
     48          /**************************************************************************************************
     49           *                                            CONSTANTS
     50           **************************************************************************************************/
     51          #define HAL_ADC_EOC         0x80    /* End of Conversion bit */
     52          #define HAL_ADC_START       0x40    /* Starts Conversion */
     53          
     54          #define HAL_ADC_STSEL_EXT   0x00    /* External Trigger */
     55          #define HAL_ADC_STSEL_FULL  0x10    /* Full Speed, No Trigger */
     56          #define HAL_ADC_STSEL_T1C0  0x20    /* Timer1, Channel 0 Compare Event Trigger */
     57          #define HAL_ADC_STSEL_ST    0x30    /* ADCCON1.ST =1 Trigger */
     58          
     59          #define HAL_ADC_RAND_NORM   0x00    /* Normal Operation */
     60          #define HAL_ADC_RAND_LFSR   0x04    /* Clock LFSR */
     61          #define HAL_ADC_RAND_SEED   0x08    /* Seed Modulator */
     62          #define HAL_ADC_RAND_STOP   0x0c    /* Stop Random Generator */
     63          #define HAL_ADC_RAND_BITS   0x0c    /* Bits [3:2] */
     64          
     65          #define HAL_ADC_REF_125V    0x00    /* Internal 1.25V Reference */
     66          #define HAL_ADC_REF_AIN7    0x40    /* AIN7 Reference */
     67          #define HAL_ADC_REF_AVDD    0x80    /* AVDD_SOC Pin Reference */
     68          #define HAL_ADC_REF_DIFF    0xc0    /* AIN7,AIN6 Differential Reference */
     69          #define HAL_ADC_REF_BITS    0xc0    /* Bits [7:6] */
     70          
     71          #define HAL_ADC_DEC_064     0x00    /* Decimate by 64 : 8-bit resolution */
     72          #define HAL_ADC_DEC_128     0x10    /* Decimate by 128 : 10-bit resolution */
     73          #define HAL_ADC_DEC_256     0x20    /* Decimate by 256 : 12-bit resolution */
     74          #define HAL_ADC_DEC_512     0x30    /* Decimate by 512 : 14-bit resolution */
     75          #define HAL_ADC_DEC_BITS    0x30    /* Bits [5:4] */
     76          
     77          #define HAL_ADC_CHN_AIN0    0x00    /* AIN0 */
     78          #define HAL_ADC_CHN_AIN1    0x01    /* AIN1 */
     79          #define HAL_ADC_CHN_AIN2    0x02    /* AIN2 */
     80          #define HAL_ADC_CHN_AIN3    0x03    /* AIN3 */
     81          #define HAL_ADC_CHN_AIN4    0x04    /* AIN4 */
     82          #define HAL_ADC_CHN_AIN5    0x05    /* AIN5 */
     83          #define HAL_ADC_CHN_AIN6    0x06    /* AIN6 */
     84          #define HAL_ADC_CHN_AIN7    0x07    /* AIN7 */
     85          #define HAL_ADC_CHN_A0A1    0x08    /* AIN0,AIN1 */
     86          #define HAL_ADC_CHN_A2A3    0x09    /* AIN2,AIN3 */
     87          #define HAL_ADC_CHN_A4A5    0x0a    /* AIN4,AIN5 */
     88          #define HAL_ADC_CHN_A6A7    0x0b    /* AIN6,AIN7 */
     89          #define HAL_ADC_CHN_GND     0x0c    /* GND */
     90          #define HAL_ADC_CHN_VREF    0x0d    /* Positive voltage reference */
     91          #define HAL_ADC_CHN_TEMP    0x0e    /* Temperature sensor */
     92          #define HAL_ADC_CHN_VDD3    0x0f    /* VDD/3 */
     93          #define HAL_ADC_CHN_BITS    0x0f    /* Bits [3:0] */
     94          
     95          #define HAL_ADC_STSEL       HAL_ADC_STSEL_ST
     96          #define HAL_ADC_RAND_GEN    HAL_ADC_RAND_STOP
     97          #define HAL_ADC_REF_VOLT    HAL_ADC_REF_AVDD
     98          #define HAL_ADC_DEC_RATE    HAL_ADC_DEC_064
     99          #define HAL_ADC_SCHN        HAL_ADC_CHN_VDD3
    100          #define HAL_ADC_ECHN        HAL_ADC_CHN_GND
    101          
    102          
    103          /* Vdd limit values */

   \                                 In  segment CODE_C, align 1
    104          static __code const uint16 HalAdcVddLimit[] =
   \                     HalAdcVddLimit:
   \   000000   9C36063A     DW 13980, 14854, 15728, 16601, 17475, 18349, 19223, 20097, 20970
   \            703DD940
   \            4344AD47
   \            174B814E
   \            EA51    
    105          {
    106            0x369C,       /*  VDD Limit - 1.6v  */
    107            0x3A06,       /*  VDD Limit - 1.7v  */
    108            0x3D70,       /*  VDD Limit - 1.8v  */
    109            0x40D9,       /*  VDD Limit - 1.9v  */
    110            0x4443,       /*  VDD Limit - 2.0v  */
    111            0x47AD,       /*  VDD Limit - 2.1v  */
    112            0x4B17,       /*  VDD Limit - 2.2v  */
    113            0x4E81,       /*  VDD Limit - 2.3v  */
    114            0x51EA,       /*  VDD Limit - 2.4v  */
    115          };
    116          
    117          
    118          /**************************************************************************************************
    119           *                                              MACROS
    120           **************************************************************************************************/
    121          #define HAL_ADC_CLR_EOC()   asm("PUSH A"); asm("MOV A,ADCL"); asm("MOV A,ADCH"); asm("POP A");
    122          
    123          /**************************************************************************************************
    124           *                                            TYPEDEFS
    125           **************************************************************************************************/
    126          
    127          /**************************************************************************************************
    128           *                                         GLOBAL VARIABLES
    129           **************************************************************************************************/
    130          
    131          /**************************************************************************************************
    132           *                                          FUNCTIONS - API
    133           **************************************************************************************************/
    134          extern bool HalAdcCheckVdd (uint8 limit);
    135          
    136          /**************************************************************************************************
    137           * @fn      HalAdcInit
    138           *
    139           * @brief   Initialize ADC Service
    140           *
    141           * @param   None
    142           *
    143           * @return  None
    144           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    145          void HalAdcInit (void)
   \                     HalAdcInit:
    146          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    147          #if (HAL_ADC == TRUE)
    148            volatile uint8  tmp;
    149          
    150            ADCCON1 = HAL_ADC_STSEL | HAL_ADC_RAND_GEN | 0x03;
   \   000009   75B43F       MOV     0xb4,#0x3f
    151            ADCCON2 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_SCHN;
   \   00000C   75B58F       MOV     0xb5,#-0x71
    152            /*
    153            *  After reset, the first ADC reading of the extra conversion always reads GND level.
    154            *  We will do a few dummy conversions to bypass this bug.
    155            */
    156            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   00000F   E5BA         MOV     A,0xba
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   F0           MOVX    @DPTR,A
    157            tmp = ADCH;
   \   000018   E5BB         MOV     A,0xbb
   \   00001A   F0           MOVX    @DPTR,A
    158            ADCCON3 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_ECHN;
   \   00001B   75B68C       MOV     0xb6,#-0x74
    159            while ((ADCCON1 & HAL_ADC_EOC) != HAL_ADC_EOC);   /* Wait for conversion */
   \                     ??HalAdcInit_0:
   \   00001E   E5B4         MOV     A,0xb4
   \   000020   A2E7         MOV     C,0xE0 /* A   */.7
   \   000022   50FA         JNC     ??HalAdcInit_0
    160            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   000024   E5BA         MOV     A,0xba
   \   000026   F0           MOVX    @DPTR,A
    161            tmp = ADCH;
   \   000027   E5BB         MOV     A,0xbb
   \   000029   F0           MOVX    @DPTR,A
    162            ADCCON3 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_ECHN;
   \   00002A   75B68C       MOV     0xb6,#-0x74
    163            while ((ADCCON1 & HAL_ADC_EOC) != HAL_ADC_EOC);   /* Wait for conversion */
   \                     ??HalAdcInit_1:
   \   00002D   E5B4         MOV     A,0xb4
   \   00002F   A2E7         MOV     C,0xE0 /* A   */.7
   \   000031   50FA         JNC     ??HalAdcInit_1
    164            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   000033   E5BA         MOV     A,0xba
   \   000035   F0           MOVX    @DPTR,A
    165            tmp = ADCH;
   \   000036   E5BB         MOV     A,0xbb
   \   000038   F0           MOVX    @DPTR,A
    166          #endif
    167          }
   \   000039   7401         MOV     A,#0x1
   \   00003B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003E                REQUIRE ?Subroutine0
   \   00003E                REQUIRE ADCCON1
   \   00003E                REQUIRE ADCCON2
   \   00003E                REQUIRE ADCCON3
   \   00003E                REQUIRE ADCL
   \   00003E                REQUIRE ADCH
   \   00003E                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    168          
    169          /**************************************************************************************************
    170           * @fn      HalAdcRead
    171           *
    172           * @brief   Read the ADC based on given channel and resolution
    173           *
    174           * @param   channel - channel where ADC will be read
    175           * @param   resolution - the resolution of the value
    176           *
    177           * @return  16 bit value of the ADC in offset binary format.
    178           *          Note that the ADC is "bipolar", which means the GND (0V) level is mid-scale.
    179           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    180          uint16 HalAdcRead (uint8 channel, uint8 resolution)
   \                     HalAdcRead:
    181          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    182            int16  reading = 0;
    183          
    184          #if (HAL_ADC == TRUE)
    185          
    186            uint8   i, resbits;
    187            uint8   adctemp;
    188            volatile  uint8 tmp;
    189            uint8  adcChannel = 1;
   \   00000A   7C01         MOV     R4,#0x1
    190          
    191            /*
    192            * If Analog input channel is AIN0..AIN7, make sure corresponing P0 I/O pin is enabled.  The code
    193            * does NOT disable the pin at the end of this function.  I think it is better to leave the pin
    194            * enabled because the results will be more accurate.  Because of the inherent capacitance on the
    195            * pin, it takes time for the voltage on the pin to charge up to its steady-state level.  If
    196            * HalAdcRead() has to turn on the pin for every conversion, the results may show a lower voltage
    197            * than actuality because the pin did not have time to fully charge.
    198            */
    199            if (channel < 8)
   \   00000C   E9           MOV     A,R1
   \   00000D   C3           CLR     C
   \   00000E   9408         SUBB    A,#0x8
   \   000010   500E         JNC     ??HalAdcRead_0
    200            {
    201              for (i=0; i < channel; i++)
   \   000012   7B00         MOV     R3,#0x0
   \   000014   8005         SJMP    ??HalAdcRead_1
    202              {
    203                adcChannel <<= 1;
   \                     ??HalAdcRead_2:
   \   000016   EC           MOV     A,R4
   \   000017   C3           CLR     C
   \   000018   33           RLC     A
   \   000019   FC           MOV     R4,A
    204              }
   \   00001A   0B           INC     R3
   \                     ??HalAdcRead_1:
   \   00001B   EB           MOV     A,R3
   \   00001C   C3           CLR     C
   \   00001D   99           SUBB    A,R1
   \   00001E   40F6         JC      ??HalAdcRead_2
    205            }
    206          
    207            /* Enable channel */
    208            ADCCFG |= adcChannel;
   \                     ??HalAdcRead_0:
   \   000020   EC           MOV     A,R4
   \   000021   45F2         ORL     A,0xf2
   \   000023   F5F2         MOV     0xf2,A
    209          
    210            /* Convert resolution to decimation rate */
    211            switch (resolution)
   \   000025   EA           MOV     A,R2
   \   000026   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for HalAdcRead>_0`:
   \   000029   01           DB        1
   \   00002A   02           DB        2
   \   00002B   ....         DW        ??HalAdcRead_3
   \   00002D   ....         DW        ??HalAdcRead_4
   \   00002F   ....         DW        ??HalAdcRead_5
   \   000031   ....         DW        ??HalAdcRead_6
    212            {
    213              case HAL_ADC_RESOLUTION_8:
    214                resbits = HAL_ADC_DEC_064;
   \                     ??HalAdcRead_4:
   \   000033   7B00         MOV     R3,#0x0
   \   000035   800A         SJMP    ??HalAdcRead_7
    215                break;
    216              case HAL_ADC_RESOLUTION_10:
    217                resbits = HAL_ADC_DEC_128;
   \                     ??HalAdcRead_5:
   \   000037   7B10         MOV     R3,#0x10
   \   000039   8006         SJMP    ??HalAdcRead_7
    218                break;
    219              case HAL_ADC_RESOLUTION_12:
    220                resbits = HAL_ADC_DEC_256;
   \                     ??HalAdcRead_6:
   \   00003B   7B20         MOV     R3,#0x20
   \   00003D   8002         SJMP    ??HalAdcRead_7
    221                break;
    222              case HAL_ADC_RESOLUTION_14:
    223              default:
    224                resbits = HAL_ADC_DEC_512;
   \                     ??HalAdcRead_3:
   \   00003F   7B30         MOV     R3,#0x30
    225                break;
    226            }
    227          
    228            /* read ADCL,ADCH to clear EOC */
    229            tmp = ADCL;
   \                     ??HalAdcRead_7:
   \   000041   E5BA         MOV     A,0xba
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   F0           MOVX    @DPTR,A
    230            tmp = ADCH;
   \   00004A   E5BB         MOV     A,0xbb
   \   00004C   F0           MOVX    @DPTR,A
    231          
    232            /* Setup Sample */
    233            adctemp = ADCCON3;
   \   00004D   E5B6         MOV     A,0xb6
    234            adctemp &= ~(HAL_ADC_CHN_BITS | HAL_ADC_DEC_BITS | HAL_ADC_REF_BITS);
    235            adctemp |= channel | resbits | HAL_ADC_REF_VOLT;
    236          
    237            /* writing to this register starts the extra conversion */
    238            ADCCON3 = adctemp;
   \   00004F   EB           MOV     A,R3
   \   000050   49           ORL     A,R1
   \   000051   4480         ORL     A,#0x80
   \   000053   F5B6         MOV     0xb6,A
    239          
    240            /* Wait for the conversion to be done */
    241            while (!(ADCCON1 & HAL_ADC_EOC));
   \                     ??HalAdcRead_8:
   \   000055   E5B4         MOV     A,0xb4
   \   000057   A2E7         MOV     C,0xE0 /* A   */.7
   \   000059   50FA         JNC     ??HalAdcRead_8
    242          
    243            /* Disable channel after done conversion */
    244            ADCCFG &= ~adcChannel;
   \   00005B   EC           MOV     A,R4
   \   00005C   F4           CPL     A
   \   00005D   55F2         ANL     A,0xf2
   \   00005F   F5F2         MOV     0xf2,A
    245          
    246            /* Read the result */
    247            reading = (int16) (ADCL);
   \   000061   ABBA         MOV     R3,0xba
   \   000063   8B82         MOV     DPL,R3
   \   000065   A882         MOV     R0,DPL
    248            reading |= (int16) (ADCH << 8);
   \   000067   E5BB         MOV     A,0xbb
   \   000069   F9           MOV     R1,A
    249          
    250            /* Treat small negative as 0 */
    251            if (reading < 0)
   \   00006A   C3           CLR     C
   \   00006B   9400         SUBB    A,#0x0
   \   00006D   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00006F   65D0         XRL     A,PSW
   \   000071   33           RLC     A
   \   000072   5004         JNC     ??HalAdcRead_9
    252              reading = 0;
   \   000074   7800         MOV     R0,#0x0
   \   000076   7900         MOV     R1,#0x0
    253          
    254            switch (resolution)
   \                     ??HalAdcRead_9:
   \   000078   EA           MOV     A,R2
   \   000079   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for HalAdcRead>_1`:
   \   00007C   01           DB        1
   \   00007D   02           DB        2
   \   00007E   ....         DW        ??HalAdcRead_10
   \   000080   ....         DW        ??HalAdcRead_11
   \   000082   ....         DW        ??HalAdcRead_12
   \   000084   ....         DW        ??HalAdcRead_13
    255            {
    256              case HAL_ADC_RESOLUTION_8:
    257                reading >>= 8;
   \                     ??HalAdcRead_11:
   \   000086   88..         MOV     ?V0 + 0,R0
   \   000088   89..         MOV     ?V0 + 1,R1
   \   00008A   7408         MOV     A,#0x8
   \   00008C   800E         SJMP    ??HalAdcRead_14
    258                break;
    259              case HAL_ADC_RESOLUTION_10:
    260                reading >>= 6;
   \                     ??HalAdcRead_12:
   \   00008E   88..         MOV     ?V0 + 0,R0
   \   000090   89..         MOV     ?V0 + 1,R1
   \   000092   7406         MOV     A,#0x6
   \   000094   8006         SJMP    ??HalAdcRead_14
    261                break;
    262              case HAL_ADC_RESOLUTION_12:
    263                reading >>= 4;
   \                     ??HalAdcRead_13:
   \   000096   88..         MOV     ?V0 + 0,R0
   \   000098   89..         MOV     ?V0 + 1,R1
   \   00009A   7404         MOV     A,#0x4
   \                     ??HalAdcRead_14:
   \   00009C   78..         MOV     R0,#?V0 + 0
   \   00009E   12....       LCALL   ?SS_SHR
   \   0000A1   A8..         MOV     R0,?V0 + 0
   \   0000A3   A9..         MOV     R1,?V0 + 1
    264                break;
    265              case HAL_ADC_RESOLUTION_14:
    266              default:
    267              break;
    268            }
    269          #endif
    270          
    271            return ((uint16)reading);
   \                     ??HalAdcRead_10:
   \   0000A5   E8           MOV     A,R0
   \   0000A6   FA           MOV     R2,A
   \   0000A7   E9           MOV     A,R1
   \   0000A8   FB           MOV     R3,A
   \   0000A9   7401         MOV     A,#0x1
   \   0000AB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AE   7F02         MOV     R7,#0x2
   \   0000B0   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   0000B3                REQUIRE ADCCON1
   \   0000B3                REQUIRE ADCCON3
   \   0000B3                REQUIRE ADCL
   \   0000B3                REQUIRE ADCH
   \   0000B3                REQUIRE ADCCFG
    272          }
    273          
    274          /**************************************************************************************************
    275           * @fn      HalAdcCheckVdd
    276           *
    277           * @brief   Check the Vdd and return TRUE if it greater than or equal the limit
    278           *
    279           * @param   limit - limit that needs to be checked with the Vdd
    280           *
    281           * @return  TRUE if Vdd >= limit, FALSE otherwise
    282           *
    283           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    284          bool HalAdcCheckVdd (uint8 limit)
   \                     HalAdcCheckVdd:
    285          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    286            uint16 value;
    287          
    288            /* If rev C or earlier, dont check the voltage */
    289            if (CHVER < REV_D)
   \   000004   90DF60       MOV     DPTR,#-0x20a0
   \   000007   E0           MOVX    A,@DPTR
   \   000008   C3           CLR     C
   \   000009   9403         SUBB    A,#0x3
   \   00000B   5004         JNC     ??HalAdcCheckVdd_0
    290            {
    291              return TRUE;
   \                     ??HalAdcCheckVdd_1:
   \   00000D   7901         MOV     R1,#0x1
   \   00000F   802F         SJMP    ??HalAdcCheckVdd_2
    292            }
    293          
    294            /* Clear ADC interrupt flag */
    295            ADCIF = 0;
   \                     ??HalAdcCheckVdd_0:
   \   000011   C28D         CLR     0x88.5
    296          
    297            /* Setup the new value for conversion */
    298            ADCCON3 = (HAL_ADC_REF_125V | HAL_ADC_DEC_064 | HAL_ADC_CHN_VDD3);
   \   000013   75B60F       MOV     0xb6,#0xf
    299          
    300            /* Wait for the conversion to finish */
    301            while ( !ADCIF );
   \                     ??HalAdcCheckVdd_3:
   \   000016   A28D         MOV     C,0x88.5
   \   000018   50FC         JNC     ??HalAdcCheckVdd_3
    302          
    303            /* Get the result */
    304            value = ADCL;
   \   00001A   AABA         MOV     R2,0xba
    305            value |= ((uint16) ADCH) << 8;
   \   00001C   E5BB         MOV     A,0xbb
   \   00001E   FB           MOV     R3,A
    306          
    307            /* Check the limit and return */
    308            return ( value >= HalAdcVddLimit[limit] );
   \   00001F   E9           MOV     A,R1
   \   000020   C3           CLR     C
   \   000021   33           RLC     A
   \   000022   F8           MOV     R0,A
   \   000023   E4           CLR     A
   \   000024   33           RLC     A
   \   000025   F9           MOV     R1,A
   \   000026   E8           MOV     A,R0
   \   000027   24..         ADD     A,#(HalAdcVddLimit & 0xff)
   \   000029   F582         MOV     DPL,A
   \   00002B   E9           MOV     A,R1
   \   00002C   34..         ADDC    A,#((HalAdcVddLimit >> 8) & 0xff)
   \   00002E   F583         MOV     DPH,A
   \   000030   E4           CLR     A
   \   000031   93           MOVC    A,@A+DPTR
   \   000032   F8           MOV     R0,A
   \   000033   7401         MOV     A,#0x1
   \   000035   93           MOVC    A,@A+DPTR
   \   000036   F9           MOV     R1,A
   \   000037   C3           CLR     C
   \   000038   EA           MOV     A,R2
   \   000039   98           SUBB    A,R0
   \   00003A   EB           MOV     A,R3
   \   00003B   99           SUBB    A,R1
   \   00003C   50CF         JNC     ??HalAdcCheckVdd_1
   \   00003E   7900         MOV     R1,#0x0
   \                     ??HalAdcCheckVdd_2:
   \   000040   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000043                REQUIRE _A_TCON
   \   000043                REQUIRE ADCCON3
   \   000043                REQUIRE ADCL
   \   000043                REQUIRE ADCH
    309          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcCheckVdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcCheckVdd
    310          
    311          /**************************************************************************************************
    312          **************************************************************************************************/
    313          
    314          
    315          
    316          

   Maximum stack usage in bytes:

     Function       ISTACK PSTACK XSTACK
     --------       ------ ------ ------
     HalAdcCheckVdd     2      0      0
     HalAdcInit         3      0      1
     HalAdcRead         1      0     11


   Segment part sizes:

     Function/Label         Bytes
     --------------         -----
     _A_TCON                   1
     ADCCON1                   1
     ADCCON2                   1
     ADCCON3                   1
     ADCL                      1
     ADCH                      1
     ADCCFG                    1
     HalAdcVddLimit           18
     HalAdcInit               62
     ?Subroutine0              7
     HalAdcRead              179
     HalAdcCheckVdd           67
     ??HalAdcInit?relay        6
     ??HalAdcRead?relay        6
     ??HalAdcCheckVdd?relay    6

 
 315 bytes in segment BANKED_CODE
  18 bytes in segment BANK_RELAYS
  18 bytes in segment CODE_C
   7 bytes in segment SFR_AN
 
 351 bytes of CODE memory
   0 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    20/Dec/2012  21:41:08 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \mac\low_level\srf03\single_chip\mac_mcu.c         #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\..\..\..\Tools\C #
#                          C2430DB\f8wEndev.cfg" (-DCPU32MHZ                  #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_OPT_FFD=0 -DBLINK_LEDS "-DCONST=const        #
#                          __code" -DGENERIC=__generic) -f "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wCo #
#                          nfig.cfg" (-DSECURE=0 -DDEFAULT_CHANLIST=0x0000080 #
#                          0 -DZDAPP_CONFIG_PAN_ID=0xFFFF                     #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\mac\low_ #
#                          level\srf03\single_chip\mac_mcu.c" -D CC2430DB -D  #
#                          NWK_AUTO_POLL -D REFLECTOR -D xZTOOL_P2 -D         #
#                          xMT_TASK -D xMT_ZDO_FUNC -D xLCD_SUPPORTED=DEBUG   #
#                          -D xPOWER_SAVING -lC "C:\Texas                     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\EndDeviceDB\List\" -lA        #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\EndDeviceDB\List\"  #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550    #
#                          -o "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\EndDeviceDB\Obj\ #
#                          " -e --require_prototypes -z9 --no_code_motion     #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\SOURCE\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\Drivers\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\ZMAIN\TI2430DB\" -I  #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MT\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\HAL #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\TARGET\CC2430DB\" -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\OSA #
#                          L\INCLUDE\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\AF\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2. #
#                          1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\.. #
#                          \..\..\COMPONENTS\STACK\NWK\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\SEC\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\STACK\SYS\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\ZDO\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\ZMAC\F8W\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\ZMA #
#                          C\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Pr #
#                          ojects\zstack\Samples\AXDApp\CC2430DB\..\..\..\..\ #
#                          ..\COMPONENTS\SERVICES\SADDR\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\SER #
#                          VICES\SDATA\" -I "C:\Texas                         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\HIGH_LEVEL\" -I           #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \LOW_LEVEL\SRF03\SINGLE_CHIP\" -I "C:\Program      #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\" -I "C:\Program       #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\EndDeviceDB\List\mac #
#                          _mcu.lst                                           #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\EndDeviceDB\Obj\mac_ #
#                          mcu.r51                                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\mac\low_level\srf03\single_chip\mac_mcu.c
      1          /**************************************************************************************************
      2            Filename:       mac_mcu.c
      3            Revised:        $Date: 2007-10-29 22:38:47 -0700 (Mon, 29 Oct 2007) $
      4            Revision:       $Revision: 15812 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40             ///////////////////////////////////////////////////////////////////////////////////
     41             //  REV_B_WORKAROUND : Place holder as a reminder to optimize the bank select code
     42             //  once Rev B obsoleted.  Currently the bank select bits share a register with
     43             //  other functionality.  This will be *mirrored* to a new location where it
     44             //  is the only thing in the register.
     45             ///////////////////////////////////////////////////////////////////////////////////
     46          
     47          
     48          /* ------------------------------------------------------------------------------------------------
     49           *                                          Includes
     50           * ------------------------------------------------------------------------------------------------
     51           */
     52          
     53          /* hal */
     54          #include "hal_defs.h"
     55          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x91
   \   unsigned char volatile __sfr RFIM
   \                     RFIM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9b
   \   unsigned char volatile __sfr S1CON
   \                     S1CON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9c
   \   unsigned char volatile __sfr T2PEROF0
   \                     T2PEROF0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr T2PEROF1
   \                     T2PEROF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr T2PEROF2
   \                     T2PEROF2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa1
   \   unsigned char volatile __sfr T2OF0
   \                     T2OF0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa2
   \   unsigned char volatile __sfr T2OF1
   \                     T2OF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa3
   \   unsigned char volatile __sfr T2OF2
   \                     T2OF2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa4
   \   unsigned char volatile __sfr T2CAPLPL
   \                     T2CAPLPL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa5
   \   unsigned char volatile __sfr T2CAPHPH
   \                     T2CAPHPH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa6
   \   unsigned char volatile __sfr T2TLD
   \                     T2TLD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa7
   \   unsigned char volatile __sfr T2THD
   \                     T2THD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa9
   \   unsigned char volatile __sfr IP0
   \                     IP0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb9
   \   unsigned char volatile __sfr IP1
   \                     IP1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbc
   \   unsigned char volatile __sfr RNDL
   \                     RNDL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbd
   \   unsigned char volatile __sfr RNDH
   \                     RNDH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc3
   \   unsigned char volatile __sfr T2CNF
   \                     T2CNF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe9
   \   unsigned char volatile __sfr RFIF
   \                     RFIF:
   \   000000                DS 1
     56          
     57          /* low-level specific */
     58          #include "mac_rx.h"
     59          #include "mac_tx.h"
     60          #include "mac_backoff_timer.h"
     61          #include "mac_csp_tx.h"
     62          #include "mac_rx_onoff.h"
     63          
     64          /* target specific */
     65          #include "mac_mcu.h"
     66          #include "mac_radio_defs.h"
     67          
     68          /* debug */
     69          #include "mac_assert.h"
     70          
     71          
     72          /* ------------------------------------------------------------------------------------------------
     73           *                                           Defines
     74           * ------------------------------------------------------------------------------------------------
     75           */
     76          #define T2CNF_BASE_VALUE    (RUN | SYNC)
     77          
     78          /* for optimized indexing of uint32's */
     79          #if HAL_MCU_LITTLE_ENDIAN()
     80          #define UINT32_NDX0   0
     81          #define UINT32_NDX1   1
     82          #define UINT32_NDX2   2
     83          #define UINT32_NDX3   3
     84          #else
     85          #define UINT32_NDX0   3
     86          #define UINT32_NDX1   2
     87          #define UINT32_NDX2   1
     88          #define UINT32_NDX3   0
     89          #endif
     90          
     91          /* ------------------------------------------------------------------------------------------------
     92           *                                        Local Variables
     93           * ------------------------------------------------------------------------------------------------
     94           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     95          static int8 maxRssi;
   \                     maxRssi:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     96          
     97          /*
     98           *  A shadow variable is required for the lower four bits of T2PEROF2.  These bits have different
     99           *  functionality for read versus write.  This would fine except the upper bits of T2PEROF2 are
    100           *  used to enable and disable interrupts and must be set independently of the lower four bits.
    101           *  Since the original value of the lower four bits is lost (it reads as something else) these
    102           *  bits must be stored in a shadow variable.  This shadow variable is declared here and is
    103           *  used where needed in this module.
    104           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    105          static uint8 shadowPerof2;
   \                     shadowPerof2:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    106          
    107          
    108          /* ------------------------------------------------------------------------------------------------
    109           *                                       Local Prototypes
    110           * ------------------------------------------------------------------------------------------------
    111           */
    112          static void mcuRecordMaxRssiIsr(void);
    113          
    114          
    115          /**************************************************************************************************
    116           * @fn          macMcuInit
    117           *
    118           * @brief       Initialize the MCU.
    119           *
    120           * @param       none
    121           *
    122           * @return      none
    123           **************************************************************************************************
    124           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    125          void macMcuInit(void)
   \                     macMcuInit:
    126          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    127          
    128            MAC_ASSERT(CHVER >= 0x03); /* chip versions before version D are obsolete */
   \   000004   90DF60       MOV     DPTR,#-0x20a0
   \   000007   E0           MOVX    A,@DPTR
   \   000008   C3           CLR     C
   \   000009   9403         SUBB    A,#0x3
   \   00000B   5003         JNC     ??macMcuInit_0
   \   00000D                ; Setup parameters for call to function halAssertHandler
   \   00000D   12....       LCALL   ??halAssertHandler?relay
    129          
    130            /* tuning adjustments for optimal radio performance; details available in datasheet */
    131            RXCTRL0H = 0x32;
   \                     ??macMcuInit_0:
   \   000010   7432         MOV     A,#0x32
   \   000012   90DF0C       MOV     DPTR,#-0x20f4
   \   000015   F0           MOVX    @DPTR,A
    132            RXCTRL0L = 0xF5;
   \   000016   74F5         MOV     A,#-0xb
   \   000018   90DF0D       MOV     DPTR,#-0x20f3
   \   00001B   F0           MOVX    @DPTR,A
    133          
    134            /* enable TX_DONE interrupts for ACK transmits */
    135            IRQSRC = TXACK;
   \   00001C   7401         MOV     A,#0x1
   \   00001E   90DF64       MOV     DPTR,#-0x209c
   \   000021   F0           MOVX    @DPTR,A
    136          
    137            /* disable the CSPT register compare function */
    138            CSPT = 0xFF;
   \   000022   74FF         MOV     A,#-0x1
   \   000024   90DF16       MOV     DPTR,#-0x20ea
   \   000027   F0           MOVX    @DPTR,A
    139          
    140            /* enable general RF interrupts */
    141            IEN2 |= RFIE;
   \   000028   439A01       ORL     0x9a,#0x1
    142          
    143            /* intialize shadow register */
    144            shadowPerof2 = 0;
   \   00002B   E4           CLR     A
   \   00002C   90....       MOV     DPTR,#shadowPerof2
   \   00002F   F0           MOVX    @DPTR,A
    145          
    146            /* set RF interrupts one notch above lowest priority (four levels available) */
    147            IP0 |=  IP_RFERR_RF_DMA_BV;
   \   000030   43A901       ORL     0xa9,#0x1
    148            IP1 &= ~IP_RFERR_RF_DMA_BV;
   \   000033   53B9FE       ANL     0xb9,#0xfe
    149          
    150            /*-------------------------------------------------------------------------------
    151             *  Initialize MAC timer.
    152             */
    153          
    154            /* set timer rollover */
    155            T2CAPLPL = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() & 0xFF;
   \   000036   75A400       MOV     0xa4,#0x0
    156            T2CAPHPH = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() >> 8;
   \   000039   75A528       MOV     0xa5,#0x28
    157          
    158            /* start timer */
    159            T2CNF |= RUN;
   \   00003C   43C301       ORL     0xc3,#0x1
    160          
    161            /* enable timer interrupts */
    162            T2IE = 1;
   \   00003F   D2BA         SETB    0xb8.2
    163          
    164           /*----------------------------------------------------------------------------------------------
    165            *  Initialize random seed value.
    166            */
    167          
    168            /* turn on radio power */
    169            RFPWR &= ~RREG_RADIO_PD;
   \   000041   90DF17       MOV     DPTR,#-0x20e9
   \   000044   E0           MOVX    A,@DPTR
   \   000045   C2E3         CLR     0xE0 /* A   */.3
   \   000047   F0           MOVX    @DPTR,A
    170            while((RFPWR & ADI_RADIO_PD));
   \                     ??macMcuInit_1:
   \   000048   E0           MOVX    A,@DPTR
   \   000049   A2E4         MOV     C,0xE0 /* A   */.4
   \   00004B   40FB         JC      ??macMcuInit_1
    171          
    172            /*
    173             *  Set radio for infinite reception.  Once radio reaches this state,
    174             *  it will stay in receive mode regardless RF activity.
    175             */
    176            MDMCTRL1L = MDMCTRL1L_RESET_VALUE | RX_MODE_INFINITE_RECEPTION;
   \   00004D   7402         MOV     A,#0x2
   \   00004F   90DF05       MOV     DPTR,#-0x20fb
   \   000052   F0           MOVX    @DPTR,A
    177          
    178            /* turn on the receiver */
    179            macRxOn();
   \   000053                ; Setup parameters for call to function macRxOn
   \   000053   12....       LCALL   ??macRxOn?relay
   \   000056   802C         SJMP    ??macMcuInit_2
    180          
    181            /*
    182             *  Wait for radio to reach infinite reception state.  Once it does,
    183             *  The least significant bit of ADTSTH should be pretty random.
    184             */
    185            while (FSMSTATE != FSM_FFCTRL_STATE_RX_INF)
    186          
    187            /* put 16 random bits into the seed value */
    188            {
    189              uint16 rndSeed;
    190              uint8  i;
    191          
    192              rndSeed = 0;
   \                     ??macMcuInit_3:
   \   000058   7800         MOV     R0,#0x0
   \   00005A   7900         MOV     R1,#0x0
    193          
    194              for(i=0; i<16; i++)
   \   00005C   7C10         MOV     R4,#0x10
    195              {
    196                /* use most random bit of analog to digital receive conversion to populate the random seed */
    197                rndSeed = (rndSeed << 1) | (ADCTSTH & 0x01);
   \                     ??macMcuInit_4:
   \   00005E   E8           MOV     A,R0
   \   00005F   C3           CLR     C
   \   000060   33           RLC     A
   \   000061   F8           MOV     R0,A
   \   000062   E9           MOV     A,R1
   \   000063   33           RLC     A
   \   000064   F9           MOV     R1,A
   \   000065   90DF3A       MOV     DPTR,#-0x20c6
   \   000068   E0           MOVX    A,@DPTR
   \   000069   A2E0         MOV     C,0xE0 /* A   */.0
   \   00006B   E4           CLR     A
   \   00006C   92E0         MOV     0xE0 /* A   */.0,C
   \   00006E   48           ORL     A,R0
   \   00006F   F8           MOV     R0,A
    198              }
   \   000070   1C           DEC     R4
   \   000071   EC           MOV     A,R4
   \   000072   70EA         JNZ     ??macMcuInit_4
    199          
    200              /*
    201               *  The seed value must not be zero.  If it is, the psuedo random sequence will be always be zero.
    202               *  There is an extremely small chance this seed could randomly be zero (more likely some type of
    203               *  hardware problem would cause this).  The following check makes sure this does not happen.
    204               */
    205              if (rndSeed == 0x0000)
   \   000074   E8           MOV     A,R0
   \   000075   7001         JNZ     ??macMcuInit_5
   \   000077   E9           MOV     A,R1
   \                     ??macMcuInit_5:
   \   000078   7004         JNZ     ??macMcuInit_6
    206              {
    207                rndSeed = 0xBEEF; /* completely arbitrary "random" value */
   \   00007A   78EF         MOV     R0,#-0x11
   \   00007C   79BE         MOV     R1,#-0x42
    208              }
    209          
    210              /*
    211               *  Two writes to RNDL will set the random seed.  A write to RNDL copies current contents
    212               *  of RNDL to RNDH before writing new the value to RNDL.
    213               */
    214              RNDL = rndSeed & 0xFF;
   \                     ??macMcuInit_6:
   \   00007E   E8           MOV     A,R0
   \   00007F   F5BC         MOV     0xbc,A
    215              RNDL = rndSeed >> 8;
   \   000081   E9           MOV     A,R1
   \   000082   F5BC         MOV     0xbc,A
    216            }
   \                     ??macMcuInit_2:
   \   000084   90DF39       MOV     DPTR,#-0x20c7
   \   000087   E0           MOVX    A,@DPTR
   \   000088   641F         XRL     A,#0x1f
   \   00008A   70CC         JNZ     ??macMcuInit_3
    217          
    218            /* turn off the receiver */
    219            macRxOff();
   \   00008C                ; Setup parameters for call to function macRxOff
   \   00008C   12....       LCALL   ??macRxOff?relay
    220          
    221            /* take receiver out of infinite reception mode; set back to normal operation */
    222            MDMCTRL1L = MDMCTRL1L_RESET_VALUE | RX_MODE_NORMAL_OPERATION;
   \   00008F   E4           CLR     A
   \   000090   90DF05       MOV     DPTR,#-0x20fb
   \   000093   F0           MOVX    @DPTR,A
    223          
    224            /* turn radio back off */
    225            RFPWR |= RREG_RADIO_PD;
   \   000094   90DF17       MOV     DPTR,#-0x20e9
   \   000097   E0           MOVX    A,@DPTR
   \   000098   D2E3         SETB    0xE0 /* A   */.3
   \   00009A   F0           MOVX    @DPTR,A
    226          }
   \   00009B   02....       LJMP    ?Subroutine3 & 0xFFFF
   \   00009E                REQUIRE IEN2
   \   00009E                REQUIRE T2CAPLPL
   \   00009E                REQUIRE T2CAPHPH
   \   00009E                REQUIRE IP0
   \   00009E                REQUIRE _A_IEN1
   \   00009E                REQUIRE IP1
   \   00009E                REQUIRE RNDL
   \   00009E                REQUIRE T2CNF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    227          
    228          
    229          /**************************************************************************************************
    230           * @fn          macMcuRandomByte
    231           *
    232           * @brief       Returns a random byte using a special hardware feature that generates new
    233           *              random values based on the truly random seed set earlier.
    234           *
    235           * @param       none
    236           *
    237           * @return      a random byte
    238           **************************************************************************************************
    239           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    240          uint8 macMcuRandomByte(void)
   \                     macMcuRandomByte:
    241          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    242            /* clock the random generator to get a new random value */
    243            ADCCON1 = (ADCCON1 & ~RCTRL_BITS) | RCTRL_CLOCK_LFSR;
   \   000000   74F3         MOV     A,#-0xd
   \   000002   55B4         ANL     A,0xb4
   \   000004   4404         ORL     A,#0x4
   \   000006   F5B4         MOV     0xb4,A
    244          
    245            /* return new randomized value from hardware */
    246            return(RNDH);
   \   000008   A9BD         MOV     R1,0xbd
   \   00000A   02....       LJMP    ?BRET
   \   00000D                REQUIRE ADCCON1
   \   00000D                REQUIRE RNDH
    247          }
    248          
    249          
    250          /**************************************************************************************************
    251           * @fn          macMcuTimerCount
    252           *
    253           * @brief       Returns the upper eight bits of hardware timer count.  The full 16-bit timer
    254           *              count is not returned because the timer compare feature only compares one byte.
    255           *
    256           * @param       none
    257           *
    258           * @return      upper eight bits of hardware timer count
    259           **************************************************************************************************
    260           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    261          uint8 macMcuTimerCount(void)
   \                     macMcuTimerCount:
    262          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    263            uint8 volatile temp;
    264          
    265            /* reading T2TLD latches T2THD */
    266            temp = T2TLD;
   \   000009   E5A6         MOV     A,0xa6
   \   00000B   85..82       MOV     DPL,?XSP + 0
   \   00000E   85..83       MOV     DPH,?XSP + 1
   \   000011   F0           MOVX    @DPTR,A
    267            return(T2THD);
   \   000012   A9A7         MOV     R1,0xa7
   \   000014   7401         MOV     A,#0x1
   \   000016   12....       LCALL   ?DEALLOC_XSTACK8
   \   000019   02....       LJMP    ?Subroutine3 & 0xFFFF
   \   00001C                REQUIRE T2TLD
   \   00001C                REQUIRE T2THD
    268          }
    269          
    270          
    271          /**************************************************************************************************
    272           * @fn          macMcuTimerCapture
    273           *
    274           * @brief       Returns the last timer capture.  This capture should have occurred at the
    275           *              receive time of the last frame (the last time SFD transitioned to active).
    276           *
    277           * @param       none
    278           *
    279           * @return      last capture of hardware timer (full 16-bit value)
    280           **************************************************************************************************
    281           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    282          uint16 macMcuTimerCapture(void)
   \                     macMcuTimerCapture:
    283          {
   \   000000                ; Saved register size: 2
   \   000000                ; Auto size: 0
    284            uint16 timerCapture;
    285          
    286            timerCapture = T2CAPLPL;
   \   000000   AAA4         MOV     R2,0xa4
    287            timerCapture |= T2CAPHPH << 8;
   \   000002   E5A5         MOV     A,0xa5
   \   000004   FB           MOV     R3,A
    288          
    289            return (timerCapture);
   \   000005   02....       LJMP    ?BRET
   \   000008                REQUIRE T2CAPLPL
   \   000008                REQUIRE T2CAPHPH
    290          }
    291          
    292          
    293          /**************************************************************************************************
    294           * @fn          macMcuOverflowCount
    295           *
    296           * @brief       Returns the value of the overflow counter which is a special hardware feature.
    297           *              The overflow count actually is only 20 bits of information.
    298           *
    299           * @param       none
    300           *
    301           * @return      value of overflow counter
    302           **************************************************************************************************
    303           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    304          uint32 macMcuOverflowCount(void)
   \                     macMcuOverflowCount:
    305          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    306            uint32 overflowCount;
    307          
    308            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    309          
    310            /* must read T2OF0 first, this latches T2OF1 and T2OF2 */
    311            ((uint8 *)&overflowCount)[UINT32_NDX0] = T2OF0;
   \   00000A   E5A1         MOV     A,0xa1
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   F0           MOVX    @DPTR,A
    312            ((uint8 *)&overflowCount)[UINT32_NDX1] = T2OF1;
   \   000013   E5A2         MOV     A,0xa2
   \   000015   C0E0         PUSH    A
   \   000017   7401         MOV     A,#0x1
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   D0E0         POP     A
   \   00001E   F0           MOVX    @DPTR,A
    313            ((uint8 *)&overflowCount)[UINT32_NDX2] = T2OF2;
   \   00001F   E5A3         MOV     A,0xa3
   \   000021   80..         SJMP    ?Subroutine4
   \   000023                REQUIRE T2OF0
   \   000023                REQUIRE T2OF1
   \   000023                REQUIRE T2OF2
    314            ((uint8 *)&overflowCount)[UINT32_NDX3] = 0;
    315          
    316            return (overflowCount);
    317          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   C0E0         PUSH    A
   \   000002   7402         MOV     A,#0x2
   \   000004   12....       LCALL   ?XSTACK_DISP0_8
   \   000007   D0E0         POP     A
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   7403         MOV     A,#0x3
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E4           CLR     A
   \   000010   12....       LCALL   ??Subroutine0_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000013   12....       LCALL   ?L_MOV_X
   \   000016   AA..         MOV     R2,?V0 + 0
   \   000018   AB..         MOV     R3,?V0 + 1
   \   00001A   AC..         MOV     R4,?V0 + 2
   \   00001C   AD..         MOV     R5,?V0 + 3
   \                     ??Subroutine4_0:
   \   00001E   7404         MOV     A,#0x4
   \   000020   12....       LCALL   ?DEALLOC_XSTACK8
   \   000023   7F04         MOV     R7,#0x4
   \   000025   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   EA           MOV     A,R2
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   EB           MOV     A,R3
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   EC           MOV     A,R4
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   A3           INC     DPTR
   \   00000F   ED           MOV     A,R5
   \                     ??Subroutine0_0:
   \   000010   F0           MOVX    @DPTR,A
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   78..         MOV     R0,#?V0 + 0
   \   000019   22           RET
    318          
    319          
    320          /**************************************************************************************************
    321           * @fn          macMcuOverflowCapture
    322           *
    323           * @brief       Returns the last capture of the overflow counter.  A special hardware feature
    324           *              captures the overflow counter when the regular hardware timer is captured.
    325           *
    326           * @param       none
    327           *
    328           * @return      last capture of overflow count
    329           **************************************************************************************************
    330           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    331          uint32 macMcuOverflowCapture(void)
   \                     macMcuOverflowCapture:
    332          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    333            uint32 overflowCapture;
    334          
    335            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    336          
    337            ((uint8 *)&overflowCapture)[UINT32_NDX0] = T2PEROF0;
   \   00000A   E59C         MOV     A,0x9c
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   F0           MOVX    @DPTR,A
    338            ((uint8 *)&overflowCapture)[UINT32_NDX1] = T2PEROF1;
   \   000013   E59D         MOV     A,0x9d
   \   000015   C0E0         PUSH    A
   \   000017   7401         MOV     A,#0x1
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   D0E0         POP     A
   \   00001E   F0           MOVX    @DPTR,A
    339            ((uint8 *)&overflowCapture)[UINT32_NDX2] = T2PEROF2 & PEROF2_BITS;
   \   00001F   740F         MOV     A,#0xf
   \   000021   559E         ANL     A,0x9e
   \   000023   80..         SJMP    ?Subroutine4
   \   000025                REQUIRE T2PEROF0
   \   000025                REQUIRE T2PEROF1
   \   000025                REQUIRE T2PEROF2
    340            ((uint8 *)&overflowCapture)[UINT32_NDX3] = 0;
    341          
    342            return (overflowCapture);
    343          }
    344          
    345          
    346          /**************************************************************************************************
    347           * @fn          macMcuOverflowSetCount
    348           *
    349           * @brief       Sets the value of the hardware overflow counter.
    350           *
    351           * @param       count - new overflow count value
    352           *
    353           * @return      none
    354           **************************************************************************************************
    355           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    356          void macMcuOverflowSetCount(uint32 count)
   \                     macMcuOverflowSetCount:
    357          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine0 & 0xFFFF
    358            MAC_ASSERT(!((count >> 16) & ~PEROF2_BITS));   /* illegal count value */
   \                     ??CrossCallReturnLabel_2:
   \   00000D   12....       LCALL   ?L_MOV_X
   \   000010   7410         MOV     A,#0x10
   \   000012   78..         MOV     R0,#?V0 + 0
   \   000014   12....       LCALL   ?UL_SHR
   \   000017   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00001A   7001         JNZ     ??macMcuOverflowSetCount_0
   \   00001C   E9           MOV     A,R1
   \                     ??macMcuOverflowSetCount_0:
   \   00001D   6003         JZ      ??macMcuOverflowSetCount_1
   \   00001F                ; Setup parameters for call to function halAssertHandler
   \   00001F   12....       LCALL   ??halAssertHandler?relay
    359          
    360            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    361          
    362            /* T2OF2 must be written last */
    363            T2OF0 = ((uint8 *)&count)[UINT32_NDX0];
   \                     ??macMcuOverflowSetCount_1:
   \   000022   85..82       MOV     DPL,?XSP + 0
   \   000025   85..83       MOV     DPH,?XSP + 1
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F5A1         MOV     0xa1,A
    364            T2OF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   00002B   7401         MOV     A,#0x1
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F5A2         MOV     0xa2,A
    365            T2OF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   000033   7402         MOV     A,#0x2
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5A3         MOV     0xa3,A
    366          }
   \   00003B   80..         SJMP    ??Subroutine4_0
   \   00003D                REQUIRE T2OF0
   \   00003D                REQUIRE T2OF1
   \   00003D                REQUIRE T2OF2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   74F0         MOV     A,#-0x10
   \   000002   55..         ANL     A,?V0 + 0
   \   000004   F8           MOV     R0,A
   \   000005   74FF         MOV     A,#-0x1
   \   000007   55..         ANL     A,?V0 + 1
   \   000009   F9           MOV     R1,A
   \   00000A   E8           MOV     A,R0
   \   00000B   22           RET
    367          
    368          
    369          /**************************************************************************************************
    370           * @fn          macMcuOverflowSetCompare
    371           *
    372           * @brief       Set overflow count compare value.  An interrupt is triggered when the overflow
    373           *              count equals this compare value.
    374           *
    375           * @param       count - overflow count compare value
    376           *
    377           * @return      none
    378           **************************************************************************************************
    379           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    380          void macMcuOverflowSetCompare(uint32 count)
   \                     macMcuOverflowSetCompare:
    381          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine0 & 0xFFFF
    382            halIntState_t  s;
    383            uint8 imBits;
    384          
    385            MAC_ASSERT(!((count >> 16) & ~PEROF2_BITS));   /* illegal count value */
   \                     ??CrossCallReturnLabel_3:
   \   00000D   12....       LCALL   ?L_MOV_X
   \   000010   7410         MOV     A,#0x10
   \   000012   78..         MOV     R0,#?V0 + 0
   \   000014   12....       LCALL   ?UL_SHR
   \   000017   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   00001A   7001         JNZ     ??macMcuOverflowSetCompare_0
   \   00001C   E9           MOV     A,R1
   \                     ??macMcuOverflowSetCompare_0:
   \   00001D   6003         JZ      ??macMcuOverflowSetCompare_1
   \   00001F                ; Setup parameters for call to function halAssertHandler
   \   00001F   12....       LCALL   ??halAssertHandler?relay
    386          
    387            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetCompare_1:
   \   000022   A2AF         MOV     C,0xa8.7
   \   000024   E4           CLR     A
   \   000025   92E0         MOV     0xE0 /* A   */.0,C
   \   000027   FA           MOV     R2,A
   \   000028   C2AF         CLR     0xa8.7
    388          
    389            /* remember value of interrupt mask bits, allows OFCMPIM bit to be restored later */
    390            imBits = T2PEROF2 & ~PEROF2_BITS;
   \   00002A   74F0         MOV     A,#-0x10
   \   00002C   559E         ANL     A,0x9e
   \   00002E   FB           MOV     R3,A
    391          
    392            /*
    393             *  Disable overflow compare interrupts.  (It is OK to write zero to compare part of
    394             *  this register.  Interrupts are disabled and the new value will be written and the
    395             *  interrupt flag cleared before interrupts are re-enabled.)
    396             */
    397            T2PEROF2 = imBits & ~OFCMPIM;
   \   00002F   74DF         MOV     A,#-0x21
   \   000031   5B           ANL     A,R3
   \   000032   FC           MOV     R4,A
   \   000033   8C9E         MOV     0x9e,R4
    398            T2PEROF2 = imBits & ~OFCMPIM;  /* writing twice is chip bug workaround */
   \   000035   8C9E         MOV     0x9e,R4
    399          
    400            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    401            T2PEROF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   000037   85..82       MOV     DPL,?XSP + 0
   \   00003A   85..83       MOV     DPH,?XSP + 1
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F59C         MOV     0x9c,A
    402            T2PEROF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   000040   7401         MOV     A,#0x1
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F59D         MOV     0x9d,A
    403          
    404            /* see declaration of this shadow variable for more information */
    405            shadowPerof2 = ((uint8 *)&count)[UINT32_NDX2];
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   90....       MOV     DPTR,#shadowPerof2
   \   000051   F0           MOVX    @DPTR,A
    406          
    407            /* write the compare value part of T2PEROF2 without re-enabling overflow compare interrupts */
    408            T2PEROF2 = (imBits & ~OFCMPIM) | shadowPerof2;
   \   000052   4C           ORL     A,R4
   \   000053   FC           MOV     R4,A
   \   000054   8C9E         MOV     0x9e,R4
    409            T2PEROF2 = (imBits & ~OFCMPIM) | shadowPerof2;  /* writing twice is chip bug workaround */
   \   000056   8C9E         MOV     0x9e,R4
    410          
    411            /*
    412             *  Now that new compare value is stored, clear the interrupt flag.  This is important just
    413             *  in case a false match was generated as the multi-byte compare value was written.
    414             */
    415            T2CNF = T2CNF_BASE_VALUE | (~OFCMPIF & T2CNF_IF_BITS);
   \   000058   75C3C3       MOV     0xc3,#-0x3d
    416          
    417            /* re-enable overflow compare interrupts if they were previously enabled */
    418            T2PEROF2 = imBits | shadowPerof2;
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   4B           ORL     A,R3
   \   00005D   FB           MOV     R3,A
   \   00005E   8B9E         MOV     0x9e,R3
    419            T2PEROF2 = imBits | shadowPerof2;  /* writing twice is chip bug workaround */
   \   000060   8B9E         MOV     0x9e,R3
    420          
    421            HAL_EXIT_CRITICAL_SECTION(s);
   \   000062   EA           MOV     A,R2
   \   000063   A2E0         MOV     C,0xE0 /* A   */.0
   \   000065   92AF         MOV     0xa8.7,C
    422          }
   \   000067   02....       LJMP    ??Subroutine4_0 & 0xFFFF
   \   00006A                REQUIRE T2PEROF0
   \   00006A                REQUIRE T2PEROF1
   \   00006A                REQUIRE T2PEROF2
   \   00006A                REQUIRE _A_IEN0
   \   00006A                REQUIRE T2CNF
    423          
    424          
    425          /**************************************************************************************************
    426           * @fn          macMcuTimer2Isr
    427           *
    428           * @brief       Interrupt service routine for timer2, the MAC timer.
    429           *
    430           * @param       none
    431           *
    432           * @return      none
    433           **************************************************************************************************
    434           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    435          HAL_ISR_FUNCTION( macMcuTimer2Isr, T2_VECTOR )
   \                     macMcuTimer2Isr:
    436          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    437            uint8 t2perof2;
    438          
    439            /* temporary variable used to suppress volatile access order warning */
    440            t2perof2 = T2PEROF2;
   \   000007   E59E         MOV     A,0x9e
   \   000009   FA           MOV     R2,A
    441          
    442            /*------------------------------------------------------------------------------------------------
    443             *  Overflow compare interrupt - triggers when then overflow counter is
    444             *  equal to the overflow compare register.
    445             */
    446            if ((T2CNF & OFCMPIF) & t2perof2)
   \   00000A   E5C3         MOV     A,0xc3
   \   00000C   5A           ANL     A,R2
   \   00000D   5420         ANL     A,#0x20
   \   00000F   6005         JZ      ??macMcuTimer2Isr_0
    447            {
    448              /* call function for dealing with the timer compare interrupt */
    449              macBackoffTimerCompareIsr();
   \   000011                ; Setup parameters for call to function macBackoffTimerCompareIsr
   \   000011   12....       LCALL   ??macBackoffTimerCompareIsr?relay
   \   000014   801E         SJMP    ??macMcuTimer2Isr_1
    450          
    451              /*
    452               *  NOTE : The interrupt flag for overflow compare is not cleared here.  This is done
    453               *         in the code that sets a new overflow compare value.
    454               */
    455            }
    456          
    457            /*------------------------------------------------------------------------------------------------
    458             *  Overflow interrupt - triggers when the hardware timer rolls over.
    459             */
    460            else if ((T2CNF & PERIF) & t2perof2)
   \                     ??macMcuTimer2Isr_0:
   \   000016   E5C3         MOV     A,0xc3
   \   000018   5A           ANL     A,R2
   \   000019   5440         ANL     A,#0x40
   \   00001B   6017         JZ      ??macMcuTimer2Isr_1
    461            {
    462              /* call energy detect interrupt function, this interrupt not used for any other functionality */
    463              mcuRecordMaxRssiIsr();
   \   00001D   90DF07       MOV     DPTR,#-0x20f9
   \   000020   E0           MOVX    A,@DPTR
   \   000021   FA           MOV     R2,A
   \   000022   90....       MOV     DPTR,#maxRssi
   \   000025   E0           MOVX    A,@DPTR
   \   000026   C3           CLR     C
   \   000027   9A           SUBB    A,R2
   \   000028   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00002A   65D0         XRL     A,PSW
   \   00002C   33           RLC     A
   \   00002D   5002         JNC     ??macMcuTimer2Isr_2
   \   00002F   EA           MOV     A,R2
   \   000030   F0           MOVX    @DPTR,A
    464          
    465              /* clear the interrupt flag by writing a zero to only that flag, write one to other flags */
    466              T2CNF = T2CNF_BASE_VALUE | (~PERIF & T2CNF_IF_BITS);
   \                     ??macMcuTimer2Isr_2:
   \   000031   75C3A3       MOV     0xc3,#-0x5d
    467            }
    468          }
   \                     ??macMcuTimer2Isr_1:
   \   000034                REQUIRE ?Subroutine6
   \   000034                REQUIRE T2PEROF2
   \   000034                REQUIRE T2CNF
   \   000034                ; // Fall through to label ?Subroutine6

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?INTERRUPT_LEAVE_XSP
    469          
    470          
    471          /**************************************************************************************************
    472           * @fn          macMcuOrT2PEROF2
    473           *
    474           * @brief       This function is used to OR the interrupt mask bits in register T2PERFOF2.
    475           *              Because of the hardware design a shadow register is required to preserve the
    476           *              other bits in this register.  See the declaration of variable shadowPerof2 above
    477           *              for a full description.
    478           *
    479           * @param       orValue - value to OR register with
    480           *
    481           * @return      none
    482           **************************************************************************************************
    483           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    484          void macMcuOrT2PEROF2(uint8 orValue)
   \                     macMcuOrT2PEROF2:
    485          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    486            halIntState_t  s;
    487          
    488            MAC_ASSERT(!(orValue & PEROF2_BITS)); /* only interrupt mask bits should be affected */
   \   000007   740F         MOV     A,#0xf
   \   000009   5E           ANL     A,R6
   \   00000A   6003         JZ      ??macMcuOrT2PEROF2_0
   \   00000C                ; Setup parameters for call to function halAssertHandler
   \   00000C   12....       LCALL   ??halAssertHandler?relay
    489          
    490            /*
    491             *  Perform OR operation only on interrupt mask bits.  The shadow register preserves
    492             *  the value previously written to the other bits in the register.
    493             */
    494            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macMcuOrT2PEROF2_0:
   \   00000F   A2AF         MOV     C,0xa8.7
   \   000011   E4           CLR     A
   \   000012   92E0         MOV     0xE0 /* A   */.0,C
   \   000014   FB           MOV     R3,A
   \   000015   C2AF         CLR     0xa8.7
    495            T2PEROF2 = ((T2PEROF2 & ~PEROF2_BITS) | orValue) | shadowPerof2;
   \   000017   90....       MOV     DPTR,#shadowPerof2
   \   00001A   74F0         MOV     A,#-0x10
   \   00001C   559E         ANL     A,0x9e
   \   00001E   4E           ORL     A,R6
   \   00001F   FA           MOV     R2,A
   \   000020   E0           MOVX    A,@DPTR
   \   000021   4A           ORL     A,R2
   \   000022   F59E         MOV     0x9e,A
    496            T2PEROF2 = ((T2PEROF2 & ~PEROF2_BITS) | orValue) | shadowPerof2;  /* writing twice is chip bug workaround */
   \   000024   74F0         MOV     A,#-0x10
   \   000026   559E         ANL     A,0x9e
   \   000028   4E           ORL     A,R6
   \   000029                REQUIRE ?Subroutine5
   \   000029                REQUIRE T2PEROF2
   \   000029                REQUIRE _A_IEN0
   \   000029                ; // Fall through to label ?Subroutine5
    497            HAL_EXIT_CRITICAL_SECTION(s);
    498          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000003   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   FA           MOV     R2,A
   \   000001   E0           MOVX    A,@DPTR
   \   000002   4A           ORL     A,R2
   \   000003   F59E         MOV     0x9e,A
   \   000005   EB           MOV     A,R3
   \   000006   A2E0         MOV     C,0xE0 /* A   */.0
   \   000008   92AF         MOV     0xa8.7,C
   \   00000A   7F01         MOV     R7,#0x1
   \   00000C   22           RET
    499          
    500          
    501          /**************************************************************************************************
    502           * @fn          macMcuAndT2PEROF2
    503           *
    504           * @brief       This function is used to AND the interrupt mask bits in register T2PERFOF2.
    505           *              Because of the hardware design a shadow register is required to preserve the
    506           *              other bits in this register.  See the declaration of variable shadowPerof2 above
    507           *              for a full description.
    508           *
    509           * @param       andValue - value to AND register with
    510           *
    511           * @return      none
    512           **************************************************************************************************
    513           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    514          void macMcuAndT2PEROF2(uint8 andValue)
   \                     macMcuAndT2PEROF2:
    515          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    516            halIntState_t  s;
    517          
    518            MAC_ASSERT((andValue & PEROF2_BITS) == PEROF2_BITS); /* only interrupt mask bits should be affected */
   \   000007   740F         MOV     A,#0xf
   \   000009   5E           ANL     A,R6
   \   00000A   640F         XRL     A,#0xf
   \   00000C   6003         JZ      ??macMcuAndT2PEROF2_0
   \   00000E                ; Setup parameters for call to function halAssertHandler
   \   00000E   12....       LCALL   ??halAssertHandler?relay
    519          
    520            /*
    521             *  Perform AND operation only on interrupt mask bits.  The shadow register preserves
    522             *  the value previously written to the other bits in the register.
    523             */
    524            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macMcuAndT2PEROF2_0:
   \   000011   A2AF         MOV     C,0xa8.7
   \   000013   E4           CLR     A
   \   000014   92E0         MOV     0xE0 /* A   */.0,C
   \   000016   FB           MOV     R3,A
   \   000017   C2AF         CLR     0xa8.7
    525            T2PEROF2 = ((T2PEROF2 & ~PEROF2_BITS) & andValue) | shadowPerof2;
   \   000019   90....       MOV     DPTR,#shadowPerof2
   \   00001C   E59E         MOV     A,0x9e
   \   00001E   5E           ANL     A,R6
   \   00001F   54F0         ANL     A,#0xf0
   \   000021   FA           MOV     R2,A
   \   000022   E0           MOVX    A,@DPTR
   \   000023   4A           ORL     A,R2
   \   000024   F59E         MOV     0x9e,A
    526            T2PEROF2 = ((T2PEROF2 & ~PEROF2_BITS) & andValue) | shadowPerof2;  /* writing twice is chip bug workaround */
   \   000026   E59E         MOV     A,0x9e
   \   000028   5E           ANL     A,R6
   \   000029   54F0         ANL     A,#0xf0
   \   00002B   80..         SJMP    ?Subroutine5
   \   00002D                REQUIRE T2PEROF2
   \   00002D                REQUIRE _A_IEN0
    527            HAL_EXIT_CRITICAL_SECTION(s);
    528          }
    529          
    530          
    531          /**************************************************************************************************
    532           * @fn          macMcuRfIsr
    533           *
    534           * @brief       Interrupt service routine that handles all RF interrupts.  There are a number
    535           *              of conditions "ganged" onto this one ISR so each condition must be tested for.
    536           *
    537           * @param       none
    538           *
    539           * @return      none
    540           **************************************************************************************************
    541           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    542          HAL_ISR_FUNCTION( macMcuRfIsr, RF_VECTOR )
   \                     macMcuRfIsr:
    543          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    544            uint8 rfim;
    545          
    546            rfim = RFIM;
   \   000007   E591         MOV     A,0x91
   \   000009   FA           MOV     R2,A
    547          
    548            if ((RFIF & IRQ_CSP_INT) & rfim)
   \   00000A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000C   C0D0         PUSH    PSW
   \   00000E   E5E9         MOV     A,0xe9
   \   000010   A2E0         MOV     C,0xE0 /* A   */.0
   \   000012   92F0         MOV     B.0,C
   \   000014   12....       LCALL   ?POP_BIT_ISP
   \   000017   1581         DEC     SP
   \   000019   82F0         ANL     C,B.0
   \   00001B   5008         JNC     ??macMcuRfIsr_0
    549            {
    550              /*
    551               *  Important!  Because of how the CSP programs are written, CSP_INT interrupts should
    552               *  be processed before CSP_STOP interrupts.  This becomes an issue when there are
    553               *  long critical sections.
    554               */
    555              /* clear flag */
    556              RFIF = ~IRQ_CSP_INT;
   \   00001D   75E9FE       MOV     0xe9,#-0x2
    557              macCspTxIntIsr();
   \   000020                ; Setup parameters for call to function macCspTxIntIsr
   \   000020   12....       LCALL   ??macCspTxIntIsr?relay
   \   000023   8037         SJMP    ??macMcuRfIsr_1
    558            }
    559            else if ((RFIF & IRQ_CSP_STOP) & rfim)
   \                     ??macMcuRfIsr_0:
   \   000025   E5E9         MOV     A,0xe9
   \   000027   5A           ANL     A,R2
   \   000028   5402         ANL     A,#0x2
   \   00002A   6008         JZ      ??macMcuRfIsr_2
    560            {
    561              /* clear flag */
    562              RFIF = ~IRQ_CSP_STOP;
   \   00002C   75E9FD       MOV     0xe9,#-0x3
    563              macCspTxStopIsr();
   \   00002F                ; Setup parameters for call to function macCspTxStopIsr
   \   00002F   12....       LCALL   ??macCspTxStopIsr?relay
   \   000032   8028         SJMP    ??macMcuRfIsr_1
    564            }
    565            else if ((RFIF & IRQ_TXDONE) & rfim)
   \                     ??macMcuRfIsr_2:
   \   000034   E5E9         MOV     A,0xe9
   \   000036   5A           ANL     A,R2
   \   000037   5440         ANL     A,#0x40
   \   000039   600C         JZ      ??macMcuRfIsr_3
    566            {
    567              /* disable interrupt - set up is for "one shot" operation */
    568              HAL_DISABLE_INTERRUPTS();
   \   00003B   C2AF         CLR     0xa8.7
    569              RFIM &= ~IM_TXDONE;
   \   00003D   5391BF       ANL     0x91,#0xbf
    570              HAL_ENABLE_INTERRUPTS();
   \   000040   D2AF         SETB    0xa8.7
    571              macRxAckTxDoneCallback();
   \   000042                ; Setup parameters for call to function macRxAckTxDoneCallback
   \   000042   12....       LCALL   ??macRxAckTxDoneCallback?relay
   \   000045   8015         SJMP    ??macMcuRfIsr_1
    572            }
    573            else if ((RFIF & IRQ_FIFOP) & rfim)
   \                     ??macMcuRfIsr_3:
   \   000047   E5E9         MOV     A,0xe9
   \   000049   5A           ANL     A,R2
   \   00004A   5420         ANL     A,#0x20
   \   00004C   600E         JZ      ??macMcuRfIsr_1
    574            {
    575              /* continue to execute interrupt handler as long as FIFOP is active */
    576              do
    577              {
    578                macRxThresholdIsr();
   \                     ??macMcuRfIsr_4:
   \   00004E                ; Setup parameters for call to function macRxThresholdIsr
   \   00004E   12....       LCALL   ??macRxThresholdIsr?relay
    579                RFIF = ~IRQ_FIFOP;
   \   000051   75E9DF       MOV     0xe9,#-0x21
    580              } while (RFSTATUS & FIFOP);
   \   000054   90DF62       MOV     DPTR,#-0x209e
   \   000057   E0           MOVX    A,@DPTR
   \   000058   A2E2         MOV     C,0xE0 /* A   */.2
   \   00005A   40F2         JC      ??macMcuRfIsr_4
    581            }
    582          
    583            S1CON = 0x00;
   \                     ??macMcuRfIsr_1:
   \   00005C   759B00       MOV     0x9b,#0x0
    584            RFIF = 0xFF;
   \   00005F   75E9FF       MOV     0xe9,#-0x1
    585          }
   \   000062   80..         SJMP    ?Subroutine6
   \   000064                REQUIRE RFIM
   \   000064                REQUIRE S1CON
   \   000064                REQUIRE _A_IEN0
   \   000064                REQUIRE RFIF
    586          
    587          
    588          /**************************************************************************************************
    589           * @fn          macMcuRecordMaxRssiStart
    590           *
    591           * @brief       Starts recording of the maximum received RSSI value.
    592           *
    593           * @param       none
    594           *
    595           * @return      none
    596           **************************************************************************************************
    597           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    598          void macMcuRecordMaxRssiStart(void)
   \                     macMcuRecordMaxRssiStart:
    599          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    600            /* start maximum recorded value at the lowest possible value */
    601            maxRssi = -128;
   \   000004   7480         MOV     A,#-0x80
   \   000006   90....       MOV     DPTR,#maxRssi
   \   000009   F0           MOVX    @DPTR,A
    602          
    603            /* enable timer overflow interrupt */
    604            macMcuOrT2PEROF2(PERIM);
   \   00000A                ; Setup parameters for call to function macMcuOrT2PEROF2
   \   00000A   7940         MOV     R1,#0x40
   \   00000C   12....       LCALL   ??macMcuOrT2PEROF2?relay
    605          }
   \   00000F                REQUIRE ?Subroutine3
   \   00000F                ; // Fall through to label ?Subroutine3
    606          
    607          
    608          /**************************************************************************************************
    609           * @fn          macMcuRecordMaxRssiStop
    610           *
    611           * @brief       Stops recording of the maximum received RSSI.  It returns the maximum value
    612           *              received since starting the recording.
    613           *
    614           * @param       none
    615           *
    616           * @return      maximum received RSSI value
    617           **************************************************************************************************
    618           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    619          int8 macMcuRecordMaxRssiStop(void)
   \                     macMcuRecordMaxRssiStop:
    620          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    621            /* disable timer overflow interrupt */
    622            macMcuAndT2PEROF2(~PERIM);
   \   000004                ; Setup parameters for call to function macMcuAndT2PEROF2
   \   000004   79BF         MOV     R1,#-0x41
   \   000006   12....       LCALL   ??macMcuAndT2PEROF2?relay
    623          
    624            return(maxRssi);
   \   000009   90....       MOV     DPTR,#maxRssi
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   80..         SJMP    ?Subroutine3
    625          }

   \                                 In  segment INTVEC, offset 0x53, root
   \                     `??macMcuTimer2Isr??INTVEC 83`:
   \   000053   02....       LJMP       (macMcuTimer2Isr)

   \                                 In  segment INTVEC, offset 0x83, root
   \                     `??macMcuRfIsr??INTVEC 131`:
   \   000083   02....       LJMP       (macMcuRfIsr)

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuRandomByte?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRandomByte

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuTimerCount?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimerCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuTimerCapture?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimerCapture

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowCount?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowCapture?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowCapture

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowSetCount?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowSetCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowSetCompare?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowSetCompare

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOrT2PEROF2?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOrT2PEROF2

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuAndT2PEROF2?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuAndT2PEROF2

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuRecordMaxRssiStart?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRecordMaxRssiStart

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuRecordMaxRssiStop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRecordMaxRssiStop
    626          
    627          
    628          /*=================================================================================================
    629           * @fn          macMcuRecordMaxRssiIsr
    630           *
    631           * @brief       Interrupt service routine called during recording of max RSSI value.
    632           *
    633           * @param       none
    634           *
    635           * @return      none
    636           *=================================================================================================
    637           */
    638          static void mcuRecordMaxRssiIsr(void)
    639          {
    640            int8 rssi;
    641          
    642            /* read latest RSSI value */
    643            rssi = RSSIL;
    644          
    645            /* if new RSSI value is greater than the maximum already received, it is the new maximum */
    646            if (rssi > maxRssi)
    647            {
    648              maxRssi = rssi;
    649            }
    650          }
    651          
    652          
    653          
    654          /**************************************************************************************************
    655           *                                  Compile Time Integrity Checks
    656           **************************************************************************************************
    657           */
    658          #if ((IRQ_SFD != IM_SFD) || (IRQ_FIFOP != IM_FIFOP) || (IRQ_TXDONE != IM_TXDONE))
    659          #error "ERROR: Compile time error with RFIF vs RFIM register defines."
    660          #endif
    661          
    662          #if ((OFCMPIF != OFCMPIM) || (PERIF != PERIM) || (CMPIF != CMPIM))
    663          #error "ERROR: Compile time error with T2CNF vs T2PEROF2 register defines."
    664          #endif
    665          
    666          
    667          /**************************************************************************************************
    668          */

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     macMcuAndT2PEROF2                  0      0      9
       -> halAssertHandler              0      0     18
     macMcuInit                         2      0      0
       -> halAssertHandler              4      0      0
       -> macRxOn                       4      0      0
       -> macRxOff                      4      0      0
     macMcuOrT2PEROF2                   0      0      9
       -> halAssertHandler              0      0     18
     macMcuOverflowCapture              1      0     16
     macMcuOverflowCount                1      0     16
     macMcuOverflowSetCompare           0      0     16
       -> halAssertHandler              0      0     32
     macMcuOverflowSetCount             0      0     16
       -> halAssertHandler              0      0     32
     macMcuRandomByte                   0      0      0
     macMcuRecordMaxRssiStart           2      0      0
       -> macMcuOrT2PEROF2              4      0      0
     macMcuRecordMaxRssiStop            2      0      0
       -> macMcuAndT2PEROF2             4      0      0
     macMcuRfIsr                       16      0      0
       -> macCspTxIntIsr               30      0      0
       -> macCspTxStopIsr              30      0      0
       -> macRxAckTxDoneCallback       30      0      0
       -> macRxThresholdIsr            30      0      0
     macMcuTimer2Isr                   15      0      0
       -> macBackoffTimerCompareIsr    30      0      0
     macMcuTimerCapture                 2      0      0
     macMcuTimerCount                   3      0      1


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     RFIM                              1
     IEN2                              1
     S1CON                             1
     T2PEROF0                          1
     T2PEROF1                          1
     T2PEROF2                          1
     T2OF0                             1
     T2OF1                             1
     T2OF2                             1
     T2CAPLPL                          1
     T2CAPHPH                          1
     T2TLD                             1
     T2THD                             1
     _A_IEN0                           1
     IP0                               1
     ADCCON1                           1
     _A_IEN1                           1
     IP1                               1
     RNDL                              1
     RNDH                              1
     T2CNF                             1
     RFIF                              1
     maxRssi                           1
     shadowPerof2                      1
     macMcuInit                      158
     ?Subroutine3                      7
     macMcuRandomByte                 13
     macMcuTimerCount                 28
     macMcuTimerCapture                8
     macMcuOverflowCount              35
     ?Subroutine4                     40
     ?Subroutine0                     26
     macMcuOverflowCapture            37
     macMcuOverflowSetCount           61
     ?Subroutine2                     12
     macMcuOverflowSetCompare        106
     macMcuTimer2Isr                  52
     ?Subroutine6                      5
     macMcuOrT2PEROF2                 41
     ?Subroutine5                      6
     ?Subroutine1                     13
     macMcuAndT2PEROF2                45
     macMcuRfIsr                     100
     macMcuRecordMaxRssiStart         15
     macMcuRecordMaxRssiStop          16
     ??macMcuTimer2Isr??INTVEC 83      3
     ??macMcuRfIsr??INTVEC 131         3
     ??macMcuInit?relay                6
     ??macMcuRandomByte?relay          6
     ??macMcuTimerCount?relay          6
     ??macMcuTimerCapture?relay        6
     ??macMcuOverflowCount?relay       6
     ??macMcuOverflowCapture?relay     6
     ??macMcuOverflowSetCount?relay    6
     ??macMcuOverflowSetCompare?relay
                                       6
     ??macMcuOrT2PEROF2?relay          6
     ??macMcuAndT2PEROF2?relay         6
     ??macMcuRecordMaxRssiStart?relay
                                       6
     ??macMcuRecordMaxRssiStop?relay
                                       6

 
 667 bytes in segment BANKED_CODE
  72 bytes in segment BANK_RELAYS
   6 bytes in segment INTVEC
 157 bytes in segment NEAR_CODE
  22 bytes in segment SFR_AN
   2 bytes in segment XDATA_Z
 
 896 bytes of CODE  memory (+  6 bytes shared)
   0 bytes of DATA  memory (+ 22 bytes shared)
   2 bytes of XDATA memory

Errors: none
Warnings: none

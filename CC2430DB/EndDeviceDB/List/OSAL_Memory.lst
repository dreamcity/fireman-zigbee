###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    20/Dec/2012  21:40:59 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \osal\common\OSAL_Memory.c                         #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\..\..\..\Tools\C #
#                          C2430DB\f8wEndev.cfg" (-DCPU32MHZ                  #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_OPT_FFD=0 -DBLINK_LEDS "-DCONST=const        #
#                          __code" -DGENERIC=__generic) -f "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wCo #
#                          nfig.cfg" (-DSECURE=0 -DDEFAULT_CHANLIST=0x0000080 #
#                          0 -DZDAPP_CONFIG_PAN_ID=0xFFFF                     #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\osal\com #
#                          mon\OSAL_Memory.c" -D CC2430DB -D NWK_AUTO_POLL    #
#                          -D REFLECTOR -D xZTOOL_P2 -D xMT_TASK -D           #
#                          xMT_ZDO_FUNC -D xLCD_SUPPORTED=DEBUG -D            #
#                          xPOWER_SAVING -lC "C:\Texas                        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\EndDeviceDB\List\" -lA        #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\EndDeviceDB\List\"  #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550    #
#                          -o "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\EndDeviceDB\Obj\ #
#                          " -e --require_prototypes -z9 --no_code_motion     #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\SOURCE\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\Drivers\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\ZMAIN\TI2430DB\" -I  #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MT\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\HAL #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\TARGET\CC2430DB\" -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\OSA #
#                          L\INCLUDE\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\AF\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2. #
#                          1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\.. #
#                          \..\..\COMPONENTS\STACK\NWK\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\SEC\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\STACK\SYS\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\ZDO\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\ZMAC\F8W\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\ZMA #
#                          C\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Pr #
#                          ojects\zstack\Samples\AXDApp\CC2430DB\..\..\..\..\ #
#                          ..\COMPONENTS\SERVICES\SADDR\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\SER #
#                          VICES\SDATA\" -I "C:\Texas                         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\HIGH_LEVEL\" -I           #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \LOW_LEVEL\SRF03\SINGLE_CHIP\" -I "C:\Program      #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\" -I "C:\Program       #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\EndDeviceDB\List\OSA #
#                          L_Memory.lst                                       #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\EndDeviceDB\Obj\OSAL #
#                          _Memory.r51                                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\osal\common\OSAL_Memory.c
      1          /**************************************************************************************************
      2            Filename:       OSAL_Memory.c
      3            Revised:        $Date: 2007-10-28 18:43:04 -0700 (Sun, 28 Oct 2007) $
      4            Revision:       $Revision: 15800 $
      5          
      6            Description:    OSAL Heap Memory management functions.
      7          
      8          
      9            Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "ZComDef.h"
     45          #include "OSAL_Memory.h"
     46          #include "OnBoard.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     47          #include "hal_assert.h"
     48          
     49          #if ( MAXMEMHEAP >= 32768 )
     50            #error MAXMEMHEAP is too big to manage!
     51          #endif
     52          
     53          // Minimum wasted bytes to justify splitting a block before allocation.
     54          #if !defined ( OSALMEM_MIN_BLKSZ )
     55            #define OSALMEM_MIN_BLKSZ    4
     56          #endif
     57          
     58          /* Profiling memory allocations showed that a significant % of very high
     59           * frequency allocations/frees are for block sizes less than or equal to 16.
     60           */
     61          #if !defined ( OSALMEM_SMALL_BLKSZ )
     62            #define OSALMEM_SMALL_BLKSZ  16
     63          #endif
     64          
     65          #if !defined ( OSALMEM_NODEBUG )
     66            #define OSALMEM_NODEBUG      TRUE
     67          #endif
     68          
     69          #if !defined ( OSALMEM_PROFILER )
     70            #define OSALMEM_PROFILER     FALSE
     71          #endif
     72          
     73          #if !defined ( OSALMEM_GUARD )
     74            #define OSALMEM_GUARD  TRUE  // TBD - Hacky workaround til Bugzilla 1252 is fixed!
     75            #define OSALMEM_READY  0xE2
     76          #endif
     77          
     78          #if ( OSALMEM_PROFILER )
     79            #define OSALMEM_INIT   'X'
     80            #define OSALMEM_ALOC   'A'
     81            #define OSALMEM_REIN   'F'
     82          #endif
     83          
     84          /*********************************************************************
     85           * MACROS
     86           */
     87          
     88          /*
     89           *  The MAC_ASSERT macro is for use during debugging.
     90           *  The given expression must evaluate as "true" or else fatal error occurs.
     91           *  At that point, the call stack feature of the debugger can pinpoint where
     92           *  the problem occurred.
     93           *
     94           *  To disable this feature and save code size, the project should define
     95           *  OSALMEM_NODEBUG to TRUE.
     96           */
     97          #if ( OSALMEM_NODEBUG )
     98            #define OSALMEM_ASSERT( expr )
     99            #define OSALMEM_DEBUG( statement )
    100          #else
    101            #define OSALMEM_ASSERT( expr)        HAL_ASSERT( expr )
    102            #define OSALMEM_DEBUG( statement)    st( statement )
    103          #endif
    104          
    105          /*********************************************************************
    106           * TYPEDEFS
    107           */
    108          
    109          typedef uint16  osalMemHdr_t;
    110          
    111          /*********************************************************************
    112           * CONSTANTS
    113           */
    114          
    115          #define OSALMEM_IN_USE  0x8000
    116          
    117          /* This number sets the size of the small-block bucket. Although profiling
    118           * shows max simultaneous alloc of 16x18, timing without profiling overhead
    119           * shows that the best worst case is achieved with the following.
    120           */
    121          #define SMALLBLKHEAP    232
    122          
    123          // To maintain data alignment of the pointer returned, reserve the greater
    124          // space for the memory block header.
    125          #define HDRSZ  ( (sizeof ( halDataAlign_t ) > sizeof( osalMemHdr_t )) ? \
    126                            sizeof ( halDataAlign_t ) : sizeof( osalMemHdr_t ) )
    127          
    128          /*********************************************************************
    129           * GLOBAL VARIABLES
    130           */
    131          
    132          /*********************************************************************
    133           * EXTERNAL VARIABLES
    134           */
    135          
    136          /*********************************************************************
    137           * EXTERNAL FUNCTIONS
    138           */
    139          
    140          /*********************************************************************
    141           * LOCAL VARIABLES
    142           */
    143          
    144          #if ( OSALMEM_GUARD )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    145            static byte ready = 0;
   \                     ready:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    146          #endif
    147          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    148          static osalMemHdr_t *ff1;  // First free block in the small-block bucket.
   \                     ff1:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    149          static osalMemHdr_t *ff2;  // First free block after the small-block bucket.
   \                     ff2:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    150          
    151          #if ( OSALMEM_METRICS )
    152            static uint16 blkMax;  // Max cnt of all blocks ever seen at once.
    153            static uint16 blkCnt;  // Current cnt of all blocks.
    154            static uint16 blkFree; // Current cnt of free blocks.
    155            static uint16 memAlo;  // Current total memory allocated.
    156            static uint16 memMax;  // Max total memory ever allocated at once.
    157          #endif
    158          
    159          #if ( OSALMEM_PROFILER )
    160            #define OSALMEM_PROMAX  8
    161            /* The profiling buckets must differ by at least OSALMEM_MIN_BLKSZ; the
    162             * last bucket must equal the max alloc size. Set the bucket sizes to
    163             * whatever sizes necessary to show how your application is using memory.
    164             */
    165            static uint16 proCnt[OSALMEM_PROMAX] = { 
    166              OSALMEM_SMALL_BLKSZ, 48, 112, 176, 192, 224, 256, 65535 };
    167            static uint16 proCur[OSALMEM_PROMAX] = { 0 };
    168            static uint16 proMax[OSALMEM_PROMAX] = { 0 };
    169            static uint16 proTot[OSALMEM_PROMAX] = { 0 };
    170            static uint16 proSmallBlkMiss;
    171          #endif
    172          
    173          // Memory Allocation Heap.
    174          #if defined( EXTERNAL_RAM )
    175            static byte *theHeap = (byte *)EXT_RAM_BEG;
    176          #else

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    177            static halDataAlign_t _theHeap[ MAXMEMHEAP / sizeof( halDataAlign_t ) ];
   \                     _theHeap:
   \   000000                DS 1664
   \   000680                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    178            static byte *theHeap = (byte *)_theHeap;
   \                     theHeap:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for theHeap>`
   \   000002                REQUIRE __INIT_XDATA_I
    179          #endif
    180          
    181          /*********************************************************************
    182           * LOCAL FUNCTIONS
    183           */
    184          
    185          /*********************************************************************
    186           * @fn      osal_mem_init
    187           *
    188           * @brief   Initialize the heap memory management system.
    189           *
    190           * @param   void
    191           *
    192           * @return  void
    193           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    194          void osal_mem_init( void )
   \                     osal_mem_init:
    195          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    196            osalMemHdr_t *tmp;
    197          
    198          #if ( OSALMEM_PROFILER )
    199            osal_memset( theHeap, OSALMEM_INIT, MAXMEMHEAP );
    200          #endif
    201          
    202            // Setup a NULL block at the end of the heap for fast comparisons with zero.
    203            tmp = (osalMemHdr_t *)theHeap + (MAXMEMHEAP / HDRSZ) - 1;
    204            *tmp = 0;
   \   000004   90....       MOV     DPTR,#theHeap
   \   000007   E0           MOVX    A,@DPTR
   \   000008   247E         ADD     A,#0x7e
   \   00000A   F8           MOV     R0,A
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   3406         ADDC    A,#0x6
   \   00000F   F9           MOV     R1,A
   \   000010   8882         MOV     DPL,R0
   \   000012   8983         MOV     DPH,R1
   \   000014   E4           CLR     A
   \   000015   F0           MOVX    @DPTR,A
   \   000016   A3           INC     DPTR
   \   000017   F0           MOVX    @DPTR,A
    205          
    206            // Setup a small-block bucket.
    207            tmp = (osalMemHdr_t *)theHeap;
    208            *tmp = SMALLBLKHEAP;
   \   000018   90....       MOV     DPTR,#theHeap
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F8           MOV     R0,A
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F583         MOV     DPH,A
   \   000021   8882         MOV     DPL,R0
   \   000023   74E8         MOV     A,#-0x18
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   E4           CLR     A
   \   000028   F0           MOVX    @DPTR,A
    209          
    210            // Setup the wilderness.
    211            tmp = (osalMemHdr_t *)theHeap + (SMALLBLKHEAP / HDRSZ);
   \   000029   90....       MOV     DPTR,#theHeap
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   24E8         ADD     A,#-0x18
   \   00002F   F8           MOV     R0,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   3400         ADDC    A,#0x0
   \   000034   F9           MOV     R1,A
    212            *tmp = ((MAXMEMHEAP / HDRSZ) * HDRSZ) - SMALLBLKHEAP - HDRSZ;
   \   000035   8882         MOV     DPL,R0
   \   000037   8983         MOV     DPH,R1
   \   000039   7496         MOV     A,#-0x6a
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   7405         MOV     A,#0x5
   \   00003F   F0           MOVX    @DPTR,A
    213          
    214          #if ( OSALMEM_GUARD )
    215            ready = OSALMEM_READY;
   \   000040   74E2         MOV     A,#-0x1e
   \   000042   90....       MOV     DPTR,#ready
   \   000045   F0           MOVX    @DPTR,A
    216          #endif
    217          
    218            // Setup a NULL block that is never freed so that the small-block bucket
    219            // is never coalesced with the wilderness.
    220            ff1 = tmp;
   \   000046   90....       MOV     DPTR,#ff1
   \   000049   E8           MOV     A,R0
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   E9           MOV     A,R1
   \   00004D   F0           MOVX    @DPTR,A
    221            ff2 = osal_mem_alloc( 0 );
   \   00004E                ; Setup parameters for call to function osal_mem_alloc
   \   00004E   7A00         MOV     R2,#0x0
   \   000050   7B00         MOV     R3,#0x0
   \   000052   12....       LCALL   ??osal_mem_alloc?relay
   \   000055   90....       MOV     DPTR,#ff2
   \   000058   EA           MOV     A,R2
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   A3           INC     DPTR
   \   00005B   EB           MOV     A,R3
   \   00005C   F0           MOVX    @DPTR,A
    222            ff1 = (osalMemHdr_t *)theHeap;
   \   00005D   90....       MOV     DPTR,#theHeap
   \   000060   12....       LCALL   ?Subroutine0 & 0xFFFF
    223          
    224          #if ( OSALMEM_METRICS )
    225            /* Start with the small-block bucket and the wilderness - don't count the
    226             * end-of-heap NULL block nor the end-of-small-block NULL block.
    227             */
    228            blkCnt = blkFree = 2;
    229          #endif
    230          }
   \                     ??CrossCallReturnLabel_0:
   \   000063                REQUIRE ?Subroutine2
   \   000063                ; // Fall through to label ?Subroutine2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ??Subroutine1_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000003   90....       MOV     DPTR,#ff1
   \   000006   E8           MOV     A,R0
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   E9           MOV     A,R1
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   FB           MOV     R3,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \                     ??Subroutine1_0:
   \   000005   E0           MOVX    A,@DPTR
   \   000006   F8           MOV     R0,A
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F9           MOV     R1,A
   \   00000A   22           RET
    231          
    232          /*********************************************************************
    233           * @fn      osal_mem_kick
    234           *
    235           * @brief   Kick the ff1 pointer out past the long-lived OSAL Task blocks.
    236           *          Invoke this once after all long-lived blocks have been allocated -
    237           *          presently at the end of osal_init_system().
    238           *
    239           * @param   void
    240           *
    241           * @return  void
    242           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    243          void osal_mem_kick( void )
   \                     osal_mem_kick:
    244          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    245            halIntState_t intState;
    246          
    247            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000004   A2AF         MOV     C,0xa8.7
   \   000006   E4           CLR     A
   \   000007   92E0         MOV     0xE0 /* A   */.0,C
   \   000009   FA           MOV     R2,A
   \   00000A   C2AF         CLR     0xa8.7
    248          
    249            /* Logic in osal_mem_free() will ratchet ff1 back down to the first free
    250             * block in the small-block bucket.
    251             */
    252            ff1 = ff2;
   \   00000C   90....       MOV     DPTR,#ff2
   \   00000F   12....       LCALL   ?Subroutine0 & 0xFFFF
    253          
    254            HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
   \                     ??CrossCallReturnLabel_1:
   \   000012   EA           MOV     A,R2
   \   000013   A2E0         MOV     C,0xE0 /* A   */.0
   \   000015   92AF         MOV     0xa8.7,C
    255          }
   \   000017   80..         SJMP    ?Subroutine2
   \   000019                REQUIRE _A_IEN0
    256          
    257          /*********************************************************************
    258           * @fn      osal_mem_alloc
    259           *
    260           * @brief   Implementation of the allocator functionality.
    261           *
    262           * @param   size - number of bytes to allocate from the heap.
    263           *
    264           * @return  void * - pointer to the heap allocation; NULL if error or failure.
    265           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    266          void *osal_mem_alloc( uint16 size )
   \                     osal_mem_alloc:
    267          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
    268            osalMemHdr_t *prev;
    269            osalMemHdr_t *hdr;
    270            halIntState_t intState;
    271            uint16 tmp;
    272            byte coal = 0;
   \   000009   75..00       MOV     ?V0 + 2,#0x0
    273          
    274          #if ( OSALMEM_GUARD )
    275            // Try to protect against premature use by HAL / OSAL.
    276            if ( ready != OSALMEM_READY )
   \   00000C   90....       MOV     DPTR,#ready
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   64E2         XRL     A,#0xe2
   \   000012   6003         JZ      ??osal_mem_alloc_0
    277            {
    278              osal_mem_init();
   \   000014                ; Setup parameters for call to function osal_mem_init
   \   000014   12....       LCALL   ??osal_mem_init?relay
    279            }
    280          #endif
    281          
    282            OSALMEM_ASSERT( size );
    283          
    284            size += HDRSZ;
   \                     ??osal_mem_alloc_0:
   \   000017   E5..         MOV     A,?V0 + 0
   \   000019   2402         ADD     A,#0x2
   \   00001B   F5..         MOV     ?V0 + 0,A
   \   00001D   E5..         MOV     A,?V0 + 1
   \   00001F   3400         ADDC    A,#0x0
   \   000021   F5..         MOV     ?V0 + 1,A
    285          
    286            // Calculate required bytes to add to 'size' to align to halDataAlign_t.
    287            if ( sizeof( halDataAlign_t ) == 2 )
    288            {
    289              size += (size & 0x01);
    290            }
    291            else if ( sizeof( halDataAlign_t ) != 1 )
    292            {
    293              const byte mod = size % sizeof( halDataAlign_t );
    294          
    295              if ( mod != 0 )
    296              {
    297                size += (sizeof( halDataAlign_t ) - mod);
    298              }
    299            }
    300          
    301            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000023   A2AF         MOV     C,0xa8.7
   \   000025   E4           CLR     A
   \   000026   92E0         MOV     0xE0 /* A   */.0,C
   \   000028   FC           MOV     R4,A
   \   000029   C2AF         CLR     0xa8.7
    302          
    303            // Smaller allocations are first attempted in the small-block bucket.
    304            if ( size <= OSALMEM_SMALL_BLKSZ )
   \   00002B   C3           CLR     C
   \   00002C   E5..         MOV     A,?V0 + 0
   \   00002E   9411         SUBB    A,#0x11
   \   000030   E5..         MOV     A,?V0 + 1
   \   000032   9400         SUBB    A,#0x0
   \   000034   5005         JNC     ??osal_mem_alloc_1
    305            {
    306              hdr = ff1;
   \   000036   90....       MOV     DPTR,#ff1
   \   000039   8003         SJMP    ??osal_mem_alloc_2
    307            }
    308            else
    309            {
    310              hdr = ff2;
   \                     ??osal_mem_alloc_1:
   \   00003B   90....       MOV     DPTR,#ff2
   \                     ??osal_mem_alloc_2:
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   FA           MOV     R2,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   12....       LCALL   ?Subroutine1 & 0xFFFF
    311            }
    312            tmp = *hdr;
    313          
    314            do
    315            {
    316              if ( tmp & OSALMEM_IN_USE )
   \                     ??CrossCallReturnLabel_2:
   \   000045   7480         MOV     A,#-0x80
   \   000047   59           ANL     A,R1
   \   000048   F5..         MOV     ?V0 + 5,A
   \   00004A   E4           CLR     A
   \   00004B   7002         JNZ     ??osal_mem_alloc_3
   \   00004D   E5..         MOV     A,?V0 + 5
   \                     ??osal_mem_alloc_3:
   \   00004F   6009         JZ      ??osal_mem_alloc_4
    317              {
    318                tmp ^= OSALMEM_IN_USE;
   \   000051   7480         MOV     A,#-0x80
   \   000053   69           XRL     A,R1
   \   000054   F9           MOV     R1,A
    319                coal = 0;
   \   000055   75..00       MOV     ?V0 + 2,#0x0
   \   000058   8077         SJMP    ??osal_mem_alloc_5
    320              }
    321              else
    322              {
    323                if ( coal != 0 )
   \                     ??osal_mem_alloc_4:
   \   00005A   E5..         MOV     A,?V0 + 2
   \   00005C   6063         JZ      ??osal_mem_alloc_6
    324                {
    325          #if ( OSALMEM_METRICS )
    326                  blkCnt--;
    327                  blkFree--;
    328          #endif
    329          
    330                  *prev += *hdr;
   \   00005E   8A82         MOV     DPL,R2
   \   000060   8B83         MOV     DPH,R3
   \   000062   E0           MOVX    A,@DPTR
   \   000063   F5..         MOV     ?V0 + 4,A
   \   000065   A3           INC     DPTR
   \   000066   E0           MOVX    A,@DPTR
   \   000067   F5..         MOV     ?V0 + 5,A
   \   000069   8E82         MOV     DPL,R6
   \   00006B   8F83         MOV     DPH,R7
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   25..         ADD     A,?V0 + 4
   \   000070   F0           MOVX    @DPTR,A
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   35..         ADDC    A,?V0 + 5
   \   000075   F0           MOVX    @DPTR,A
    331          
    332                  if ( *prev >= size )
   \   000076   8E82         MOV     DPL,R6
   \   000078   8F83         MOV     DPH,R7
   \   00007A   C3           CLR     C
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   95..         SUBB    A,?V0 + 0
   \   00007E   A3           INC     DPTR
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   95..         SUBB    A,?V0 + 1
   \   000082   404D         JC      ??osal_mem_alloc_5
    333                  {
    334                    hdr = prev;
   \   000084   EE           MOV     A,R6
   \   000085   FA           MOV     R2,A
   \   000086   EF           MOV     A,R7
   \   000087   12....       LCALL   ?Subroutine1 & 0xFFFF
    335                    tmp = *hdr;
    336                    break;
    337                  }
    338                }
    339                else
    340                {
    341                  if ( tmp >= size )
    342                  {
    343                    break;
    344                  }
    345          
    346                  coal = 1;
    347                  prev = hdr;
    348                }
    349              }
    350          
    351              hdr = (osalMemHdr_t *)((byte *)hdr + tmp);
    352          
    353              tmp = *hdr;
    354              if ( tmp == 0 )
    355              {
    356                hdr = NULL;
    357                break;
    358              }
    359          
    360          
    361            } while ( 1 );
    362          
    363            if ( hdr != NULL )
   \                     ??CrossCallReturnLabel_3:
   \   00008A   EA           MOV     A,R2
   \   00008B   7001         JNZ     ??osal_mem_alloc_7
   \   00008D   EB           MOV     A,R3
   \                     ??osal_mem_alloc_7:
   \   00008E   606C         JZ      ??osal_mem_alloc_8
    364            {
    365              tmp -= size;
   \   000090   C3           CLR     C
   \   000091   E8           MOV     A,R0
   \   000092   95..         SUBB    A,?V0 + 0
   \   000094   F8           MOV     R0,A
   \   000095   E9           MOV     A,R1
   \   000096   95..         SUBB    A,?V0 + 1
   \   000098   F9           MOV     R1,A
    366          
    367              // Determine whether the threshold for splitting is met.
    368              if ( tmp >= OSALMEM_MIN_BLKSZ )
   \   000099   C3           CLR     C
   \   00009A   E8           MOV     A,R0
   \   00009B   9404         SUBB    A,#0x4
   \   00009D   E9           MOV     A,R1
   \   00009E   9400         SUBB    A,#0x0
   \   0000A0   4046         JC      ??osal_mem_alloc_9
    369              {
    370                // Split the block before allocating it.
    371                osalMemHdr_t *next = (osalMemHdr_t *)((byte *)hdr + size);
    372                *next = tmp;
   \   0000A2   EA           MOV     A,R2
   \   0000A3   25..         ADD     A,?V0 + 0
   \   0000A5   F582         MOV     DPL,A
   \   0000A7   EB           MOV     A,R3
   \   0000A8   35..         ADDC    A,?V0 + 1
   \   0000AA   F583         MOV     DPH,A
   \   0000AC   E8           MOV     A,R0
   \   0000AD   F0           MOVX    @DPTR,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   E9           MOV     A,R1
   \   0000B0   F0           MOVX    @DPTR,A
    373                *hdr = (size | OSALMEM_IN_USE);
   \   0000B1   7480         MOV     A,#-0x80
   \   0000B3   45..         ORL     A,?V0 + 1
   \   0000B5   F9           MOV     R1,A
   \   0000B6   8A82         MOV     DPL,R2
   \   0000B8   8B83         MOV     DPH,R3
   \   0000BA   E5..         MOV     A,?V0 + 0
   \   0000BC   F0           MOVX    @DPTR,A
   \   0000BD   A3           INC     DPTR
   \   0000BE   E9           MOV     A,R1
   \   0000BF   8031         SJMP    ??osal_mem_alloc_10
    374          
    375          #if ( OSALMEM_METRICS )
    376                blkCnt++;
    377                if ( blkMax < blkCnt )
    378                {
    379                  blkMax = blkCnt;
    380                }
    381                memAlo += size;
    382          #endif
    383              }
   \                     ??osal_mem_alloc_6:
   \   0000C1   C3           CLR     C
   \   0000C2   E8           MOV     A,R0
   \   0000C3   95..         SUBB    A,?V0 + 0
   \   0000C5   E9           MOV     A,R1
   \   0000C6   95..         SUBB    A,?V0 + 1
   \   0000C8   50C0         JNC     ??CrossCallReturnLabel_3
   \   0000CA   75..01       MOV     ?V0 + 2,#0x1
   \   0000CD   EA           MOV     A,R2
   \   0000CE   FE           MOV     R6,A
   \   0000CF   EB           MOV     A,R3
   \   0000D0   FF           MOV     R7,A
   \                     ??osal_mem_alloc_5:
   \   0000D1   EA           MOV     A,R2
   \   0000D2   28           ADD     A,R0
   \   0000D3   FA           MOV     R2,A
   \   0000D4   EB           MOV     A,R3
   \   0000D5   39           ADDC    A,R1
   \   0000D6   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0000D9   E8           MOV     A,R0
   \   0000DA   7001         JNZ     ??osal_mem_alloc_11
   \   0000DC   E9           MOV     A,R1
   \                     ??osal_mem_alloc_11:
   \   0000DD   6003         JZ      $+5
   \   0000DF   02....       LJMP    ??CrossCallReturnLabel_2 & 0xFFFF
   \   0000E2   7A00         MOV     R2,#0x0
   \   0000E4   7B00         MOV     R3,#0x0
   \   0000E6   8014         SJMP    ??osal_mem_alloc_8
    384              else
    385              {
    386          #if ( OSALMEM_METRICS )
    387                memAlo += *hdr;
    388                blkFree--;
    389          #endif
    390          
    391                *hdr |= OSALMEM_IN_USE;
   \                     ??osal_mem_alloc_9:
   \   0000E8   8A82         MOV     DPL,R2
   \   0000EA   8B83         MOV     DPH,R3
   \   0000EC   E0           MOVX    A,@DPTR
   \   0000ED   F0           MOVX    @DPTR,A
   \   0000EE   A3           INC     DPTR
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   4480         ORL     A,#0x80
   \                     ??osal_mem_alloc_10:
   \   0000F2   F0           MOVX    @DPTR,A
    392              }
    393          
    394          #if ( OSALMEM_METRICS )
    395              if ( memMax < memAlo )
    396              {
    397                memMax = memAlo;
    398              }
    399          #endif
    400          
    401          #if ( OSALMEM_PROFILER )
    402            {
    403              byte idx;
    404              size = *hdr ^ OSALMEM_IN_USE;
    405          
    406              for ( idx = 0; idx < OSALMEM_PROMAX; idx++ )
    407              {
    408                if ( size <= proCnt[idx] )
    409                {
    410                  break;
    411                }
    412              }
    413              proCur[idx]++;
    414              if ( proMax[idx] < proCur[idx] )
    415              {
    416                proMax[idx] = proCur[idx];
    417              }
    418              proTot[idx]++;
    419            }
    420          #endif
    421          
    422              hdr++;
   \   0000F3   EA           MOV     A,R2
   \   0000F4   2402         ADD     A,#0x2
   \   0000F6   0A           INC     R2
   \   0000F7   0A           INC     R2
   \   0000F8   EB           MOV     A,R3
   \   0000F9   3400         ADDC    A,#0x0
   \   0000FB   FB           MOV     R3,A
    423          
    424          #if ( OSALMEM_PROFILER )
    425              osal_memset( (byte *)hdr, OSALMEM_ALOC, (size - HDRSZ) );
    426          
    427              /* A small-block could not be allocated in the small-block bucket.
    428               * When this occurs significantly frequently, increase the size of the
    429               * bucket in order to restore better worst case run times. Set the first
    430               * profiling bucket size in proCnt[] to the small-block bucket size and
    431               * divide proSmallBlkMiss by the corresponding proTot[] size to get % miss.
    432               * Best worst case time on TrasmitApp was achieved at a 0-15% miss rate
    433               * during steady state Tx load, 0% during idle and steady state Rx load.
    434               */
    435              if ( (size <= OSALMEM_SMALL_BLKSZ) && (hdr > ff2) )
    436              {
    437                proSmallBlkMiss++;
    438              }
    439          #endif
    440            }
    441          
    442            HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
   \                     ??osal_mem_alloc_8:
   \   0000FC   EC           MOV     A,R4
   \   0000FD   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000FF   92AF         MOV     0xa8.7,C
    443          
    444            return (void *)hdr;
   \   000101   7F06         MOV     R7,#0x6
   \   000103   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000106                REQUIRE _A_IEN0
    445          }
    446          
    447          /*********************************************************************
    448           * @fn      osal_mem_free
    449           *
    450           * @brief   Implementation of the de-allocator functionality.
    451           *
    452           * @param   ptr - pointer to the memory to free.
    453           *
    454           * @return  void
    455           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    456          void osal_mem_free( void *ptr )
   \                     osal_mem_free:
    457          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    458            osalMemHdr_t *currHdr;
    459            halIntState_t intState;
    460          
    461          #if ( OSALMEM_GUARD )
    462            // Try to protect against premature use by HAL / OSAL.
    463            if ( ready != OSALMEM_READY )
   \   000009   90....       MOV     DPTR,#ready
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   64E2         XRL     A,#0xe2
   \   00000F   6003         JZ      ??osal_mem_free_0
    464            {
    465              osal_mem_init();
   \   000011                ; Setup parameters for call to function osal_mem_init
   \   000011   12....       LCALL   ??osal_mem_init?relay
    466            }
    467          #endif
    468          
    469            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \                     ??osal_mem_free_0:
   \   000014   A2AF         MOV     C,0xa8.7
   \   000016   E4           CLR     A
   \   000017   92E0         MOV     0xE0 /* A   */.0,C
   \   000019   FC           MOV     R4,A
   \   00001A   C2AF         CLR     0xa8.7
    470          
    471            OSALMEM_ASSERT( ptr );
    472          
    473            currHdr = (osalMemHdr_t *)ptr - 1;
   \   00001C   EE           MOV     A,R6
   \   00001D   24FE         ADD     A,#-0x2
   \   00001F   F8           MOV     R0,A
   \   000020   EF           MOV     A,R7
   \   000021   34FF         ADDC    A,#-0x1
   \   000023   F9           MOV     R1,A
    474          
    475            // Has this block already been freed?
    476            OSALMEM_ASSERT( *currHdr & OSALMEM_IN_USE );
    477          
    478            *currHdr &= ~OSALMEM_IN_USE;
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   547F         ANL     A,#0x7f
   \   00002E   F0           MOVX    @DPTR,A
    479          
    480          #if ( OSALMEM_PROFILER )
    481            {
    482              uint16 size = *currHdr;
    483              byte idx;
    484          
    485              for ( idx = 0; idx < OSALMEM_PROMAX; idx++ )
    486              {
    487                if ( size <= proCnt[idx] )
    488                {
    489                  break;
    490                }
    491              }
    492          
    493              proCur[idx]--;
    494            }
    495          #endif
    496          
    497          #if ( OSALMEM_METRICS )
    498            memAlo -= *currHdr;
    499            blkFree++;
    500          #endif
    501          
    502            if ( ff1 > currHdr )
   \   00002F   90....       MOV     DPTR,#ff1
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FA           MOV     R2,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   FB           MOV     R3,A
   \   000037   C3           CLR     C
   \   000038   E8           MOV     A,R0
   \   000039   9A           SUBB    A,R2
   \   00003A   E9           MOV     A,R1
   \   00003B   9B           SUBB    A,R3
   \   00003C   5008         JNC     ??osal_mem_free_1
    503            {
    504              ff1 = currHdr;
   \   00003E   90....       MOV     DPTR,#ff1
   \   000041   E8           MOV     A,R0
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
   \   000044   E9           MOV     A,R1
   \   000045   F0           MOVX    @DPTR,A
    505            }
    506          
    507          #if ( OSALMEM_PROFILER )
    508            osal_memset( (byte *)currHdr+HDRSZ, OSALMEM_REIN, (*currHdr - HDRSZ) );
    509          #endif
    510          
    511            HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
   \                     ??osal_mem_free_1:
   \   000046   EC           MOV     A,R4
   \   000047   A2E0         MOV     C,0xE0 /* A   */.0
   \   000049   92AF         MOV     0xa8.7,C
    512          }
   \   00004B   7F01         MOV     R7,#0x1
   \   00004D   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000050                REQUIRE _A_IEN0

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for theHeap>`:
   \   000000   ....         DW _theHeap

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_mem_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_mem_kick?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_kick

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_mem_alloc?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_alloc

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_mem_free?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_free
    513          
    514          #if ( OSALMEM_METRICS )
    515          /*********************************************************************
    516           * @fn      osal_heap_block_max
    517           *
    518           * @brief   Return the maximum number of blocks ever allocated at once.
    519           *
    520           * @param   none
    521           *
    522           * @return  Maximum number of blocks ever allocated at once.
    523           */
    524          uint16 osal_heap_block_max( void )
    525          {
    526            return blkMax;
    527          }
    528          
    529          /*********************************************************************
    530           * @fn      osal_heap_block_cnt
    531           *
    532           * @brief   Return the current number of blocks now allocated.
    533           *
    534           * @param   none
    535           *
    536           * @return  Current number of blocks now allocated.
    537           */
    538          uint16 osal_heap_block_cnt( void )
    539          {
    540            return blkCnt;
    541          }
    542          
    543          /*********************************************************************
    544           * @fn      osal_heap_block_free
    545           *
    546           * @brief   Return the current number of free blocks.
    547           *
    548           * @param   none
    549           *
    550           * @return  Current number of free blocks.
    551           */
    552          uint16 osal_heap_block_free( void )
    553          {
    554            return blkFree;
    555          }
    556          
    557          /*********************************************************************
    558           * @fn      osal_heap_mem_used
    559           *
    560           * @brief   Return the current number of bytes allocated.
    561           *
    562           * @param   none
    563           *
    564           * @return  Current number of bytes allocated.
    565           */
    566          uint16 osal_heap_mem_used( void )
    567          {
    568            return memAlo;
    569          }
    570          #endif
    571          
    572          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    573          /*********************************************************************
    574           * @fn      osal_heap_high_water
    575           *
    576           * @brief   Return the highest byte ever allocated in the heap.
    577           *
    578           * @param   none
    579           *
    580           * @return  Highest number of bytes ever used by the stack.
    581           */
    582          uint16 osal_heap_high_water( void )
    583          {
    584          #if ( OSALMEM_METRICS )
    585            return memMax;
    586          #else
    587            return MAXMEMHEAP;
    588          #endif
    589          }
    590          #endif
    591          
    592          /*********************************************************************
    593          *********************************************************************/

   Maximum stack usage in bytes:

     Function            ISTACK PSTACK XSTACK
     --------            ------ ------ ------
     osal_mem_alloc          0      0     14
       -> osal_mem_init      0      0     28
     osal_mem_free           0      0      9
       -> osal_mem_init      0      0     18
     osal_mem_init           2      0     14
       -> osal_mem_alloc     4      0      0
     osal_mem_kick           2      0      0


   Segment part sizes:

     Function/Label             Bytes
     --------------             -----
     _A_IEN0                       1
     ready                         1
     ff1                           2
     ff2                           2
     _theHeap                   1664
     theHeap                       2
     osal_mem_init                99
     ?Subroutine2                  7
     ?Subroutine0                 12
     ?Subroutine1                 11
     osal_mem_kick                25
     osal_mem_alloc              262
     osal_mem_free                80
     ?<Initializer for theHeap>    2
     ??osal_mem_init?relay         6
     ??osal_mem_kick?relay         6
     ??osal_mem_alloc?relay        6
     ??osal_mem_free?relay         6

 
   496 bytes in segment BANKED_CODE
    24 bytes in segment BANK_RELAYS
     1 byte  in segment SFR_AN
     2 bytes in segment XDATA_I
     2 bytes in segment XDATA_ID
 1 669 bytes in segment XDATA_Z
 
   522 bytes of CODE  memory
     0 bytes of DATA  memory (+ 1 byte shared)
 1 671 bytes of XDATA memory

Errors: none
Warnings: none

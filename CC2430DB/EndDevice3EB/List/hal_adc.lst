###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    03/Apr/2013  14:45:10 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \hal\target\CC2430EB\hal_adc.c                     #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345 -          #
#                          2\CC2430DB\..\..\..\Tools\CC2430DB\f8wEndev.cfg"   #
#                          (-DCPU32MHZ -DFORCE_MAC_NEAR -DROOT=__near_func    #
#                          -DMAC_OPT_FFD=0 -DBLINK_LEDS "-DCONST=const        #
#                          __code" -DGENERIC=__generic) -f "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345 -                       #
#                          2\CC2430DB\..\..\..\Tools\CC2430DB\f8wConfig.cfg"  #
#                          (-DSECURE=0 -DDEFAULT_CHANLIST=0x00000800          #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\hal\targ #
#                          et\CC2430EB\hal_adc.c" -D CC2430EB -D AXD_END -D   #
#                          AXD_END_C -D NWK_AUTO_POLL -D REFLECTOR -D         #
#                          xZTOOL_P1 -D xMT_TASK -D xMT_ZDO_FUNC -D           #
#                          xLCD_SUPPORTED=DEBUG -D xPOWER_SAVING -lC          #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\cc2430-zstack-adxl345 -             #
#                          2\CC2430DB\EndDevice3EB\List\" -lA "C:\Texas       #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345 -                       #
#                          2\CC2430DB\EndDevice3EB\List\" --diag_suppress     #
#                          Pe001,Pa010 --diag_remark pe550 -o "C:\Texas       #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345 -                       #
#                          2\CC2430DB\EndDevice3EB\Obj\" -e                   #
#                          --require_prototypes -z2 --no_cse --no_unroll      #
#                          --no_inline --no_code_motion --no_tbaa --debug     #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs 8  #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345 -          #
#                          2\CC2430DB\" -I "C:\Texas                          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345 -                       #
#                          2\CC2430DB\..\SOURCE\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345 -                       #
#                          2\CC2430DB\..\Drivers\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345 -                       #
#                          2\CC2430DB\..\..\..\ZMAIN\TI2430DB\" -I "C:\Texas  #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345 -                       #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\MT\" -I       #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\cc2430-zstack-adxl345 -             #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\" #
#                           -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Proje #
#                          cts\zstack\Samples\cc2430-zstack-adxl345 -         #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC #
#                          2430EB\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\cc2430-zstack-adxl345   #
#                          - 2\CC2430DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CC #
#                          SOC\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\ #
#                          Projects\zstack\Samples\cc2430-zstack-adxl345 -    #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\ #
#                          " -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Proj #
#                          ects\zstack\Samples\cc2430-zstack-adxl345 -        #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\AF\"    #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345 -          #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\NWK\"   #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345 -          #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\SEC\"   #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345 -          #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\SYS\"   #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345 -          #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\"   #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345 -          #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\"    #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345 -          #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\ZMAC\" -I     #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\cc2430-zstack-adxl345 -             #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\SERVICES\SADD #
#                          R\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Pr #
#                          ojects\zstack\Samples\cc2430-zstack-adxl345 -      #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\SERVICES\SDAT #
#                          A\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Pr #
#                          ojects\zstack\Samples\cc2430-zstack-adxl345 -      #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\" #
#                           -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Proje #
#                          cts\zstack\Samples\cc2430-zstack-adxl345 -         #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVE #
#                          L\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Pr #
#                          ojects\zstack\Samples\cc2430-zstack-adxl345 -      #
#                          2\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL #
#                          \SRF03\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\cc2430-zstack-adxl345   #
#                          - 2\CC2430DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEV #
#                          EL\SRF03\SINGLE_CHIP\" -I "C:\Program Files\IAR    #
#                          Systems\Embedded Workbench 4.0 Evaluation          #
#                          version\8051\INC\" -I "C:\Program Files\IAR        #
#                          Systems\Embedded Workbench 4.0 Evaluation          #
#                          version\8051\INC\CLIB\"                            #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345 -              #
#                          2\CC2430DB\EndDevice3EB\List\hal_adc.lst           #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345 -              #
#                          2\CC2430DB\EndDevice3EB\Obj\hal_adc.r51            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\hal\target\CC2430EB\hal_adc.c
      1          /**************************************************************************************************
      2            Filename:       hal_adc.c
      3            Revised:        $Date: 2007-11-01 08:44:53 -0700 (Thu, 01 Nov 2007) $
      4            Revision:       $Revision: 15821 $
      5          
      6            Description:    This file contains the interface to the HAL ADC.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /**************************************************************************************************
     41           *                                           INCLUDES
     42           **************************************************************************************************/
     43          #include  "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x88
   \   union <unnamed> volatile __sfr _A_TCON
   \                     _A_TCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb5
   \   unsigned char volatile __sfr ADCCON2
   \                     ADCCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb6
   \   unsigned char volatile __sfr ADCCON3
   \                     ADCCON3:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xba
   \   unsigned char volatile __sfr ADCL
   \                     ADCL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr ADCH
   \                     ADCH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf2
   \   unsigned char volatile __sfr ADCCFG
   \                     ADCCFG:
   \   000000                DS 1
     44          #include  "hal_defs.h"
     45          #include  "hal_types.h"
     46          #include  "hal_adc.h"
     47          
     48          /**************************************************************************************************
     49           *                                            CONSTANTS
     50           **************************************************************************************************/
     51          #define HAL_ADC_EOC         0x80    /* End of Conversion bit */
     52          #define HAL_ADC_START       0x40    /* Starts Conversion */
     53          
     54          #define HAL_ADC_STSEL_EXT   0x00    /* External Trigger */
     55          #define HAL_ADC_STSEL_FULL  0x10    /* Full Speed, No Trigger */
     56          #define HAL_ADC_STSEL_T1C0  0x20    /* Timer1, Channel 0 Compare Event Trigger */
     57          #define HAL_ADC_STSEL_ST    0x30    /* ADCCON1.ST =1 Trigger */
     58          
     59          #define HAL_ADC_RAND_NORM   0x00    /* Normal Operation */
     60          #define HAL_ADC_RAND_LFSR   0x04    /* Clock LFSR */
     61          #define HAL_ADC_RAND_SEED   0x08    /* Seed Modulator */
     62          #define HAL_ADC_RAND_STOP   0x0c    /* Stop Random Generator */
     63          #define HAL_ADC_RAND_BITS   0x0c    /* Bits [3:2] */
     64          
     65          #define HAL_ADC_REF_125V    0x00    /* Internal 1.25V Reference */
     66          #define HAL_ADC_REF_AIN7    0x40    /* AIN7 Reference */
     67          #define HAL_ADC_REF_AVDD    0x80    /* AVDD_SOC Pin Reference */
     68          #define HAL_ADC_REF_DIFF    0xc0    /* AIN7,AIN6 Differential Reference */
     69          #define HAL_ADC_REF_BITS    0xc0    /* Bits [7:6] */
     70          
     71          #define HAL_ADC_DEC_064     0x00    /* Decimate by 64 : 8-bit resolution */
     72          #define HAL_ADC_DEC_128     0x10    /* Decimate by 128 : 10-bit resolution */
     73          #define HAL_ADC_DEC_256     0x20    /* Decimate by 256 : 12-bit resolution */
     74          #define HAL_ADC_DEC_512     0x30    /* Decimate by 512 : 14-bit resolution */
     75          #define HAL_ADC_DEC_BITS    0x30    /* Bits [5:4] */
     76          
     77          #define HAL_ADC_CHN_AIN0    0x00    /* AIN0 */
     78          #define HAL_ADC_CHN_AIN1    0x01    /* AIN1 */
     79          #define HAL_ADC_CHN_AIN2    0x02    /* AIN2 */
     80          #define HAL_ADC_CHN_AIN3    0x03    /* AIN3 */
     81          #define HAL_ADC_CHN_AIN4    0x04    /* AIN4 */
     82          #define HAL_ADC_CHN_AIN5    0x05    /* AIN5 */
     83          #define HAL_ADC_CHN_AIN6    0x06    /* AIN6 */
     84          #define HAL_ADC_CHN_AIN7    0x07    /* AIN7 */
     85          #define HAL_ADC_CHN_A0A1    0x08    /* AIN0,AIN1 */
     86          #define HAL_ADC_CHN_A2A3    0x09    /* AIN2,AIN3 */
     87          #define HAL_ADC_CHN_A4A5    0x0a    /* AIN4,AIN5 */
     88          #define HAL_ADC_CHN_A6A7    0x0b    /* AIN6,AIN7 */
     89          #define HAL_ADC_CHN_GND     0x0c    /* GND */
     90          #define HAL_ADC_CHN_VREF    0x0d    /* Positive voltage reference */
     91          #define HAL_ADC_CHN_TEMP    0x0e    /* Temperature sensor */
     92          #define HAL_ADC_CHN_VDD3    0x0f    /* VDD/3 */
     93          #define HAL_ADC_CHN_BITS    0x0f    /* Bits [3:0] */
     94          
     95          #define HAL_ADC_STSEL       HAL_ADC_STSEL_ST
     96          #define HAL_ADC_RAND_GEN    HAL_ADC_RAND_STOP
     97          #define HAL_ADC_REF_VOLT    HAL_ADC_REF_AVDD
     98          #define HAL_ADC_DEC_RATE    HAL_ADC_DEC_064
     99          #define HAL_ADC_SCHN        HAL_ADC_CHN_VDD3
    100          #define HAL_ADC_ECHN        HAL_ADC_CHN_GND
    101          
    102          
    103          /* Vdd limit values */

   \                                 In  segment CODE_C, align 1
    104          static __code const uint16 HalAdcVddLimit[] =
   \                     HalAdcVddLimit:
   \   000000   9C36063A     DW 13980, 14854, 15728, 16601, 17475, 18349, 19223, 20097, 20970
   \            703DD940
   \            4344AD47
   \            174B814E
   \            EA51    
    105          {
    106            0x369C,       /*  VDD Limit - 1.6v  */
    107            0x3A06,       /*  VDD Limit - 1.7v  */
    108            0x3D70,       /*  VDD Limit - 1.8v  */
    109            0x40D9,       /*  VDD Limit - 1.9v  */
    110            0x4443,       /*  VDD Limit - 2.0v  */
    111            0x47AD,       /*  VDD Limit - 2.1v  */
    112            0x4B17,       /*  VDD Limit - 2.2v  */
    113            0x4E81,       /*  VDD Limit - 2.3v  */
    114            0x51EA,       /*  VDD Limit - 2.4v  */
    115          };
    116          
    117          
    118          /**************************************************************************************************
    119           *                                              MACROS
    120           **************************************************************************************************/
    121          #define HAL_ADC_CLR_EOC()   asm("PUSH A"); asm("MOV A,ADCL"); asm("MOV A,ADCH"); asm("POP A");
    122          
    123          /**************************************************************************************************
    124           *                                            TYPEDEFS
    125           **************************************************************************************************/
    126          
    127          /**************************************************************************************************
    128           *                                         GLOBAL VARIABLES
    129           **************************************************************************************************/
    130          
    131          /**************************************************************************************************
    132           *                                          FUNCTIONS - API
    133           **************************************************************************************************/
    134          extern bool HalAdcCheckVdd (uint8 limit);
    135          
    136          /**************************************************************************************************
    137           * @fn      HalAdcInit
    138           *
    139           * @brief   Initialize ADC Service
    140           *
    141           * @param   None
    142           *
    143           * @return  None
    144           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    145          void HalAdcInit (void)
   \                     HalAdcInit:
    146          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    147          #if (HAL_ADC == TRUE)
    148            volatile uint8  tmp;
    149          
    150            ADCCON1 = HAL_ADC_STSEL | HAL_ADC_RAND_GEN | 0x03;
   \   000009   75B43F       MOV     0xb4,#0x3f
    151            ADCCON2 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_SCHN;
   \   00000C   75B58F       MOV     0xb5,#-0x71
    152            /*
    153            *  After reset, the first ADC reading of the extra conversion always reads GND level.
    154            *  We will do a few dummy conversions to bypass this bug.
    155            */
    156            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   00000F   E5BA         MOV     A,0xba
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   F0           MOVX    @DPTR,A
    157            tmp = ADCH;
   \   000018   E5BB         MOV     A,0xbb
   \   00001A   85..82       MOV     DPL,?XSP + 0
   \   00001D   85..83       MOV     DPH,?XSP + 1
   \   000020   F0           MOVX    @DPTR,A
    158            ADCCON3 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_ECHN;
   \   000021   75B68C       MOV     0xb6,#-0x74
    159            while ((ADCCON1 & HAL_ADC_EOC) != HAL_ADC_EOC);   /* Wait for conversion */
   \                     ??HalAdcInit_0:
   \   000024   E5B4         MOV     A,0xb4
   \   000026   A2E7         MOV     C,0xE0 /* A   */.7
   \   000028   50FA         JNC     ??HalAdcInit_0
    160            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   00002A   E5BA         MOV     A,0xba
   \   00002C   85..82       MOV     DPL,?XSP + 0
   \   00002F   85..83       MOV     DPH,?XSP + 1
   \   000032   F0           MOVX    @DPTR,A
    161            tmp = ADCH;
   \   000033   E5BB         MOV     A,0xbb
   \   000035   85..82       MOV     DPL,?XSP + 0
   \   000038   85..83       MOV     DPH,?XSP + 1
   \   00003B   F0           MOVX    @DPTR,A
    162            ADCCON3 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_ECHN;
   \   00003C   75B68C       MOV     0xb6,#-0x74
    163            while ((ADCCON1 & HAL_ADC_EOC) != HAL_ADC_EOC);   /* Wait for conversion */
   \                     ??HalAdcInit_1:
   \   00003F   E5B4         MOV     A,0xb4
   \   000041   A2E7         MOV     C,0xE0 /* A   */.7
   \   000043   50FA         JNC     ??HalAdcInit_1
    164            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   000045   E5BA         MOV     A,0xba
   \   000047   85..82       MOV     DPL,?XSP + 0
   \   00004A   85..83       MOV     DPH,?XSP + 1
   \   00004D   F0           MOVX    @DPTR,A
    165            tmp = ADCH;
   \   00004E   E5BB         MOV     A,0xbb
   \   000050   85..82       MOV     DPL,?XSP + 0
   \   000053   85..83       MOV     DPH,?XSP + 1
   \   000056   F0           MOVX    @DPTR,A
    166          #endif
    167          }
   \   000057   7401         MOV     A,#0x1
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005C   D083         POP     DPH
   \   00005E   D082         POP     DPL
   \   000060   02....       LJMP    ?BRET
   \   000063                REQUIRE ADCCON1
   \   000063                REQUIRE ADCCON2
   \   000063                REQUIRE ADCCON3
   \   000063                REQUIRE ADCL
   \   000063                REQUIRE ADCH
    168          
    169          /**************************************************************************************************
    170           * @fn      HalAdcRead
    171           *
    172           * @brief   Read the ADC based on given channel and resolution
    173           *
    174           * @param   channel - channel where ADC will be read
    175           * @param   resolution - the resolution of the value
    176           *
    177           * @return  16 bit value of the ADC in offset binary format.
    178           *          Note that the ADC is "bipolar", which means the GND (0V) level is mid-scale.
    179           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    180          uint16 HalAdcRead (uint8 channel, uint8 resolution)
   \                     HalAdcRead:
    181          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FC           MOV     R4,A
    182            int16  reading = 0;
    183          
    184          #if (HAL_ADC == TRUE)
    185          
    186            uint8   i, resbits;
    187            uint8   adctemp;
    188            volatile  uint8 tmp;
    189            uint8  adcChannel = 1;
   \   00000C   7F01         MOV     R7,#0x1
    190          
    191            /*
    192            * If Analog input channel is AIN0..AIN7, make sure corresponing P0 I/O pin is enabled.  The code
    193            * does NOT disable the pin at the end of this function.  I think it is better to leave the pin
    194            * enabled because the results will be more accurate.  Because of the inherent capacitance on the
    195            * pin, it takes time for the voltage on the pin to charge up to its steady-state level.  If
    196            * HalAdcRead() has to turn on the pin for every conversion, the results may show a lower voltage
    197            * than actuality because the pin did not have time to fully charge.
    198            */
    199            if (channel < 8)
   \   00000E   E9           MOV     A,R1
   \   00000F   C3           CLR     C
   \   000010   9408         SUBB    A,#0x8
   \   000012   500E         JNC     ??HalAdcRead_0
    200            {
    201              for (i=0; i < channel; i++)
   \   000014   7D00         MOV     R5,#0x0
   \                     ??HalAdcRead_1:
   \   000016   ED           MOV     A,R5
   \   000017   C3           CLR     C
   \   000018   99           SUBB    A,R1
   \   000019   5007         JNC     ??HalAdcRead_0
    202              {
    203                adcChannel <<= 1;
   \   00001B   EF           MOV     A,R7
   \   00001C   C3           CLR     C
   \   00001D   33           RLC     A
   \   00001E   FF           MOV     R7,A
    204              }
   \   00001F   0D           INC     R5
   \   000020   80F4         SJMP    ??HalAdcRead_1
    205            }
    206          
    207            /* Enable channel */
    208            ADCCFG |= adcChannel;
   \                     ??HalAdcRead_0:
   \   000022   EF           MOV     A,R7
   \   000023   45F2         ORL     A,0xf2
   \   000025   F5F2         MOV     0xf2,A
    209          
    210            /* Convert resolution to decimation rate */
    211            switch (resolution)
   \   000027   EC           MOV     A,R4
   \   000028   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for HalAdcRead>_0`:
   \   00002B   01           DB        1
   \   00002C   02           DB        2
   \   00002D   ....         DW        ??HalAdcRead_2
   \   00002F   ....         DW        ??HalAdcRead_3
   \   000031   ....         DW        ??HalAdcRead_4
   \   000033   ....         DW        ??HalAdcRead_5
    212            {
    213              case HAL_ADC_RESOLUTION_8:
    214                resbits = HAL_ADC_DEC_064;
   \                     ??HalAdcRead_3:
   \   000035   7E00         MOV     R6,#0x0
   \   000037   800A         SJMP    ??HalAdcRead_6
    215                break;
    216              case HAL_ADC_RESOLUTION_10:
    217                resbits = HAL_ADC_DEC_128;
   \                     ??HalAdcRead_4:
   \   000039   7E10         MOV     R6,#0x10
   \   00003B   8006         SJMP    ??HalAdcRead_6
    218                break;
    219              case HAL_ADC_RESOLUTION_12:
    220                resbits = HAL_ADC_DEC_256;
   \                     ??HalAdcRead_5:
   \   00003D   7E20         MOV     R6,#0x20
   \   00003F   8002         SJMP    ??HalAdcRead_6
    221                break;
    222              case HAL_ADC_RESOLUTION_14:
    223              default:
    224                resbits = HAL_ADC_DEC_512;
   \                     ??HalAdcRead_2:
   \   000041   7E30         MOV     R6,#0x30
    225                break;
    226            }
    227          
    228            /* read ADCL,ADCH to clear EOC */
    229            tmp = ADCL;
   \                     ??HalAdcRead_6:
   \   000043   E5BA         MOV     A,0xba
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   F0           MOVX    @DPTR,A
    230            tmp = ADCH;
   \   00004C   E5BB         MOV     A,0xbb
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   F0           MOVX    @DPTR,A
    231          
    232            /* Setup Sample */
    233            adctemp = ADCCON3;
   \   000055   E5B6         MOV     A,0xb6
    234            adctemp &= ~(HAL_ADC_CHN_BITS | HAL_ADC_DEC_BITS | HAL_ADC_REF_BITS);
   \   000057   75..00       MOV     ?V0 + 2,#0x0
    235            adctemp |= channel | resbits | HAL_ADC_REF_VOLT;
   \   00005A   EE           MOV     A,R6
   \   00005B   49           ORL     A,R1
   \   00005C   4480         ORL     A,#0x80
   \   00005E   42..         ORL     ?V0 + 2,A
    236          
    237            /* writing to this register starts the extra conversion */
    238            ADCCON3 = adctemp;
   \   000060   85..B6       MOV     0xb6,?V0 + 2
    239          
    240            /* Wait for the conversion to be done */
    241            while (!(ADCCON1 & HAL_ADC_EOC));
   \                     ??HalAdcRead_7:
   \   000063   E5B4         MOV     A,0xb4
   \   000065   A2E7         MOV     C,0xE0 /* A   */.7
   \   000067   50FA         JNC     ??HalAdcRead_7
    242          
    243            /* Disable channel after done conversion */
    244            ADCCFG &= ~adcChannel;
   \   000069   EF           MOV     A,R7
   \   00006A   F4           CPL     A
   \   00006B   55F2         ANL     A,0xf2
   \   00006D   F5F2         MOV     0xf2,A
    245          
    246            /* Read the result */
    247            reading = (int16) (ADCL);
   \   00006F   A8BA         MOV     R0,0xba
   \   000071   8882         MOV     DPL,R0
   \   000073   758300       MOV     DPH,#0x0
   \   000076   AA82         MOV     R2,DPL
   \   000078   AB83         MOV     R3,DPH
    248            reading |= (int16) (ADCH << 8);
   \   00007A   E5BB         MOV     A,0xbb
   \   00007C   F5..         MOV     ?V0 + 0,A
   \   00007E   E4           CLR     A
   \   00007F   C5..         XCH     A,?V0 + 0
   \   000081   F5..         MOV     ?V0 + 1,A
   \   000083   E5..         MOV     A,?V0 + 0
   \   000085   4A           ORL     A,R2
   \   000086   FA           MOV     R2,A
   \   000087   E5..         MOV     A,?V0 + 1
   \   000089   4B           ORL     A,R3
   \   00008A   FB           MOV     R3,A
    249          
    250            /* Treat small negative as 0 */
    251            if (reading < 0)
   \   00008B   C3           CLR     C
   \   00008C   EA           MOV     A,R2
   \   00008D   9400         SUBB    A,#0x0
   \   00008F   EB           MOV     A,R3
   \   000090   9400         SUBB    A,#0x0
   \   000092   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000094   65D0         XRL     A,PSW
   \   000096   33           RLC     A
   \   000097   5004         JNC     ??HalAdcRead_8
    252              reading = 0;
   \   000099   7A00         MOV     R2,#0x0
   \   00009B   7B00         MOV     R3,#0x0
    253          
    254            switch (resolution)
   \                     ??HalAdcRead_8:
   \   00009D   EC           MOV     A,R4
   \   00009E   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for HalAdcRead>_1`:
   \   0000A1   01           DB        1
   \   0000A2   02           DB        2
   \   0000A3   ....         DW        ??HalAdcRead_9
   \   0000A5   ....         DW        ??HalAdcRead_10
   \   0000A7   ....         DW        ??HalAdcRead_11
   \   0000A9   ....         DW        ??HalAdcRead_12
    255            {
    256              case HAL_ADC_RESOLUTION_8:
    257                reading >>= 8;
   \                     ??HalAdcRead_10:
   \   0000AB   8A..         MOV     ?V0 + 0,R2
   \   0000AD   8B..         MOV     ?V0 + 1,R3
   \   0000AF   7408         MOV     A,#0x8
   \   0000B1   78..         MOV     R0,#?V0 + 0
   \   0000B3   12....       LCALL   ?SS_SHR
   \   0000B6   AA..         MOV     R2,?V0 + 0
   \   0000B8   AB..         MOV     R3,?V0 + 1
   \   0000BA   8020         SJMP    ??HalAdcRead_9
    258                break;
    259              case HAL_ADC_RESOLUTION_10:
    260                reading >>= 6;
   \                     ??HalAdcRead_11:
   \   0000BC   8A..         MOV     ?V0 + 0,R2
   \   0000BE   8B..         MOV     ?V0 + 1,R3
   \   0000C0   7406         MOV     A,#0x6
   \   0000C2   78..         MOV     R0,#?V0 + 0
   \   0000C4   12....       LCALL   ?SS_SHR
   \   0000C7   AA..         MOV     R2,?V0 + 0
   \   0000C9   AB..         MOV     R3,?V0 + 1
   \   0000CB   800F         SJMP    ??HalAdcRead_9
    261                break;
    262              case HAL_ADC_RESOLUTION_12:
    263                reading >>= 4;
   \                     ??HalAdcRead_12:
   \   0000CD   8A..         MOV     ?V0 + 0,R2
   \   0000CF   8B..         MOV     ?V0 + 1,R3
   \   0000D1   7404         MOV     A,#0x4
   \   0000D3   78..         MOV     R0,#?V0 + 0
   \   0000D5   12....       LCALL   ?SS_SHR
   \   0000D8   AA..         MOV     R2,?V0 + 0
   \   0000DA   AB..         MOV     R3,?V0 + 1
    264                break;
    265              case HAL_ADC_RESOLUTION_14:
    266              default:
    267              break;
    268            }
    269          #endif
    270          
    271            return ((uint16)reading);
   \                     ??HalAdcRead_9:
   \   0000DC   7401         MOV     A,#0x1
   \   0000DE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E1   7F03         MOV     R7,#0x3
   \   0000E3   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   0000E6                REQUIRE ADCCON1
   \   0000E6                REQUIRE ADCCON3
   \   0000E6                REQUIRE ADCL
   \   0000E6                REQUIRE ADCH
   \   0000E6                REQUIRE ADCCFG
    272          }
    273          
    274          /**************************************************************************************************
    275           * @fn      HalAdcCheckVdd
    276           *
    277           * @brief   Check the Vdd and return TRUE if it greater than or equal the limit
    278           *
    279           * @param   limit - limit that needs to be checked with the Vdd
    280           *
    281           * @return  TRUE if Vdd >= limit, FALSE otherwise
    282           *
    283           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    284          bool HalAdcCheckVdd (uint8 limit)
   \                     HalAdcCheckVdd:
    285          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   FD           MOV     R5,A
    286            uint16 value;
    287          
    288            /* If rev C or earlier, dont check the voltage */
    289            if (CHVER < REV_D)
   \   000006   90DF60       MOV     DPTR,#-0x20a0
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   C3           CLR     C
   \   00000B   9403         SUBB    A,#0x3
   \   00000D   5004         JNC     ??HalAdcCheckVdd_0
    290            {
    291              return TRUE;
   \   00000F   7901         MOV     R1,#0x1
   \   000011   8057         SJMP    ??HalAdcCheckVdd_1
    292            }
    293          
    294            /* Clear ADC interrupt flag */
    295            ADCIF = 0;
   \                     ??HalAdcCheckVdd_0:
   \   000013   C28D         CLR     0x88.5
    296          
    297            /* Setup the new value for conversion */
    298            ADCCON3 = (HAL_ADC_REF_125V | HAL_ADC_DEC_064 | HAL_ADC_CHN_VDD3);
   \   000015   75B60F       MOV     0xb6,#0xf
    299          
    300            /* Wait for the conversion to finish */
    301            while ( !ADCIF );
   \                     ??HalAdcCheckVdd_2:
   \   000018   A28D         MOV     C,0x88.5
   \   00001A   50FC         JNC     ??HalAdcCheckVdd_2
    302          
    303            /* Get the result */
    304            value = ADCL;
   \   00001C   ACBA         MOV     R4,0xba
   \   00001E   8C82         MOV     DPL,R4
   \   000020   758300       MOV     DPH,#0x0
   \   000023   AA82         MOV     R2,DPL
   \   000025   AB83         MOV     R3,DPH
    305            value |= ((uint16) ADCH) << 8;
   \   000027   E5BB         MOV     A,0xbb
   \   000029   F8           MOV     R0,A
   \   00002A   E4           CLR     A
   \   00002B   C8           XCH     A,R0
   \   00002C   F9           MOV     R1,A
   \   00002D   E8           MOV     A,R0
   \   00002E   4A           ORL     A,R2
   \   00002F   FA           MOV     R2,A
   \   000030   E9           MOV     A,R1
   \   000031   4B           ORL     A,R3
   \   000032   FB           MOV     R3,A
    306          
    307            /* Check the limit and return */
    308            return ( value >= HalAdcVddLimit[limit] );
   \   000033   ED           MOV     A,R5
   \   000034   F8           MOV     R0,A
   \   000035   7900         MOV     R1,#0x0
   \   000037   E8           MOV     A,R0
   \   000038   75F002       MOV     B,#0x2
   \   00003B   A4           MUL     AB
   \   00003C   C8           XCH     A,R0
   \   00003D   ACF0         MOV     R4,B
   \   00003F   75F000       MOV     B,#0x0
   \   000042   A4           MUL     AB
   \   000043   2C           ADD     A,R4
   \   000044   FC           MOV     R4,A
   \   000045   75F002       MOV     B,#0x2
   \   000048   E9           MOV     A,R1
   \   000049   A4           MUL     AB
   \   00004A   2C           ADD     A,R4
   \   00004B   F9           MOV     R1,A
   \   00004C   E8           MOV     A,R0
   \   00004D   24..         ADD     A,#(HalAdcVddLimit & 0xff)
   \   00004F   F582         MOV     DPL,A
   \   000051   E9           MOV     A,R1
   \   000052   34..         ADDC    A,#((HalAdcVddLimit >> 8) & 0xff)
   \   000054   F583         MOV     DPH,A
   \   000056   E4           CLR     A
   \   000057   93           MOVC    A,@A+DPTR
   \   000058   F8           MOV     R0,A
   \   000059   7401         MOV     A,#0x1
   \   00005B   93           MOVC    A,@A+DPTR
   \   00005C   F9           MOV     R1,A
   \   00005D   C3           CLR     C
   \   00005E   EA           MOV     A,R2
   \   00005F   98           SUBB    A,R0
   \   000060   EB           MOV     A,R3
   \   000061   99           SUBB    A,R1
   \   000062   4004         JC      ??HalAdcCheckVdd_3
   \   000064   7901         MOV     R1,#0x1
   \   000066   8002         SJMP    ??HalAdcCheckVdd_1
   \                     ??HalAdcCheckVdd_3:
   \   000068   7900         MOV     R1,#0x0
   \                     ??HalAdcCheckVdd_1:
   \   00006A   D083         POP     DPH
   \   00006C   D082         POP     DPL
   \   00006E   02....       LJMP    ?BRET
   \   000071                REQUIRE _A_TCON
   \   000071                REQUIRE ADCCON3
   \   000071                REQUIRE ADCL
   \   000071                REQUIRE ADCH
    309          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcCheckVdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcCheckVdd
    310          
    311          /**************************************************************************************************
    312          **************************************************************************************************/
    313          
    314          
    315          
    316          

   Maximum stack usage in bytes:

     Function       ISTACK PSTACK XSTACK
     --------       ------ ------ ------
     HalAdcCheckVdd     2      0      0
     HalAdcInit         3      0      1
     HalAdcRead         1      0     12


   Segment part sizes:

     Function/Label         Bytes
     --------------         -----
     _A_TCON                   1
     ADCCON1                   1
     ADCCON2                   1
     ADCCON3                   1
     ADCL                      1
     ADCH                      1
     ADCCFG                    1
     HalAdcVddLimit           18
     HalAdcInit               99
     HalAdcRead              230
     HalAdcCheckVdd          113
     ??HalAdcInit?relay        6
     ??HalAdcRead?relay        6
     ??HalAdcCheckVdd?relay    6

 
 442 bytes in segment BANKED_CODE
  18 bytes in segment BANK_RELAYS
  18 bytes in segment CODE_C
   7 bytes in segment SFR_AN
 
 478 bytes of CODE memory
   0 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: none

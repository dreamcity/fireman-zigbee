###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    12/Mar/2013  15:45:33 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \hal\target\CC2430EB\hal_uart.c                    #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\. #
#                          .\..\..\Tools\CC2430DB\f8wCoord.cfg" (-DCPU32MHZ   #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS           #
#                          "-DCONST=const __code" -DGENERIC=__generic) -f     #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\cc2430-zstack-adxl345\CC2430DB\..\. #
#                          .\..\Tools\CC2430DB\f8wConfig.cfg" (-DSECURE=0     #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\hal\targ #
#                          et\CC2430EB\hal_uart.c" -D CC2430EB -D REFLECTOR   #
#                          -D HAL_UART -D xZTOOL_P1 -D AXD_COR -D MT_TASK -D  #
#                          xMT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG -lC "C:\Texas  #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\CoordinatorEB\ #
#                          List\" -lA "C:\Texas Instruments\ZStack-1.4.3-1.2. #
#                          1\Projects\zstack\Samples\cc2430-zstack-adxl345\CC #
#                          2430DB\CoordinatorEB\List\" --diag_suppress        #
#                          Pe001,Pa010 --diag_remark pe550 -o "C:\Texas       #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\CoordinatorEB\ #
#                          Obj\" -e --require_prototypes -z9                  #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\cc2430-zstack-adxl345\CC2430DB\"    #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\. #
#                          .\SOURCE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\cc2430-zstack-adxl345 #
#                          \CC2430DB\..\Drivers\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\ZMAIN #
#                          \TI2430DB\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MT\" -I "C:\Texas                      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\INCLUDE\" -I "C:\Texas             #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\TARGET\CC2430EB\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\OSAL\INCLUDE\" -I "C:\Texas            #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\AF\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\NWK\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SEC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SYS\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\ZDO\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\ZMAC\F8W\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\ZMAC\" -I "C:\Texas                    #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SADDR\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SDATA\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\INCLUDE\" -I "C:\Texas             #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\HIGH_LEVEL\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\LOW_LEVEL\SRF03\SINGLE_CHIP\" -I   #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          4.0 Evaluation version\8051\INC\" -I "C:\Program   #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\CC2430DB\Coord #
#                          inatorEB\List\hal_uart.lst                         #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\CC2430DB\Coord #
#                          inatorEB\Obj\hal_uart.r51                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\hal\target\CC2430EB\hal_uart.c
      1          /**************************************************************************************************
      2            Filename:       _hal_uart.c
      3            Revised:        $Date: 2007-11-01 08:44:53 -0700 (Thu, 01 Nov 2007) $
      4            Revision:       $Revision: 15821 $
      5          
      6            Description: This file contains the interface to the H/W UART driver.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "hal_types.h"
     45          #include "hal_assert.h"
     46          #include "hal_board.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x86
   \   unsigned char volatile __sfr U0CSR
   \                     U0CSR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x95
   \   unsigned char volatile __sfr ST0
   \                     ST0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc1
   \   unsigned char volatile __sfr U0DBUF
   \                     U0DBUF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc2
   \   unsigned char volatile __sfr U0BAUD
   \                     U0BAUD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc4
   \   unsigned char volatile __sfr U0UCR
   \                     U0UCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc5
   \   unsigned char volatile __sfr U0GCR
   \                     U0GCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd1
   \   unsigned char volatile __sfr DMAIRQ
   \                     DMAIRQ:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd6
   \   unsigned char volatile __sfr DMAARM
   \                     DMAARM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd7
   \   unsigned char volatile __sfr DMAREQ
   \                     DMAREQ:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf1
   \   unsigned char volatile __sfr PERCFG
   \                     PERCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf2
   \   unsigned char volatile __sfr ADCCFG
   \                     ADCCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
     47          #include "hal_defs.h"
     48          #if defined( HAL_UART_DMA ) && HAL_UART_DMA
     49            #include "hal_dma.h"
     50          #endif
     51          #include "hal_mcu.h"
     52          #include "hal_uart.h"
     53          #include "osal.h"
     54          
     55          /*********************************************************************
     56           * MACROS
     57           */
     58          
     59          #if !defined ( HAL_UART_DEBUG )
     60            #define HAL_UART_DEBUG  FALSE
     61          #endif
     62          
     63          #if !defined ( HAL_UART_CLOSE )
     64            #define HAL_UART_CLOSE  FALSE
     65          #endif
     66          
     67          #if !defined ( HAL_UART_BIG_TX_BUF )
     68            #define HAL_UART_BIG_TX_BUF  FALSE
     69          #endif
     70          
     71          /*
     72           *  The MAC_ASSERT macro is for use during debugging.
     73           *  The given expression must evaluate as "true" or else fatal error occurs.
     74           *  At that point, the call stack feature of the debugger can pinpoint where
     75           *  the problem occurred.
     76           *
     77           *  To disable this feature and save code size, the project should define
     78           *  HAL_UART_DEBUG to FALSE.
     79           */
     80          #if ( HAL_UART_DEBUG )
     81            #define HAL_UART_ASSERT( expr)        HAL_ASSERT( expr )
     82          #else
     83            #define HAL_UART_ASSERT( expr )
     84          #endif
     85          
     86          #define P2DIR_PRIPO               0xC0
     87          #if HAL_UART_0_ENABLE
     88            #define HAL_UART_PRIPO          0x00
     89          #else
     90            #define HAL_UART_PRIPO          0x40
     91          #endif
     92          
     93          #define HAL_UART_0_PERCFG_BIT     0x01  // USART0 on P0, so clear this bit.
     94          #define HAL_UART_0_P0_RX_TX       0x0c  // Peripheral I/O Select for Rx/Tx.
     95          #define HAL_UART_0_P0_RTS         0x10  // Peripheral I/O Select for RTS.
     96          #define HAL_UART_0_P0_CTS         0x20  // Peripheral I/O Select for CTS.
     97          
     98          #define HAL_UART_1_PERCFG_BIT     0x02  // USART1 on P1, so set this bit.
     99          #define HAL_UART_1_P1_RTS         0x10  // Peripheral I/O Select for RTS.
    100          #define HAL_UART_1_P1_CTS         0x20  // Peripheral I/O Select for CTS.
    101          #define HAL_UART_1_P1_RX_TX       0xC0  // Peripheral I/O Select for Rx/Tx.
    102          
    103          #define TX_AVAIL( cfg ) \
    104            ((cfg->txTail == cfg->txHead) ? (cfg->txMax-1) : \
    105            ((cfg->txTail >  cfg->txHead) ? (cfg->txTail - cfg->txHead - 1) : \
    106                               (cfg->txMax - cfg->txHead + cfg->txTail)))
    107          
    108          #define RX0_FLOW_ON  ( P0 &= ~HAL_UART_0_P0_CTS )
    109          #define RX0_FLOW_OFF ( P0 |= HAL_UART_0_P0_CTS )
    110          #define RX1_FLOW_ON  ( P1 &= ~HAL_UART_1_P1_CTS)
    111          #define RX1_FLOW_OFF ( P1 |= HAL_UART_1_P1_CTS )
    112          
    113          #define RX_STOP_FLOW( cfg ) { \
    114            if ( !(cfg->flag & UART_CFG_U1F) ) \
    115            { \
    116              RX0_FLOW_OFF; \
    117            } \
    118            else \
    119            { \
    120              RX1_FLOW_OFF; \
    121            } \
    122            if ( cfg->flag & UART_CFG_DMA ) \
    123            { \
    124              cfg->rxTick = DMA_RX_DLY; \
    125            } \
    126            cfg->flag |= UART_CFG_RXF; \
    127          }
    128          
    129          #define RX_STRT_FLOW( cfg ) { \
    130            if ( !(cfg->flag & UART_CFG_U1F) ) \
    131            { \
    132              RX0_FLOW_ON; \
    133            } \
    134            else \
    135            { \
    136              RX1_FLOW_ON; \
    137            } \
    138            cfg->flag &= ~UART_CFG_RXF; \
    139          }
    140          
    141          #define UART_RX_AVAIL( cfg ) \
    142            ( (cfg->rxHead >= cfg->rxTail) ? (cfg->rxHead - cfg->rxTail) : \
    143                                             (cfg->rxMax - cfg->rxTail + cfg->rxHead +1 ) )
    144          
    145          /* Need to leave enough of the Rx buffer free to handle the incoming bytes
    146           * after asserting flow control, but before the transmitter has obeyed it.
    147           * At the max expected baud rate of 115.2k, 16 bytes will only take ~1.3 msecs,
    148           * but at the min expected baud rate of 38.4k, they could take ~4.2 msecs.
    149           * SAFE_RX_MIN and DMA_RX_DLY must both be consistent according to
    150           * the min & max expected baud rate.
    151           */
    152          #if !defined( SAFE_RX_MIN )
    153            #define SAFE_RX_MIN  48  // bytes - max expected per poll @ 115.2k
    154            // 16 bytes @ 38.4 kBaud -> 4.16 msecs -> 138 32-kHz ticks.
    155            #define DMA_RX_DLY  140
    156            //  2 bytes @ 38.4 kBaud -> 0.52 msecs ->  17 32-kHz ticks.
    157            #define DMA_TX_DLY   20
    158          #endif
    159          
    160          // The timeout tick is at 32-kHz, so multiply msecs by 33.
    161          #define RX_MSECS_TO_TICKS  33
    162          
    163          // The timeout only supports 1 byte.
    164          #if !defined( HAL_UART_RX_IDLE )
    165            #define HAL_UART_RX_IDLE  (6 * RX_MSECS_TO_TICKS)
    166          #endif
    167          
    168          // Only supporting 1 of the 2 USART modules to be driven by DMA at a time.
    169          #if HAL_UART_DMA == 1
    170            #define DMATRIG_RX  HAL_DMA_TRIG_URX0
    171            #define DMATRIG_TX  HAL_DMA_TRIG_UTX0
    172            #define DMA_UDBUF   HAL_DMA_U0DBUF
    173            #define DMA_PAD     U0BAUD
    174          #elif HAL_UART_DMA == 2
    175            #define DMATRIG_RX  HAL_DMA_TRIG_URX1
    176            #define DMATRIG_TX  HAL_DMA_TRIG_UTX1
    177            #define DMA_UDBUF   HAL_DMA_U1DBUF
    178            #define DMA_PAD     U1BAUD
    179          #endif
    180          
    181          #define DMA_RX( cfg ) { \
    182            volatile uint8 ft2430 = U0DBUF; \
    183            \
    184            halDMADesc_t *ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_RX ); \
    185            \
    186            HAL_DMA_SET_DEST( ch, cfg->rxBuf ); \
    187            \
    188            HAL_DMA_SET_LEN( ch, cfg->rxMax ); \
    189            \
    190            HAL_DMA_CLEAR_IRQ( HAL_DMA_CH_RX ); \
    191            \
    192            HAL_DMA_ARM_CH( HAL_DMA_CH_RX ); \
    193          }
    194          
    195          #define DMA_TX( cfg ) { \
    196            halDMADesc_t *ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_TX ); \
    197            \
    198            HAL_DMA_SET_SOURCE( ch, (cfg->txBuf + cfg->txTail) ); \
    199            \
    200            HAL_DMA_SET_LEN( ch, cfg->txCnt ); \
    201            \
    202            HAL_DMA_CLEAR_IRQ( HAL_DMA_CH_TX ); \
    203            \
    204            HAL_DMA_ARM_CH( HAL_DMA_CH_TX ); \
    205            \
    206            HAL_DMA_START_CH( HAL_DMA_CH_TX ); \
    207          }
    208          
    209          /*********************************************************************
    210           * TYPEDEFS
    211           */
    212          
    213          typedef struct
    214          {
    215            uint8 *rxBuf;
    216            uint8 rxHead;
    217            uint8 rxTail;
    218            uint8 rxMax;
    219            uint8 rxCnt;
    220            uint8 rxTick;
    221            uint8 rxHigh;
    222          
    223            uint8 *txBuf;
    224          #if HAL_UART_BIG_TX_BUF
    225            uint16 txHead;
    226            uint16 txTail;
    227            uint16 txMax;
    228            uint16 txCnt;
    229          #else
    230            uint8 txHead;
    231            uint8 txTail;
    232            uint8 txMax;
    233            uint8 txCnt;
    234          #endif
    235            uint8 txTick;
    236          
    237            uint8 flag;
    238          
    239            halUARTCBack_t rxCB;
    240          } uartCfg_t;
    241          
    242          /*********************************************************************
    243           * CONSTANTS
    244           */
    245          
    246          // Used by DMA macros to shift 1 to create a mask for DMA registers.
    247          #define HAL_DMA_CH_TX    3
    248          #define HAL_DMA_CH_RX    4
    249          
    250          #define HAL_DMA_U0DBUF  0xDFC1
    251          #define HAL_DMA_U1DBUF  0xDFF9
    252          
    253          // UxCSR - USART Control and Status Register.
    254          #define CSR_MODE      0x80
    255          #define CSR_RE        0x40
    256          #define CSR_SLAVE     0x20
    257          #define CSR_FE        0x10
    258          #define CSR_ERR       0x08
    259          #define CSR_RX_BYTE   0x04
    260          #define CSR_TX_BYTE   0x02
    261          #define CSR_ACTIVE    0x01
    262          
    263          // UxUCR - USART UART Control Register.
    264          #define UCR_FLUSH     0x80
    265          #define UCR_FLOW      0x40
    266          #define UCR_D9        0x20
    267          #define UCR_BIT9      0x10
    268          #define UCR_PARITY    0x08
    269          #define UCR_SPB       0x04
    270          #define UCR_STOP      0x02
    271          #define UCR_START     0x01
    272          
    273          #define UTX0IE        0x04
    274          #define UTX1IE        0x08
    275          
    276          #define UART_CFG_U1F  0x80  // USART1 flag bit.
    277          #define UART_CFG_DMA  0x40  // Port is using DMA.
    278          #define UART_CFG_FLW  0x20  // Port is using flow control.
    279          #define UART_CFG_SP4  0x10
    280          #define UART_CFG_SP3  0x08
    281          #define UART_CFG_SP2  0x04
    282          #define UART_CFG_RXF  0x02  // Rx flow is disabled.
    283          #define UART_CFG_TXF  0x01  // Tx is in process.
    284          
    285          /*********************************************************************
    286           * GLOBAL VARIABLES
    287           */
    288          
    289          /*********************************************************************
    290           * GLOBAL FUNCTIONS
    291           */
    292          
    293          /*********************************************************************
    294           * LOCAL VARIABLES
    295           */
    296          
    297          #if HAL_UART_0_ENABLE

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    298          static uartCfg_t *cfg0;
   \                     cfg0:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    299          #endif
    300          #if HAL_UART_1_ENABLE
    301          static uartCfg_t *cfg1;
    302          #endif
    303          
    304          /*********************************************************************
    305           * LOCAL FUNCTIONS
    306           */
    307          
    308          #if HAL_UART_DMA
    309          static void pollDMA( uartCfg_t *cfg );
    310          #endif
    311          #if HAL_UART_ISR
    312          static void pollISR( uartCfg_t *cfg );
    313          #endif
    314          
    315          #if HAL_UART_DMA
    316          /******************************************************************************
    317           * @fn      pollDMA
    318           *
    319           * @brief   Poll a USART module implemented by DMA.
    320           *
    321           * @param   cfg - USART configuration structure.
    322           *
    323           * @return  none
    324           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    325          static void pollDMA( uartCfg_t *cfg )
   \                     pollDMA:
    326          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    327            const uint8 cnt = cfg->rxHead;
   \   00000E   EE           MOV     A,R6
   \   00000F   2402         ADD     A,#0x2
   \   000011   0A           INC     R2
   \   000012   0A           INC     R2
   \   000013   12....       LCALL   ?Subroutine4 & 0xFFFF
    328            uint8 *pad = cfg->rxBuf+(cfg->rxHead*2);
   \                     ??CrossCallReturnLabel_9:
   \   000016   C3           CLR     C
   \   000017   33           RLC     A
   \   000018   F8           MOV     R0,A
   \   000019   E4           CLR     A
   \   00001A   33           RLC     A
   \   00001B   F9           MOV     R1,A
   \   00001C   8E82         MOV     DPL,R6
   \   00001E   8F83         MOV     DPH,R7
   \   000020   E0           MOVX    A,@DPTR
   \   000021   28           ADD     A,R0
   \   000022   F8           MOV     R0,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   39           ADDC    A,R1
   \   000026   8035         SJMP    ??pollDMA_0
    329          
    330            // Pack the received bytes to the front of the queue.
    331            while ( (*pad == DMA_PAD) && (cfg->rxHead < cfg->rxMax) )
    332            {
    333              cfg->rxBuf[cfg->rxHead++] = *(pad+1);
   \                     ??pollDMA_1:
   \   000028   EE           MOV     A,R6
   \   000029   2402         ADD     A,#0x2
   \   00002B   FA           MOV     R2,A
   \   00002C   8882         MOV     DPL,R0
   \   00002E   8983         MOV     DPH,R1
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   C0E0         PUSH    A
   \   000034   8A82         MOV     DPL,R2
   \   000036   8B83         MOV     DPH,R3
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5..         MOV     ?V0 + 0,A
   \   00003B   8E82         MOV     DPL,R6
   \   00003D   8F83         MOV     DPH,R7
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   25..         ADD     A,?V0 + 0
   \   000042   FD           MOV     R5,A
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   3400         ADDC    A,#0x0
   \   000047   8D82         MOV     DPL,R5
   \   000049   F583         MOV     DPH,A
   \   00004B   D0E0         POP     A
   \   00004D   F0           MOVX    @DPTR,A
   \   00004E   8A82         MOV     DPL,R2
   \   000050   8B83         MOV     DPH,R3
   \   000052   E0           MOVX    A,@DPTR
   \   000053   04           INC     A
   \   000054   F0           MOVX    @DPTR,A
    334              pad += 2;
   \   000055   E8           MOV     A,R0
   \   000056   2402         ADD     A,#0x2
   \   000058   08           INC     R0
   \   000059   08           INC     R0
   \   00005A   E9           MOV     A,R1
   \   00005B   3400         ADDC    A,#0x0
   \                     ??pollDMA_0:
   \   00005D   F9           MOV     R1,A
    335            }
   \   00005E   8882         MOV     DPL,R0
   \   000060   8983         MOV     DPH,R1
   \   000062   E0           MOVX    A,@DPTR
   \   000063   65C2         XRL     A,0xc2
   \   000065   7019         JNZ     ??pollDMA_2
   \   000067   8E82         MOV     DPL,R6
   \   000069   8F83         MOV     DPH,R7
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   C0E0         PUSH    A
   \   000070   8E82         MOV     DPL,R6
   \   000072   8F83         MOV     DPH,R7
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   E0           MOVX    A,@DPTR
   \   000079   FA           MOV     R2,A
   \   00007A   D0E0         POP     A
   \   00007C   C3           CLR     C
   \   00007D   9A           SUBB    A,R2
   \   00007E   40A8         JC      ??pollDMA_1
    336          
    337            if ( !(cfg->flag & UART_CFG_RXF) )
   \                     ??pollDMA_2:
   \   000080   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000083   A2E1         MOV     C,0xE0 /* A   */.1
   \   000085   8E82         MOV     DPL,R6
   \   000087   8F83         MOV     DPH,R7
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   4042         JC      ??pollDMA_3
    338            {
    339              /* It is necessary to stop Rx flow and wait for H/W-enqueued bytes still
    340               * incoming to stop before resetting the DMA Rx engine. If DMA Rx is
    341               * aborted during incoming data, a byte may be lost inside the engine
    342               * during the 2-step transfer process of read/write.
    343               */
    344              if ( cfg->rxHead >= (cfg->rxMax - SAFE_RX_MIN) )
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   FA           MOV     R2,A
   \   00008F   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000092   4023         JC      ??pollDMA_4
    345              {
    346                RX_STOP_FLOW( cfg );
   \   000094   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000097   4004         JC      ??pollDMA_5
   \   000099   D285         SETB    0x80.5
   \   00009B   8002         SJMP    ??pollDMA_6
   \                     ??pollDMA_5:
   \   00009D   D295         SETB    0x90.5
   \                     ??pollDMA_6:
   \   00009F   A2E6         MOV     C,0xE0 /* A   */.6
   \   0000A1   500D         JNC     ??pollDMA_7
   \   0000A3   748C         MOV     A,#-0x74
   \   0000A5   8E82         MOV     DPL,R6
   \   0000A7   8F83         MOV     DPH,R7
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   F0           MOVX    @DPTR,A
   \                     ??pollDMA_7:
   \   0000B0   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000B3   D2E1         SETB    0xE0 /* A   */.1
   \   0000B5   8057         SJMP    ??pollDMA_8
    347              }
    348              // If anything received, reset the Rx idle timer.
    349              else if ( cfg->rxHead != cnt )
   \                     ??pollDMA_4:
   \   0000B7   8E82         MOV     DPL,R6
   \   0000B9   8F83         MOV     DPH,R7
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   6C           XRL     A,R4
   \   0000BF   604E         JZ      ??pollDMA_9
    350              {
    351                cfg->rxTick = HAL_UART_RX_IDLE;
   \   0000C1   74C6         MOV     A,#-0x3a
   \   0000C3   8E82         MOV     DPL,R6
   \   0000C5   8F83         MOV     DPH,R7
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   A3           INC     DPTR
   \   0000CD   803F         SJMP    ??pollDMA_8
    352              }
    353            }
    354            else if ( !cfg->rxTick && (cfg->rxHead == cfg->rxTail) )
   \                     ??pollDMA_3:
   \   0000CF   A3           INC     DPTR
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   A3           INC     DPTR
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   7039         JNZ     ??pollDMA_9
   \   0000D6   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   0000D9   7034         JNZ     ??pollDMA_9
    355            {
    356              HAL_DMA_ABORT_CH( HAL_DMA_CH_RX );
   \   0000DB   75D690       MOV     0xd6,#-0x70
    357              cfg->rxHead = cfg->rxTail = 0;
   \   0000DE   12....       LCALL   ?Subroutine16 & 0xFFFF
    358              osal_memset( cfg->rxBuf, ~DMA_PAD, cfg->rxMax*2 );
   \                     ??CrossCallReturnLabel_49:
   \   0000E1   2404         ADD     A,#0x4
   \   0000E3   F5..         MOV     ?V0 + 0,A
   \   0000E5   EF           MOV     A,R7
   \   0000E6   3400         ADDC    A,#0x0
   \   0000E8   F5..         MOV     ?V0 + 1,A
   \   0000EA                ; Setup parameters for call to function osal_memset
   \   0000EA   85..82       MOV     DPL,?V0 + 0
   \   0000ED   F583         MOV     DPH,A
   \   0000EF   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   0000F2   A3           INC     DPTR
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   FB           MOV     R3,A
   \   0000F5   12....       LCALL   ?Subroutine10 & 0xFFFF
    359              DMA_RX( cfg );
   \                     ??CrossCallReturnLabel_39:
   \   0000F8   85..82       MOV     DPL,?V0 + 0
   \   0000FB   85..83       MOV     DPH,?V0 + 1
   \   0000FE   12....       LCALL   ?Subroutine8 & 0xFFFF
    360              RX_STRT_FLOW( cfg );
   \                     ??CrossCallReturnLabel_35:
   \   000101   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000104   4004         JC      ??pollDMA_10
   \   000106   C285         CLR     0x80.5
   \   000108   8002         SJMP    ??pollDMA_11
   \                     ??pollDMA_10:
   \   00010A   C295         CLR     0x90.5
   \                     ??pollDMA_11:
   \   00010C   C2E1         CLR     0xE0 /* A   */.1
   \                     ??pollDMA_8:
   \   00010E   F0           MOVX    @DPTR,A
    361            }
    362          
    363            if ( HAL_DMA_CHECK_IRQ( HAL_DMA_CH_TX ) )
   \                     ??pollDMA_9:
   \   00010F   E5D1         MOV     A,0xd1
   \   000111   A2E3         MOV     C,0xE0 /* A   */.3
   \   000113   5048         JNC     ??pollDMA_12
    364            {
    365              HAL_DMA_CLEAR_IRQ( HAL_DMA_CH_TX );
   \   000115   53D1F7       ANL     0xd1,#0xf7
    366              cfg->flag &= ~UART_CFG_TXF;
   \   000118   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   00011B   C2E0         CLR     0xE0 /* A   */.0
   \   00011D   F0           MOVX    @DPTR,A
    367              cfg->txTick = DMA_TX_DLY;
   \   00011E   EE           MOV     A,R6
   \   00011F   240E         ADD     A,#0xe
   \   000121   12....       LCALL   ??Subroutine21_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000124   7414         MOV     A,#0x14
   \   000126   F0           MOVX    @DPTR,A
    368          
    369              if ( (cfg->txMax - cfg->txCnt) < cfg->txTail )
   \   000127   EE           MOV     A,R6
   \   000128   240C         ADD     A,#0xc
   \   00012A   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   00012D   F8           MOV     R0,A
   \   00012E   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000131   E8           MOV     A,R0
   \   000132   C3           CLR     C
   \   000133   9A           SUBB    A,R2
   \   000134   F8           MOV     R0,A
   \   000135   E4           CLR     A
   \   000136   9400         SUBB    A,#0x0
   \   000138   F9           MOV     R1,A
   \   000139   EE           MOV     A,R6
   \   00013A   240B         ADD     A,#0xb
   \   00013C   12....       LCALL   ??Subroutine2_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   00013F   C3           CLR     C
   \   000140   E8           MOV     A,R0
   \   000141   9A           SUBB    A,R2
   \   000142   E9           MOV     A,R1
   \   000143   9400         SUBB    A,#0x0
   \   000145   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000147   65D0         XRL     A,PSW
   \   000149   33           RLC     A
   \   00014A   5005         JNC     ??pollDMA_13
    370              {
    371                cfg->txTail = 0;  // DMA can only run to the end of the Tx buffer.
   \   00014C   E4           CLR     A
   \                     ??pollDMA_14:
   \   00014D   F0           MOVX    @DPTR,A
   \   00014E   02....       LJMP    ??pollDMA_15 & 0xFFFF
    372              }
    373              else
    374              {
    375                cfg->txTail += cfg->txCnt;
   \                     ??pollDMA_13:
   \   000151   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000154   EE           MOV     A,R6
   \   000155   240B         ADD     A,#0xb
   \   000157   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   00015A   2A           ADD     A,R2
   \   00015B   80F0         SJMP    ??pollDMA_14
    376              }
    377            }
    378            else if ( !(cfg->flag & UART_CFG_TXF) && !cfg->txTick )
   \                     ??pollDMA_12:
   \   00015D   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000160   A2E0         MOV     C,0xE0 /* A   */.0
   \   000162   5003         JNC     $+5
   \   000164   02....       LJMP    ??pollDMA_15 & 0xFFFF
   \   000167   EE           MOV     A,R6
   \   000168   240E         ADD     A,#0xe
   \   00016A   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   00016D   6003         JZ      $+5
   \   00016F   02....       LJMP    ??pollDMA_15 & 0xFFFF
    379            {
    380              if ( cfg->txTail != cfg->txHead )
   \   000172   EE           MOV     A,R6
   \   000173   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000176   6A           XRL     A,R2
   \   000177   7003         JNZ     $+5
   \   000179   02....       LJMP    ??pollDMA_15 & 0xFFFF
    381              {
    382                if ( cfg->txTail < cfg->txHead )
   \   00017C   EE           MOV     A,R6
   \   00017D   240B         ADD     A,#0xb
   \   00017F   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000182   C0E0         PUSH    A
   \   000184   8E82         MOV     DPL,R6
   \   000186   8F83         MOV     DPH,R7
   \   000188   A3           INC     DPTR
   \   000189   A3           INC     DPTR
   \   00018A   A3           INC     DPTR
   \   00018B   A3           INC     DPTR
   \   00018C   A3           INC     DPTR
   \   00018D   A3           INC     DPTR
   \   00018E   A3           INC     DPTR
   \   00018F   A3           INC     DPTR
   \   000190   A3           INC     DPTR
   \   000191   A3           INC     DPTR
   \   000192   E0           MOVX    A,@DPTR
   \   000193   FA           MOV     R2,A
   \   000194   D0E0         POP     A
   \   000196   C3           CLR     C
   \   000197   9A           SUBB    A,R2
   \   000198   EE           MOV     A,R6
   \   000199   5007         JNC     ??pollDMA_16
    383                {
    384                  cfg->txCnt = cfg->txHead - cfg->txTail;
   \   00019B   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   00019E   C3           CLR     C
   \   00019F   9A           SUBB    A,R2
   \   0001A0   800E         SJMP    ??pollDMA_17
    385                }
    386                else  // Can only run DMA engine up to max, then restart at zero.
    387                {
    388                  cfg->txCnt = cfg->txMax - cfg->txTail + 1;
   \                     ??pollDMA_16:
   \   0001A2   240B         ADD     A,#0xb
   \   0001A4   12....       LCALL   ??Subroutine2_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0001A7   EE           MOV     A,R6
   \   0001A8   240C         ADD     A,#0xc
   \   0001AA   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   0001AD   C3           CLR     C
   \   0001AE   9A           SUBB    A,R2
   \   0001AF   04           INC     A
   \                     ??pollDMA_17:
   \   0001B0   C0E0         PUSH    A
   \   0001B2   EE           MOV     A,R6
   \   0001B3   240D         ADD     A,#0xd
   \   0001B5   12....       LCALL   ??Subroutine21_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   0001B8   D0E0         POP     A
   \   0001BA   F0           MOVX    @DPTR,A
    389                }
    390          
    391                cfg->flag |= UART_CFG_TXF;
   \   0001BB   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0001BE   D2E0         SETB    0xE0 /* A   */.0
   \   0001C0   F0           MOVX    @DPTR,A
    392                DMA_TX( cfg );
   \   0001C1   EE           MOV     A,R6
   \   0001C2   2408         ADD     A,#0x8
   \   0001C4   F8           MOV     R0,A
   \   0001C5   EF           MOV     A,R7
   \   0001C6   3400         ADDC    A,#0x0
   \   0001C8   F9           MOV     R1,A
   \   0001C9   EE           MOV     A,R6
   \   0001CA   240B         ADD     A,#0xb
   \   0001CC   FA           MOV     R2,A
   \   0001CD   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   0001D0   8882         MOV     DPL,R0
   \   0001D2   8983         MOV     DPH,R1
   \   0001D4   E0           MOVX    A,@DPTR
   \   0001D5   2C           ADD     A,R4
   \   0001D6   A3           INC     DPTR
   \   0001D7   E0           MOVX    A,@DPTR
   \   0001D8   3400         ADDC    A,#0x0
   \   0001DA   90....       MOV     DPTR,#(dmaCh1234 + 16)
   \   0001DD   F0           MOVX    @DPTR,A
   \   0001DE   8A82         MOV     DPL,R2
   \   0001E0   8B83         MOV     DPH,R3
   \   0001E2   E0           MOVX    A,@DPTR
   \   0001E3   FA           MOV     R2,A
   \   0001E4   8882         MOV     DPL,R0
   \   0001E6   8983         MOV     DPH,R1
   \   0001E8   E0           MOVX    A,@DPTR
   \   0001E9   2A           ADD     A,R2
   \   0001EA   90....       MOV     DPTR,#(dmaCh1234 + 17)
   \   0001ED   F0           MOVX    @DPTR,A
   \   0001EE   EE           MOV     A,R6
   \   0001EF   240D         ADD     A,#0xd
   \   0001F1   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   0001F4   90....       MOV     DPTR,#(dmaCh1234 + 21)
   \   0001F7   F0           MOVX    @DPTR,A
   \   0001F8   90....       MOV     DPTR,#(dmaCh1234 + 20)
   \   0001FB   E0           MOVX    A,@DPTR
   \   0001FC   54E0         ANL     A,#0xe0
   \   0001FE   F0           MOVX    @DPTR,A
   \   0001FF   53D1F7       ANL     0xd1,#0xf7
   \   000202   75D608       MOV     0xd6,#0x8
   \   000205   75D708       MOV     0xd7,#0x8
    393              }
    394            }
    395          }
   \                     ??pollDMA_15:
   \   000208   7401         MOV     A,#0x1
   \   00020A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00020D   7F02         MOV     R7,#0x2
   \   00020F   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000212                REQUIRE _A_P0
   \   000212                REQUIRE _A_P1
   \   000212                REQUIRE U0DBUF
   \   000212                REQUIRE U0BAUD
   \   000212                REQUIRE DMAIRQ
   \   000212                REQUIRE DMAARM
   \   000212                REQUIRE DMAREQ

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   EF           MOV     A,R7
   \   000001   3400         ADDC    A,#0x0
   \   000003   FB           MOV     R3,A
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FC           MOV     R4,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   EE           MOV     A,R6
   \   000001   240D         ADD     A,#0xd
   \                     ??Subroutine2_0:
   \   000003   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000006   FA           MOV     R2,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000003   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A                REQUIRE ?Subroutine22
   \   00000A                ; // Fall through to label ?Subroutine22

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   240B         ADD     A,#0xb
   \                     ??Subroutine21_0:
   \   000002   F582         MOV     DPL,A
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   F583         MOV     DPH,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E4           CLR     A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   EE           MOV     A,R6
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ??osal_memset?relay
   \   000003   E5C1         MOV     A,0xc1
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   90....       MOV     DPTR,#(dmaCh1234 + 26)
   \   000012   F0           MOVX    @DPTR,A
   \   000013   8E82         MOV     DPL,R6
   \   000015   8F83         MOV     DPH,R7
   \   000017   E0           MOVX    A,@DPTR
   \   000018   90....       MOV     DPTR,#(dmaCh1234 + 27)
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C3           CLR     C
   \   000002   33           RLC     A
   \   000003   FC           MOV     R4,A
   \   000004   E4           CLR     A
   \   000005   33           RLC     A
   \   000006   FD           MOV     R5,A
   \   000007   E5C2         MOV     A,0xc2
   \   000009   F4           CPL     A
   \   00000A   F9           MOV     R1,A
   \   00000B   8E82         MOV     DPL,R6
   \   00000D   8F83         MOV     DPH,R7
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FA           MOV     R2,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   90....       MOV     DPTR,#(dmaCh1234 + 29)
   \   000004   F0           MOVX    @DPTR,A
   \   000005   90....       MOV     DPTR,#(dmaCh1234 + 28)
   \   000008   E0           MOVX    A,@DPTR
   \   000009   54E0         ANL     A,#0xe0
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   53D1EF       ANL     0xd1,#0xef
   \   00000F   75D610       MOV     0xd6,#0x10
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   6A           XRL     A,R2
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   8E82         MOV     DPL,R6
   \   000004   8F83         MOV     DPH,R7
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   EE           MOV     A,R6
   \   000001   240F         ADD     A,#0xf
   \   000003   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000006   A2E7         MOV     C,0xE0 /* A   */.7
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F8           MOV     R0,A
   \   00000A   74D0         MOV     A,#-0x30
   \   00000C   28           ADD     A,R0
   \   00000D   F8           MOV     R0,A
   \   00000E   74FF         MOV     A,#-0x1
   \   000010   3400         ADDC    A,#0x0
   \   000012   F9           MOV     R1,A
   \   000013   C3           CLR     C
   \   000014   EA           MOV     A,R2
   \   000015   98           SUBB    A,R0
   \   000016   E4           CLR     A
   \   000017   99           SUBB    A,R1
   \   000018   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00001A   65D0         XRL     A,PSW
   \   00001C   33           RLC     A
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   EE           MOV     A,R6
   \   000001   240F         ADD     A,#0xf
   \                     ??Subroutine7_0:
   \   000003   F582         MOV     DPL,A
   \   000005   EF           MOV     A,R7
   \                     ??Subroutine7_1:
   \   000006   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   F582         MOV     DPL,A
   \   000002   EF           MOV     A,R7
   \                     ??Subroutine20_0:
   \   000003   3400         ADDC    A,#0x0
   \   000005   F583         MOV     DPH,A
   \   000007   E0           MOVX    A,@DPTR
   \   000008   22           RET
    396          #endif
    397          
    398          #if HAL_UART_ISR
    399          /******************************************************************************
    400           * @fn      pollISR
    401           *
    402           * @brief   Poll a USART module implemented by ISR.
    403           *
    404           * @param   cfg - USART configuration structure.
    405           *
    406           * @return  none
    407           *****************************************************************************/
    408          static void pollISR( uartCfg_t *cfg )
    409          {
    410            uint8 cnt = UART_RX_AVAIL( cfg );
    411          
    412            if ( !(cfg->flag & UART_CFG_RXF) )
    413            {
    414              // If anything received, reset the Rx idle timer.
    415              if ( cfg->rxCnt != cnt )
    416              {
    417                cfg->rxTick = HAL_UART_RX_IDLE;
    418                cfg->rxCnt = cnt;
    419              }
    420          
    421              /* It is necessary to stop Rx flow in advance of a full Rx buffer because
    422               * bytes can keep coming while sending H/W fifo flushes.
    423               */
    424              if ( cfg->rxCnt >= (cfg->rxMax - SAFE_RX_MIN) )
    425              {
    426                RX_STOP_FLOW( cfg );
    427              }
    428            }
    429          }
    430          #endif
    431          
    432          /******************************************************************************
    433           * @fn      HalUARTInit
    434           *
    435           * @brief   Initialize the UART
    436           *
    437           * @param   none
    438           *
    439           * @return  none
    440           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    441          void HalUARTInit( void )
   \                     HalUARTInit:
    442          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    443          #if HAL_UART_DMA
    444            halDMADesc_t *ch;
    445          #endif
    446          
    447            // Set P2 priority - USART0 over USART1 if both are defined.
    448            P2DIR &= ~P2DIR_PRIPO;
   \   000004   53FF3F       ANL     0xff,#0x3f
   \   000007   E5FF         MOV     A,0xff
    449            P2DIR |= HAL_UART_PRIPO;
   \   000009   85FFFF       MOV     0xff,0xff
    450          
    451          #if HAL_UART_0_ENABLE
    452            // Set UART0 I/O location to P0.
    453            PERCFG &= ~HAL_UART_0_PERCFG_BIT;
   \   00000C   53F1FE       ANL     0xf1,#0xfe
    454          
    455            /* Enable Tx and Rx on P0 */
    456            P0SEL |= HAL_UART_0_P0_RX_TX;
   \   00000F   43F30C       ORL     0xf3,#0xc
   \   000012   E5F3         MOV     A,0xf3
    457          
    458            /* Make sure ADC doesnt use this */
    459            ADCCFG &= ~HAL_UART_0_P0_RX_TX;
   \   000014   53F2F3       ANL     0xf2,#0xf3
   \   000017   E5F2         MOV     A,0xf2
    460          
    461            /* Mode is UART Mode */
    462            U0CSR = CSR_MODE;
   \   000019   758680       MOV     0x86,#-0x80
    463          
    464            /* Flush it */
    465            U0UCR = UCR_FLUSH;
   \   00001C   75C480       MOV     0xc4,#-0x80
    466          #endif
    467          
    468          #if HAL_UART_1_ENABLE
    469            // Set UART1 I/O location to P1.
    470            PERCFG |= HAL_UART_1_PERCFG_BIT;
    471          
    472            /* Enable Tx and Rx on P1 */
    473            P1SEL  |= HAL_UART_1_P1_RX_TX;
    474          
    475            /* Make sure ADC doesnt use this */
    476            ADCCFG &= ~HAL_UART_1_P1_RX_TX;
    477          
    478            /* Mode is UART Mode */
    479            U1CSR = CSR_MODE;
    480          
    481            /* Flush it */
    482            U1UCR = UCR_FLUSH;
    483          #endif
    484          
    485          #if HAL_UART_DMA
    486            // Setup Tx by DMA.
    487            ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_TX );
    488          
    489            // The start address of the destination.
    490            HAL_DMA_SET_DEST( ch, DMA_UDBUF );
   \   00001F   74DF         MOV     A,#-0x21
   \   000021   90....       MOV     DPTR,#(dmaCh1234 + 18)
   \   000024   F0           MOVX    @DPTR,A
   \   000025   74C1         MOV     A,#-0x3f
   \   000027   90....       MOV     DPTR,#(dmaCh1234 + 19)
   \   00002A   F0           MOVX    @DPTR,A
    491          
    492            // Using the length field to determine how many bytes to transfer.
    493            HAL_DMA_SET_VLEN( ch, HAL_DMA_VLEN_USE_LEN );
   \   00002B   90....       MOV     DPTR,#(dmaCh1234 + 20)
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   541F         ANL     A,#0x1f
   \   000031   F0           MOVX    @DPTR,A
    494          
    495            // One byte is transferred each time.
    496            HAL_DMA_SET_WORD_SIZE( ch, HAL_DMA_WORDSIZE_BYTE );
    497          
    498            // The bytes are transferred 1-by-1 on Tx Complete trigger.
    499            HAL_DMA_SET_TRIG_MODE( ch, HAL_DMA_TMODE_SINGLE );
    500            HAL_DMA_SET_TRIG_SRC( ch, DMATRIG_TX );
   \   000032   740F         MOV     A,#0xf
   \   000034   90....       MOV     DPTR,#(dmaCh1234 + 22)
   \   000037   F0           MOVX    @DPTR,A
    501          
    502            // The source address is decremented by 1 byte after each transfer.
    503            HAL_DMA_SET_SRC_INC( ch, HAL_DMA_SRCINC_1 );
    504          
    505            // The destination address is constant - the Tx Data Buffer.
    506            HAL_DMA_SET_DST_INC( ch, HAL_DMA_DSTINC_0 );
    507          
    508            // The DMA is to be polled and shall not issue an IRQ upon completion.
    509            HAL_DMA_SET_IRQ( ch, HAL_DMA_IRQMASK_DISABLE );
    510          
    511            // Xfer all 8 bits of a byte xfer.
    512            HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS );
    513          
    514            // DMA Tx has shared priority for memory access - every other one.
    515            HAL_DMA_SET_PRIORITY( ch, HAL_DMA_PRI_HIGH );
   \   000038   7442         MOV     A,#0x42
   \   00003A   90....       MOV     DPTR,#(dmaCh1234 + 23)
   \   00003D   F0           MOVX    @DPTR,A
    516          
    517            // Setup Rx by DMA.
    518            ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_RX );
    519          
    520            // The start address of the source.
    521            HAL_DMA_SET_SOURCE( ch, DMA_UDBUF );
   \   00003E   74DF         MOV     A,#-0x21
   \   000040   90....       MOV     DPTR,#(dmaCh1234 + 24)
   \   000043   F0           MOVX    @DPTR,A
   \   000044   74C1         MOV     A,#-0x3f
   \   000046   90....       MOV     DPTR,#(dmaCh1234 + 25)
   \   000049   F0           MOVX    @DPTR,A
    522          
    523            // Using the length field to determine how many bytes to transfer.
    524            HAL_DMA_SET_VLEN( ch, HAL_DMA_VLEN_USE_LEN );
   \   00004A   90....       MOV     DPTR,#(dmaCh1234 + 28)
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   541F         ANL     A,#0x1f
   \   000050   F0           MOVX    @DPTR,A
    525          
    526            /* The trick is to cfg DMA to xfer 2 bytes for every 1 byte of Rx.
    527             * The byte after the Rx Data Buffer is the Baud Cfg Register,
    528             * which always has a known value. So init Rx buffer to inverse of that
    529             * known value. DMA word xfer will flip the bytes, so every valid Rx byte
    530             * in the Rx buffer will be preceded by a DMA_PAD char equal to the
    531             * Baud Cfg Register value.
    532             */
    533            HAL_DMA_SET_WORD_SIZE( ch, HAL_DMA_WORDSIZE_WORD );
    534          
    535            // The bytes are transferred 1-by-1 on Rx Complete trigger.
    536            HAL_DMA_SET_TRIG_MODE( ch, HAL_DMA_TMODE_SINGLE );
    537            HAL_DMA_SET_TRIG_SRC( ch, DMATRIG_RX );
   \   000051   748E         MOV     A,#-0x72
   \   000053   90....       MOV     DPTR,#(dmaCh1234 + 30)
   \   000056   F0           MOVX    @DPTR,A
    538          
    539            // The source address is constant - the Rx Data Buffer.
    540            HAL_DMA_SET_SRC_INC( ch, HAL_DMA_SRCINC_0 );
    541          
    542            // The destination address is incremented by 1 word after each transfer.
    543            HAL_DMA_SET_DST_INC( ch, HAL_DMA_DSTINC_1 );
    544          
    545            // The DMA is to be polled and shall not issue an IRQ upon completion.
    546            HAL_DMA_SET_IRQ( ch, HAL_DMA_IRQMASK_DISABLE );
    547          
    548            // Xfer all 8 bits of a byte xfer.
    549            HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS );
    550          
    551            // DMA has highest priority for memory access.
    552            HAL_DMA_SET_PRIORITY( ch, HAL_DMA_PRI_HIGH );
   \   000057   7412         MOV     A,#0x12
   \   000059   90....       MOV     DPTR,#(dmaCh1234 + 31)
   \   00005C   F0           MOVX    @DPTR,A
    553          #endif
    554          }
   \   00005D                REQUIRE ?Subroutine23
   \   00005D                REQUIRE U0CSR
   \   00005D                REQUIRE U0UCR
   \   00005D                REQUIRE PERCFG
   \   00005D                REQUIRE ADCCFG
   \   00005D                REQUIRE P0SEL
   \   00005D                REQUIRE P2DIR
   \   00005D                ; // Fall through to label ?Subroutine23

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    555          
    556          /******************************************************************************
    557           * @fn      HalUARTOpen
    558           *
    559           * @brief   Open a port according tp the configuration specified by parameter.
    560           *
    561           * @param   port   - UART port
    562           *          config - contains configuration information
    563           *
    564           * @return  Status of the function call
    565           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    566          uint8 HalUARTOpen( uint8 port, halUARTCfg_t *config )
   \                     HalUARTOpen:
    567          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 2,R1
   \   00000C   8A..         MOV     ?V0 + 0,R2
   \   00000E   8B..         MOV     ?V0 + 1,R3
    568            uartCfg_t **cfgPP = NULL;
   \   000010   7E00         MOV     R6,#0x0
   \   000012   7F00         MOV     R7,#0x0
    569            uartCfg_t *cfg;
    570          
    571          #if HAL_UART_0_ENABLE
    572            if ( port == HAL_UART_PORT_0 )
   \   000014   E9           MOV     A,R1
   \   000015   7004         JNZ     ??HalUARTOpen_0
    573            {
    574              cfgPP = &cfg0;
   \   000017   7E..         MOV     R6,#(cfg0 & 0xff)
   \   000019   7F..         MOV     R7,#((cfg0 >> 8) & 0xff)
    575            }
    576          #endif
    577          
    578          #if HAL_UART_1_ENABLE
    579            if ( port == HAL_UART_PORT_1 )
    580            {
    581              cfgPP = &cfg1;
    582            }
    583          #endif
    584          
    585            HAL_UART_ASSERT( cfgPP );
    586          
    587          #if HAL_UART_CLOSE
    588            // Protect against user re-opening port before closing it.
    589            HalUARTClose( port );
    590          #else
    591            HAL_UART_ASSERT( *cfgPP == NULL );
    592          #endif
    593          
    594            HAL_UART_ASSERT( (config->baudRate == HAL_UART_BR_38400) ||
    595                             (config->baudRate == HAL_UART_BR_115200) );
    596          
    597            /* Whereas runtime heap alloc can be expected to fail - one-shot system
    598             * initialization must succeed, so no check for alloc fail.
    599             */
    600            *cfgPP = (uartCfg_t *)osal_mem_alloc( sizeof( uartCfg_t ) );
   \                     ??HalUARTOpen_0:
   \   00001B                ; Setup parameters for call to function osal_mem_alloc
   \   00001B   7A12         MOV     R2,#0x12
   \   00001D   7B00         MOV     R3,#0x0
   \   00001F   12....       LCALL   ?Subroutine17 & 0xFFFF
    601            cfg = *cfgPP;
   \                     ??CrossCallReturnLabel_51:
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FE           MOV     R6,A
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   FF           MOV     R7,A
    602            HAL_UART_ASSERT( cfg );
    603          
    604            cfg->rxMax = config->rx.maxBufSize;
   \   00002B   E5..         MOV     A,?V0 + 0
   \   00002D   240A         ADD     A,#0xa
   \   00002F   F5..         MOV     ?V0 + 4,A
   \   000031   E5..         MOV     A,?V0 + 1
   \   000033   3400         ADDC    A,#0x0
   \   000035   F5..         MOV     ?V0 + 5,A
   \   000037   85..82       MOV     DPL,?V0 + 4
   \   00003A   F583         MOV     DPH,A
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   8E82         MOV     DPL,R6
   \   00003F   8F83         MOV     DPH,R7
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   F0           MOVX    @DPTR,A
    605          
    606          #if !HAL_UART_BIG_TX_BUF
    607            HAL_UART_ASSERT( (config->tx.maxBufSize < 256) );
    608          #endif
    609            cfg->txMax = config->tx.maxBufSize;
   \   000046   EE           MOV     A,R6
   \   000047   240C         ADD     A,#0xc
   \   000049   F8           MOV     R0,A
   \   00004A   EF           MOV     A,R7
   \   00004B   3400         ADDC    A,#0x0
   \   00004D   F9           MOV     R1,A
   \   00004E   E5..         MOV     A,?V0 + 0
   \   000050   2412         ADD     A,#0x12
   \   000052   F582         MOV     DPL,A
   \   000054   E5..         MOV     A,?V0 + 1
   \   000056   12....       LCALL   ??Subroutine7_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000059   8882         MOV     DPL,R0
   \   00005B   8983         MOV     DPH,R1
   \   00005D   F0           MOVX    @DPTR,A
    610            cfg->txBuf = osal_mem_alloc( cfg->txMax+1 );
   \   00005E                ; Setup parameters for call to function osal_mem_alloc
   \   00005E   F8           MOV     R0,A
   \   00005F   7401         MOV     A,#0x1
   \   000061   28           ADD     A,R0
   \   000062   FA           MOV     R2,A
   \   000063   E4           CLR     A
   \   000064   3400         ADDC    A,#0x0
   \   000066   FB           MOV     R3,A
   \   000067   12....       LCALL   ??osal_mem_alloc?relay
   \   00006A   8E82         MOV     DPL,R6
   \   00006C   8F83         MOV     DPH,R7
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   EA           MOV     A,R2
   \   000077   F0           MOVX    @DPTR,A
   \   000078   A3           INC     DPTR
   \   000079   EB           MOV     A,R3
   \   00007A   F0           MOVX    @DPTR,A
    611          
    612            cfg->rxHead = cfg->rxTail = 0;
   \   00007B   12....       LCALL   ?Subroutine16 & 0xFFFF
    613            cfg->txHead = cfg->txTail = 0;
   \                     ??CrossCallReturnLabel_50:
   \   00007E   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000081   E4           CLR     A
   \   000082   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   F0           MOVX    @DPTR,A
    614            cfg->rxHigh = config->rx.maxBufSize - config->flowControlThreshold;
   \   00008A   85..82       MOV     DPL,?V0 + 0
   \   00008D   85..83       MOV     DPH,?V0 + 1
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   E0           MOVX    A,@DPTR
   \   000094   F8           MOV     R0,A
   \   000095   85..82       MOV     DPL,?V0 + 4
   \   000098   85..83       MOV     DPH,?V0 + 5
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   C3           CLR     C
   \   00009D   98           SUBB    A,R0
   \   00009E   8E82         MOV     DPL,R6
   \   0000A0   8F83         MOV     DPH,R7
   \   0000A2   A3           INC     DPTR
   \   0000A3   A3           INC     DPTR
   \   0000A4   A3           INC     DPTR
   \   0000A5   A3           INC     DPTR
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   F0           MOVX    @DPTR,A
    615            cfg->rxCB = config->callBackFunc;
   \   0000AA   E5..         MOV     A,?V0 + 0
   \   0000AC   241B         ADD     A,#0x1b
   \   0000AE   F582         MOV     DPL,A
   \   0000B0   E5..         MOV     A,?V0 + 1
   \   0000B2   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0000B5   F9           MOV     R1,A
   \   0000B6   EE           MOV     A,R6
   \   0000B7   2410         ADD     A,#0x10
   \   0000B9   12....       LCALL   ??Subroutine21_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   0000BC   E8           MOV     A,R0
   \   0000BD   F0           MOVX    @DPTR,A
   \   0000BE   A3           INC     DPTR
   \   0000BF   E9           MOV     A,R1
   \   0000C0   F0           MOVX    @DPTR,A
    616          
    617          #if HAL_UART_0_ENABLE
    618            if ( port == HAL_UART_PORT_0 )
   \   0000C1   E5..         MOV     A,?V0 + 2
   \   0000C3   6003         JZ      $+5
   \   0000C5   02....       LJMP    ??HalUARTOpen_1 & 0xFFFF
    619            {
    620              // Only supporting 38400 or 115200 for code size - other is possible.
    621              U0BAUD = (config->baudRate == HAL_UART_BR_38400) ? 59 : 216;
   \   0000C8   85..82       MOV     DPL,?V0 + 0
   \   0000CB   85..83       MOV     DPH,?V0 + 1
   \   0000CE   A3           INC     DPTR
   \   0000CF   E0           MOVX    A,@DPTR
   \   0000D0   6406         XRL     A,#0x6
   \   0000D2   7004         JNZ     ??HalUARTOpen_2
   \   0000D4   7A3B         MOV     R2,#0x3b
   \   0000D6   8002         SJMP    ??HalUARTOpen_3
   \                     ??HalUARTOpen_2:
   \   0000D8   7AD8         MOV     R2,#-0x28
   \                     ??HalUARTOpen_3:
   \   0000DA   8AC2         MOV     0xc2,R2
    622              U0GCR = (config->baudRate == HAL_UART_BR_38400) ? 10 : 11;
   \   0000DC   85..82       MOV     DPL,?V0 + 0
   \   0000DF   85..83       MOV     DPH,?V0 + 1
   \   0000E2   A3           INC     DPTR
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   6406         XRL     A,#0x6
   \   0000E6   7004         JNZ     ??HalUARTOpen_4
   \   0000E8   7A0A         MOV     R2,#0xa
   \   0000EA   8002         SJMP    ??HalUARTOpen_5
   \                     ??HalUARTOpen_4:
   \   0000EC   7A0B         MOV     R2,#0xb
   \                     ??HalUARTOpen_5:
   \   0000EE   8AC5         MOV     0xc5,R2
    623          
    624              U0CSR |= CSR_RE;
   \   0000F0   438640       ORL     0x86,#0x40
    625          
    626          #if HAL_UART_DMA == 1
    627              cfg->flag = UART_CFG_DMA;
   \   0000F3   EE           MOV     A,R6
   \   0000F4   240F         ADD     A,#0xf
   \   0000F6   12....       LCALL   ??Subroutine21_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   0000F9   7440         MOV     A,#0x40
   \   0000FB   F0           MOVX    @DPTR,A
    628              HAL_UART_ASSERT( (config->rx.maxBufSize <= 128) );
    629              HAL_UART_ASSERT( (config->rx.maxBufSize > SAFE_RX_MIN) );
    630              cfg->rxBuf = osal_mem_alloc( cfg->rxMax*2 );
   \   0000FC   EE           MOV     A,R6
   \   0000FD   2404         ADD     A,#0x4
   \   0000FF   F5..         MOV     ?V0 + 2,A
   \   000101   EF           MOV     A,R7
   \   000102   3400         ADDC    A,#0x0
   \   000104   F5..         MOV     ?V0 + 3,A
   \   000106                ; Setup parameters for call to function osal_mem_alloc
   \   000106   85..82       MOV     DPL,?V0 + 2
   \   000109   F583         MOV     DPH,A
   \   00010B   E0           MOVX    A,@DPTR
   \   00010C   C3           CLR     C
   \   00010D   33           RLC     A
   \   00010E   FA           MOV     R2,A
   \   00010F   E4           CLR     A
   \   000110   33           RLC     A
   \   000111   FB           MOV     R3,A
   \   000112   12....       LCALL   ?Subroutine17 & 0xFFFF
    631              osal_memset( cfg->rxBuf, ~DMA_PAD, cfg->rxMax*2 );
   \                     ??CrossCallReturnLabel_52:
   \   000115                ; Setup parameters for call to function osal_memset
   \   000115   85..82       MOV     DPL,?V0 + 2
   \   000118   85..83       MOV     DPH,?V0 + 3
   \   00011B   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   00011E   12....       LCALL   ?Subroutine10 & 0xFFFF
    632              DMA_RX( cfg );
   \                     ??CrossCallReturnLabel_40:
   \   000121   85..82       MOV     DPL,?V0 + 2
   \   000124   85..83       MOV     DPH,?V0 + 3
   \   000127   12....       LCALL   ?Subroutine8 & 0xFFFF
    633          #else
    634              cfg->flag = 0;
    635              HAL_UART_ASSERT( (config->rx.maxBufSize < 256) );
    636              cfg->rxBuf = osal_mem_alloc( cfg->rxMax+1 );
    637              URX0IE = 1;
    638              IEN2 |= UTX0IE;
    639          #endif
    640          
    641              // 8 bits/char; no parity; 1 stop bit; stop bit hi.
    642              if ( config->flowControl )
   \                     ??CrossCallReturnLabel_36:
   \   00012A   85..82       MOV     DPL,?V0 + 0
   \   00012D   85..83       MOV     DPH,?V0 + 1
   \   000130   A3           INC     DPTR
   \   000131   A3           INC     DPTR
   \   000132   E0           MOVX    A,@DPTR
   \   000133   6013         JZ      ??HalUARTOpen_6
    643              {
    644                cfg->flag |= UART_CFG_FLW;
   \   000135   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000138   D2E5         SETB    0xE0 /* A   */.5
   \   00013A   F0           MOVX    @DPTR,A
    645                U0UCR = UCR_FLOW | UCR_STOP;
   \   00013B   75C442       MOV     0xc4,#0x42
    646                // Must rely on H/W for RTS (i.e. Tx stops when receiver negates CTS.)
    647                P0SEL |= HAL_UART_0_P0_RTS;
   \   00013E   43F310       ORL     0xf3,#0x10
    648                // Cannot use H/W for CTS as DMA does not clear the Rx bytes properly.
    649                P0DIR |= HAL_UART_0_P0_CTS;
   \   000141   43FD20       ORL     0xfd,#0x20
    650                RX0_FLOW_ON;
   \   000144   C285         CLR     0x80.5
   \   000146   8003         SJMP    ??HalUARTOpen_1
    651              }
    652              else
    653              {
    654                U0UCR = UCR_STOP;
   \                     ??HalUARTOpen_6:
   \   000148   75C402       MOV     0xc4,#0x2
    655              }
    656              }
    657          #endif
    658          
    659          #if HAL_UART_1_ENABLE
    660            if ( port == HAL_UART_PORT_1 )
    661            {
    662              // Only supporting 38400 or 115200 for code size - other is possible.
    663              U1BAUD = (config->baudRate == HAL_UART_BR_38400) ? 59 : 216;
    664              U1GCR = (config->baudRate == HAL_UART_BR_38400) ? 10 : 11;
    665          
    666              U1CSR |= CSR_RE;
    667          
    668          #if HAL_UART_DMA == 2
    669              cfg->flag = (UART_CFG_U1F | UART_CFG_DMA);
    670              HAL_UART_ASSERT( (config->rx.maxBufSize <= 128) );
    671              HAL_UART_ASSERT( (config->rx.maxBufSize > SAFE_RX_MIN) );
    672              cfg->rxBuf = osal_mem_alloc( cfg->rxMax*2 );
    673              osal_memset( cfg->rxBuf, ~DMA_PAD, cfg->rxMax*2 );
    674              DMA_RX( cfg );
    675          #else
    676              cfg->flag = UART_CFG_U1F;
    677              HAL_UART_ASSERT( (config->rx.maxBufSize < 256) );
    678              cfg->rxBuf = osal_mem_alloc( cfg->rxMax+1 );
    679              URX1IE = 1;
    680              IEN2 |= UTX1IE;
    681          #endif
    682          
    683              // 8 bits/char; no parity; 1 stop bit; stop bit hi.
    684              if ( config->flowControl )
    685              {
    686                cfg->flag |= UART_CFG_FLW;
    687                U1UCR = UCR_FLOW | UCR_STOP;
    688                // Must rely on H/W for RTS (i.e. Tx stops when receiver negates CTS.)
    689                P1SEL |= HAL_UART_1_P1_RTS;
    690                // Cannot use H/W for CTS as DMA does not clear the Rx bytes properly.
    691                P1DIR |= HAL_UART_1_P1_CTS;
    692                RX1_FLOW_ON;
    693              }
    694              else
    695              {
    696                U1UCR = UCR_STOP;
    697              }
    698            }
    699          #endif
    700          
    701            return HAL_UART_SUCCESS;
   \                     ??HalUARTOpen_1:
   \   00014B   7900         MOV     R1,#0x0
   \   00014D   7401         MOV     A,#0x1
   \   00014F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000152   7F06         MOV     R7,#0x6
   \   000154   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000157                REQUIRE _A_P0
   \   000157                REQUIRE U0CSR
   \   000157                REQUIRE U0DBUF
   \   000157                REQUIRE U0BAUD
   \   000157                REQUIRE U0UCR
   \   000157                REQUIRE U0GCR
   \   000157                REQUIRE DMAIRQ
   \   000157                REQUIRE DMAARM
   \   000157                REQUIRE P0SEL
   \   000157                REQUIRE P0DIR
    702          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ??osal_mem_alloc?relay
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000003   F8           MOV     R0,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET
    703          
    704          /******************************************************************************
    705           * @fn      HalUARTClose
    706           *
    707           * @brief   Close the UART
    708           *
    709           * @param   port - UART port
    710           *
    711           * @return  none
    712           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    713          void HalUARTClose( uint8 port )
   \                     HalUARTClose:
    714          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    715          #if HAL_UART_CLOSE
    716            uartCfg_t *cfg;
    717          
    718          #if HAL_UART_0_ENABLE
    719            if ( port == HAL_UART_PORT_0 )
    720            {
    721              U0CSR &= ~CSR_RE;
    722          #if HAL_UART_DMA == 1
    723              HAL_DMA_ABORT_CH( HAL_DMA_CH_RX );
    724              HAL_DMA_ABORT_CH( HAL_DMA_CH_TX );
    725          #else
    726              URX0IE = 0;
    727          #endif
    728              cfg = cfg0;
    729              cfg0 = NULL;
    730            }
    731          #endif
    732          #if HAL_UART_1_ENABLE
    733            if ( port == HAL_UART_PORT_1 )
    734            {
    735              U1CSR &= ~CSR_RE;
    736          #if HAL_UART_DMA == 2
    737              HAL_DMA_ABORT_CH( HAL_DMA_CH_RX );
    738              HAL_DMA_ABORT_CH( HAL_DMA_CH_TX );
    739          #else
    740              URX1IE = 0;
    741          #endif
    742              cfg = cfg1;
    743              cfg1 = NULL;
    744            }
    745          #endif
    746          
    747            if ( cfg )
    748            {
    749              if ( cfg->rxBuf )
    750              {
    751                osal_mem_free( cfg->rxBuf );
    752              }
    753              if ( cfg->txBuf )
    754              {
    755                osal_mem_free( cfg->txBuf );
    756              }
    757              osal_mem_free( cfg );
    758            }
    759          #endif
    760          }
   \   000000   02....       LJMP    ?BRET
    761          
    762          /******************************************************************************
    763           * @fn      HalUARTPoll
    764           *
    765           * @brief   Poll the UART.
    766           *
    767           * @param   none
    768           *
    769           * @return  none
    770           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    771          void HalUARTPoll( void )
   \                     HalUARTPoll:
    772          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    773          #if ( HAL_UART_0_ENABLE | HAL_UART_1_ENABLE )
    774            static uint8 tickShdw;
    775            uartCfg_t *cfg;
    776            uint8 tick;
    777          
    778          #if HAL_UART_0_ENABLE
    779            if ( cfg0 )
   \   000005   90....       MOV     DPTR,#cfg0
   \   000008   E0           MOVX    A,@DPTR
   \   000009   7002         JNZ     ??HalUARTPoll_0
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \                     ??HalUARTPoll_0:
   \   00000D   6008         JZ      ??HalUARTPoll_1
    780            {
    781              cfg = cfg0;
   \   00000F   90....       MOV     DPTR,#cfg0
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FE           MOV     R6,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FF           MOV     R7,A
    782            }
    783          #endif
    784          #if HAL_UART_1_ENABLE
    785            if ( cfg1 )
    786            {
    787              cfg = cfg1;
    788            }
    789          #endif
    790          
    791            // Use the LSB of the sleep timer (ST0 must be read first anyway).
    792            tick = ST0 - tickShdw;
   \                     ??HalUARTPoll_1:
   \   000017   90....       MOV     DPTR,#??tickShdw
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FA           MOV     R2,A
   \   00001C   E595         MOV     A,0x95
   \   00001E   C3           CLR     C
   \   00001F   9A           SUBB    A,R2
   \   000020   FA           MOV     R2,A
    793            tickShdw = ST0;
   \   000021   E595         MOV     A,0x95
   \   000023   F0           MOVX    @DPTR,A
    794          
    795            do
    796            {
    797              if ( cfg->txTick > tick )
   \   000024   EE           MOV     A,R6
   \   000025   240E         ADD     A,#0xe
   \   000027   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   00002A   FB           MOV     R3,A
   \   00002B   EA           MOV     A,R2
   \   00002C   C3           CLR     C
   \   00002D   9B           SUBB    A,R3
   \   00002E   5005         JNC     ??HalUARTPoll_2
    798              {
    799                cfg->txTick -= tick;
   \   000030   E0           MOVX    A,@DPTR
   \   000031   C3           CLR     C
   \   000032   9A           SUBB    A,R2
   \   000033   8001         SJMP    ??HalUARTPoll_3
    800              }
    801              else
    802              {
    803                cfg->txTick = 0;
   \                     ??HalUARTPoll_2:
   \   000035   E4           CLR     A
   \                     ??HalUARTPoll_3:
   \   000036   12....       LCALL   ?Subroutine15 & 0xFFFF
    804              }
    805          
    806              if ( cfg->rxTick > tick )
   \                     ??CrossCallReturnLabel_47:
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   FB           MOV     R3,A
   \   00003B   EA           MOV     A,R2
   \   00003C   C3           CLR     C
   \   00003D   9B           SUBB    A,R3
   \   00003E   500F         JNC     ??HalUARTPoll_4
    807              {
    808                cfg->rxTick -= tick;
   \   000040   8E82         MOV     DPL,R6
   \   000042   8F83         MOV     DPH,R7
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   C3           CLR     C
   \   00004C   9A           SUBB    A,R2
   \   00004D   800B         SJMP    ??HalUARTPoll_5
    809              }
    810              else
    811              {
    812                cfg->rxTick = 0;
   \                     ??HalUARTPoll_4:
   \   00004F   E4           CLR     A
   \   000050   8E82         MOV     DPL,R6
   \   000052   8F83         MOV     DPH,R7
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \                     ??HalUARTPoll_5:
   \   00005A   F0           MOVX    @DPTR,A
    813              }
    814          
    815          #if HAL_UART_ISR
    816          #if HAL_UART_DMA
    817              if ( cfg->flag & UART_CFG_DMA )
    818              {
    819                pollDMA( cfg );
    820              }
    821              else
    822          #endif
    823                {
    824                pollISR( cfg );
    825                }
    826          #elif HAL_UART_DMA
    827              pollDMA( cfg );
   \   00005B                ; Setup parameters for call to function pollDMA
   \   00005B   EE           MOV     A,R6
   \   00005C   FA           MOV     R2,A
   \   00005D   EF           MOV     A,R7
   \   00005E   FB           MOV     R3,A
   \   00005F   12....       LCALL   ??pollDMA?relay
    828          #endif
    829          
    830              /* The following logic makes continuous callbacks on any eligible flag
    831               * until the condition corresponding to the flag is rectified.
    832               * So even if new data is not received, continuous callbacks are made.
    833               */
    834                if ( cfg->rxHead != cfg->rxTail )
   \   000062   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000065   6069         JZ      ??HalUARTPoll_6
    835                {
    836                uint8 evt;
    837          
    838                if ( cfg->rxHead >= (cfg->rxMax - SAFE_RX_MIN) )
   \   000067   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   00006A   4004         JC      ??HalUARTPoll_7
    839                {
    840                  evt = HAL_UART_RX_FULL;
   \   00006C   7A01         MOV     R2,#0x1
   \   00006E   803D         SJMP    ??HalUARTPoll_8
    841                }
    842                else if ( cfg->rxHigh && (cfg->rxHead >= cfg->rxHigh) )
   \                     ??HalUARTPoll_7:
   \   000070   8E82         MOV     DPL,R6
   \   000072   8F83         MOV     DPH,R7
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   6020         JZ      ??HalUARTPoll_9
   \   00007E   8E82         MOV     DPL,R6
   \   000080   8F83         MOV     DPH,R7
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   C0E0         PUSH    A
   \   000087   8E82         MOV     DPL,R6
   \   000089   8F83         MOV     DPH,R7
   \   00008B   A3           INC     DPTR
   \   00008C   A3           INC     DPTR
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   E0           MOVX    A,@DPTR
   \   000093   FA           MOV     R2,A
   \   000094   D0E0         POP     A
   \   000096   C3           CLR     C
   \   000097   9A           SUBB    A,R2
   \   000098   4004         JC      ??HalUARTPoll_9
    843                {
    844                  evt = HAL_UART_RX_ABOUT_FULL;
   \   00009A   7A02         MOV     R2,#0x2
   \   00009C   800F         SJMP    ??HalUARTPoll_8
    845              }
    846                else if ( cfg->rxTick == 0 )
   \                     ??HalUARTPoll_9:
   \   00009E   8E82         MOV     DPL,R6
   \   0000A0   8F83         MOV     DPH,R7
   \   0000A2   A3           INC     DPTR
   \   0000A3   A3           INC     DPTR
   \   0000A4   A3           INC     DPTR
   \   0000A5   A3           INC     DPTR
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   7025         JNZ     ??HalUARTPoll_6
    847              {
    848                  evt = HAL_UART_RX_TIMEOUT;
   \   0000AB   7A04         MOV     R2,#0x4
   \                     ??HalUARTPoll_8:
   \   0000AD   EE           MOV     A,R6
   \   0000AE   2410         ADD     A,#0x10
   \   0000B0   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   0000B3   7002         JNZ     ??HalUARTPoll_10
   \   0000B5   A3           INC     DPTR
   \   0000B6   E0           MOVX    A,@DPTR
   \                     ??HalUARTPoll_10:
   \   0000B7   6017         JZ      ??HalUARTPoll_6
    849              }
    850              else
    851              {
    852                  evt = 0;
    853              }
    854          
    855              if ( evt && cfg->rxCB )
    856              {
    857                  cfg->rxCB( ((cfg->flag & UART_CFG_U1F)!=0), evt );
   \   0000B9                ; Setup parameters for indirect call
   \   0000B9   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0000BC   E4           CLR     A
   \   0000BD   92E0         MOV     0xE0 /* A   */.0,C
   \   0000BF   F9           MOV     R1,A
   \   0000C0   EE           MOV     A,R6
   \   0000C1   2410         ADD     A,#0x10
   \   0000C3   F582         MOV     DPL,A
   \   0000C5   EF           MOV     A,R7
   \   0000C6   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   0000C9   F583         MOV     DPH,A
   \   0000CB   8882         MOV     DPL,R0
   \   0000CD   12....       LCALL   ?CALL_IND
    858              }
    859              }
    860          
    861          #if HAL_UART_0_ENABLE
    862              if ( cfg == cfg0 )
    863              {
    864          #if HAL_UART_1_ENABLE
    865                if ( cfg1 )
    866                {
    867                  cfg = cfg1;
    868                }
    869                else
    870          #endif
    871                  break;
    872              }
    873              else
    874          #endif
    875                break;
    876          
    877            } while ( TRUE );
    878          #else
    879            return;
    880          #endif
    881          }
   \                     ??HalUARTPoll_6:
   \   0000D0   7F01         MOV     R7,#0x1
   \   0000D2   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   0000D5                REQUIRE ST0

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??tickShdw:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    882          
    883          /**************************************************************************************************
    884           * @fn      Hal_UART_RxBufLen()
    885           *
    886           * @brief   Calculate Rx Buffer length - the number of bytes in the buffer.
    887           *
    888           * @param   port - UART port
    889           *
    890           * @return  length of current Rx Buffer
    891           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    892          uint16 Hal_UART_RxBufLen( uint8 port )
   \                     Hal_UART_RxBufLen:
    893          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
    894            uartCfg_t *cfg = NULL;
   \   000005   7800         MOV     R0,#0x0
   \   000007   7900         MOV     R1,#0x0
    895          
    896          #if HAL_UART_0_ENABLE
    897            if ( port == HAL_UART_PORT_0 )
   \   000009   7008         JNZ     ??Hal_UART_RxBufLen_0
    898            {
    899              cfg = cfg0;
   \   00000B   90....       MOV     DPTR,#cfg0
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F8           MOV     R0,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
    900            }
    901          #endif
    902          #if HAL_UART_1_ENABLE
    903            if ( port == HAL_UART_PORT_1 )
    904            {
    905              cfg = cfg1;
    906            }
    907          #endif
    908          
    909            HAL_UART_ASSERT( cfg );
    910          
    911            return UART_RX_AVAIL( cfg );
   \                     ??Hal_UART_RxBufLen_0:
   \   000013   8882         MOV     DPL,R0
   \   000015   8983         MOV     DPH,R1
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   C0E0         PUSH    A
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   FA           MOV     R2,A
   \   000025   D0E0         POP     A
   \   000027   C3           CLR     C
   \   000028   9A           SUBB    A,R2
   \   000029   8882         MOV     DPL,R0
   \   00002B   8983         MOV     DPH,R1
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   400D         JC      ??Hal_UART_RxBufLen_1
   \   000031   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000034   F8           MOV     R0,A
   \   000035   EA           MOV     A,R2
   \   000036   C3           CLR     C
   \   000037   98           SUBB    A,R0
   \   000038   FA           MOV     R2,A
   \   000039   E4           CLR     A
   \   00003A   9400         SUBB    A,#0x0
   \   00003C   8020         SJMP    ??Hal_UART_RxBufLen_2
   \                     ??Hal_UART_RxBufLen_1:
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000043   FC           MOV     R4,A
   \   000044   EA           MOV     A,R2
   \   000045   C3           CLR     C
   \   000046   9C           SUBB    A,R4
   \   000047   FA           MOV     R2,A
   \   000048   E4           CLR     A
   \   000049   9400         SUBB    A,#0x0
   \   00004B   FB           MOV     R3,A
   \   00004C   8882         MOV     DPL,R0
   \   00004E   8983         MOV     DPH,R1
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   2A           ADD     A,R2
   \   000054   F8           MOV     R0,A
   \   000055   E4           CLR     A
   \   000056   3B           ADDC    A,R3
   \   000057   F9           MOV     R1,A
   \   000058   7401         MOV     A,#0x1
   \   00005A   28           ADD     A,R0
   \   00005B   FA           MOV     R2,A
   \   00005C   E4           CLR     A
   \   00005D   39           ADDC    A,R1
   \                     ??Hal_UART_RxBufLen_2:
   \   00005E   FB           MOV     R3,A
   \   00005F   02....       LJMP    ?Subroutine23 & 0xFFFF
    912          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   8882         MOV     DPL,R0
   \   000004   8983         MOV     DPH,R1
   \   000006   02....       LJMP    ?Subroutine22 & 0xFFFF
    913          
    914          /*****************************************************************************
    915           * @fn      HalUARTRead
    916           *
    917           * @brief   Read a buffer from the UART
    918           *
    919           * @param   port - USART module designation
    920           *          buf  - valid data buffer at least 'len' bytes in size
    921           *          len  - max length number of bytes to copy to 'buf'
    922           *
    923           * @return  length of buffer that was read
    924           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    925          uint16 HalUARTRead( uint8 port, uint8 *buf, uint16 len )
   \                     HalUARTRead:
    926          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
    927            uartCfg_t *cfg = NULL;
   \   000006   7800         MOV     R0,#0x0
   \   000008   7900         MOV     R1,#0x0
    928            uint8 cnt = 0;
   \   00000A   88..         MOV     ?V0 + 2,R0
    929          
    930          #if HAL_UART_0_ENABLE
    931            if ( port == HAL_UART_PORT_0 )
   \   00000C   7016         JNZ     ??HalUARTRead_0
    932            {
    933              cfg = cfg0;
   \   00000E   90....       MOV     DPTR,#cfg0
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F8           MOV     R0,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   800C         SJMP    ??HalUARTRead_0
    934            }
    935          #endif
    936          #if HAL_UART_1_ENABLE
    937            if ( port == HAL_UART_PORT_1 )
    938            {
    939              cfg = cfg1;
    940            }
    941          #endif
    942          
    943            HAL_UART_ASSERT( cfg );
    944          
    945            while ( (cfg->rxTail != cfg->rxHead) && (cnt < len) )
    946            {
    947              *buf++ = cfg->rxBuf[cfg->rxTail];
    948              if ( cfg->rxTail == cfg->rxMax )
    949              {
    950                cfg->rxTail = 0;
    951              }
    952              else
    953              {
    954                cfg->rxTail++;
   \                     ??HalUARTRead_1:
   \   000018   8882         MOV     DPL,R0
   \   00001A   8983         MOV     DPH,R1
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   04           INC     A
   \                     ??HalUARTRead_2:
   \   000021   F0           MOVX    @DPTR,A
    955              }
    956              cnt++;
   \   000022   05..         INC     ?V0 + 2
   \                     ??HalUARTRead_0:
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   6E           XRL     A,R6
   \   000030   604E         JZ      ??HalUARTRead_3
   \   000032   85....       MOV     ?V0 + 0,?V0 + 2
   \   000035   C3           CLR     C
   \   000036   E5..         MOV     A,?V0 + 0
   \   000038   9C           SUBB    A,R4
   \   000039   E4           CLR     A
   \   00003A   9D           SUBB    A,R5
   \   00003B   5043         JNC     ??HalUARTRead_3
   \   00003D   E8           MOV     A,R0
   \   00003E   2403         ADD     A,#0x3
   \   000040   FE           MOV     R6,A
   \   000041   E9           MOV     A,R1
   \   000042   3400         ADDC    A,#0x0
   \   000044   FF           MOV     R7,A
   \   000045   8E82         MOV     DPL,R6
   \   000047   8F83         MOV     DPH,R7
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F5..         MOV     ?V0 + 0,A
   \   00004C   8882         MOV     DPL,R0
   \   00004E   8983         MOV     DPH,R1
   \   000050   E0           MOVX    A,@DPTR
   \   000051   25..         ADD     A,?V0 + 0
   \   000053   F5..         MOV     ?V0 + 3,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   3400         ADDC    A,#0x0
   \   000059   85..82       MOV     DPL,?V0 + 3
   \   00005C   F583         MOV     DPH,A
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   8A82         MOV     DPL,R2
   \   000061   8B83         MOV     DPH,R3
   \   000063   F0           MOVX    @DPTR,A
   \   000064   A3           INC     DPTR
   \   000065   AA82         MOV     R2,DPL
   \   000067   AB83         MOV     R3,DPH
   \   000069   8E82         MOV     DPL,R6
   \   00006B   8F83         MOV     DPH,R7
   \   00006D   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   6E           XRL     A,R6
   \   000074   70A2         JNZ     ??HalUARTRead_1
   \   000076   E4           CLR     A
   \   000077   8882         MOV     DPL,R0
   \   000079   8983         MOV     DPH,R1
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   80A1         SJMP    ??HalUARTRead_2
    957            }
    958          
    959          #if HAL_UART_DMA
    960            #if HAL_UART_ISR
    961            if ( cfg->flag & UART_CFG_DMA )
    962            #endif
    963            {
    964              /* If there is no flow control on a DMA-driven UART, the Rx Head & Tail
    965               * pointers must be reset to zero after every read in order to preserve the
    966               * full length of the Rx buffer. This implies that every Read must read all
    967               * of the Rx bytes available, or the pointers will not be reset and the
    968               * next incoming packet may not fit in the Rx buffer space remaining - thus
    969               * the end portion of the incoming packet that does not fit would be lost.
    970               */
    971              if ( !(cfg->flag & UART_CFG_FLW) )
   \                     ??HalUARTRead_3:
   \   000080   E8           MOV     A,R0
   \   000081   240F         ADD     A,#0xf
   \   000083   F582         MOV     DPL,A
   \   000085   E9           MOV     A,R1
   \   000086   12....       LCALL   ??Subroutine7_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000089   A2E5         MOV     C,0xE0 /* A   */.5
   \   00008B   4003         JC      ??HalUARTRead_4
    972              {
    973                // This is a trick to trigger the DMA abort and restart logic in pollDMA.
    974                cfg->flag |= UART_CFG_RXF;
   \   00008D   D2E1         SETB    0xE0 /* A   */.1
   \   00008F   F0           MOVX    @DPTR,A
    975              }
    976            }
    977          #endif
    978          
    979          #if HAL_UART_ISR
    980            #if HAL_UART_DMA
    981            if ( !(cfg->flag & UART_CFG_DMA) )
    982            #endif
    983            {
    984              cfg->rxCnt = UART_RX_AVAIL( cfg );
    985          
    986              if ( cfg->flag & UART_CFG_RXF )
    987              {
    988                if ( cfg->rxCnt < (cfg->rxMax - SAFE_RX_MIN) )
    989                {
    990                  RX_STRT_FLOW( cfg );
    991                }
    992              }
    993            }
    994          #endif
    995          
    996            return cnt;
   \                     ??HalUARTRead_4:
   \   000090   AA..         MOV     R2,?V0 + 2
   \   000092   7B00         MOV     R3,#0x0
   \   000094                REQUIRE ?Subroutine24
   \   000094                ; // Fall through to label ?Subroutine24
    997          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   8882         MOV     DPL,R0
   \   000004   8983         MOV     DPH,R1
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   22           RET
    998          
    999          /******************************************************************************
   1000           * @fn      HalUARTWrite
   1001           *
   1002           * @brief   Write a buffer to the UART.
   1003           *
   1004           * @param   port    - UART port
   1005           *          pBuffer - pointer to the buffer that will be written, not freed
   1006           *          length  - length of
   1007           *
   1008           * @return  length of the buffer that was sent
   1009           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1010          uint16 HalUARTWrite( uint8 port, uint8 *buf, uint16 len )
   \                     HalUARTWrite:
   1011          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   EC           MOV     A,R4
   \   00000C   FA           MOV     R2,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FB           MOV     R3,A
   1012            uartCfg_t *cfg = NULL;
   \   00000F   7800         MOV     R0,#0x0
   \   000011   7900         MOV     R1,#0x0
   1013            uint8 cnt;
   1014          
   1015          #if HAL_UART_0_ENABLE
   1016            if ( port == HAL_UART_PORT_0 )
   \   000013   E5..         MOV     A,?V0 + 0
   \   000015   7008         JNZ     ??HalUARTWrite_0
   1017            {
   1018              cfg = cfg0;
   \   000017   90....       MOV     DPTR,#cfg0
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F8           MOV     R0,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F9           MOV     R1,A
   1019            }
   1020          #endif
   1021          #if HAL_UART_1_ENABLE
   1022            if ( port == HAL_UART_PORT_1 )
   1023            {
   1024              cfg = cfg1;
   1025            }
   1026          #endif
   1027          
   1028            HAL_UART_ASSERT( cfg );
   1029          
   1030            if ( cfg->txHead == cfg->txTail )
   \                     ??HalUARTWrite_0:
   \   00001F   8882         MOV     DPL,R0
   \   000021   8983         MOV     DPH,R1
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   FC           MOV     R4,A
   \   00002F   E8           MOV     A,R0
   \   000030   240B         ADD     A,#0xb
   \   000032   F582         MOV     DPL,A
   \   000034   E9           MOV     A,R1
   \   000035   12....       LCALL   ??Subroutine7_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000038   6C           XRL     A,R4
   \   000039   7021         JNZ     ??HalUARTWrite_1
   1031            {
   1032          #if HAL_UART_DMA
   1033              // When pointers are equal, reset to zero to get max len w/out wrapping.
   1034              cfg->txHead = cfg->txTail = 0;
   \   00003B   E4           CLR     A
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   8882         MOV     DPL,R0
   \   00003F   8983         MOV     DPH,R1
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   00004F   74FF         MOV     A,#-0x1
   \   000051   2C           ADD     A,R4
   \   000052   F5..         MOV     ?V0 + 0,A
   \   000054   74FF         MOV     A,#-0x1
   \   000056   3400         ADDC    A,#0x0
   \   000058   F5..         MOV     ?V0 + 1,A
   \   00005A   8040         SJMP    ??HalUARTWrite_2
   1035          #endif
   1036          #if HAL_UART_ISR
   1037          #if HAL_UART_DMA
   1038              if ( !(cfg->flag & UART_CFG_DMA) )
   1039          #endif
   1040              {
   1041                cfg->flag &= ~UART_CFG_TXF;
   1042              }
   1043          #endif
   1044            }
   1045          
   1046            // Accept "all-or-none" on write request.
   1047            if ( TX_AVAIL( cfg ) < len )
   \                     ??HalUARTWrite_1:
   \   00005C   8882         MOV     DPL,R0
   \   00005E   8983         MOV     DPH,R1
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   C0E0         PUSH    A
   \   00006D   E8           MOV     A,R0
   \   00006E   240B         ADD     A,#0xb
   \   000070   12....       LCALL   ??Subroutine5_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000073   D0E0         POP     A
   \   000075   C3           CLR     C
   \   000076   9C           SUBB    A,R4
   \   000077   500B         JNC     ??HalUARTWrite_3
   \   000079   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00007C   74FF         MOV     A,#-0x1
   \   00007E   2C           ADD     A,R4
   \   00007F   1C           DEC     R4
   \   000080   74FF         MOV     A,#-0x1
   \   000082   8012         SJMP    ??HalUARTWrite_4
   \                     ??HalUARTWrite_3:
   \   000084   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000087   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   00008A   E8           MOV     A,R0
   \   00008B   240B         ADD     A,#0xb
   \   00008D   F582         MOV     DPL,A
   \   00008F   E9           MOV     A,R1
   \   000090   12....       LCALL   ??Subroutine7_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000093   2C           ADD     A,R4
   \   000094   FC           MOV     R4,A
   \   000095   E4           CLR     A
   \                     ??HalUARTWrite_4:
   \   000096   3D           ADDC    A,R5
   \   000097   FD           MOV     R5,A
   \   000098   8C..         MOV     ?V0 + 0,R4
   \   00009A   8D..         MOV     ?V0 + 1,R5
   \                     ??HalUARTWrite_2:
   \   00009C   C3           CLR     C
   \   00009D   E5..         MOV     A,?V0 + 0
   \   00009F   9A           SUBB    A,R2
   \   0000A0   E5..         MOV     A,?V0 + 1
   \   0000A2   9B           SUBB    A,R3
   \   0000A3   5006         JNC     ??HalUARTWrite_5
   1048            {
   1049              return 0;
   \   0000A5   7A00         MOV     R2,#0x0
   \   0000A7   7B00         MOV     R3,#0x0
   \   0000A9   8078         SJMP    ??HalUARTWrite_6
   1050            }
   1051          
   1052            for ( cnt = len; cnt; cnt-- )
   \                     ??HalUARTWrite_5:
   \   0000AB   EA           MOV     A,R2
   \   0000AC   F5..         MOV     ?V0 + 3,A
   \   0000AE   8013         SJMP    ??HalUARTWrite_7
   1053            {
   1054              cfg->txBuf[ cfg->txHead ] = *buf++;
   1055          
   1056              if ( cfg->txHead == cfg->txMax )
   1057              {
   1058                cfg->txHead = 0;
   1059              }
   1060              else
   1061              {
   1062                cfg->txHead++;
   \                     ??HalUARTWrite_8:
   \   0000B0   8882         MOV     DPL,R0
   \   0000B2   8983         MOV     DPH,R1
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   A3           INC     DPTR
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   04           INC     A
   \                     ??HalUARTWrite_9:
   \   0000C0   F0           MOVX    @DPTR,A
   1063              }
   \   0000C1   15..         DEC     ?V0 + 3
   \                     ??HalUARTWrite_7:
   \   0000C3   E5..         MOV     A,?V0 + 3
   \   0000C5   605C         JZ      ??HalUARTWrite_6
   \   0000C7   E8           MOV     A,R0
   \   0000C8   240A         ADD     A,#0xa
   \   0000CA   FC           MOV     R4,A
   \   0000CB   E9           MOV     A,R1
   \   0000CC   3400         ADDC    A,#0x0
   \   0000CE   FD           MOV     R5,A
   \   0000CF   8E82         MOV     DPL,R6
   \   0000D1   8F83         MOV     DPH,R7
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   C0E0         PUSH    A
   \   0000D6   8C82         MOV     DPL,R4
   \   0000D8   8D83         MOV     DPH,R5
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   F5..         MOV     ?V0 + 0,A
   \   0000DD   8882         MOV     DPL,R0
   \   0000DF   8983         MOV     DPH,R1
   \   0000E1   A3           INC     DPTR
   \   0000E2   A3           INC     DPTR
   \   0000E3   A3           INC     DPTR
   \   0000E4   A3           INC     DPTR
   \   0000E5   A3           INC     DPTR
   \   0000E6   A3           INC     DPTR
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   25..         ADD     A,?V0 + 0
   \   0000EC   F5..         MOV     ?V0 + 2,A
   \   0000EE   A3           INC     DPTR
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   3400         ADDC    A,#0x0
   \   0000F2   85..82       MOV     DPL,?V0 + 2
   \   0000F5   F583         MOV     DPH,A
   \   0000F7   D0E0         POP     A
   \   0000F9   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   0000FC   AE82         MOV     R6,DPL
   \   0000FE   AF83         MOV     R7,DPH
   \   000100   8C82         MOV     DPL,R4
   \   000102   8D83         MOV     DPH,R5
   \   000104   E0           MOVX    A,@DPTR
   \   000105   FC           MOV     R4,A
   \   000106   E8           MOV     A,R0
   \   000107   240C         ADD     A,#0xc
   \   000109   F582         MOV     DPL,A
   \   00010B   E9           MOV     A,R1
   \   00010C   12....       LCALL   ??Subroutine7_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00010F   6C           XRL     A,R4
   \   000110   709E         JNZ     ??HalUARTWrite_8
   \   000112   E4           CLR     A
   \   000113   8882         MOV     DPL,R0
   \   000115   8983         MOV     DPH,R1
   \   000117   A3           INC     DPTR
   \   000118   A3           INC     DPTR
   \   000119   A3           INC     DPTR
   \   00011A   A3           INC     DPTR
   \   00011B   A3           INC     DPTR
   \   00011C   A3           INC     DPTR
   \   00011D   A3           INC     DPTR
   \   00011E   A3           INC     DPTR
   \   00011F   A3           INC     DPTR
   \   000120   A3           INC     DPTR
   \   000121   809D         SJMP    ??HalUARTWrite_9
   1064            }
   1065          
   1066          #if HAL_UART_ISR
   1067          #if HAL_UART_DMA
   1068            if ( !(cfg->flag & UART_CFG_DMA) )
   1069          #endif
   1070            {
   1071              if ( !(cfg->flag & UART_CFG_TXF) && len )
   1072              {
   1073                cfg->flag |= UART_CFG_TXF;
   1074                if ( !(cfg->flag & UART_CFG_U1F) )
   1075                {
   1076                  U0DBUF = cfg->txBuf[cfg->txTail];
   1077                }
   1078                else
   1079                {
   1080                  U1DBUF = cfg->txBuf[cfg->txTail];
   1081                }
   1082              }
   1083            }
   1084          #endif
   1085          
   1086            return len;
   \                     ??HalUARTWrite_6:
   \   000123   02....       LJMP    ?Subroutine24 & 0xFFFF
   1087          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F5..         MOV     ?V0 + 0,A
   \   000011   EC           MOV     A,R4
   \   000012   C3           CLR     C
   \   000013   95..         SUBB    A,?V0 + 0
   \   000015   FC           MOV     R4,A
   \   000016   E4           CLR     A
   \   000017   9400         SUBB    A,#0x0
   \   000019   FD           MOV     R5,A
   \   00001A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   E8           MOV     A,R0
   \   000001   240C         ADD     A,#0xc
   \                     ??Subroutine5_0:
   \   000003   F582         MOV     DPL,A
   \   000005   E9           MOV     A,R1
   \   000006   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000009   FC           MOV     R4,A
   \   00000A   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??pollDMA?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    pollDMA

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTOpen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTOpen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTClose?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTClose

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??Hal_UART_RxBufLen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    Hal_UART_RxBufLen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTWrite?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTWrite
   1088          
   1089          #if HAL_UART_ISR
   1090          /***************************************************************************************************
   1091           * @fn      halUart0RxIsr
   1092           *
   1093           * @brief   UART0 Receive Interrupt
   1094           *
   1095           * @param   None
   1096           *
   1097           * @return  None
   1098           ***************************************************************************************************/
   1099          #if HAL_UART_0_ENABLE
   1100          HAL_ISR_FUNCTION( halUart0RxIsr, URX0_VECTOR )
   1101          {
   1102            cfg0->rxBuf[cfg0->rxHead] = U0DBUF;
   1103          
   1104            if ( cfg0->rxHead == cfg0->rxMax )
   1105            {
   1106              cfg0->rxHead = 0;
   1107            }
   1108            else
   1109            {
   1110              cfg0->rxHead++;
   1111            }
   1112          }
   1113          #endif
   1114          
   1115          /***************************************************************************************************
   1116           * @fn      halUart1RxIsr
   1117           *
   1118           * @brief   UART1 Receive Interrupt
   1119           *
   1120           * @param   None
   1121           *
   1122           * @return  None
   1123           ***************************************************************************************************/
   1124          #if HAL_UART_1_ENABLE
   1125          HAL_ISR_FUNCTION( halUart1RxIsr, URX1_VECTOR )
   1126          {
   1127            cfg1->rxBuf[cfg1->rxHead] = U1DBUF;
   1128          
   1129            if ( cfg1->rxHead == cfg1->rxMax )
   1130            {
   1131              cfg1->rxHead = 0;
   1132            }
   1133            else
   1134            {
   1135              cfg1->rxHead++;
   1136            }
   1137          }
   1138          #endif
   1139          
   1140          /***************************************************************************************************
   1141           * @fn      halUart0TxIsr
   1142           *
   1143           * @brief   UART0 Transmit Interrupt
   1144           *
   1145           * @param   None
   1146           *
   1147           * @return  None
   1148           ***************************************************************************************************/
   1149          #if HAL_UART_0_ENABLE
   1150          HAL_ISR_FUNCTION( halUart0TxIsr, UTX0_VECTOR )
   1151          {
   1152            UTX0IF = 0;
   1153          
   1154            if ( cfg0->txTail == cfg0->txMax )
   1155            {
   1156              cfg0->txTail = 0;
   1157            }
   1158            else
   1159            {
   1160              cfg0->txTail++;
   1161            }
   1162          
   1163            if ( cfg0->txTail != cfg0->txHead )
   1164            {
   1165              U0DBUF = cfg0->txBuf[cfg0->txTail];
   1166            }
   1167          }
   1168          #endif
   1169          
   1170          /***************************************************************************************************
   1171           * @fn      halUart1TxIsr
   1172           *
   1173           * @brief   UART1 Transmit Interrupt
   1174           *
   1175           * @param   None
   1176           *
   1177           * @return  None
   1178           ***************************************************************************************************/
   1179          #if HAL_UART_1_ENABLE
   1180          HAL_ISR_FUNCTION( halUart1TxIsr, UTX1_VECTOR )
   1181          {
   1182            UTX1IF = 0;
   1183            U1CSR &= ~CSR_TX_BYTE;  // Rev-D does not require, older does.
   1184          
   1185            if ( cfg1->txTail == cfg1->txMax )
   1186            {
   1187              cfg1->txTail = 0;
   1188            }
   1189            else
   1190            {
   1191              cfg1->txTail++;
   1192            }
   1193          
   1194            if ( cfg1->txTail != cfg1->txHead )
   1195            {
   1196              U1DBUF = cfg1->txBuf[cfg1->txTail];
   1197            }
   1198          }
   1199          #endif
   1200          #endif
   1201          
   1202          /******************************************************************************
   1203          ******************************************************************************/

   Maximum stack usage in bytes:

     Function            ISTACK PSTACK XSTACK
     --------            ------ ------ ------
     HalUARTClose            0      0      0
     HalUARTInit             2      0      0
     HalUARTOpen             1      0     15
       -> osal_mem_alloc     0      0     30
       -> osal_mem_alloc     0      0     30
       -> osal_mem_alloc     0      0     30
       -> osal_memset        0      0     30
     HalUARTPoll             1      0      9
       -> pollDMA            0      0     18
     HalUARTRead             1      0     12
     HalUARTWrite            1      0     12
     Hal_UART_RxBufLen       3      0      0
     pollDMA                 1      0     20
       -> osal_memset        0      0     22


   Segment part sizes:

     Function/Label            Bytes
     --------------            -----
     _A_P0                        1
     U0CSR                        1
     _A_P1                        1
     ST0                          1
     U0DBUF                       1
     U0BAUD                       1
     U0UCR                        1
     U0GCR                        1
     DMAIRQ                       1
     DMAARM                       1
     DMAREQ                       1
     PERCFG                       1
     ADCCFG                       1
     P0SEL                        1
     P0DIR                        1
     P2DIR                        1
     cfg0                         2
     pollDMA                    530
     ?Subroutine4                11
     ?Subroutine2                 8
     ?Subroutine0                10
     ?Subroutine22                5
     ?Subroutine21               10
     ?Subroutine16               15
     ?Subroutine10               29
     ?Subroutine9                18
     ?Subroutine8                19
     ?Subroutine19                7
     ?Subroutine12               12
     ?Subroutine18               10
     ?Subroutine3                 9
     ?Subroutine1                30
     ?Subroutine7                10
     ?Subroutine20                9
     HalUARTInit                 93
     ?Subroutine23                7
     HalUARTOpen                343
     ?Subroutine17               13
     ?Subroutine15                9
     ?Subroutine6                 7
     HalUARTClose                 3
     HalUARTPoll                213
     tickShdw                     1
     Hal_UART_RxBufLen           98
     ?Subroutine13                9
     HalUARTRead                148
     ?Subroutine24                5
     ?Subroutine14                9
     HalUARTWrite               294
     ?Subroutine11               27
     ?Subroutine5                11
     ??pollDMA?relay              6
     ??HalUARTInit?relay          6
     ??HalUARTOpen?relay          6
     ??HalUARTClose?relay         6
     ??HalUARTPoll?relay          6
     ??Hal_UART_RxBufLen?relay    6
     ??HalUARTRead?relay          6
     ??HalUARTWrite?relay         6

 
 2 031 bytes in segment BANKED_CODE
    48 bytes in segment BANK_RELAYS
    16 bytes in segment SFR_AN
     3 bytes in segment XDATA_Z
 
 2 079 bytes of CODE  memory
     0 bytes of DATA  memory (+ 16 bytes shared)
     3 bytes of XDATA memory

Errors: none
Warnings: none

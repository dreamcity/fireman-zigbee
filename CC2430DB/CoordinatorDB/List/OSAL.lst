###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    28/Dec/2012  21:16:54 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \osal\common\OSAL.c                                #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\..\..\..\Tools\C #
#                          C2430DB\f8wCoord.cfg" (-DCPU32MHZ                  #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS           #
#                          "-DCONST=const __code" -DGENERIC=__generic) -f     #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\Tools\CC24 #
#                          30DB\f8wConfig.cfg" (-DSECURE=0                    #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\osal\com #
#                          mon\OSAL.c" -D CC2430DB -D REFLECTOR -D xZTOOL_P2  #
#                          -D xMT_TASK -D xMT_ZDO_FUNC -D                     #
#                          xLCD_SUPPORTED=DEBUG -lC "C:\Texas                 #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\CoordinatorDB\List\" -lA      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\CoordinatorDB\List\ #
#                          " --diag_suppress Pe001,Pa010 --diag_remark pe550  #
#                          -o "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\CoordinatorDB\Ob #
#                          j\" -e --require_prototypes -z9 --no_code_motion   #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\SOURCE\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\ZMAIN\TI2430DB\" -I  #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MT\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\HAL #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\TARGET\CC2430DB\" -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\OSA #
#                          L\INCLUDE\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\AF\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2. #
#                          1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\.. #
#                          \..\..\COMPONENTS\STACK\NWK\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\SEC\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\STACK\SYS\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\ZDO\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\ZMAC\F8W\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\ZMA #
#                          C\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Pr #
#                          ojects\zstack\Samples\AXDApp\CC2430DB\..\..\..\..\ #
#                          ..\COMPONENTS\SERVICES\SADDR\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\SER #
#                          VICES\SDATA\" -I "C:\Texas                         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\HIGH_LEVEL\" -I           #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \LOW_LEVEL\SRF03\SINGLE_CHIP\" -I "C:\Program      #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\" -I "C:\Program       #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\CoordinatorDB\List\O #
#                          SAL.lst                                            #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\CoordinatorDB\Obj\OS #
#                          AL.r51                                             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\osal\common\OSAL.c
      1          /**************************************************************************************************
      2            Filename:       OSAL.c
      3            Revised:        $Date: 2007-10-28 18:43:04 -0700 (Sun, 28 Oct 2007) $
      4            Revision:       $Revision: 15800 $
      5          
      6          
      7            Description:    This API allows the software components in the Z-stack to be written
      8                            independently of the specifics of the operating system, kernel or tasking
      9                            environment (including control loops or connect-to-interrupt systems).
     10          
     11          
     12            Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
     13          
     14            IMPORTANT: Your use of this Software is limited to those specific rights
     15            granted under the terms of a software license agreement between the user
     16            who downloaded the software, his/her employer (which must be your employer)
     17            and Texas Instruments Incorporated (the "License").  You may not use this
     18            Software unless you agree to abide by the terms of the License. The License
     19            limits your use, and you acknowledge, that the Software may not be modified,
     20            copied or distributed unless embedded on a Texas Instruments microcontroller
     21            or used solely and exclusively in conjunction with a Texas Instruments radio
     22            frequency transceiver, which is integrated into your product.  Other than for
     23            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     24            works of, modify, distribute, perform, display or sell this Software and/or
     25            its documentation for any purpose.
     26          
     27            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     28            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     29            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     30            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     31            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     32            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     33            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     34            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     35            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     36            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     37            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     38          
     39            Should you have any questions regarding your right to use this Software,
     40            contact Texas Instruments Incorporated at www.TI.com. 
     41          **************************************************************************************************/
     42          
     43          /*********************************************************************
     44           * INCLUDES
     45           */
     46          
     47          #include <stdlib.h>
     48          #include <string.h>
     49          
     50          #include "ZComDef.h"
     51          #include "OSAL.h"
     52          #include "OSAL_Tasks.h"
     53          #include "OSAL_Custom.h"
     54          #include "OSAL_Memory.h"
     55          #include "OSAL_PwrMgr.h"
     56          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     57          
     58          #include "OnBoard.h"
     59          
     60          /* HAL */
     61          #include "hal_drivers.h"
     62          
     63          /*********************************************************************
     64           * MACROS
     65           */
     66          
     67          #define OSAL_MSG_LEN(msg_ptr)      ((osal_msg_hdr_t *) (msg_ptr) - 1)->len
     68          
     69          #define OSAL_MSG_ID(msg_ptr)      ((osal_msg_hdr_t *) (msg_ptr) - 1)->dest_id
     70          
     71          /*********************************************************************
     72           * CONSTANTS
     73           */
     74          
     75          /*********************************************************************
     76           * TYPEDEFS
     77           */
     78          
     79          /*********************************************************************
     80           * GLOBAL VARIABLES
     81           */
     82          
     83          // Message Pool Definitions

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     84          osal_msg_q_t osal_qHead;
   \                     osal_qHead:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     85          
     86          #if defined( OSAL_TOTAL_MEM )
     87            UINT16 osal_msg_cnt;
     88          #endif
     89          
     90          /*********************************************************************
     91           * EXTERNAL VARIABLES
     92           */
     93          
     94          /*********************************************************************
     95           * EXTERNAL FUNCTIONS
     96           */
     97          
     98          /*********************************************************************
     99           * LOCAL VARIABLES
    100           */
    101          
    102          /*********************************************************************
    103           * LOCAL FUNCTION PROTOTYPES
    104           */
    105          
    106          /*********************************************************************
    107           * HELPER FUNCTIONS
    108           */
    109          /* very ugly stub so Keil can compile */
    110          #ifdef __KEIL__
    111          char *  itoa ( int value, char * buffer, int radix )
    112          {
    113            return(buffer);
    114          }
    115          #endif
    116          
    117          /*********************************************************************
    118           * @fn      osal_strlen
    119           *
    120           * @brief
    121           *
    122           *   Calculates the length of a string.  The string must be null
    123           *   terminated.
    124           *
    125           * @param   char *pString - pointer to text string
    126           *
    127           * @return  int - number of characters
    128           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    129          int osal_strlen( char *pString )
   \                     osal_strlen:
    130          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    131            return (int)( strlen( pString ) );
   \   000004                ; Setup parameters for call to function strlen
   \   000004   12....       LCALL   ??strlen?relay
   \   000007   02....       LJMP    ?Subroutine19 & 0xFFFF
    132          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    133          
    134          /*********************************************************************
    135           * @fn      osal_memcpy
    136           *
    137           * @brief
    138           *
    139           *   Generic memory copy.
    140           *
    141           *   Note: This function differs from the standard memcpy(), since
    142           *         it returns the pointer to the next destination byte. The
    143           *         standard memcpy() returns the original destination address.
    144           *
    145           * @param   dst - destination address
    146           * @param   src - source address
    147           * @param   len - number of bytes to copy
    148           *
    149           * @return  pointer to end of destination buffer
    150           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    151          void *osal_memcpy( void *dst, const void GENERIC *src, unsigned int len )
   \                     osal_memcpy:
    152          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   740B         MOV     A,#0xb
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F5..         MOV     ?V0 + 0,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 1,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
    153            byte *pDst;
    154            const byte GENERIC *pSrc;
    155          
    156            pSrc = src;
   \   000017   A9..         MOV     R1,?V0 + 0
   \   000019   AA..         MOV     R2,?V0 + 1
   \   00001B   FB           MOV     R3,A
    157            pDst = dst;
   \   00001C   8E82         MOV     DPL,R6
   \   00001E   8F83         MOV     DPH,R7
   \   000020   800D         SJMP    ??osal_memcpy_0
    158          
    159            while ( len-- )
    160              *pDst++ = *pSrc++;
   \                     ??osal_memcpy_1:
   \   000022   12....       LCALL   ?C_GPTR_LOAD
   \   000025   F0           MOVX    @DPTR,A
   \   000026   E9           MOV     A,R1
   \   000027   2401         ADD     A,#0x1
   \   000029   09           INC     R1
   \   00002A   EA           MOV     A,R2
   \   00002B   3400         ADDC    A,#0x0
   \   00002D   FA           MOV     R2,A
   \   00002E   A3           INC     DPTR
   \                     ??osal_memcpy_0:
   \   00002F   EC           MOV     A,R4
   \   000030   FE           MOV     R6,A
   \   000031   ED           MOV     A,R5
   \   000032   FF           MOV     R7,A
   \   000033   74FF         MOV     A,#-0x1
   \   000035   2E           ADD     A,R6
   \   000036   1C           DEC     R4
   \   000037   74FF         MOV     A,#-0x1
   \   000039   3F           ADDC    A,R7
   \   00003A   FD           MOV     R5,A
   \   00003B   EE           MOV     A,R6
   \   00003C   7001         JNZ     ??osal_memcpy_2
   \   00003E   EF           MOV     A,R7
   \                     ??osal_memcpy_2:
   \   00003F   70E1         JNZ     ??osal_memcpy_1
    161          
    162            return ( pDst );
   \   000041   AA82         MOV     R2,DPL
   \   000043   AB83         MOV     R3,DPH
   \   000045                REQUIRE ?Subroutine20
   \   000045                ; // Fall through to label ?Subroutine20
    163          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   7F03         MOV     R7,#0x3
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    164          
    165          /*********************************************************************
    166           * @fn      osal_cpyExtAddr
    167           *
    168           * @brief
    169           *
    170           *   Copy extended addresses.  This function will copy 8 bytes.
    171           *
    172           * @param   dest  destination address pointer
    173           * @param   src   source address pointer
    174           *
    175           * @return  dest + Z_EXTADDR_LEN
    176           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    177          void *osal_cpyExtAddr( void *dest, void *src )
   \                     osal_cpyExtAddr:
    178          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
    179            return osal_memcpy( dest, src, Z_EXTADDR_LEN );
   \   000005                ; Setup parameters for call to function osal_memcpy
   \   000005   8C..         MOV     ?V0 + 0,R4
   \   000007   8D..         MOV     ?V0 + 1,R5
   \   000009   75..00       MOV     ?V0 + 2,#0x0
   \   00000C   78..         MOV     R0,#?V0 + 0
   \   00000E   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000011   7C08         MOV     R4,#0x8
   \   000013   7D00         MOV     R5,#0x0
   \   000015   12....       LCALL   ??osal_memcpy?relay
   \   000018   7403         MOV     A,#0x3
   \   00001A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001D   80..         SJMP    ?Subroutine20
    180          }
    181          
    182          /*********************************************************************
    183           * @fn      osal_memset
    184           *
    185           * @brief
    186           *
    187           *   Set memory buffer to value.
    188           *
    189           * @param   dest - pointer to buffer
    190           * @param   value - what to set each byte of the message
    191           * @param   size - how big
    192           *
    193           * @return  value of next widget, 0 if no widget found
    194           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    195          void *osal_memset( void *dest, byte value, int len )
   \                     osal_memset:
    196          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    197            return memset( dest, value, len );
   \   000005                ; Setup parameters for call to function memset
   \   000005   8C..         MOV     ?V0 + 0,R4
   \   000007   8D..         MOV     ?V0 + 1,R5
   \   000009   78..         MOV     R0,#?V0 + 0
   \   00000B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00000E   E9           MOV     A,R1
   \   00000F   FC           MOV     R4,A
   \   000010   7D00         MOV     R5,#0x0
   \   000012   12....       LCALL   ??memset?relay
   \   000015   7402         MOV     A,#0x2
   \   000017   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001A   02....       LJMP    ?Subroutine21 & 0xFFFF
    198          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    199          
    200          /*********************************************************************
    201           * @fn      osal_build_uint16
    202           *
    203           * @brief
    204           *
    205           *   Build a uint16 out of 2 bytes (0 then 1).
    206           *
    207           * @param   swapped - 0 then 1
    208           *
    209           * @return  uint16
    210           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    211          uint16 osal_build_uint16( byte *swapped )
   \                     osal_build_uint16:
    212          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    213            return ( BUILD_UINT16( swapped[0], swapped[1] ) );
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FC           MOV     R4,A
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   EC           MOV     A,R4
   \   00000F   FA           MOV     R2,A
   \   000010   E9           MOV     A,R1
   \   000011   FB           MOV     R3,A
   \   000012   02....       LJMP    ?Subroutine23 & 0xFFFF
    214          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    215          
    216          /*********************************************************************
    217           * @fn      osal_build_uint32
    218           *
    219           * @brief
    220           *
    221           *   Build a uint32 out of sequential bytes.
    222           *
    223           * @param   swapped - sequential bytes
    224           * @param   len - number of bytes in the byte array
    225           *
    226           * @return  uint32
    227           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    228          uint32 osal_build_uint32( byte *swapped, byte len )
   \                     osal_build_uint32:
    229          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
    230            if ( len == 2 )
   \   000005   7402         MOV     A,#0x2
   \   000007   69           XRL     A,R1
   \   000008   701D         JNZ     ??osal_build_uint32_0
    231              return ( BUILD_UINT32( swapped[0], swapped[1], 0L, 0L ) );
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000011   78..         MOV     R0,#?V0 + 4
   \   000013   12....       LCALL   ?L_SHL
   \   000016   78..         MOV     R0,#?V0 + 0
   \   000018   79..         MOV     R1,#?V0 + 4
   \   00001A   12....       LCALL   ?L_ADD
   \   00001D   AA..         MOV     R2,?V0 + 0
   \   00001F   AB..         MOV     R3,?V0 + 1
   \   000021   AC..         MOV     R4,?V0 + 2
   \   000023   AD..         MOV     R5,?V0 + 3
   \   000025   8059         SJMP    ??osal_build_uint32_1
    232            else if ( len == 3 )
   \                     ??osal_build_uint32_0:
   \   000027   7403         MOV     A,#0x3
   \   000029   69           XRL     A,R1
   \   00002A   7016         JNZ     ??osal_build_uint32_2
    233              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], 0L ) );
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000033   12....       LCALL   ?L_SHL
   \   000036   78..         MOV     R0,#?V0 + 0
   \   000038   79..         MOV     R1,#?V0 + 4
   \   00003A   12....       LCALL   ?L_ADD
   \   00003D   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000040   80CF         SJMP    ??CrossCallReturnLabel_36
    234            else if ( len == 4 )
   \                     ??osal_build_uint32_2:
   \   000042   7404         MOV     A,#0x4
   \   000044   69           XRL     A,R1
   \   000045   8A82         MOV     DPL,R2
   \   000047   8B83         MOV     DPH,R3
   \   000049   702D         JNZ     ??osal_build_uint32_3
    235              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], swapped[3] ) );
   \   00004B   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00004E   12....       LCALL   ?L_SHL
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   79..         MOV     R1,#?V0 + 4
   \   000055   12....       LCALL   ?L_ADD
   \   000058   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   00005B   78..         MOV     R0,#?V0 + 4
   \   00005D   12....       LCALL   ?L_SHL
   \   000060   78..         MOV     R0,#?V0 + 0
   \   000062   79..         MOV     R1,#?V0 + 4
   \   000064   12....       LCALL   ?L_ADD
   \   000067   8A82         MOV     DPL,R2
   \   000069   8B83         MOV     DPH,R3
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   F5..         MOV     ?V0 + 4,A
   \   000071   75..00       MOV     ?V0 + 6,#0x0
   \   000074   7418         MOV     A,#0x18
   \   000076   8099         SJMP    ??CrossCallReturnLabel_36
    236            else
    237              return ( (uint32)swapped[0] );
   \                     ??osal_build_uint32_3:
   \   000078   E0           MOVX    A,@DPTR
   \   000079   FA           MOV     R2,A
   \   00007A   7B00         MOV     R3,#0x0
   \   00007C   7C00         MOV     R4,#0x0
   \   00007E   7D00         MOV     R5,#0x0
   \                     ??osal_build_uint32_1:
   \   000080                REQUIRE ?Subroutine24
   \   000080                ; // Fall through to label ?Subroutine24
    238          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V0 + 4,A
   \   000009   75..00       MOV     ?V0 + 5,#0x0
   \   00000C   7410         MOV     A,#0x10
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000003   78..         MOV     R0,#?V0 + 4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   75..00       MOV     ?V0 + 1,#0x0
   \   000006   75..00       MOV     ?V0 + 2,#0x0
   \   000009   75..00       MOV     ?V0 + 3,#0x0
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F5..         MOV     ?V0 + 4,A
   \   000010   75..00       MOV     ?V0 + 5,#0x0
   \   000013   75..00       MOV     ?V0 + 6,#0x0
   \   000016   75..00       MOV     ?V0 + 7,#0x0
   \   000019   7408         MOV     A,#0x8
   \   00001B   22           RET
    239          
    240          #if !defined ( ZBIT ) && !defined ( ZBIT2 )
    241          /*********************************************************************
    242           * @fn      _ltoa
    243           *
    244           * @brief
    245           *
    246           *   convert a long unsigned int to a string.
    247           *
    248           * @param  l - long to convert
    249           * @param  buf - buffer to convert to
    250           * @param  radix - 10 dec, 16 hex
    251           *
    252           * @return  pointer to buffer
    253           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    254          unsigned char * _ltoa(unsigned long l, unsigned char *buf, unsigned char radix)
   \                     _ltoa:
    255          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 36
   \   000005   74DC         MOV     A,#-0x24
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   EC           MOV     A,R4
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   ED           MOV     A,R5
   \   000019   F0           MOVX    @DPTR,A
    256          #if defined( __GNUC__ )
    257            return ( (char*)ltoa( l, buf, radix ) );
    258          #else
    259            unsigned char tmp1[10] = "", tmp2[10] = "", tmp3[10] = "";
   \   00001A   7406         MOV     A,#0x6
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   AC82         MOV     R4,DPL
   \   000021   AD83         MOV     R5,DPH
   \   000023   7583..       MOV     DPH,#((`?<Constant "">` >> 8) & 0xff)
   \   000026   7582..       MOV     DPL,#(`?<Constant "">` & 0xff)
   \   000029   740A         MOV     A,#0xa
   \   00002B   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   00002E   7583..       MOV     DPH,#((`?<Constant "">_1` >> 8) & 0xff)
   \   000031   7582..       MOV     DPL,#(`?<Constant "">_1` & 0xff)
   \   000034   740A         MOV     A,#0xa
   \   000036   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   000039   7583..       MOV     DPH,#((`?<Constant "">_2` >> 8) & 0xff)
   \   00003C   7582..       MOV     DPL,#(`?<Constant "">_2` & 0xff)
   \   00003F   740A         MOV     A,#0xa
   \   000041   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    260            unsigned short num1, num2, num3;
    261            unsigned char i;
    262          
    263            buf[0] = '\0';
   \   000044   7434         MOV     A,#0x34
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   00004C   E4           CLR     A
   \   00004D   F0           MOVX    @DPTR,A
    264          
    265            if ( radix == 10 )
   \   00004E   740A         MOV     A,#0xa
   \   000050   69           XRL     A,R1
   \   000051   6003         JZ      $+5
   \   000053   02....       LJMP    ??_ltoa_0 & 0xFFFF
    266            {
    267              num1 = l % 10000;
   \   000056   7402         MOV     A,#0x2
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   78..         MOV     R0,#?V0 + 4
   \   00005D   12....       LCALL   ?L_MOV_X
   \   000060   90....       MOV     DPTR,#__Constant_2710
   \   000063   78..         MOV     R0,#?V0 + 0
   \   000065   12....       LCALL   ?L_MOV_X
   \   000068   78..         MOV     R0,#?V0 + 4
   \   00006A   79..         MOV     R1,#?V0 + 0
   \   00006C   12....       LCALL   ?UL_DIV_MOD
   \   00006F   85..82       MOV     DPL,?XSP + 0
   \   000072   85..83       MOV     DPH,?XSP + 1
   \   000075   E5..         MOV     A,?V0 + 0
   \   000077   F0           MOVX    @DPTR,A
   \   000078   A3           INC     DPTR
   \   000079   E5..         MOV     A,?V0 + 1
   \   00007B   F0           MOVX    @DPTR,A
    268              num2 = (l / 10000) % 10000;
   \   00007C   7402         MOV     A,#0x2
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   78..         MOV     R0,#?V0 + 4
   \   000083   12....       LCALL   ?L_MOV_X
   \   000086   90....       MOV     DPTR,#__Constant_2710
   \   000089   78..         MOV     R0,#?V0 + 0
   \   00008B   12....       LCALL   ?L_MOV_X
   \   00008E   78..         MOV     R0,#?V0 + 4
   \   000090   79..         MOV     R1,#?V0 + 0
   \   000092   12....       LCALL   ?UL_DIV_MOD
   \   000095   90....       MOV     DPTR,#__Constant_2710
   \   000098   78..         MOV     R0,#?V0 + 0
   \   00009A   12....       LCALL   ?L_MOV_X
   \   00009D   78..         MOV     R0,#?V0 + 4
   \   00009F   79..         MOV     R1,#?V0 + 0
   \   0000A1   12....       LCALL   ?UL_DIV_MOD
   \   0000A4   AE..         MOV     R6,?V0 + 0
   \   0000A6   AF..         MOV     R7,?V0 + 1
    269              num3 = (unsigned short)(l / 100000000);
   \   0000A8   7402         MOV     A,#0x2
   \   0000AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AD   78..         MOV     R0,#?V0 + 4
   \   0000AF   12....       LCALL   ?L_MOV_X
   \   0000B2   90....       MOV     DPTR,#__Constant_5f5e100
   \   0000B5   78..         MOV     R0,#?V0 + 0
   \   0000B7   12....       LCALL   ?L_MOV_X
   \   0000BA   78..         MOV     R0,#?V0 + 4
   \   0000BC   79..         MOV     R1,#?V0 + 0
   \   0000BE   12....       LCALL   ?UL_DIV_MOD
   \   0000C1   85....       MOV     ?V0 + 6,?V0 + 4
   \   0000C4   85....       MOV     ?V0 + 7,?V0 + 5
    270          
    271              if (num3) _itoa(num3, tmp3, 10);
   \   0000C7   E5..         MOV     A,?V0 + 6
   \   0000C9   7002         JNZ     ??_ltoa_1
   \   0000CB   E5..         MOV     A,?V0 + 7
   \                     ??_ltoa_1:
   \   0000CD   6012         JZ      ??_ltoa_2
   \   0000CF                ; Setup parameters for call to function _itoa
   \   0000CF   790A         MOV     R1,#0xa
   \   0000D1   741A         MOV     A,#0x1a
   \   0000D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D6   AC82         MOV     R4,DPL
   \   0000D8   AD83         MOV     R5,DPH
   \   0000DA   AA..         MOV     R2,?V0 + 6
   \   0000DC   AB..         MOV     R3,?V0 + 7
   \   0000DE   12....       LCALL   ??_itoa?relay
    272              if (num2) _itoa(num2, tmp2, 10);
   \                     ??_ltoa_2:
   \   0000E1   EE           MOV     A,R6
   \   0000E2   7001         JNZ     ??_ltoa_3
   \   0000E4   EF           MOV     A,R7
   \                     ??_ltoa_3:
   \   0000E5   6012         JZ      ??_ltoa_4
   \   0000E7                ; Setup parameters for call to function _itoa
   \   0000E7   790A         MOV     R1,#0xa
   \   0000E9   7410         MOV     A,#0x10
   \   0000EB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EE   AC82         MOV     R4,DPL
   \   0000F0   AD83         MOV     R5,DPH
   \   0000F2   EE           MOV     A,R6
   \   0000F3   FA           MOV     R2,A
   \   0000F4   EF           MOV     A,R7
   \   0000F5   FB           MOV     R3,A
   \   0000F6   12....       LCALL   ??_itoa?relay
    273              if (num1) _itoa(num1, tmp1, 10);
   \                     ??_ltoa_4:
   \   0000F9   85..82       MOV     DPL,?XSP + 0
   \   0000FC   85..83       MOV     DPH,?XSP + 1
   \   0000FF   E0           MOVX    A,@DPTR
   \   000100   7002         JNZ     ??_ltoa_5
   \   000102   A3           INC     DPTR
   \   000103   E0           MOVX    A,@DPTR
   \                     ??_ltoa_5:
   \   000104   600A         JZ      ??CrossCallReturnLabel_18
   \   000106                ; Setup parameters for call to function _itoa
   \   000106   790A         MOV     R1,#0xa
   \   000108   7406         MOV     A,#0x6
   \   00010A   12....       LCALL   ?XSTACK_DISP0_8
   \   00010D   12....       LCALL   ?Subroutine7 & 0xFFFF
    274          
    275              if (num3)
   \                     ??CrossCallReturnLabel_18:
   \   000110   E5..         MOV     A,?V0 + 6
   \   000112   7002         JNZ     ??_ltoa_6
   \   000114   E5..         MOV     A,?V0 + 7
   \                     ??_ltoa_6:
   \   000116   602C         JZ      ??_ltoa_7
    276              {
    277                strcpy((char*)buf, (char const*)tmp3);
   \   000118                ; Setup parameters for call to function strcpy
   \   000118   741A         MOV     A,#0x1a
   \   00011A   12....       LCALL   ?XSTACK_DISP0_8
   \   00011D   AC82         MOV     R4,DPL
   \   00011F   AD83         MOV     R5,DPH
   \   000121   7434         MOV     A,#0x34
   \   000123   12....       LCALL   ?XSTACK_DISP0_8
   \   000126   12....       LCALL   ?Subroutine5 & 0xFFFF
    278                for (i = 0; i < 4 - strlen((char const*)tmp2); i++)
   \                     ??CrossCallReturnLabel_14:
   \   000129   800C         SJMP    ??CrossCallReturnLabel_5
    279                  strcat((char*)buf, "0");
   \                     ??_ltoa_8:
   \   00012B                ; Setup parameters for call to function strcat
   \   00012B   7C..         MOV     R4,#(`?<Constant "0">` & 0xff)
   \   00012D   7D..         MOV     R5,#((`?<Constant "0">` >> 8) & 0xff)
   \   00012F   7434         MOV     A,#0x34
   \   000131   12....       LCALL   ?XSTACK_DISP0_8
   \   000134   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000137   85....       MOV     ?V0 + 2,?V0 + 0
   \   00013A                ; Setup parameters for call to function strlen
   \   00013A   7410         MOV     A,#0x10
   \   00013C   12....       LCALL   ?XSTACK_DISP0_8
   \   00013F   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000142   40E7         JC      ??_ltoa_8
    280              }
    281              strcat((char*)buf, (char const*)tmp2);
   \                     ??_ltoa_7:
   \   000144                ; Setup parameters for call to function strcat
   \   000144   7410         MOV     A,#0x10
   \   000146   12....       LCALL   ?XSTACK_DISP0_8
   \   000149   AC82         MOV     R4,DPL
   \   00014B   AD83         MOV     R5,DPH
   \   00014D   7434         MOV     A,#0x34
   \   00014F   12....       LCALL   ?XSTACK_DISP0_8
   \   000152   12....       LCALL   ?Subroutine6 & 0xFFFF
    282              if (num3 || num2)
   \                     ??CrossCallReturnLabel_16:
   \   000155   7002         JNZ     ??_ltoa_9
   \   000157   E5..         MOV     A,?V0 + 7
   \                     ??_ltoa_9:
   \   000159   7006         JNZ     ??_ltoa_10
   \   00015B   EE           MOV     A,R6
   \   00015C   7001         JNZ     ??_ltoa_11
   \   00015E   EF           MOV     A,R7
   \                     ??_ltoa_11:
   \   00015F   601E         JZ      ??_ltoa_12
    283              {
    284                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
   \                     ??_ltoa_10:
   \   000161   75..00       MOV     ?V0 + 0,#0x0
   \   000164   800C         SJMP    ??CrossCallReturnLabel_6
    285                  strcat((char*)buf, "0");
   \                     ??_ltoa_13:
   \   000166                ; Setup parameters for call to function strcat
   \   000166   7C..         MOV     R4,#(`?<Constant "0">` & 0xff)
   \   000168   7D..         MOV     R5,#((`?<Constant "0">` >> 8) & 0xff)
   \   00016A   7434         MOV     A,#0x34
   \   00016C   12....       LCALL   ?XSTACK_DISP0_8
   \   00016F   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000172   85....       MOV     ?V0 + 2,?V0 + 0
   \   000175                ; Setup parameters for call to function strlen
   \   000175   7406         MOV     A,#0x6
   \   000177   12....       LCALL   ?XSTACK_DISP0_8
   \   00017A   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   00017D   40E7         JC      ??_ltoa_13
    286              }
    287              strcat((char*)buf, (char const*)tmp1);
   \                     ??_ltoa_12:
   \   00017F                ; Setup parameters for call to function strcat
   \   00017F   7406         MOV     A,#0x6
   \   000181   12....       LCALL   ?XSTACK_DISP0_8
   \   000184   AC82         MOV     R4,DPL
   \   000186   AD83         MOV     R5,DPH
   \   000188   7434         MOV     A,#0x34
   \   00018A   12....       LCALL   ?XSTACK_DISP0_8
   \   00018D   12....       LCALL   ?Subroutine6 & 0xFFFF
    288              if (!num3 && !num2 && !num1)
   \                     ??CrossCallReturnLabel_17:
   \   000190   7002         JNZ     ??_ltoa_14
   \   000192   E5..         MOV     A,?V0 + 7
   \                     ??_ltoa_14:
   \   000194   7022         JNZ     ??_ltoa_15
   \                     ??_ltoa_16:
   \   000196   EE           MOV     A,R6
   \   000197   7001         JNZ     ??_ltoa_17
   \   000199   EF           MOV     A,R7
   \                     ??_ltoa_17:
   \   00019A   701C         JNZ     ??_ltoa_15
   \   00019C   85..82       MOV     DPL,?XSP + 0
   \   00019F   85..83       MOV     DPH,?XSP + 1
   \   0001A2   E0           MOVX    A,@DPTR
   \   0001A3   7002         JNZ     ??_ltoa_18
   \   0001A5   A3           INC     DPTR
   \   0001A6   E0           MOVX    A,@DPTR
   \                     ??_ltoa_18:
   \   0001A7   700F         JNZ     ??_ltoa_15
    289                strcpy((char*)buf, "0");
   \   0001A9                ; Setup parameters for call to function strcpy
   \   0001A9   7C..         MOV     R4,#(`?<Constant "0">` & 0xff)
   \   0001AB   7D..         MOV     R5,#((`?<Constant "0">` >> 8) & 0xff)
   \   0001AD   7434         MOV     A,#0x34
   \   0001AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B2   12....       LCALL   ??Subroutine8_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   0001B5   12....       LCALL   ??strcpy?relay
    290            }
    291            else if ( radix == 16 )
    292            {
    293              num1 = l & 0x0000FFFF;
    294              num2 = l >> 16;
    295          
    296              if (num2) _itoa(num2, tmp2, 16);
    297              if (num1) _itoa(num1, tmp1, 16);
    298          
    299              if (num2)
    300              {
    301                strcpy((char*)buf,(char const*)tmp2);
    302                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
    303                  strcat((char*)buf, "0");
    304              }
    305              strcat((char*)buf, (char const*)tmp1);
    306              if (!num2 && !num1)
    307                strcpy((char*)buf, "0");
    308            }
    309            else
    310              return NULL;
    311          
    312            return buf;
   \                     ??_ltoa_15:
   \   0001B8   7434         MOV     A,#0x34
   \   0001BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BD   12....       LCALL   ??Subroutine8_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   0001C0   7424         MOV     A,#0x24
   \   0001C2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001C5   02....       LJMP    ?Subroutine24 & 0xFFFF
   \                     ??_ltoa_0:
   \   0001C8   7410         MOV     A,#0x10
   \   0001CA   69           XRL     A,R1
   \   0001CB   6003         JZ      $+5
   \   0001CD   02....       LJMP    ??_ltoa_19 & 0xFFFF
   \   0001D0   7402         MOV     A,#0x2
   \   0001D2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D5   78..         MOV     R0,#?V0 + 0
   \   0001D7   12....       LCALL   ?L_MOV_X
   \   0001DA   85..82       MOV     DPL,?XSP + 0
   \   0001DD   85..83       MOV     DPH,?XSP + 1
   \   0001E0   E5..         MOV     A,?V0 + 0
   \   0001E2   F0           MOVX    @DPTR,A
   \   0001E3   A3           INC     DPTR
   \   0001E4   E5..         MOV     A,?V0 + 1
   \   0001E6   F0           MOVX    @DPTR,A
   \   0001E7   7402         MOV     A,#0x2
   \   0001E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EC   78..         MOV     R0,#?V0 + 0
   \   0001EE   12....       LCALL   ?L_MOV_X
   \   0001F1   7410         MOV     A,#0x10
   \   0001F3   78..         MOV     R0,#?V0 + 0
   \   0001F5   12....       LCALL   ?UL_SHR
   \   0001F8   AE..         MOV     R6,?V0 + 0
   \   0001FA   AF..         MOV     R7,?V0 + 1
   \   0001FC   EE           MOV     A,R6
   \   0001FD   7001         JNZ     ??_ltoa_20
   \   0001FF   EF           MOV     A,R7
   \                     ??_ltoa_20:
   \   000200   6011         JZ      ??_ltoa_21
   \   000202                ; Setup parameters for call to function _itoa
   \   000202   7910         MOV     R1,#0x10
   \   000204   E9           MOV     A,R1
   \   000205   12....       LCALL   ?XSTACK_DISP0_8
   \   000208   AC82         MOV     R4,DPL
   \   00020A   AD83         MOV     R5,DPH
   \   00020C   EE           MOV     A,R6
   \   00020D   FA           MOV     R2,A
   \   00020E   EF           MOV     A,R7
   \   00020F   FB           MOV     R3,A
   \   000210   12....       LCALL   ??_itoa?relay
   \                     ??_ltoa_21:
   \   000213   85..82       MOV     DPL,?XSP + 0
   \   000216   85..83       MOV     DPH,?XSP + 1
   \   000219   E0           MOVX    A,@DPTR
   \   00021A   7002         JNZ     ??_ltoa_22
   \   00021C   A3           INC     DPTR
   \   00021D   E0           MOVX    A,@DPTR
   \                     ??_ltoa_22:
   \   00021E   600A         JZ      ??CrossCallReturnLabel_19
   \   000220                ; Setup parameters for call to function _itoa
   \   000220   7910         MOV     R1,#0x10
   \   000222   7406         MOV     A,#0x6
   \   000224   12....       LCALL   ?XSTACK_DISP0_8
   \   000227   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   00022A   EE           MOV     A,R6
   \   00022B   7001         JNZ     ??_ltoa_23
   \   00022D   EF           MOV     A,R7
   \                     ??_ltoa_23:
   \   00022E   602C         JZ      ??_ltoa_24
   \   000230                ; Setup parameters for call to function strcpy
   \   000230   7410         MOV     A,#0x10
   \   000232   12....       LCALL   ?XSTACK_DISP0_8
   \   000235   AC82         MOV     R4,DPL
   \   000237   AD83         MOV     R5,DPH
   \   000239   7434         MOV     A,#0x34
   \   00023B   12....       LCALL   ?XSTACK_DISP0_8
   \   00023E   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000241   800C         SJMP    ??CrossCallReturnLabel_7
   \                     ??_ltoa_25:
   \   000243                ; Setup parameters for call to function strcat
   \   000243   7C..         MOV     R4,#(`?<Constant "0">` & 0xff)
   \   000245   7D..         MOV     R5,#((`?<Constant "0">` >> 8) & 0xff)
   \   000247   7434         MOV     A,#0x34
   \   000249   12....       LCALL   ?XSTACK_DISP0_8
   \   00024C   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00024F   85....       MOV     ?V0 + 2,?V0 + 0
   \   000252                ; Setup parameters for call to function strlen
   \   000252   7406         MOV     A,#0x6
   \   000254   12....       LCALL   ?XSTACK_DISP0_8
   \   000257   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   00025A   40E7         JC      ??_ltoa_25
   \                     ??_ltoa_24:
   \   00025C                ; Setup parameters for call to function strcat
   \   00025C   7406         MOV     A,#0x6
   \   00025E   12....       LCALL   ?XSTACK_DISP0_8
   \   000261   AC82         MOV     R4,DPL
   \   000263   AD83         MOV     R5,DPH
   \   000265   7434         MOV     A,#0x34
   \   000267   12....       LCALL   ?XSTACK_DISP0_8
   \   00026A   12....       LCALL   ??Subroutine8_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   00026D   12....       LCALL   ??strcat?relay
   \   000270   02....       LJMP    ??_ltoa_16 & 0xFFFF
   \                     ??_ltoa_19:
   \   000273   7A00         MOV     R2,#0x0
   \   000275   7B00         MOV     R3,#0x0
   \   000277   02....       LJMP    ??CrossCallReturnLabel_21 & 0xFFFF
    313          #endif
    314          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   85..82       MOV     DPL,?XSP + 0
   \   000007   85..83       MOV     DPH,?XSP + 1
   \   00000A   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00000D   12....       LCALL   ??_itoa?relay
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000003   E5..         MOV     A,?V0 + 6
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000003   12....       LCALL   ??strcpy?relay
   \   000006   75..00       MOV     ?V0 + 0,#0x0
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000003   05..         INC     ?V0 + 0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000003   12....       LCALL   ??strcat?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004   12....       LCALL   ??strlen?relay
   \   000007   8A..         MOV     ?V0 + 4,R2
   \   000009   8B..         MOV     ?V0 + 5,R3
   \   00000B   7404         MOV     A,#0x4
   \   00000D   C3           CLR     C
   \   00000E   95..         SUBB    A,?V0 + 4
   \   000010   F8           MOV     R0,A
   \   000011   E4           CLR     A
   \   000012   95..         SUBB    A,?V0 + 5
   \   000014   F9           MOV     R1,A
   \   000015   C3           CLR     C
   \   000016   E5..         MOV     A,?V0 + 2
   \   000018   98           SUBB    A,R0
   \   000019   E4           CLR     A
   \   00001A   99           SUBB    A,R1
   \   00001B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \                     ??Subroutine8_0:
   \   000004   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
    315          #endif // !defined(ZBIT) && !defined(ZBIT2)
    316          
    317          /*********************************************************************
    318           * @fn          osal_AddrEqual
    319           *
    320           * @brief       Compares two address_t structures.
    321           *
    322           * @param       a1 - first Address
    323           * @param       a2 - second endpoint
    324           *
    325           * @return      true - addresses are equal, false - not equal
    326           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    327          byte osal_AddrEqual( zAddrType_t *a1, zAddrType_t *a2 )
   \                     osal_AddrEqual:
    328          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    329            if ( a1->addrMode != a2->addrMode )
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   FE           MOV     R6,A
   \   000013   8C82         MOV     DPL,R4
   \   000015   8D83         MOV     DPH,R5
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6E           XRL     A,R6
   \   000021   6004         JZ      ??osal_AddrEqual_0
    330              return ( false );
   \                     ??osal_AddrEqual_1:
   \   000023   7900         MOV     R1,#0x0
   \   000025   803D         SJMP    ??osal_AddrEqual_2
    331          
    332            else if (a1->addrMode == AddrNotPresent )
   \                     ??osal_AddrEqual_0:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   7004         JNZ     ??osal_AddrEqual_3
    333              return ( true );
   \                     ??osal_AddrEqual_4:
   \   000036   7901         MOV     R1,#0x1
   \   000038   802A         SJMP    ??osal_AddrEqual_2
    334          
    335            else if (a1->addrMode == Addr16Bit )
   \                     ??osal_AddrEqual_3:
   \   00003A   6402         XRL     A,#0x2
   \   00003C   8A82         MOV     DPL,R2
   \   00003E   8B83         MOV     DPH,R3
   \   000040   7012         JNZ     ??osal_AddrEqual_5
    336              return ( a1->addr.shortAddr == a2->addr.shortAddr );
   \   000042   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000045   8C82         MOV     DPL,R4
   \   000047   8D83         MOV     DPH,R5
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   68           XRL     A,R0
   \   00004B   7003         JNZ     ??osal_AddrEqual_6
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   69           XRL     A,R1
   \                     ??osal_AddrEqual_6:
   \   000050   70D1         JNZ     ??osal_AddrEqual_1
   \   000052   80E2         SJMP    ??osal_AddrEqual_4
    337          
    338            else if ( a1->addrMode == Addr64Bit )
   \                     ??osal_AddrEqual_5:
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   6403         XRL     A,#0x3
   \   00005F   70C2         JNZ     ??osal_AddrEqual_1
    339              return ( osal_ExtAddrEqual( a1->addr.extAddr, a2->addr.extAddr ) );
   \   000061                ; Setup parameters for call to function osal_ExtAddrEqual
   \   000061   12....       LCALL   ??osal_ExtAddrEqual?relay
   \                     ??osal_AddrEqual_2:
   \   000064   02....       LJMP    ?Subroutine23 & 0xFFFF
    340          
    341            else
    342              return ( false );
    343          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    344          
    345          /*********************************************************************
    346           * @fn      osal_ExtAddrEqual()
    347           *
    348           * @brief   Verify that the extended addresses are equal.
    349           *
    350           * @param   extAddr1 - extended address
    351           * @param   extAddr2 - extended address
    352           *
    353           * @return  TRUE - If addresses are same
    354           *          FALSE  - If not same
    355           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    356          byte osal_ExtAddrEqual( byte *extAddr1, byte *extAddr2 )
   \                     osal_ExtAddrEqual:
    357          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    358            byte i;
    359          
    360            for ( i = Z_EXTADDR_LEN; i ; i-- )
   \   000005   75..08       MOV     ?V0 + 0,#0x8
    361            {
    362              if ( *extAddr1++ != *extAddr2++ )
   \                     ??osal_ExtAddrEqual_0:
   \   000008   EA           MOV     A,R2
   \   000009   F8           MOV     R0,A
   \   00000A   EB           MOV     A,R3
   \   00000B   F9           MOV     R1,A
   \   00000C   8882         MOV     DPL,R0
   \   00000E   8983         MOV     DPH,R1
   \   000010   A3           INC     DPTR
   \   000011   AA82         MOV     R2,DPL
   \   000013   AB83         MOV     R3,DPH
   \   000015   EC           MOV     A,R4
   \   000016   FE           MOV     R6,A
   \   000017   ED           MOV     A,R5
   \   000018   FF           MOV     R7,A
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   A3           INC     DPTR
   \   00001E   AC82         MOV     R4,DPL
   \   000020   AD83         MOV     R5,DPH
   \   000022   8882         MOV     DPL,R0
   \   000024   8983         MOV     DPH,R1
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F8           MOV     R0,A
   \   000028   8E82         MOV     DPL,R6
   \   00002A   8F83         MOV     DPH,R7
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   68           XRL     A,R0
   \   00002E   6004         JZ      ??osal_ExtAddrEqual_1
    363                return ( false );
   \   000030   7900         MOV     R1,#0x0
   \   000032   8008         SJMP    ??osal_ExtAddrEqual_2
    364            }
   \                     ??osal_ExtAddrEqual_1:
   \   000034   15..         DEC     ?V0 + 0
   \   000036   E5..         MOV     A,?V0 + 0
   \   000038   70CE         JNZ     ??osal_ExtAddrEqual_0
    365          
    366            return ( true );
   \   00003A   7901         MOV     R1,#0x1
   \                     ??osal_ExtAddrEqual_2:
   \   00003C   80..         SJMP    ?Subroutine21
    367          }
    368          
    369          /*********************************************************************
    370           * @fn        osal_rand
    371           *
    372           * @brief    Random number generator
    373           *
    374           * @param   none
    375           *
    376           * @return  uint16 - new random number
    377           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    378          uint16 osal_rand( void )
   \                     osal_rand:
    379          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    380            return ( Onboard_rand() );
   \   000004                ; Setup parameters for call to function Onboard_rand
   \   000004   12....       LCALL   ??Onboard_rand?relay
   \   000007   02....       LJMP    ?Subroutine19 & 0xFFFF
    381          }
    382          
    383          /*********************************************************************
    384           * API FUNCTIONS
    385           *********************************************************************/
    386          
    387          /*********************************************************************
    388           * @fn      osal_msg_allocate
    389           *
    390           * @brief
    391           *
    392           *    This function is called by a task to allocate a message buffer
    393           *    into which the task will encode the particular message it wishes
    394           *    to send.  This common buffer scheme is used to strictly limit the
    395           *    creation of message buffers within the system due to RAM size
    396           *    limitations on the microprocessor.   Note that all message buffers
    397           *    are a fixed size (at least initially).  The parameter len is kept
    398           *    in case a message pool with varying fixed message sizes is later
    399           *    created (for example, a pool of message buffers of size LARGE,
    400           *    MEDIUM and SMALL could be maintained and allocated based on request
    401           *    from the tasks).
    402           *
    403           *
    404           * @param   byte len  - wanted buffer length
    405           *
    406           *
    407           * @return  pointer to allocated buffer or NULL if allocation failed.
    408           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    409          byte * osal_msg_allocate( uint16 len )
   \                     osal_msg_allocate:
    410          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    411            osal_msg_hdr_t *hdr;
    412          
    413            if ( len == 0 )
   \   000009   EE           MOV     A,R6
   \   00000A   7001         JNZ     ??osal_msg_allocate_0
   \   00000C   EF           MOV     A,R7
   \                     ??osal_msg_allocate_0:
   \   00000D   7006         JNZ     ??osal_msg_allocate_1
    414              return ( NULL );
   \                     ??osal_msg_allocate_2:
   \   00000F   7A00         MOV     R2,#0x0
   \   000011   7B00         MOV     R3,#0x0
   \   000013   803E         SJMP    ??osal_msg_allocate_3
    415          
    416            hdr = (osal_msg_hdr_t *) osal_mem_alloc( (short)(len + sizeof( osal_msg_hdr_t )) );
   \                     ??osal_msg_allocate_1:
   \   000015                ; Setup parameters for call to function osal_mem_alloc
   \   000015   7405         MOV     A,#0x5
   \   000017   2E           ADD     A,R6
   \   000018   FA           MOV     R2,A
   \   000019   E4           CLR     A
   \   00001A   3F           ADDC    A,R7
   \   00001B   FB           MOV     R3,A
   \   00001C   12....       LCALL   ??osal_mem_alloc?relay
   \   00001F   8A..         MOV     ?V0 + 0,R2
   \   000021   8B..         MOV     ?V0 + 1,R3
   \   000023   A8..         MOV     R0,?V0 + 0
   \   000025   A9..         MOV     R1,?V0 + 1
    417            if ( hdr )
   \   000027   E8           MOV     A,R0
   \   000028   7001         JNZ     ??osal_msg_allocate_4
   \   00002A   E9           MOV     A,R1
   \                     ??osal_msg_allocate_4:
   \   00002B   60E2         JZ      ??osal_msg_allocate_2
    418            {
    419              hdr->next = NULL;
   \   00002D   8882         MOV     DPL,R0
   \   00002F   8983         MOV     DPH,R1
   \   000031   E4           CLR     A
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   F0           MOVX    @DPTR,A
    420              hdr->len = len;
   \   000035   8882         MOV     DPL,R0
   \   000037   8983         MOV     DPH,R1
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   EE           MOV     A,R6
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   A3           INC     DPTR
   \   00003E   EF           MOV     A,R7
   \   00003F   F0           MOVX    @DPTR,A
    421              hdr->dest_id = TASK_NO_TASK;
   \   000040   74FF         MOV     A,#-0x1
   \   000042   8882         MOV     DPL,R0
   \   000044   8983         MOV     DPH,R1
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   F0           MOVX    @DPTR,A
    422          
    423          #if defined( OSAL_TOTAL_MEM )
    424              osal_msg_cnt++;
    425          #endif
    426              return ( (byte *) (hdr + 1) );
   \   00004B   E8           MOV     A,R0
   \   00004C   2405         ADD     A,#0x5
   \   00004E   FA           MOV     R2,A
   \   00004F   E9           MOV     A,R1
   \   000050   3400         ADDC    A,#0x0
   \   000052   FB           MOV     R3,A
   \                     ??osal_msg_allocate_3:
   \   000053                REQUIRE ?Subroutine21
   \   000053                ; // Fall through to label ?Subroutine21
    427            }
    428            else
    429              return ( NULL );
    430          }
    431          
    432          /*********************************************************************
    433           * @fn      osal_msg_deallocate
    434           *
    435           * @brief
    436           *
    437           *    This function is used to deallocate a message buffer. This function
    438           *    is called by a task (or processing element) after it has finished
    439           *    processing a received message.
    440           *
    441           *
    442           * @param   byte *msg_ptr - pointer to new message buffer
    443           *
    444           * @return  ZSUCCESS, INVALID_MSG_POINTER
    445           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    446          byte osal_msg_deallocate( byte *msg_ptr )
   \                     osal_msg_deallocate:
    447          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    448            byte *x;
    449          
    450            if ( msg_ptr == NULL )
   \   000004   EA           MOV     A,R2
   \   000005   7001         JNZ     ??osal_msg_deallocate_0
   \   000007   EB           MOV     A,R3
   \                     ??osal_msg_deallocate_0:
   \   000008   7004         JNZ     ??osal_msg_deallocate_1
    451              return ( INVALID_MSG_POINTER );
   \   00000A   7903         MOV     R1,#0x3
   \   00000C   8018         SJMP    ??osal_msg_deallocate_2
    452          
    453            // don't deallocate queued buffer
    454            if ( OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_deallocate_1:
   \   00000E   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   000011   64FF         XRL     A,#0xff
   \   000013   6004         JZ      ??osal_msg_deallocate_3
    455              return ( MSG_BUFFER_NOT_AVAIL );
   \   000015   7902         MOV     R1,#0x2
   \   000017   800D         SJMP    ??osal_msg_deallocate_2
    456          
    457            x = (byte *)((byte *)msg_ptr - sizeof( osal_msg_hdr_t ));
    458          
    459            osal_mem_free( (void *)x );
   \                     ??osal_msg_deallocate_3:
   \   000019                ; Setup parameters for call to function osal_mem_free
   \   000019   EA           MOV     A,R2
   \   00001A   24FB         ADD     A,#-0x5
   \   00001C   FA           MOV     R2,A
   \   00001D   EB           MOV     A,R3
   \   00001E   34FF         ADDC    A,#-0x1
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   ??osal_mem_free?relay
    460          
    461          #if defined( OSAL_TOTAL_MEM )
    462            if ( osal_msg_cnt )
    463              osal_msg_cnt--;
    464          #endif
    465          
    466            return ( ZSUCCESS );
   \   000024   7900         MOV     R1,#0x0
   \                     ??osal_msg_deallocate_2:
   \   000026                REQUIRE ?Subroutine19
   \   000026                ; // Fall through to label ?Subroutine19
    467          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   EA           MOV     A,R2
   \   000001   24FF         ADD     A,#-0x1
   \                     ??Subroutine13_0:
   \   000003   F582         MOV     DPL,A
   \   000005   EB           MOV     A,R3
   \                     ??Subroutine13_1:
   \   000006   34FF         ADDC    A,#-0x1
   \   000008   F583         MOV     DPH,A
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   22           RET
    468          
    469          #if defined( OSAL_TOTAL_MEM )
    470          /*********************************************************************
    471           * @fn      osal_num_msgs
    472           *
    473           * @brief
    474           *
    475           *    This function returns the number of allocated messages
    476           *
    477           * @param   void
    478           *
    479           * @return  UINT16 - number of msgs out
    480           */
    481          UINT16 osal_num_msgs( void )
    482          {
    483            return ( osal_msg_cnt );
    484          }
    485          #endif
    486          
    487          /*********************************************************************
    488           * @fn      osal_msg_send
    489           *
    490           * @brief
    491           *
    492           *    This function is called by a task to send a command message to
    493           *    another task or processing element.  The sending_task field must
    494           *    refer to a valid task, since the task ID will be used
    495           *    for the response message.  This function will also set a message
    496           *    ready event in the destination tasks event list.
    497           *
    498           *
    499           * @param   byte destination task - Send msg to?  Task ID
    500           * @param   byte *msg_ptr - pointer to new message buffer
    501           * @param   byte len - length of data in message
    502           *
    503           * @return  ZSUCCESS, INVALID_SENDING_TASK, INVALID_DESTINATION_TASK,
    504           *          INVALID_MSG_POINTER, INVALID_LEN
    505           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    506          byte osal_msg_send( byte destination_task, byte *msg_ptr )
   \                     osal_msg_send:
    507          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    508            if ( msg_ptr == NULL )
   \   000007   EA           MOV     A,R2
   \   000008   7001         JNZ     ??osal_msg_send_0
   \   00000A   EB           MOV     A,R3
   \                     ??osal_msg_send_0:
   \   00000B   7004         JNZ     ??osal_msg_send_1
    509              return ( INVALID_MSG_POINTER );
   \                     ??osal_msg_send_2:
   \   00000D   7903         MOV     R1,#0x3
   \   00000F   8041         SJMP    ??osal_msg_send_3
    510          
    511            if ( destination_task >= tasksCnt )
   \                     ??osal_msg_send_1:
   \   000011   90....       MOV     DPTR,#tasksCnt
   \   000014   E0           MOVX    A,@DPTR
   \   000015   FC           MOV     R4,A
   \   000016   E9           MOV     A,R1
   \   000017   C3           CLR     C
   \   000018   9C           SUBB    A,R4
   \   000019   4007         JC      ??osal_msg_send_4
    512            {
    513              osal_msg_deallocate( msg_ptr );
   \   00001B                ; Setup parameters for call to function osal_msg_deallocate
   \   00001B   12....       LCALL   ??osal_msg_deallocate?relay
    514              return ( INVALID_TASK );
   \   00001E   7901         MOV     R1,#0x1
   \   000020   8030         SJMP    ??osal_msg_send_3
    515            }
    516          
    517            // Check the message header
    518            if ( OSAL_MSG_NEXT( msg_ptr ) != NULL ||
    519                 OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_send_4:
   \   000022   EA           MOV     A,R2
   \   000023   24FB         ADD     A,#-0x5
   \   000025   12....       LCALL   ??Subroutine13_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000028   7002         JNZ     ??osal_msg_send_5
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \                     ??osal_msg_send_5:
   \   00002C   7007         JNZ     ??osal_msg_send_6
   \   00002E   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000031   64FF         XRL     A,#0xff
   \   000033   6005         JZ      ??osal_msg_send_7
    520            {
    521              osal_msg_deallocate( msg_ptr );
   \                     ??osal_msg_send_6:
   \   000035                ; Setup parameters for call to function osal_msg_deallocate
   \   000035   12....       LCALL   ??osal_msg_deallocate?relay
   \   000038   80D3         SJMP    ??osal_msg_send_2
    522              return ( INVALID_MSG_POINTER );
    523            }
    524          
    525            OSAL_MSG_ID( msg_ptr ) = destination_task;
   \                     ??osal_msg_send_7:
   \   00003A   EE           MOV     A,R6
   \   00003B   F0           MOVX    @DPTR,A
    526          
    527            // queue message
    528            osal_msg_enqueue( &osal_qHead, msg_ptr );
   \   00003C                ; Setup parameters for call to function osal_msg_enqueue
   \   00003C   EA           MOV     A,R2
   \   00003D   FC           MOV     R4,A
   \   00003E   EB           MOV     A,R3
   \   00003F   FD           MOV     R5,A
   \   000040   7A..         MOV     R2,#(osal_qHead & 0xff)
   \   000042   7B..         MOV     R3,#((osal_qHead >> 8) & 0xff)
   \   000044   12....       LCALL   ??osal_msg_enqueue?relay
    529          
    530            // Signal the task that a message is waiting
    531            osal_set_event( destination_task, SYS_EVENT_MSG );
   \   000047                ; Setup parameters for call to function osal_set_event
   \   000047   7A00         MOV     R2,#0x0
   \   000049   7B80         MOV     R3,#-0x80
   \   00004B   EE           MOV     A,R6
   \   00004C   F9           MOV     R1,A
   \   00004D   12....       LCALL   ??osal_set_event?relay
    532          
    533            return ( ZSUCCESS );
   \   000050   7900         MOV     R1,#0x0
   \                     ??osal_msg_send_3:
   \   000052                REQUIRE ?Subroutine23
   \   000052                ; // Fall through to label ?Subroutine23
    534          }
    535          
    536          /*********************************************************************
    537           * @fn      osal_msg_receive
    538           *
    539           * @brief
    540           *
    541           *    This function is called by a task to retrieve a received command
    542           *    message. The calling task must deallocate the message buffer after
    543           *    processing the message using the osal_msg_deallocate() call.
    544           *
    545           * @param   byte task_id - receiving tasks ID
    546           *
    547           * @return  *byte - message information or NULL if no message
    548           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    549          byte *osal_msg_receive( byte task_id )
   \                     osal_msg_receive:
    550          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    551            osal_msg_hdr_t *listHdr;
    552            osal_msg_hdr_t *prevHdr=0;
   \   000005   75..00       MOV     ?V0 + 2,#0x0
   \   000008   75..00       MOV     ?V0 + 3,#0x0
    553            halIntState_t   intState;
    554          
    555            // Hold off interrupts
    556            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000B   A2AF         MOV     C,0xa8.7
   \   00000D   E4           CLR     A
   \   00000E   92E0         MOV     0xE0 /* A   */.0,C
   \   000010   FE           MOV     R6,A
   \   000011   C2AF         CLR     0xa8.7
    557          
    558            // Point to the top of the queue
    559            listHdr = osal_qHead;
   \   000013   90....       MOV     DPTR,#osal_qHead
   \   000016   8020         SJMP    ??osal_msg_receive_0
    560          
    561            // Look through the queue for a message that belongs to the asking task
    562            while ( listHdr != NULL )
    563            {
    564              if ( (listHdr - 1)->dest_id == task_id )
   \                     ??osal_msg_receive_1:
   \   000018   E5..         MOV     A,?V0 + 0
   \   00001A   24FF         ADD     A,#-0x1
   \   00001C   F582         MOV     DPL,A
   \   00001E   E5..         MOV     A,?V0 + 1
   \   000020   12....       LCALL   ??Subroutine13_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000023   69           XRL     A,R1
   \   000024   602C         JZ      ??osal_msg_receive_2
    565              {
    566                break;
    567              }
    568              prevHdr = listHdr;
   \   000026   85....       MOV     ?V0 + 2,?V0 + 0
   \   000029   85....       MOV     ?V0 + 3,?V0 + 1
    569              listHdr = OSAL_MSG_NEXT( listHdr );
   \   00002C   E5..         MOV     A,?V0 + 0
   \   00002E   24FB         ADD     A,#-0x5
   \   000030   F582         MOV     DPL,A
   \   000032   E5..         MOV     A,?V0 + 1
   \   000034   34FF         ADDC    A,#-0x1
   \   000036   F583         MOV     DPH,A
   \                     ??osal_msg_receive_0:
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5..         MOV     ?V0 + 0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F5..         MOV     ?V0 + 1,A
    570            }
   \   00003F   E5..         MOV     A,?V0 + 0
   \   000041   7002         JNZ     ??osal_msg_receive_3
   \   000043   E5..         MOV     A,?V0 + 1
   \                     ??osal_msg_receive_3:
   \   000045   70D1         JNZ     ??osal_msg_receive_1
    571          
    572            // Did we find a message?
    573            if ( listHdr == NULL )
    574            {
    575              // Release interrupts
    576              HAL_EXIT_CRITICAL_SECTION(intState);
   \   000047   EE           MOV     A,R6
   \   000048   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004A   92AF         MOV     0xa8.7,C
    577              return NULL;
   \   00004C   7A00         MOV     R2,#0x0
   \   00004E   7B00         MOV     R3,#0x0
   \   000050   801E         SJMP    ??osal_msg_receive_4
    578            }
    579          
    580            // Take out of the link list
    581            osal_msg_extract( &osal_qHead, listHdr, prevHdr );
   \                     ??osal_msg_receive_2:
   \   000052                ; Setup parameters for call to function osal_msg_extract
   \   000052   78..         MOV     R0,#?V0 + 2
   \   000054   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000057   AC..         MOV     R4,?V0 + 0
   \   000059   AD..         MOV     R5,?V0 + 1
   \   00005B   7A..         MOV     R2,#(osal_qHead & 0xff)
   \   00005D   7B..         MOV     R3,#((osal_qHead >> 8) & 0xff)
   \   00005F   12....       LCALL   ??osal_msg_extract?relay
   \   000062   7402         MOV     A,#0x2
   \   000064   12....       LCALL   ?DEALLOC_XSTACK8
    582          
    583            // Release interrupts
    584            HAL_EXIT_CRITICAL_SECTION(intState);
   \   000067   EE           MOV     A,R6
   \   000068   A2E0         MOV     C,0xE0 /* A   */.0
   \   00006A   92AF         MOV     0xa8.7,C
    585          
    586            return ( (byte*) listHdr );
   \   00006C   AA..         MOV     R2,?V0 + 0
   \   00006E   AB..         MOV     R3,?V0 + 1
   \                     ??osal_msg_receive_4:
   \   000070   7F04         MOV     R7,#0x4
   \   000072   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000075                REQUIRE _A_IEN0
    587          }
    588          
    589          /*********************************************************************
    590           * @fn      osal_msg_enqueue
    591           *
    592           * @brief
    593           *
    594           *    This function enqueues an OSAL message into an OSAL queue.
    595           *
    596           * @param   osal_msg_q_t *q_ptr - OSAL queue
    597           * @param   void *msg_ptr  - OSAL message
    598           *
    599           * @return  none
    600           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    601          void osal_msg_enqueue( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_enqueue:
    602          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    603            void *list;
    604            halIntState_t intState;
    605          
    606            // Hold off interrupts
    607            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   92E0         MOV     0xE0 /* A   */.0,C
   \   00000A   FE           MOV     R6,A
   \   00000B   C2AF         CLR     0xa8.7
    608          
    609            // If first message in queue
    610            if ( *q_ptr == NULL )
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7002         JNZ     ??osal_msg_enqueue_0
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \                     ??osal_msg_enqueue_0:
   \   000016   8A82         MOV     DPL,R2
   \   000018   8B83         MOV     DPH,R3
   \   00001A   7005         JNZ     ??CrossCallReturnLabel_53
    611            {
    612              *q_ptr = msg_ptr;
   \   00001C   8018         SJMP    ??CrossCallReturnLabel_54
    613            }
    614            else
    615            {
    616              // Find end of queue
    617              for ( list = *q_ptr; OSAL_MSG_NEXT( list ) != NULL; list = OSAL_MSG_NEXT( list ) );
   \                     ??osal_msg_enqueue_1:
   \   00001E   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000021   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000024   E8           MOV     A,R0
   \   000025   24FB         ADD     A,#-0x5
   \   000027   F582         MOV     DPL,A
   \   000029   E9           MOV     A,R1
   \   00002A   12....       LCALL   ??Subroutine13_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00002D   7002         JNZ     ??osal_msg_enqueue_2
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \                     ??osal_msg_enqueue_2:
   \   000031   70EB         JNZ     ??osal_msg_enqueue_1
    618          
    619              // Add message to end of queue
    620              OSAL_MSG_NEXT( list ) = msg_ptr;
   \   000033   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000036                REQUIRE ?Subroutine22
   \   000036                REQUIRE _A_IEN0
   \   000036                ; // Fall through to label ?Subroutine22
    621            }
    622          
    623            // Re-enable interrupts
    624            HAL_EXIT_CRITICAL_SECTION(intState);
    625          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000003   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   EC           MOV     A,R4
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   ED           MOV     A,R5
   \   000004   F0           MOVX    @DPTR,A
   \   000005   EE           MOV     A,R6
   \   000006   A2E0         MOV     C,0xE0 /* A   */.0
   \   000008   92AF         MOV     0xa8.7,C
   \   00000A   7F01         MOV     R7,#0x1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E8           MOV     A,R0
   \   000001   24FB         ADD     A,#-0x5
   \   000003   F582         MOV     DPL,A
   \   000005   E9           MOV     A,R1
   \   000006                REQUIRE ?Subroutine26
   \   000006                ; // Fall through to label ?Subroutine26

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   34FF         ADDC    A,#-0x1
   \   000002   F583         MOV     DPH,A
   \   000004   22           RET
    626          
    627          /*********************************************************************
    628           * @fn      osal_msg_dequeue
    629           *
    630           * @brief
    631           *
    632           *    This function dequeues an OSAL message from an OSAL queue.
    633           *
    634           * @param   osal_msg_q_t *q_ptr - OSAL queue
    635           *
    636           * @return  void * - pointer to OSAL message or NULL of queue is empty.
    637           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    638          void *osal_msg_dequeue( osal_msg_q_t *q_ptr )
   \                     osal_msg_dequeue:
    639          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
    640            void *msg_ptr;
    641            halIntState_t intState;
    642          
    643            // Hold off interrupts
    644            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000009   A2AF         MOV     C,0xa8.7
   \   00000B   E4           CLR     A
   \   00000C   92E0         MOV     0xE0 /* A   */.0,C
   \   00000E   F5..         MOV     ?V0 + 0,A
   \   000010   C2AF         CLR     0xa8.7
    645          
    646            if ( *q_ptr == NULL )
   \   000012   8882         MOV     DPL,R0
   \   000014   8983         MOV     DPH,R1
   \   000016   E0           MOVX    A,@DPTR
   \   000017   7002         JNZ     ??osal_msg_dequeue_0
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \                     ??osal_msg_dequeue_0:
   \   00001B   700C         JNZ     ??osal_msg_dequeue_1
    647            {
    648              HAL_EXIT_CRITICAL_SECTION(intState);
   \   00001D   E5..         MOV     A,?V0 + 0
   \   00001F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000021   92AF         MOV     0xa8.7,C
    649              return NULL;
   \   000023   7A00         MOV     R2,#0x0
   \   000025   7B00         MOV     R3,#0x0
   \   000027   802E         SJMP    ??CrossCallReturnLabel_47
    650            }
    651          
    652            // Dequeue message
    653            msg_ptr = *q_ptr;
   \                     ??osal_msg_dequeue_1:
   \   000029   12....       LCALL   ?Subroutine8 & 0xFFFF
    654            *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \                     ??CrossCallReturnLabel_23:
   \   00002C   EA           MOV     A,R2
   \   00002D   24FB         ADD     A,#-0x5
   \   00002F   FC           MOV     R4,A
   \   000030   EB           MOV     A,R3
   \   000031   34FF         ADDC    A,#-0x1
   \   000033   FD           MOV     R5,A
   \   000034   8C82         MOV     DPL,R4
   \   000036   8D83         MOV     DPH,R5
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FE           MOV     R6,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FF           MOV     R7,A
   \   00003D   8882         MOV     DPL,R0
   \   00003F   8983         MOV     DPH,R1
   \   000041   EE           MOV     A,R6
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
   \   000044   EF           MOV     A,R7
   \   000045   F0           MOVX    @DPTR,A
    655            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   000046   8C82         MOV     DPL,R4
   \   000048   8D83         MOV     DPH,R5
   \   00004A   E4           CLR     A
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   F0           MOVX    @DPTR,A
    656            OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   00004E   EA           MOV     A,R2
   \   00004F   24FF         ADD     A,#-0x1
   \   000051   F582         MOV     DPL,A
   \   000053   EB           MOV     A,R3
   \   000054   12....       LCALL   ?Subroutine15 & 0xFFFF
    657          
    658            // Re-enable interrupts
    659            HAL_EXIT_CRITICAL_SECTION(intState);
    660          
    661            return msg_ptr;
   \                     ??CrossCallReturnLabel_47:
   \   000057   02....       LJMP    ?Subroutine21 & 0xFFFF
   \   00005A                REQUIRE _A_IEN0
    662          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   34FF         ADDC    A,#-0x1
   \   000002   F583         MOV     DPH,A
   \   000004   74FF         MOV     A,#-0x1
   \   000006   F0           MOVX    @DPTR,A
   \   000007   E5..         MOV     A,?V0 + 0
   \   000009                REQUIRE ?Subroutine25
   \   000009                ; // Fall through to label ?Subroutine25

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   A2E0         MOV     C,0xE0 /* A   */.0
   \   000002   92AF         MOV     0xa8.7,C
   \   000004   22           RET
    663          
    664          /*********************************************************************
    665           * @fn      osal_msg_push
    666           *
    667           * @brief
    668           *
    669           *    This function pushes an OSAL message to the head of an OSAL
    670           *    queue.
    671           *
    672           * @param   osal_msg_q_t *q_ptr - OSAL queue
    673           * @param   void *msg_ptr  - OSAL message
    674           *
    675           * @return  none
    676           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    677          void osal_msg_push( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_push:
    678          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    679            halIntState_t intState;
    680          
    681            // Hold off interrupts
    682            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   92E0         MOV     0xE0 /* A   */.0,C
   \   00000A   FE           MOV     R6,A
   \   00000B   C2AF         CLR     0xa8.7
    683          
    684            if ( *q_ptr == NULL )
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7002         JNZ     ??osal_msg_push_0
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \                     ??osal_msg_push_0:
   \   000016   7007         JNZ     ??osal_msg_push_1
    685            {
    686              *q_ptr = msg_ptr;
   \                     ??osal_msg_push_2:
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   02....       LJMP    ?Subroutine22 & 0xFFFF
    687            }
    688            else
    689            {
    690              // Push message to head of queue
    691              OSAL_MSG_NEXT( msg_ptr ) = *q_ptr;
   \                     ??osal_msg_push_1:
   \   00001F   8A82         MOV     DPL,R2
   \   000021   8B83         MOV     DPH,R3
   \   000023   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000026   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000029   E8           MOV     A,R0
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   E9           MOV     A,R1
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   80E8         SJMP    ??osal_msg_push_2
   \   000030                REQUIRE _A_IEN0
    692              *q_ptr = msg_ptr;
    693            }
    694          
    695            // Re-enable interrupts
    696            HAL_EXIT_CRITICAL_SECTION(intState);
    697          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   EC           MOV     A,R4
   \   000001   24FB         ADD     A,#-0x5
   \   000003   F582         MOV     DPL,A
   \   000005   ED           MOV     A,R5
   \   000006   80..         SJMP    ?Subroutine26
    698          
    699          /*********************************************************************
    700           * @fn      osal_msg_extract
    701           *
    702           * @brief
    703           *
    704           *    This function extracts and removes an OSAL message from the
    705           *    middle of an OSAL queue.
    706           *
    707           * @param   osal_msg_q_t *q_ptr - OSAL queue
    708           * @param   void *msg_ptr  - OSAL message to be extracted
    709           * @param   void *prev_ptr  - OSAL message before msg_ptr in queue
    710           *
    711           * @return  none
    712           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    713          void osal_msg_extract( osal_msg_q_t *q_ptr, void *msg_ptr, void *prev_ptr )
   \                     osal_msg_extract:
    714          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ?Subroutine3 & 0xFFFF
    715            halIntState_t intState;
    716          
    717            // Hold off interrupts
    718            HAL_ENTER_CRITICAL_SECTION(intState);
   \                     ??CrossCallReturnLabel_11:
   \   00000D   A2AF         MOV     C,0xa8.7
   \   00000F   E4           CLR     A
   \   000010   92E0         MOV     0xE0 /* A   */.0,C
   \   000012   F5..         MOV     ?V0 + 0,A
   \   000014   C2AF         CLR     0xa8.7
    719          
    720            if ( msg_ptr == *q_ptr )
   \   000016   8A82         MOV     DPL,R2
   \   000018   8B83         MOV     DPH,R3
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FE           MOV     R6,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   FF           MOV     R7,A
   \   00001F   EC           MOV     A,R4
   \   000020   6E           XRL     A,R6
   \   000021   7002         JNZ     ??osal_msg_extract_0
   \   000023   ED           MOV     A,R5
   \   000024   6F           XRL     A,R7
   \                     ??osal_msg_extract_0:
   \   000025   7010         JNZ     ??osal_msg_extract_1
    721            {
    722              // remove from first
    723              *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \   000027   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00002A   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   00002D   8A82         MOV     DPL,R2
   \   00002F   8B83         MOV     DPH,R3
   \   000031   E8           MOV     A,R0
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   E9           MOV     A,R1
   \   000035   800D         SJMP    ??osal_msg_extract_2
    724            }
    725            else
    726            {
    727              // remove from middle
    728              OSAL_MSG_NEXT( prev_ptr ) = OSAL_MSG_NEXT( msg_ptr );
   \                     ??osal_msg_extract_1:
   \   000037   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   00003A   12....       LCALL   ??Subroutine8_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   00003D   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000040   EA           MOV     A,R2
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   EB           MOV     A,R3
   \                     ??osal_msg_extract_2:
   \   000044   F0           MOVX    @DPTR,A
    729            }
    730            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   000045   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000048   E4           CLR     A
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   F0           MOVX    @DPTR,A
    731            OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   00004C   EC           MOV     A,R4
   \   00004D   24FF         ADD     A,#-0x1
   \   00004F   F582         MOV     DPL,A
   \   000051   ED           MOV     A,R5
   \   000052   12....       LCALL   ?Subroutine15 & 0xFFFF
    732          
    733            // Re-enable interrupts
    734            HAL_EXIT_CRITICAL_SECTION(intState);
    735          }
   \                     ??CrossCallReturnLabel_48:
   \   000055   02....       LJMP    ?Subroutine23 & 0xFFFF
   \   000058                REQUIRE _A_IEN0
    736          
    737          /*********************************************************************
    738           * @fn      osal_msg_enqueue_max
    739           *
    740           * @brief
    741           *
    742           *    This function enqueues an OSAL message into an OSAL queue if
    743           *    the length of the queue is less than max.
    744           *
    745           * @param   osal_msg_q_t *q_ptr - OSAL queue
    746           * @param   void *msg_ptr  - OSAL message
    747           * @param   byte max - maximum length of queue
    748           *
    749           * @return  TRUE if message was enqueued, FALSE otherwise
    750           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    751          byte osal_msg_enqueue_max( osal_msg_q_t *q_ptr, void *msg_ptr, byte max )
   \                     osal_msg_enqueue_max:
    752          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    753            void *list;
    754            byte ret = FALSE;
   \   000007   75..00       MOV     ?V0 + 0,#0x0
    755            halIntState_t intState;
    756          
    757            // Hold off interrupts
    758            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000A   A2AF         MOV     C,0xa8.7
   \   00000C   E4           CLR     A
   \   00000D   92E0         MOV     0xE0 /* A   */.0,C
   \   00000F   FF           MOV     R7,A
   \   000010   C2AF         CLR     0xa8.7
    759          
    760            // If first message in queue
    761            if ( *q_ptr == NULL )
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   E0           MOVX    A,@DPTR
   \   000017   7002         JNZ     ??osal_msg_enqueue_max_0
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \                     ??osal_msg_enqueue_max_0:
   \   00001B   8A82         MOV     DPL,R2
   \   00001D   8B83         MOV     DPH,R3
   \   00001F   7005         JNZ     ??CrossCallReturnLabel_56
    762            {
    763              *q_ptr = msg_ptr;
   \   000021   801F         SJMP    ??CrossCallReturnLabel_57
    764              ret = TRUE;
    765            }
    766            else
    767            {
    768              // Find end of queue or max
    769              list = *q_ptr;
    770              max--;
    771              while ( (OSAL_MSG_NEXT( list ) != NULL) && (max > 0) )
    772              {
    773                list = OSAL_MSG_NEXT( list );
   \                     ??osal_msg_enqueue_max_1:
   \   000023   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000026   12....       LCALL   ?Subroutine3 & 0xFFFF
    774                max--;
   \                     ??CrossCallReturnLabel_13:
   \   000029   1E           DEC     R6
    775              }
   \   00002A   E8           MOV     A,R0
   \   00002B   24FB         ADD     A,#-0x5
   \   00002D   F582         MOV     DPL,A
   \   00002F   E9           MOV     A,R1
   \   000030   12....       LCALL   ??Subroutine13_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000033   7002         JNZ     ??osal_msg_enqueue_max_2
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \                     ??osal_msg_enqueue_max_2:
   \   000037   6003         JZ      ??osal_msg_enqueue_max_3
   \   000039   EE           MOV     A,R6
   \   00003A   70E7         JNZ     ??osal_msg_enqueue_max_1
    776          
    777              // Add message to end of queue if max not reached
    778              if ( max != 0 )
   \                     ??osal_msg_enqueue_max_3:
   \   00003C   EE           MOV     A,R6
   \   00003D   600B         JZ      ??osal_msg_enqueue_max_4
    779              {
    780                OSAL_MSG_NEXT( list ) = msg_ptr;
   \   00003F   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000042   EC           MOV     A,R4
   \   000043   F0           MOVX    @DPTR,A
   \   000044   A3           INC     DPTR
   \   000045   ED           MOV     A,R5
   \   000046   F0           MOVX    @DPTR,A
    781                ret = TRUE;
   \   000047   75..01       MOV     ?V0 + 0,#0x1
    782              }
    783            }
    784          
    785            // Re-enable interrupts
    786            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_enqueue_max_4:
   \   00004A   EF           MOV     A,R7
   \   00004B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004D   92AF         MOV     0xa8.7,C
    787          
    788            return ret;
   \   00004F   A9..         MOV     R1,?V0 + 0
   \   000051   02....       LJMP    ?Subroutine21 & 0xFFFF
   \   000054                REQUIRE _A_IEN0
    789          }
    790          
    791          /*********************************************************************
    792           * @fn      osal_set_event
    793           *
    794           * @brief
    795           *
    796           *    This function is called to set the event flags for a task.  The
    797           *    event passed in is OR'd into the task's event variable.
    798           *
    799           * @param   byte task_id - receiving tasks ID
    800           * @param   byte event_flag - what event to set
    801           *
    802           * @return  ZSUCCESS, INVALID_TASK
    803           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    804          byte osal_set_event( byte task_id, UINT16 event_flag )
   \                     osal_set_event:
    805          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    806            if ( task_id < tasksCnt )
   \   000004   90....       MOV     DPTR,#tasksCnt
   \   000007   E0           MOVX    A,@DPTR
   \   000008   FC           MOV     R4,A
   \   000009   E9           MOV     A,R1
   \   00000A   C3           CLR     C
   \   00000B   9C           SUBB    A,R4
   \   00000C   501F         JNC     ??osal_set_event_0
    807            {
    808            halIntState_t   intState;
    809              HAL_ENTER_CRITICAL_SECTION(intState);    // Hold off interrupts
   \   00000E   A2AF         MOV     C,0xa8.7
   \   000010   E4           CLR     A
   \   000011   92E0         MOV     0xE0 /* A   */.0,C
   \   000013   FD           MOV     R5,A
   \   000014   C2AF         CLR     0xa8.7
    810              tasksEvents[task_id] |= event_flag;  // Stuff the event bit(s)
   \   000016   E9           MOV     A,R1
   \   000017   C3           CLR     C
   \   000018   33           RLC     A
   \   000019   F8           MOV     R0,A
   \   00001A   E4           CLR     A
   \   00001B   33           RLC     A
   \   00001C   F9           MOV     R1,A
   \   00001D   90....       MOV     DPTR,#tasksEvents
   \   000020   E0           MOVX    A,@DPTR
   \   000021   28           ADD     A,R0
   \   000022   FC           MOV     R4,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   39           ADDC    A,R1
   \   000026   12....       LCALL   ?Subroutine4 & 0xFFFF
    811              HAL_EXIT_CRITICAL_SECTION(intState);     // Release interrupts
    812            }
    813             else
    814              return ( INVALID_TASK );
    815          
    816            return ( ZSUCCESS );
   \                     ??CrossCallReturnLabel_45:
   \   000029   7900         MOV     R1,#0x0
   \   00002B   8002         SJMP    ??osal_set_event_1
   \                     ??osal_set_event_0:
   \   00002D   7901         MOV     R1,#0x1
   \                     ??osal_set_event_1:
   \   00002F   02....       LJMP    ?Subroutine19 & 0xFFFF
   \   000032                REQUIRE _A_IEN0
    817          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   8C82         MOV     DPL,R4
   \   000002   F583         MOV     DPH,A
   \   000004   E0           MOVX    A,@DPTR
   \   000005   4A           ORL     A,R2
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   4B           ORL     A,R3
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   ED           MOV     A,R5
   \   00000C   02....       LJMP    ?Subroutine25 & 0xFFFF
    818          
    819          /*********************************************************************
    820           * @fn      osal_isr_register
    821           *
    822           * @brief
    823           *
    824           *   This function is called to register a service routine with an
    825           *   interrupt. When the interrupt occurs, this service routine is called.
    826           *
    827           * @param   byte interrupt_id - Interrupt number
    828           * @param   void (*isr_ptr)( byte* ) - function pointer to ISR
    829           *
    830           * @return  ZSUCCESS, INVALID_INTERRUPT_ID, or INVALID_ISR_PTR
    831           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    832          byte osal_isr_register( byte interrupt_id, void (*isr_ptr)( byte* ) )
   \                     osal_isr_register:
    833          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    834            return ( ZSUCCESS );
   \   000000   7900         MOV     R1,#0x0
   \   000002   02....       LJMP    ?BRET
    835          }
    836          
    837          /*********************************************************************
    838           * @fn      osal_int_enable
    839           *
    840           * @brief
    841           *
    842           *   This function is called to enable an interrupt. Once enabled,
    843           *   occurrence of the interrupt causes the service routine associated
    844           *   with that interrupt to be called.
    845           *
    846           *   If INTS_ALL is the interrupt_id, interrupts (in general) are enabled.
    847           *   If a single interrupt is passed in, then interrupts still have
    848           *   to be enabled with another call to INTS_ALL.
    849           *
    850           * @param   byte interrupt_id - Interrupt number
    851           *
    852           * @return  ZSUCCESS or INVALID_INTERRUPT_ID
    853           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    854          byte osal_int_enable( byte interrupt_id )
   \                     osal_int_enable:
    855          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    856          
    857            if ( interrupt_id == INTS_ALL )
   \   000000   74FF         MOV     A,#-0x1
   \   000002   69           XRL     A,R1
   \   000003   7006         JNZ     ??osal_int_enable_0
    858            {
    859              HAL_ENABLE_INTERRUPTS();
   \   000005   D2AF         SETB    0xa8.7
    860            }
    861            else
    862              return ( INVALID_INTERRUPT_ID );
    863          
    864            return ( ZSUCCESS );
   \   000007   7900         MOV     R1,#0x0
   \   000009   8002         SJMP    ??osal_int_enable_1
   \                     ??osal_int_enable_0:
   \   00000B   7909         MOV     R1,#0x9
   \                     ??osal_int_enable_1:
   \   00000D   02....       LJMP    ?BRET
   \   000010                REQUIRE _A_IEN0
    865          }
    866          
    867          /*********************************************************************
    868           * @fn      osal_int_disable
    869           *
    870           * @brief
    871           *
    872           *   This function is called to disable an interrupt. When a disabled
    873           *   interrupt occurs, the service routine associated with that
    874           *   interrupt is not called.
    875           *
    876           *   If INTS_ALL is the interrupt_id, interrupts (in general) are disabled.
    877           *   If a single interrupt is passed in, then just that interrupt is disabled.
    878           *
    879           * @param   byte interrupt_id - Interrupt number
    880           *
    881           * @return  ZSUCCESS or INVALID_INTERRUPT_ID
    882           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    883          byte osal_int_disable( byte interrupt_id )
   \                     osal_int_disable:
    884          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    885          
    886            if ( interrupt_id == INTS_ALL )
   \   000000   74FF         MOV     A,#-0x1
   \   000002   69           XRL     A,R1
   \   000003   7006         JNZ     ??osal_int_disable_0
    887            {
    888              HAL_DISABLE_INTERRUPTS();
   \   000005   C2AF         CLR     0xa8.7
    889            }
    890            else
    891              return ( INVALID_INTERRUPT_ID );
    892          
    893            return ( ZSUCCESS );
   \   000007   7900         MOV     R1,#0x0
   \   000009   8002         SJMP    ??osal_int_disable_1
   \                     ??osal_int_disable_0:
   \   00000B   7909         MOV     R1,#0x9
   \                     ??osal_int_disable_1:
   \   00000D   02....       LJMP    ?BRET
   \   000010                REQUIRE _A_IEN0
    894          }
    895          
    896          /*********************************************************************
    897           * @fn      osal_init_system
    898           *
    899           * @brief
    900           *
    901           *   This function initializes the "task" system by creating the
    902           *   tasks defined in the task table (OSAL_Tasks.h).
    903           *
    904           * @param   void
    905           *
    906           * @return  ZSUCCESS
    907           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    908          byte osal_init_system( void )
   \                     osal_init_system:
    909          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    910            // Initialize the Memory Allocation System
    911            osal_mem_init();
   \   000004                ; Setup parameters for call to function osal_mem_init
   \   000004   12....       LCALL   ??osal_mem_init?relay
    912          
    913            // Initialize the message queue
    914            osal_qHead = NULL;
   \   000007   90....       MOV     DPTR,#osal_qHead
   \   00000A   E4           CLR     A
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   F0           MOVX    @DPTR,A
    915          
    916          #if defined( OSAL_TOTAL_MEM )
    917            osal_msg_cnt = 0;
    918          #endif
    919          
    920            // Initialize the timers
    921            osalTimerInit();
   \   00000E                ; Setup parameters for call to function osalTimerInit
   \   00000E   12....       LCALL   ??osalTimerInit?relay
    922          
    923            // Initialize the Power Management System
    924            osal_pwrmgr_init();
   \   000011                ; Setup parameters for call to function osal_pwrmgr_init
   \   000011   12....       LCALL   ??osal_pwrmgr_init?relay
    925          
    926            // Initialize the system tasks.
    927            osalInitTasks();
   \   000014                ; Setup parameters for call to function osalInitTasks
   \   000014   12....       LCALL   ??osalInitTasks?relay
    928          
    929            // Setup efficient search for the first free block of heap.
    930            osal_mem_kick();
   \   000017                ; Setup parameters for call to function osal_mem_kick
   \   000017   12....       LCALL   ??osal_mem_kick?relay
    931          
    932            return ( ZSUCCESS );
   \   00001A   7900         MOV     R1,#0x0
   \   00001C   02....       LJMP    ?Subroutine19 & 0xFFFF
    933          }
    934          
    935          /*********************************************************************
    936           * @fn      osal_start_system
    937           *
    938           * @brief
    939           *
    940           *   This function is the main loop function of the task system.  It
    941           *   will look through all task events and call the task_event_processor()
    942           *   function for the task with the event.  If there are no events (for
    943           *   all tasks), this function puts the processor into Sleep.
    944           *   This Function doesn't return.
    945           *
    946           * @param   void
    947           *
    948           * @return  none
    949           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    950          void osal_start_system( void )
   \                     osal_start_system:
    951          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    952          #if !defined ( ZBIT )
    953            for(;;)  // Forever Loop
    954          #endif
    955            {
    956              uint8 idx = 0;
   \                     ??osal_start_system_0:
   \   000005   75..00       MOV     ?V0 + 0,#0x0
    957          
    958              Hal_ProcessPoll();  // This replaces MT_SerialPoll() and osal_check_timer().
   \   000008                ; Setup parameters for call to function Hal_ProcessPoll
   \   000008   12....       LCALL   ??Hal_ProcessPoll?relay
    959          
    960              do {
    961                if (tasksEvents[idx])  // Task is highest priority that is ready.
   \                     ??osal_start_system_1:
   \   00000B   E5..         MOV     A,?V0 + 0
   \   00000D   C3           CLR     C
   \   00000E   33           RLC     A
   \   00000F   F8           MOV     R0,A
   \   000010   E4           CLR     A
   \   000011   33           RLC     A
   \   000012   F9           MOV     R1,A
   \   000013   90....       MOV     DPTR,#tasksEvents
   \   000016   E0           MOVX    A,@DPTR
   \   000017   28           ADD     A,R0
   \   000018   FA           MOV     R2,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   39           ADDC    A,R1
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   F583         MOV     DPH,A
   \   000020   E0           MOVX    A,@DPTR
   \   000021   7002         JNZ     ??osal_start_system_2
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \                     ??osal_start_system_2:
   \   000025   700D         JNZ     ??osal_start_system_3
    962                {
    963                  break;
    964                }
    965              } while (++idx < tasksCnt);
   \   000027   05..         INC     ?V0 + 0
   \   000029   90....       MOV     DPTR,#tasksCnt
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   FA           MOV     R2,A
   \   00002E   E5..         MOV     A,?V0 + 0
   \   000030   C3           CLR     C
   \   000031   9A           SUBB    A,R2
   \   000032   40D7         JC      ??osal_start_system_1
    966          
    967              if (idx < tasksCnt)
   \                     ??osal_start_system_3:
   \   000034   90....       MOV     DPTR,#tasksCnt
   \   000037   E0           MOVX    A,@DPTR
   \   000038   FA           MOV     R2,A
   \   000039   E5..         MOV     A,?V0 + 0
   \   00003B   C3           CLR     C
   \   00003C   9A           SUBB    A,R2
   \   00003D   50C6         JNC     ??osal_start_system_0
    968              {
    969                uint16 events;
    970                halIntState_t intState;
    971          
    972                HAL_ENTER_CRITICAL_SECTION(intState);
   \   00003F   A2AF         MOV     C,0xa8.7
   \   000041   E4           CLR     A
   \   000042   92E0         MOV     0xE0 /* A   */.0,C
   \   000044   FD           MOV     R5,A
   \   000045   C2AF         CLR     0xa8.7
    973                events = tasksEvents[idx];
   \   000047   E5..         MOV     A,?V0 + 0
   \   000049   C3           CLR     C
   \   00004A   33           RLC     A
   \   00004B   FE           MOV     R6,A
   \   00004C   E4           CLR     A
   \   00004D   33           RLC     A
   \   00004E   FF           MOV     R7,A
   \   00004F   90....       MOV     DPTR,#tasksEvents
   \   000052   E0           MOVX    A,@DPTR
   \   000053   2E           ADD     A,R6
   \   000054   F8           MOV     R0,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   3F           ADDC    A,R7
   \   000058   F9           MOV     R1,A
   \   000059   12....       LCALL   ?Subroutine8 & 0xFFFF
    974                tasksEvents[idx] = 0;  // Clear the Events for this task.
   \                     ??CrossCallReturnLabel_25:
   \   00005C   8882         MOV     DPL,R0
   \   00005E   8983         MOV     DPH,R1
   \   000060   E4           CLR     A
   \   000061   F0           MOVX    @DPTR,A
   \   000062   A3           INC     DPTR
   \   000063   F0           MOVX    @DPTR,A
    975                HAL_EXIT_CRITICAL_SECTION(intState);
   \   000064   ED           MOV     A,R5
   \   000065   A2E0         MOV     C,0xE0 /* A   */.0
   \   000067   92AF         MOV     0xa8.7,C
    976          
    977                events = (tasksArr[idx])( idx, events );
   \   000069                ; Setup parameters for indirect call
   \   000069   A9..         MOV     R1,?V0 + 0
   \   00006B   EE           MOV     A,R6
   \   00006C   24..         ADD     A,#(tasksArr & 0xff)
   \   00006E   F582         MOV     DPL,A
   \   000070   EF           MOV     A,R7
   \   000071   34..         ADDC    A,#((tasksArr >> 8) & 0xff)
   \   000073   F583         MOV     DPH,A
   \   000075   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000078   12....       LCALL   ?CALL_IND
    978          
    979                    HAL_ENTER_CRITICAL_SECTION(intState);
   \   00007B   A2AF         MOV     C,0xa8.7
   \   00007D   E4           CLR     A
   \   00007E   92E0         MOV     0xE0 /* A   */.0,C
   \   000080   FD           MOV     R5,A
   \   000081   C2AF         CLR     0xa8.7
    980                tasksEvents[idx] |= events;  // Add back unprocessed events to the current task.
   \   000083   90....       MOV     DPTR,#tasksEvents
   \   000086   E0           MOVX    A,@DPTR
   \   000087   2E           ADD     A,R6
   \   000088   FC           MOV     R4,A
   \   000089   A3           INC     DPTR
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   3F           ADDC    A,R7
   \   00008C   12....       LCALL   ?Subroutine4 & 0xFFFF
    981                    HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??CrossCallReturnLabel_46:
   \   00008F   02....       LJMP    ??osal_start_system_0 & 0xFFFF
   \   000092                REQUIRE _A_IEN0
    982                }
    983          #if defined( POWER_SAVING )
    984              else  // Complete pass through all task events with no activity?
    985              {
    986                osal_pwrmgr_powerconserve();  // Put the processor/system into sleep
    987              }
    988          #endif
    989              }
    990          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "0">>`:
   \   000000   3000         DB "0"

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_2710>`:
   \   000000   10270000     DD 10000

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_5f5e100>`:
   \   000000   00E1F505     DD 100000000

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_strlen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_strlen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memcpy?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memcpy

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_cpyExtAddr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_cpyExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_build_uint16?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_build_uint16

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_build_uint32?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_build_uint32

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??_ltoa?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    _ltoa

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_AddrEqual?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_AddrEqual

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_ExtAddrEqual?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_ExtAddrEqual

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_rand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_rand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_allocate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_allocate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_deallocate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_deallocate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_send?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_send

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_receive?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_receive

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_enqueue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_enqueue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_dequeue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_dequeue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_push?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_push

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_extract?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_extract

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_enqueue_max?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_enqueue_max

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_set_event?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_set_event

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_isr_register?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_isr_register

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_int_enable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_int_enable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_int_disable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_int_disable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_init_system?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_init_system

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_start_system?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_start_system

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     `?<Constant "">`:
   \   000000                DS 10
   \   00000A                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     `?<Constant "">_1`:
   \   000000                DS 10
   \   00000A                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     `?<Constant "">_2`:
   \   000000                DS 10
   \   00000A                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "0">`:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for <Constant "0">>`
   \   000002                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_2710:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_2710>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_5f5e100:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_5f5e100>`
   \   000004                REQUIRE __INIT_XDATA_I
    991          
    992          /*********************************************************************
    993          *********************************************************************/

   Maximum stack usage in bytes:

     Function                 ISTACK PSTACK XSTACK
     --------                 ------ ------ ------
     _ltoa                        2      0     54
       -> _itoa                   0      0    104
       -> _itoa                   0      0    104
       -> _itoa                   0      0    104
       -> strcpy                  0      0    104
       -> strcat                  0      0    104
       -> strlen                  0      0    104
       -> strcat                  0      0    104
       -> strcat                  0      0    104
       -> strlen                  0      0    104
       -> strcat                  0      0    104
       -> strcpy                  0      0    104
       -> _itoa                   0      0    104
       -> _itoa                   0      0    104
       -> strcpy                  0      0    104
       -> strcat                  0      0    104
       -> strlen                  0      0    104
       -> strcat                  0      0    104
     osal_AddrEqual               0      0      9
       -> osal_ExtAddrEqual       0      0     18
     osal_ExtAddrEqual            0      0     19
     osal_build_uint16            0      0      9
     osal_build_uint32            0      0     16
     osal_cpyExtAddr              0      0     14
       -> osal_memcpy             0      0     28
     osal_init_system             2      0      0
       -> osal_mem_init           4      0      0
       -> osalTimerInit           4      0      0
       -> osal_pwrmgr_init        4      0      0
       -> osalInitTasks           4      0      0
       -> osal_mem_kick           4      0      0
     osal_int_disable             0      0      0
     osal_int_enable              0      0      0
     osal_isr_register            0      0      0
     osal_memcpy                  1      0     25
     osal_memset                  0      0     12
       -> memset                  0      0     24
     osal_msg_allocate            1      0     10
       -> osal_mem_alloc          0      0     20
     osal_msg_deallocate          2      0      9
       -> osal_mem_free           4      0      0
     osal_msg_dequeue             1      0     10
     osal_msg_enqueue             0      0     18
     osal_msg_enqueue_max         0      0     10
     osal_msg_extract             1      0     23
     osal_msg_push                0      0      9
     osal_msg_receive             0      0     14
       -> osal_msg_extract        0      0     28
     osal_msg_send                1      0      9
       -> osal_msg_deallocate     0      0     18
       -> osal_msg_deallocate     0      0     18
       -> osal_msg_enqueue        0      0     18
       -> osal_set_event          0      0     18
     osal_rand                    2      0      0
       -> Onboard_rand            4      0      0
     osal_set_event               3      0      9
     osal_start_system            1      0     10
       -> Hal_ProcessPoll         0      0     20
     osal_strlen                  2      0      0
       -> strlen                  4      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _A_IEN0                           1
     osal_qHead                        2
     osal_strlen                      10
     ?Subroutine19                     7
     osal_memcpy                      69
     ?Subroutine20                     5
     osal_cpyExtAddr                  31
     osal_memset                      29
     ?Subroutine21                     5
     osal_build_uint16                21
     ?Subroutine23                     5
     osal_build_uint32               128
     ?Subroutine24                     5
     ?Subroutine9                     15
     ?Subroutine1                      6
     ?Subroutine16                    28
     _ltoa                           634
     ?Subroutine7                     17
     ?Subroutine6                      6
     ?Subroutine5                     10
     ?Subroutine2                      6
     ?Subroutine17                     7
     ?Subroutine0                     28
     ?Subroutine8                      8
     ?Subroutine18                     6
     ?Subroutine10                     9
     osal_AddrEqual                  103
     ?Subroutine3                      6
     osal_ExtAddrEqual                62
     osal_rand                        10
     osal_msg_allocate                83
     osal_msg_deallocate              38
     ?Subroutine13                    12
     osal_msg_send                    82
     osal_msg_receive                117
     osal_msg_enqueue                 54
     ?Subroutine22                     6
     ?Subroutine11                    13
     ?Subroutine14                     6
     ?Subroutine26                     5
     osal_msg_dequeue                 90
     ?Subroutine15                     9
     ?Subroutine25                     5
     osal_msg_push                    48
     ?Subroutine12                     8
     osal_msg_extract                 88
     osal_msg_enqueue_max             84
     osal_set_event                   50
     ?Subroutine4                     15
     osal_isr_register                 5
     osal_int_enable                  16
     osal_int_disable                 16
     osal_init_system                 31
     osal_start_system               146
     ?<Initializer for <Constant "0">>
                                       2
     ?<Initializer for __Constant_2710>
                                       4
     ?<Initializer for __Constant_5f5e100>
                                       4
     ??osal_strlen?relay               6
     ??osal_memcpy?relay               6
     ??osal_cpyExtAddr?relay           6
     ??osal_memset?relay               6
     ??osal_build_uint16?relay         6
     ??osal_build_uint32?relay         6
     ??_ltoa?relay                     6
     ??osal_AddrEqual?relay            6
     ??osal_ExtAddrEqual?relay         6
     ??osal_rand?relay                 6
     ??osal_msg_allocate?relay         6
     ??osal_msg_deallocate?relay       6
     ??osal_msg_send?relay             6
     ??osal_msg_receive?relay          6
     ??osal_msg_enqueue?relay          6
     ??osal_msg_dequeue?relay          6
     ??osal_msg_push?relay             6
     ??osal_msg_extract?relay          6
     ??osal_msg_enqueue_max?relay      6
     ??osal_set_event?relay            6
     ??osal_isr_register?relay         6
     ??osal_int_enable?relay           6
     ??osal_int_disable?relay          6
     ??osal_init_system?relay          6
     ??osal_start_system?relay         6
     ?<Constant "">                   10
     ?<Constant "">_1                 10
     ?<Constant "">_2                 10
     ?<Constant "0">                   2
     __Constant_2710                   4
     __Constant_5f5e100                4

 
 2 303 bytes in segment BANKED_CODE
   150 bytes in segment BANK_RELAYS
     1 byte  in segment SFR_AN
    10 bytes in segment XDATA_I
    10 bytes in segment XDATA_ID
    32 bytes in segment XDATA_Z
 
 2 455 bytes of CODE  memory (+ 8 bytes shared)
     0 bytes of DATA  memory (+ 1 byte  shared)
    34 bytes of XDATA memory (+ 8 bytes shared)

Errors: none
Warnings: none

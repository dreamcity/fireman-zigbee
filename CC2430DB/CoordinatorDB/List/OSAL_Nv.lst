###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    28/Dec/2012  21:17:07 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \osal\mcu\ccsoc\OSAL_Nv.c                          #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\..\..\..\Tools\C #
#                          C2430DB\f8wCoord.cfg" (-DCPU32MHZ                  #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS           #
#                          "-DCONST=const __code" -DGENERIC=__generic) -f     #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\Tools\CC24 #
#                          30DB\f8wConfig.cfg" (-DSECURE=0                    #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\osal\mcu #
#                          \ccsoc\OSAL_Nv.c" -D CC2430DB -D REFLECTOR -D      #
#                          xZTOOL_P2 -D xMT_TASK -D xMT_ZDO_FUNC -D           #
#                          xLCD_SUPPORTED=DEBUG -lC "C:\Texas                 #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\CoordinatorDB\List\" -lA      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\CoordinatorDB\List\ #
#                          " --diag_suppress Pe001,Pa010 --diag_remark pe550  #
#                          -o "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\CoordinatorDB\Ob #
#                          j\" -e --require_prototypes -z9 --no_code_motion   #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\SOURCE\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\ZMAIN\TI2430DB\" -I  #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MT\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\HAL #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\TARGET\CC2430DB\" -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\OSA #
#                          L\INCLUDE\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\AF\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2. #
#                          1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\.. #
#                          \..\..\COMPONENTS\STACK\NWK\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\SEC\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\STACK\SYS\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\ZDO\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\ZMAC\F8W\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\ZMA #
#                          C\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Pr #
#                          ojects\zstack\Samples\AXDApp\CC2430DB\..\..\..\..\ #
#                          ..\COMPONENTS\SERVICES\SADDR\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\SER #
#                          VICES\SDATA\" -I "C:\Texas                         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\HIGH_LEVEL\" -I           #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \LOW_LEVEL\SRF03\SINGLE_CHIP\" -I "C:\Program      #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\" -I "C:\Program       #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\CoordinatorDB\List\O #
#                          SAL_Nv.lst                                         #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\CoordinatorDB\Obj\OS #
#                          AL_Nv.r51                                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\osal\mcu\ccsoc\OSAL_Nv.c
      1          /**************************************************************************************************
      2            Filename:       OSAL_Nv.c
      3            Revised:        $Date: 2007-10-28 18:43:04 -0700 (Sun, 28 Oct 2007) $
      4            Revision:       $Revision: 15800 $
      5          
      6            Description:    This module contains the OSAL non-volatile memory functions.
      7          
      8          
      9            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /**************************************************************************************************
     41            Notes:
     42              - A trick buried deep in initPage() requires that the MSB of the NV Item Id is to
     43                be reserved for use by this module.
     44              - Due to .s51 code and code-size saving tricks, the max NV item size is 1024 bytes.
     45          **************************************************************************************************/
     46          
     47          /*********************************************************************
     48           * INCLUDES
     49           */
     50          
     51          #include "ZComDef.h"
     52          #include "hal_adc.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xab
   \   unsigned char volatile __sfr FWT
   \                     FWT:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xad
   \   unsigned char volatile __sfr FADDRH
   \                     FADDRH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xae
   \   unsigned char volatile __sfr FCTL
   \                     FCTL:
   \   000000                DS 1
     53          #include "osal.h"
     54          #include "OSAL_Nv.h"
     55          #include <ioCC2430.h>
     56          
     57          /*********************************************************************
     58           * CONSTANTS
     59           */
     60          
     61          #define OSAL_NV_ACTIVE          0x00
     62          #define OSAL_NV_ERASED          0xFF
     63          #define OSAL_NV_ERASED_ID       0xFFFF
     64          #define OSAL_NV_ZEROED_ID       0x0000
     65          // Reserve MSB of Id to signal a search for the "old" source copy (new write interrupted/failed.)
     66          #define OSAL_NV_SOURCE_ID       0x8000
     67          
     68          #define OSAL_NV_PAGE_FREE      (OSAL_NV_PAGE_SIZE - Z_EXTADDR_LEN)
     69          
     70          /* The last Flash page will reserve an IEEE addr block at the end of the page where the tools know
     71           * to program the IEEE.
     72           */
     73          #define OSAL_NV_IEEE_OFFSET    (OSAL_NV_PAGE_SIZE - Z_EXTADDR_LEN)
     74          #define OSAL_NV_IEEE_PAGE       63
     75          
     76          // In case pages 0-1 are ever used, define a null page value.
     77          #define OSAL_NV_PAGE_NULL       0
     78          
     79          // In case item Id 0 is ever used, define a null item value.
     80          #define OSAL_NV_ITEM_NULL       0
     81          
     82          #define OSAL_NV_WORD_SIZE       4
     83          
     84          #define OSAL_NV_PAGE_HDR_OFFSET 0
     85          
     86          /*********************************************************************
     87           * MACROS
     88           */
     89          
     90          #define  OSAL_NV_CHECK_BUS_VOLTAGE  (HalAdcCheckVdd( HAL_ADC_VDD_LIMIT_4 ))
     91          
     92          #define OSAL_NV_DATA_SIZE( LEN )  \
     93             ((((LEN) + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE)
     94          
     95          #define OSAL_NV_ITEM_SIZE( LEN )  \
     96            (((((LEN) + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE) + OSAL_NV_HDR_SIZE)
     97          
     98          /*********************************************************************
     99           * TYPEDEFS
    100           */
    101          
    102          typedef struct
    103          {
    104            uint16 id;
    105            uint16 len;   // Enforce Flash-WORD size on len.
    106            uint16 chk;   // Byte-wise checksum of the 'len' data bytes of the item.
    107            uint16 stat;  // Item status.
    108          } osalNvHdr_t;
    109          // Struct member offsets.
    110          #define OSAL_NV_HDR_ID    0
    111          #define OSAL_NV_HDR_LEN   2
    112          #define OSAL_NV_HDR_CHK   4
    113          #define OSAL_NV_HDR_STAT  6
    114          
    115          #define OSAL_NV_HDR_ITEM  2  // Length of any item of a header struct.
    116          #define OSAL_NV_HDR_SIZE  8
    117          #define OSAL_NV_HDR_HALF (OSAL_NV_HDR_SIZE / 2)
    118          
    119          typedef struct
    120          {
    121            uint16 active;
    122            uint16 inUse;
    123            uint16 xfer;
    124            uint16 spare;
    125          } osalNvPgHdr_t;
    126          // Struct member offsets.
    127          #define OSAL_NV_PG_ACTIVE 0
    128          #define OSAL_NV_PG_INUSE  2
    129          #define OSAL_NV_PG_XFER   4
    130          #define OSAL_NV_PG_SPARE  6
    131          
    132          #define OSAL_NV_PAGE_HDR_SIZE  8
    133          #define OSAL_NV_PAGE_HDR_HALF (OSAL_NV_PAGE_HDR_SIZE / 2)
    134          
    135          typedef enum
    136          {
    137            eNvXfer,
    138            eNvZero
    139          } eNvHdrEnum;
    140          
    141          typedef enum
    142          {
    143            ePgActive,
    144            ePgInUse,
    145            ePgXfer,
    146            ePgSpare
    147          } ePgHdrEnum;
    148          
    149          /*********************************************************************
    150           * GLOBAL VARIABLES
    151           */
    152          
    153          /* This can be placed in the non-retention RAM - the assembly routine is copied from Flash to XDATA
    154           * on every call. If enough retention RAM is available, or if on a mains-powered device, could
    155           * easily change to copy Flash to XDATA only on initialization.
    156           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    157          uint8 __xdata flashXdataBuf[22];
   \                     flashXdataBuf:
   \   000000                DS 22
   \   000016                REQUIRE __INIT_XDATA_Z
    158          
    159          /*********************************************************************
    160           * EXTERNAL FUNCTIONS
    161           */
    162          
    163          /*********************************************************************
    164           * @fn      nvRead...
    165           *
    166           * @brief   Reads a byte, OSAL_NV_WORD_SIZE, or OSAL_NV_HDR_SIZE bytes from NV.
    167           *
    168           * @param   pg - Valid NV page.
    169           * @param   offset - Valid offset into the page.
    170           * @param   buf - Valid buffer space at least as big as the read request.
    171           *
    172           * @return  none
    173           */
    174          extern __near_func void nvReadByte( uint8 pg, uint16 offset, uint8 *buf );
    175          extern __near_func void nvReadWord( uint8 pg, uint16 offset, uint8 *buf );
    176          extern __near_func void nvReadHdr(uint8 pg, uint16 offset, uint8 *buf);
    177          
    178          /*********************************************************************
    179           * @fn      nvReadBuf
    180           *
    181           * @brief   Reads N bytes from NV.
    182           *
    183           * @param   pg - Valid NV page.
    184           * @param   offset - Valid offset into the page.
    185           * @param   buf - Valid buffer space at least as big as the read request.
    186           * @param   cnt - Number of bytes to read.
    187           *
    188           * @return  none
    189           */
    190          extern __near_func void nvReadBuf(uint8 pg, uint16 offset, uint8 *buf, uint16 cnt);
    191          
    192          /*********************************************************************
    193           * @fn      flashWriteBuf
    194           *
    195           * @brief   Writes N blocks of 4-bytes to NV.
    196           *
    197           * @param   cnt - Number of blocks of 4-bytes to write.
    198           * @param   buf - Valid buffer space at least as big as the write request.
    199           * @param   addr - Valid FADDRH/L address: 3-byte addr / 4 = 2-byte addr.
    200           *
    201           * @return  none
    202           */
    203          extern __near_func void flashWriteBuf(uint8 cnt, uint16 buf, uint16 addr);
    204          
    205          extern bool HalAdcCheckVdd(uint8 limit);
    206          
    207          /*********************************************************************
    208           * LOCAL VARIABLES
    209           */
    210          
    211          // Offset into the page of the first available erased space.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    212          static uint16 pgOff[OSAL_NV_PAGES_USED];
   \                     pgOff:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    213          
    214          // Count of the bytes lost for the zeroed-out items.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    215          static uint16 pgLost[OSAL_NV_PAGES_USED];
   \                     pgLost:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    216          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    217          static uint8 pgRes;  // Page reserved for item compacting transfer.
   \                     pgRes:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    218          
    219          // Saving ~100 code bytes to move a uint8* parameter/return value from findItem() to a global.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    220          static uint8 findPg;
   \                     findPg:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    221          
    222          /* Immediately before the voltage critical operations of a page erase or
    223           * a word write, check bus voltage. If less than min, set global flag & abort.
    224           * Since this is to be done at the lowest level, many void functions would have to be changed to
    225           * return a value and code added to check that value before proceeding, resulting in a very
    226           * expensive code size hit for implementing this properly. Therefore, use this global as follows:
    227           * at the start of osal_nv_item_init/osal_nv_write, set to FALSE, and at the end, before returning,
    228           * check the value. Thus, the global is an accumulator of any error that occurred in any of the
    229           * attempts to modify Flash with a low bus voltage during the complicated sequence of events that
    230           * may occur on any item init or write. This is much more expedient and code saving than adding
    231           * return values and checking return values to early out. No matter which method is used, an NV
    232           * data record may end up mangled due to the low VCC conditions. The strategy is that the headers
    233           * and checksums will detect and allow recovery from such a condition.
    234           *
    235           * One unfortunate side-effect of using the global fail flag vice adding and checking return
    236           * values, is that when setting an item Id to zero has failed due to the low VCC check,
    237           * the page lost-bytes counter is still updated. Having an artificially high lost-byte
    238           * count makes it look like there are more bytes to recover from compacting a page than there may
    239           * actually be. The easy work-around implemented is it to invoke initNV() from osal_nv_item_init or
    240           * osal_nv_write anytime that the failF gets set - this will re-walk all of the pages and set the
    241           * page offset count and page lost bytes count to their actual values.
    242           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    243          static uint8 failF;
   \                     failF:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    244          
    245          /*********************************************************************
    246           * LOCAL FUNCTIONS
    247           */
    248          
    249          static uint8  initNV( void );
    250          
    251          static void   setPageUse( uint8 pg, uint8 inUse );
    252          static uint16 initPage( uint8 pg, uint16 id, uint8 findDups );
    253          static void   erasePage( uint8 pg );
    254          static void   compactPage( uint8 pg );
    255          
    256          static uint16 findItem( uint16 id );
    257          static uint8  initItem( uint8 flag, uint16 id, uint16 len, void *buf );
    258          static void   setItem( uint8 pg, uint16 offset, eNvHdrEnum stat );
    259          
    260          static uint16 calcChkB( uint16 len, uint8 *buf );
    261          static uint16 calcChkF( byte pg, uint16 offset, uint16 len );
    262          
    263          static void   writeWord( uint8 pg, uint16 offset, uint8 *buf );
    264          static void   writeWordH( uint8 pg, uint16 offset, uint8 *buf );
    265          static void   writeWordM( uint8 pg, uint16 offset, uint8 *buf, uint8 cnt );
    266          static void   writeBuf( uint8 pg, uint16 offset, uint16 len, uint8 *buf );
    267          static void   xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len );
    268          
    269          static uint8  writeItem( uint8 pg, uint16 id, uint16 len, void *buf, uint8 flag );
    270          
    271          static uint8  writeIEEE( void *buf );
    272          
    273          /*********************************************************************
    274           * @fn      initNV
    275           *
    276           * @brief   Initialize the NV flash pages.
    277           *
    278           * @param   none
    279           *
    280           * @return  TRUE
    281           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    282          static uint8 initNV( void )
   \                     initNV:
    283          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    284            osalNvPgHdr_t pgHdr, ieee;
    285            uint8 oldPg = OSAL_NV_PAGE_NULL;
   \   00000A   75..00       MOV     ?V0 + 0,#0x0
    286            uint8 newPg = OSAL_NV_PAGE_NULL;
   \   00000D   7F00         MOV     R7,#0x0
    287            uint8 findDups = FALSE;
   \   00000F   8F..         MOV     ?V0 + 4,R7
    288            uint8 xBad;
    289            uint8 pg;
    290          
    291            nvReadHdr( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee) );
   \   000011                ; Setup parameters for call to function nvReadHdr
   \   000011   7408         MOV     A,#0x8
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   12....       LCALL   ?Subroutine0 & 0xFFFF
    292            if ( (ieee.active == OSAL_NV_ERASED_ID) &&
    293                 (ieee.inUse == OSAL_NV_ERASED_ID) &&
    294                 (ieee.xfer == OSAL_NV_ERASED_ID) &&
    295                 (ieee.spare == OSAL_NV_ERASED_ID) )
   \                     ??CrossCallReturnLabel_0:
   \   000019   7004         JNZ     ??initNV_0
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   64FF         XRL     A,#0xff
   \                     ??initNV_0:
   \   00001F   7035         JNZ     ??initNV_1
   \   000021   740A         MOV     A,#0xa
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   E0           MOVX    A,@DPTR
   \   000027   64FF         XRL     A,#0xff
   \   000029   7004         JNZ     ??initNV_2
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   64FF         XRL     A,#0xff
   \                     ??initNV_2:
   \   00002F   7025         JNZ     ??initNV_1
   \   000031   740C         MOV     A,#0xc
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   E0           MOVX    A,@DPTR
   \   000037   64FF         XRL     A,#0xff
   \   000039   7004         JNZ     ??initNV_3
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   64FF         XRL     A,#0xff
   \                     ??initNV_3:
   \   00003F   7015         JNZ     ??initNV_1
   \   000041   740E         MOV     A,#0xe
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   E0           MOVX    A,@DPTR
   \   000047   64FF         XRL     A,#0xff
   \   000049   7004         JNZ     ??initNV_4
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   64FF         XRL     A,#0xff
   \                     ??initNV_4:
   \   00004F   7005         JNZ     ??initNV_1
    296            {
    297              xBad = TRUE;
   \   000051   75..01       MOV     ?V0 + 1,#0x1
   \   000054   8002         SJMP    ??initNV_5
    298            }
    299            else
    300            {
    301              xBad = FALSE;
   \                     ??initNV_1:
   \   000056   8F..         MOV     ?V0 + 1,R7
    302            }
    303          
    304            pgRes = OSAL_NV_PAGE_NULL;
   \                     ??initNV_5:
   \   000058   E4           CLR     A
   \   000059   90....       MOV     DPTR,#pgRes
   \   00005C   F0           MOVX    @DPTR,A
    305          
    306            for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
   \   00005D   7E3C         MOV     R6,#0x3c
    307            {
    308              nvReadHdr( pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8 *)(&pgHdr) );
   \                     ??initNV_6:
   \   00005F                ; Setup parameters for call to function nvReadHdr
   \   00005F   85..82       MOV     DPL,?XSP + 0
   \   000062   85..83       MOV     DPH,?XSP + 1
   \   000065   AC82         MOV     R4,DPL
   \   000067   AD83         MOV     R5,DPH
   \   000069   7A00         MOV     R2,#0x0
   \   00006B   7B00         MOV     R3,#0x0
   \   00006D   EE           MOV     A,R6
   \   00006E   F9           MOV     R1,A
   \   00006F   12....       LCALL   ??Subroutine0_0 & 0xFFFF
    309          
    310              if ( pgHdr.active == OSAL_NV_ERASED_ID )
   \                     ??CrossCallReturnLabel_2:
   \   000072   7004         JNZ     ??initNV_7
   \   000074   A3           INC     DPTR
   \   000075   E0           MOVX    A,@DPTR
   \   000076   64FF         XRL     A,#0xff
   \                     ??initNV_7:
   \   000078   7013         JNZ     ??initNV_8
    311              {
    312                if ( pgRes == OSAL_NV_PAGE_NULL )
   \   00007A   90....       MOV     DPTR,#pgRes
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   7004         JNZ     ??initNV_9
    313                {
    314                  pgRes = pg;
   \   000080   EE           MOV     A,R6
   \   000081   F0           MOVX    @DPTR,A
   \   000082   802F         SJMP    ??initNV_10
    315                }
    316                else
    317                {
    318                  setPageUse( pg, TRUE );
   \                     ??initNV_9:
   \   000084                ; Setup parameters for call to function setPageUse
   \   000084   7A01         MOV     R2,#0x1
   \   000086   EE           MOV     A,R6
   \   000087   F9           MOV     R1,A
   \   000088   12....       LCALL   ??setPageUse?relay
   \   00008B   8026         SJMP    ??initNV_10
    319                }
    320              }
    321              else  // Page is active.
    322              {
    323                // If the page is not yet in use, it is the tgt of items from an xfer.
    324                if ( pgHdr.inUse == OSAL_NV_ERASED_ID )
   \                     ??initNV_8:
   \   00008D   7402         MOV     A,#0x2
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   E0           MOVX    A,@DPTR
   \   000093   64FF         XRL     A,#0xff
   \   000095   7004         JNZ     ??initNV_11
   \   000097   A3           INC     DPTR
   \   000098   E0           MOVX    A,@DPTR
   \   000099   64FF         XRL     A,#0xff
   \                     ??initNV_11:
   \   00009B   7004         JNZ     ??initNV_12
    325                {
    326                  newPg = pg;
   \   00009D   EE           MOV     A,R6
   \   00009E   FF           MOV     R7,A
   \   00009F   8012         SJMP    ??initNV_10
    327                }
    328                // An Xfer from this page was in progress.
    329                else if ( pgHdr.xfer != OSAL_NV_ERASED_ID )
   \                     ??initNV_12:
   \   0000A1   7404         MOV     A,#0x4
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   64FF         XRL     A,#0xff
   \   0000A9   7004         JNZ     ??initNV_13
   \   0000AB   A3           INC     DPTR
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   64FF         XRL     A,#0xff
   \                     ??initNV_13:
   \   0000AF   6002         JZ      ??initNV_10
    330                {
    331                  oldPg = pg;
   \   0000B1   8E..         MOV     ?V0 + 0,R6
    332                }
    333              }
    334          
    335              // Calculate page offset and lost bytes - any "old" item triggers an N^2 re-scan from start.
    336              if ( initPage( pg, OSAL_NV_ITEM_NULL, findDups ) != OSAL_NV_ITEM_NULL )
   \                     ??initNV_10:
   \   0000B3                ; Setup parameters for call to function initPage
   \   0000B3   AC..         MOV     R4,?V0 + 4
   \   0000B5   7A00         MOV     R2,#0x0
   \   0000B7   7B00         MOV     R3,#0x0
   \   0000B9   EE           MOV     A,R6
   \   0000BA   F9           MOV     R1,A
   \   0000BB   12....       LCALL   ??initPage?relay
   \   0000BE   EA           MOV     A,R2
   \   0000BF   7001         JNZ     ??initNV_14
   \   0000C1   EB           MOV     A,R3
   \                     ??initNV_14:
   \   0000C2   6008         JZ      ??initNV_15
    337              {
    338                findDups = TRUE;
   \   0000C4   75..01       MOV     ?V0 + 4,#0x1
    339                pg = OSAL_NV_PAGE_BEG-1;
   \   0000C7   7E3B         MOV     R6,#0x3b
    340                continue;
   \   0000C9   02....       LJMP    ??initNV_16 & 0xFFFF
    341              }
    342          
    343              nvReadHdr( pg, OSAL_NV_IEEE_OFFSET, (uint8 *)(&pgHdr) );
   \                     ??initNV_15:
   \   0000CC                ; Setup parameters for call to function nvReadHdr
   \   0000CC   85..82       MOV     DPL,?XSP + 0
   \   0000CF   85..83       MOV     DPH,?XSP + 1
   \   0000D2   AC82         MOV     R4,DPL
   \   0000D4   AD83         MOV     R5,DPH
   \   0000D6   7AF8         MOV     R2,#-0x8
   \   0000D8   7B07         MOV     R3,#0x7
   \   0000DA   EE           MOV     A,R6
   \   0000DB   F9           MOV     R1,A
   \   0000DC   12....       LCALL   nvReadHdr & 0xFFFF
    344              if ( xBad )
   \   0000DF   E5..         MOV     A,?V0 + 1
   \   0000E1   605D         JZ      ??initNV_17
    345              {
    346                /* TBD - For the cost of more code space, the IEEE could be checksummed & then tested here
    347                 * before installing to the erased IEEE on page 63.
    348                 */
    349                if ( (pgHdr.active != OSAL_NV_ERASED_ID) ||
    350                     (pgHdr.inUse != OSAL_NV_ERASED_ID) ||
    351                     (pgHdr.xfer != OSAL_NV_ERASED_ID) ||
    352                     (pgHdr.spare != OSAL_NV_ERASED_ID) )
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   64FF         XRL     A,#0xff
   \   0000E6   7004         JNZ     ??initNV_18
   \   0000E8   A3           INC     DPTR
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   64FF         XRL     A,#0xff
   \                     ??initNV_18:
   \   0000EC   7030         JNZ     ??initNV_19
   \   0000EE   7402         MOV     A,#0x2
   \   0000F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   64FF         XRL     A,#0xff
   \   0000F6   7004         JNZ     ??initNV_20
   \   0000F8   A3           INC     DPTR
   \   0000F9   E0           MOVX    A,@DPTR
   \   0000FA   64FF         XRL     A,#0xff
   \                     ??initNV_20:
   \   0000FC   7020         JNZ     ??initNV_19
   \   0000FE   7404         MOV     A,#0x4
   \   000100   12....       LCALL   ?XSTACK_DISP0_8
   \   000103   E0           MOVX    A,@DPTR
   \   000104   64FF         XRL     A,#0xff
   \   000106   7004         JNZ     ??initNV_21
   \   000108   A3           INC     DPTR
   \   000109   E0           MOVX    A,@DPTR
   \   00010A   64FF         XRL     A,#0xff
   \                     ??initNV_21:
   \   00010C   7010         JNZ     ??initNV_19
   \   00010E   7406         MOV     A,#0x6
   \   000110   12....       LCALL   ?XSTACK_DISP0_8
   \   000113   E0           MOVX    A,@DPTR
   \   000114   64FF         XRL     A,#0xff
   \   000116   7004         JNZ     ??initNV_22
   \   000118   A3           INC     DPTR
   \   000119   E0           MOVX    A,@DPTR
   \   00011A   64FF         XRL     A,#0xff
   \                     ??initNV_22:
   \   00011C   6035         JZ      ??initNV_16
    353                {
    354                  writeWordM( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&pgHdr), 2 );
   \                     ??initNV_19:
   \   00011E                ; Setup parameters for call to function writeWordM
   \   00011E   75..02       MOV     ?V0 + 1,#0x2
   \   000121   78..         MOV     R0,#?V0 + 1
   \   000123   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000126   7401         MOV     A,#0x1
   \   000128   12....       LCALL   ?XSTACK_DISP0_8
   \   00012B   AC82         MOV     R4,DPL
   \   00012D   AD83         MOV     R5,DPH
   \   00012F   7AF8         MOV     R2,#-0x8
   \   000131   7B07         MOV     R3,#0x7
   \   000133   793F         MOV     R1,#0x3f
   \   000135   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000138   12....       LCALL   ?DEALLOC_XSTACK8
    355                  xBad = FALSE;
   \   00013B   75..00       MOV     ?V0 + 1,#0x0
   \   00013E   8013         SJMP    ??initNV_16
    356                }
    357              }
    358              else
    359              {
    360                writeWordM( pg, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee), 2 );
   \                     ??initNV_17:
   \   000140                ; Setup parameters for call to function writeWordM
   \   000140   75..02       MOV     ?V0 + 2,#0x2
   \   000143   78..         MOV     R0,#?V0 + 2
   \   000145   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000148   7409         MOV     A,#0x9
   \   00014A   12....       LCALL   ?XSTACK_DISP0_8
   \   00014D   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000150   12....       LCALL   ?DEALLOC_XSTACK8
    361              }
    362            }  // for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
   \                     ??initNV_16:
   \   000153   0E           INC     R6
   \   000154   EE           MOV     A,R6
   \   000155   C3           CLR     C
   \   000156   943E         SUBB    A,#0x3e
   \   000158   5003         JNC     $+5
   \   00015A   02....       LJMP    ??initNV_6 & 0xFFFF
    363          
    364            /* First the old page is erased, and then the new page is put into use.
    365             * So if a transfer was in progress, the new page will always not yet be
    366             * marked as in use, since that is the last step to ending a transfer.
    367             */
    368            if ( newPg != OSAL_NV_PAGE_NULL )
   \   00015D   EF           MOV     A,R7
   \   00015E   6016         JZ      ??initNV_23
    369            {
    370              /* If there is already a fallow page reserved, keep it and put the newPg in use.
    371               * An unfinished compaction will finish to the new reserve page and the old page
    372               * will be erased and reserved.
    373               */
    374              if ( pgRes != OSAL_NV_PAGE_NULL )
   \   000160   90....       MOV     DPTR,#pgRes
   \   000163   E0           MOVX    A,@DPTR
   \   000164   6033         JZ      ??initNV_24
    375              {
    376                setPageUse( newPg, TRUE );
   \   000166                ; Setup parameters for call to function setPageUse
   \   000166   7A01         MOV     R2,#0x1
   \   000168   EF           MOV     A,R7
   \   000169   F9           MOV     R1,A
   \   00016A   12....       LCALL   ??setPageUse?relay
    377              }
    378              /* If setting old page to 'xfer' failed or board reset before it was effected, there is no way
    379               * to know which page was the 'old page' - so just reset all NV pages to start clean.
    380               */
    381              else if ( oldPg != OSAL_NV_PAGE_NULL )
    382              {
    383                pgRes = newPg;
    384              }
    385          
    386              /* If a page compaction was interrupted and the page being compacted is not
    387               * yet erased, then there may be items remaining to xfer before erasing.
    388               */
    389              if ( oldPg != OSAL_NV_PAGE_NULL )
   \                     ??initNV_25:
   \   00016D   E5..         MOV     A,?V0 + 0
   \   00016F   6005         JZ      ??initNV_23
    390              {
    391                compactPage( oldPg );
   \                     ??initNV_26:
   \   000171                ; Setup parameters for call to function compactPage
   \   000171   A9..         MOV     R1,?V0 + 0
   \   000173   12....       LCALL   ??compactPage?relay
    392              }
    393            }
    394          
    395            /* If no page met the criteria to be the reserve page:
    396             *  - A compactPage() failed or board reset before doing so.
    397             *  - Perhaps the user changed which Flash pages are dedicated to NV and downloaded the code
    398             *    without erasing Flash?
    399             */
    400            if ( pgRes == OSAL_NV_PAGE_NULL )
   \                     ??initNV_23:
   \   000176   90....       MOV     DPTR,#pgRes
   \   000179   E0           MOVX    A,@DPTR
   \   00017A   7011         JNZ     ??initNV_27
    401            {
    402              for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
   \   00017C   7E3C         MOV     R6,#0x3c
    403              {
    404                erasePage( pg );
   \                     ??initNV_28:
   \   00017E                ; Setup parameters for call to function erasePage
   \   00017E   EE           MOV     A,R6
   \   00017F   F9           MOV     R1,A
   \   000180   12....       LCALL   ??erasePage?relay
    405              }
   \   000183   0E           INC     R6
   \   000184   EE           MOV     A,R6
   \   000185   C3           CLR     C
   \   000186   943E         SUBB    A,#0x3e
   \   000188   40F4         JC      ??initNV_28
    406              initNV();
   \   00018A                ; Setup parameters for call to function initNV
   \   00018A   12....       LCALL   ??initNV?relay
    407            }
    408          
    409            return TRUE;
   \                     ??initNV_27:
   \   00018D   7901         MOV     R1,#0x1
   \   00018F   7410         MOV     A,#0x10
   \   000191   12....       LCALL   ?DEALLOC_XSTACK8
   \   000194   7F05         MOV     R7,#0x5
   \   000196   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??initNV_24:
   \   000199   E5..         MOV     A,?V0 + 0
   \   00019B   60D0         JZ      ??initNV_25
   \   00019D   EF           MOV     A,R7
   \   00019E   F0           MOVX    @DPTR,A
   \   00019F   80D0         SJMP    ??initNV_26
    410          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7AF8         MOV     R2,#-0x8
   \   000006   7B07         MOV     R3,#0x7
   \   000008   793F         MOV     R1,#0x3f
   \                     ??Subroutine0_0:
   \   00000A   12....       LCALL   nvReadHdr & 0xFFFF
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   64FF         XRL     A,#0xff
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7AF8         MOV     R2,#-0x8
   \   000006   7B07         MOV     R3,#0x7
   \   000008   EE           MOV     A,R6
   \   000009   F9           MOV     R1,A
   \                     ??Subroutine20_0:
   \   00000A   12....       LCALL   ??writeWordM?relay
   \   00000D   7401         MOV     A,#0x1
   \   00000F   22           RET
    411          
    412          /*********************************************************************
    413           * @fn      setPageUse
    414           *
    415           * @brief   Set page header active/inUse state according to 'inUse'.
    416           *
    417           * @param   pg - Valid NV page to verify and init.
    418           * @param   inUse - Boolean TRUE if inUse, FALSE if only active.
    419           *
    420           * @return  none
    421           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    422          static void setPageUse( uint8 pg, uint8 inUse )
   \                     setPageUse:
    423          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    424            osalNvPgHdr_t pgHdr;
    425          
    426            pgHdr.active = OSAL_NV_ZEROED_ID;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   F0           MOVX    @DPTR,A
    427          
    428            if ( inUse )
   \   000013   EA           MOV     A,R2
   \   000014   6008         JZ      ??setPageUse_0
    429            {
    430              pgHdr.inUse = OSAL_NV_ZEROED_ID;
   \   000016   7402         MOV     A,#0x2
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   E4           CLR     A
   \   00001C   8007         SJMP    ??setPageUse_1
    431            }
    432            else
    433            {
    434              pgHdr.inUse = OSAL_NV_ERASED_ID;
   \                     ??setPageUse_0:
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   74FF         MOV     A,#-0x1
   \                     ??setPageUse_1:
   \   000025   12....       LCALL   ??Subroutine17_1 & 0xFFFF
    435            }
    436          
    437            writeWord( pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8*)(&pgHdr) );
   \                     ??CrossCallReturnLabel_56:
   \   000028   7A00         MOV     R2,#0x0
   \   00002A   7B00         MOV     R3,#0x0
   \   00002C   12....       LCALL   ??writeWord?relay
    438          }
   \   00002F   7408         MOV     A,#0x8
   \   000031   12....       LCALL   ?DEALLOC_XSTACK8
   \   000034                REQUIRE ?Subroutine37
   \   000034                ; // Fall through to label ?Subroutine37

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \                     ??Subroutine17_0:
   \   000006   E4           CLR     A
   \                     ??Subroutine17_1:
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \                     ??Subroutine17_2:
   \   000009   F0           MOVX    @DPTR,A
   \   00000A                ; Setup parameters for call to function writeWordH
   \   00000A                ; Setup parameters for call to function writeWord
   \   00000A                ; Setup parameters for call to function nvReadHdr
   \   00000A                ; Setup parameters for call to function writeWord
   \   00000A                ; Setup parameters for call to function writeWord
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   AC82         MOV     R4,DPL
   \   000012   AD83         MOV     R5,DPH
   \   000014   22           RET
    439          
    440          /*********************************************************************
    441           * @fn      initPage
    442           *
    443           * @brief   Walk the page items; calculate checksums, lost bytes & page offset.
    444           *
    445           * @param   pg - Valid NV page to verify and init.
    446           * @param   id - Valid NV item Id to use function as a "findItem".
    447           *               If set to NULL then just perform the page initialization.
    448           *
    449           * @return  If 'id' is non-NULL and good checksums are found, return the offset
    450           *          of the data corresponding to item Id; else OSAL_NV_ITEM_NULL.
    451           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    452          static uint16 initPage( uint8 pg, uint16 id, uint8 findDups )
   \                     initPage:
    453          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   89..         MOV     ?V0 + 6,R1
   \   000017   8C..         MOV     ?V0 + 7,R4
    454            uint16 offset = OSAL_NV_PAGE_HDR_SIZE;
   \   000019   75..08       MOV     ?V0 + 2,#0x8
   \   00001C   75..00       MOV     ?V0 + 3,#0x0
    455            uint16 sz, lost = 0;
   \   00001F   7E00         MOV     R6,#0x0
   \   000021   7F00         MOV     R7,#0x0
   \   000023   8026         SJMP    ??initPage_0
    456            osalNvHdr_t hdr;
    457          
    458            do
    459            {
    460              nvReadHdr( pg, offset, (uint8 *)(&hdr) );
    461          
    462              if ( hdr.id == OSAL_NV_ERASED_ID )
    463              {
    464                break;
    465              }
    466              offset += OSAL_NV_HDR_SIZE;
    467              sz = OSAL_NV_DATA_SIZE( hdr.len );
    468          
    469              // A bad 'len' write has blown away the rest of the page.
    470              if ( (offset + sz) > OSAL_NV_PAGE_FREE )
    471              {
    472                lost += (OSAL_NV_PAGE_FREE - offset + OSAL_NV_HDR_SIZE);
    473                offset = OSAL_NV_PAGE_FREE;
    474                break;
    475              }
    476          
    477              if ( hdr.id != OSAL_NV_ZEROED_ID )
    478              {
    479                /* This trick allows function to do double duty for findItem() without
    480                 * compromising its essential functionality at powerup initialization.
    481                 */
    482                if ( id != OSAL_NV_ITEM_NULL )
    483                {
    484                  /* This trick allows asking to find the old/transferred item in case
    485                   * of a successful new item write that gets interrupted before the
    486                   * old item can be zeroed out.
    487                   */
    488                  if ( (id & 0x7fff) == hdr.id )
    489                  {
    490                    if ( (((id & OSAL_NV_SOURCE_ID) == 0) && (hdr.stat == OSAL_NV_ERASED_ID)) ||
    491                         (((id & OSAL_NV_SOURCE_ID) != 0) && (hdr.stat != OSAL_NV_ERASED_ID)) )
    492                    {
    493                      return offset;
    494                    }
    495                  }
    496                }
    497                // When invoked from the osal_nv_init(), verify checksums and find & zero any duplicates.
    498                else
    499                {
    500                  if ( hdr.chk == calcChkF( pg, offset, hdr.len ) )
    501                  {
    502                    if ( findDups )
    503                    {
    504                      if ( hdr.stat == OSAL_NV_ERASED_ID )
    505                      {
    506                        /* The trick of setting the MSB of the item Id causes the logic
    507                         * immediately above to return a valid page only if the header 'stat'
    508                         * indicates that it was the older item being transferred.
    509                         */
    510                        uint16 off = findItem( (hdr.id | OSAL_NV_SOURCE_ID) );
    511            
    512                        if ( off != OSAL_NV_ITEM_NULL )
    513                        {
    514                          setItem( findPg, off, eNvZero );  // Mark old duplicate as invalid.
    515                        }
    516                      }
    517                    }
    518                    // Any "old" item immediately exits and triggers the N^2 exhaustive initialization.
    519                    else if ( hdr.stat != OSAL_NV_ERASED_ID )
    520                    {
    521                      return OSAL_NV_ERASED_ID;
    522                    }
    523                  }
    524                  else
    525                  {
    526                    setItem( pg, offset, eNvZero );  // Mark bad checksum as invalid.
   \                     ??initPage_1:
   \   000025                ; Setup parameters for call to function setItem
   \   000025   7C01         MOV     R4,#0x1
   \   000027   AA..         MOV     R2,?V0 + 2
   \   000029   AB..         MOV     R3,?V0 + 3
   \   00002B   A9..         MOV     R1,?V0 + 6
   \   00002D   12....       LCALL   ??setItem?relay
    527                    lost += (OSAL_NV_HDR_SIZE + sz);
    528                  }
    529                }
    530              }
    531              else
    532              {
    533                lost += (OSAL_NV_HDR_SIZE + sz);
   \                     ??initPage_2:
   \   000030   7408         MOV     A,#0x8
   \   000032   25..         ADD     A,?V0 + 0
   \   000034   F8           MOV     R0,A
   \   000035   E4           CLR     A
   \   000036   35..         ADDC    A,?V0 + 1
   \   000038   F9           MOV     R1,A
   \   000039   EE           MOV     A,R6
   \   00003A   28           ADD     A,R0
   \   00003B   FE           MOV     R6,A
   \   00003C   EF           MOV     A,R7
   \   00003D   39           ADDC    A,R1
   \   00003E   FF           MOV     R7,A
    534              }
    535              offset += sz;
   \                     ??initPage_3:
   \   00003F   E5..         MOV     A,?V0 + 2
   \   000041   25..         ADD     A,?V0 + 0
   \   000043   F5..         MOV     ?V0 + 2,A
   \   000045   E5..         MOV     A,?V0 + 3
   \   000047   35..         ADDC    A,?V0 + 1
   \   000049   F5..         MOV     ?V0 + 3,A
    536          
    537            } while ( TRUE );
   \                     ??initPage_0:
   \   00004B                ; Setup parameters for call to function nvReadHdr
   \   00004B   7402         MOV     A,#0x2
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   AC82         MOV     R4,DPL
   \   000052   AD83         MOV     R5,DPH
   \   000054   AA..         MOV     R2,?V0 + 2
   \   000056   AB..         MOV     R3,?V0 + 3
   \   000058   A9..         MOV     R1,?V0 + 6
   \   00005A   12....       LCALL   ??Subroutine0_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   00005D   7004         JNZ     ??initPage_4
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   64FF         XRL     A,#0xff
   \                     ??initPage_4:
   \   000063   6043         JZ      ??initPage_5
   \   000065   E5..         MOV     A,?V0 + 2
   \   000067   2408         ADD     A,#0x8
   \   000069   F5..         MOV     ?V0 + 2,A
   \   00006B   E5..         MOV     A,?V0 + 3
   \   00006D   3400         ADDC    A,#0x0
   \   00006F   F5..         MOV     ?V0 + 3,A
   \   000071   7404         MOV     A,#0x4
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000079   F5..         MOV     ?V0 + 0,A
   \   00007B   74FF         MOV     A,#-0x1
   \   00007D   59           ANL     A,R1
   \   00007E   F5..         MOV     ?V0 + 1,A
   \   000080   E5..         MOV     A,?V0 + 0
   \   000082   25..         ADD     A,?V0 + 2
   \   000084   F8           MOV     R0,A
   \   000085   E9           MOV     A,R1
   \   000086   35..         ADDC    A,?V0 + 3
   \   000088   F9           MOV     R1,A
   \   000089   C3           CLR     C
   \   00008A   E8           MOV     A,R0
   \   00008B   94F9         SUBB    A,#-0x7
   \   00008D   E9           MOV     A,R1
   \   00008E   9407         SUBB    A,#0x7
   \   000090   4030         JC      ??initPage_6
   \   000092   E4           CLR     A
   \   000093   2E           ADD     A,R6
   \   000094   F8           MOV     R0,A
   \   000095   7408         MOV     A,#0x8
   \   000097   3F           ADDC    A,R7
   \   000098   F9           MOV     R1,A
   \   000099   E8           MOV     A,R0
   \   00009A   C3           CLR     C
   \   00009B   95..         SUBB    A,?V0 + 2
   \   00009D   FE           MOV     R6,A
   \   00009E   E9           MOV     A,R1
   \   00009F   95..         SUBB    A,?V0 + 3
   \   0000A1   FF           MOV     R7,A
   \   0000A2   75..F8       MOV     ?V0 + 2,#-0x8
   \   0000A5   75..07       MOV     ?V0 + 3,#0x7
    538          
    539            pgOff[pg - OSAL_NV_PAGE_BEG] = offset;
   \                     ??initPage_5:
   \   0000A8   E5..         MOV     A,?V0 + 6
   \   0000AA   12....       LCALL   ??Subroutine25_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   0000AD   E5..         MOV     A,?V0 + 2
   \   0000AF   F0           MOVX    @DPTR,A
   \   0000B0   A3           INC     DPTR
   \   0000B1   E5..         MOV     A,?V0 + 3
   \   0000B3   12....       LCALL   ?Subroutine19 & 0xFFFF
    540            pgLost[pg - OSAL_NV_PAGE_BEG] = lost;
   \                     ??CrossCallReturnLabel_60:
   \   0000B6   EE           MOV     A,R6
   \   0000B7   F0           MOVX    @DPTR,A
   \   0000B8   A3           INC     DPTR
   \   0000B9   EF           MOV     A,R7
   \   0000BA   F0           MOVX    @DPTR,A
    541          
    542            return OSAL_NV_ITEM_NULL;
   \   0000BB   7A00         MOV     R2,#0x0
   \   0000BD   7B00         MOV     R3,#0x0
   \                     ??initPage_7:
   \   0000BF   02....       LJMP    ?Subroutine38 & 0xFFFF
   \                     ??initPage_6:
   \   0000C2   7402         MOV     A,#0x2
   \   0000C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   7002         JNZ     ??initPage_8
   \   0000CA   A3           INC     DPTR
   \   0000CB   E0           MOVX    A,@DPTR
   \                     ??initPage_8:
   \   0000CC   7003         JNZ     $+5
   \   0000CE   02....       LJMP    ??initPage_2 & 0xFFFF
   \   0000D1   85..82       MOV     DPL,?XSP + 0
   \   0000D4   85..83       MOV     DPH,?XSP + 1
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   7002         JNZ     ??initPage_9
   \   0000DA   A3           INC     DPTR
   \   0000DB   E0           MOVX    A,@DPTR
   \                     ??initPage_9:
   \   0000DC   605D         JZ      ??initPage_10
   \   0000DE   85..82       MOV     DPL,?XSP + 0
   \   0000E1   85..83       MOV     DPH,?XSP + 1
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   F8           MOV     R0,A
   \   0000E6   A3           INC     DPTR
   \   0000E7   E0           MOVX    A,@DPTR
   \   0000E8   547F         ANL     A,#0x7f
   \   0000EA   F9           MOV     R1,A
   \   0000EB   7402         MOV     A,#0x2
   \   0000ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   68           XRL     A,R0
   \   0000F2   7003         JNZ     ??initPage_11
   \   0000F4   A3           INC     DPTR
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   69           XRL     A,R1
   \                     ??initPage_11:
   \   0000F7   6003         JZ      $+5
   \   0000F9   02....       LJMP    ??initPage_3 & 0xFFFF
   \   0000FC   85..82       MOV     DPL,?XSP + 0
   \   0000FF   85..83       MOV     DPH,?XSP + 1
   \   000102   A3           INC     DPTR
   \   000103   E0           MOVX    A,@DPTR
   \   000104   5480         ANL     A,#0x80
   \   000106   F9           MOV     R1,A
   \   000107   E4           CLR     A
   \   000108   7001         JNZ     ??initPage_12
   \   00010A   E9           MOV     A,R1
   \                     ??initPage_12:
   \   00010B   7015         JNZ     ??initPage_13
   \   00010D   7408         MOV     A,#0x8
   \   00010F   12....       LCALL   ?XSTACK_DISP0_8
   \   000112   E0           MOVX    A,@DPTR
   \   000113   64FF         XRL     A,#0xff
   \   000115   7004         JNZ     ??initPage_14
   \   000117   A3           INC     DPTR
   \   000118   E0           MOVX    A,@DPTR
   \   000119   64FF         XRL     A,#0xff
   \                     ??initPage_14:
   \   00011B   6003         JZ      $+5
   \   00011D   02....       LJMP    ??initPage_3 & 0xFFFF
   \   000120   8013         SJMP    ??initPage_15
   \                     ??initPage_13:
   \   000122   7408         MOV     A,#0x8
   \   000124   12....       LCALL   ?XSTACK_DISP0_8
   \   000127   E0           MOVX    A,@DPTR
   \   000128   64FF         XRL     A,#0xff
   \   00012A   7004         JNZ     ??initPage_16
   \   00012C   A3           INC     DPTR
   \   00012D   E0           MOVX    A,@DPTR
   \   00012E   64FF         XRL     A,#0xff
   \                     ??initPage_16:
   \   000130   7003         JNZ     $+5
   \   000132   02....       LJMP    ??initPage_3 & 0xFFFF
   \                     ??initPage_15:
   \   000135   AA..         MOV     R2,?V0 + 2
   \   000137   AB..         MOV     R3,?V0 + 3
   \   000139   8084         SJMP    ??initPage_7
   \                     ??initPage_10:
   \   00013B                ; Setup parameters for call to function calcChkF
   \   00013B   7404         MOV     A,#0x4
   \   00013D   12....       LCALL   ?XSTACK_DISP0_8
   \   000140   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000143   AA..         MOV     R2,?V0 + 2
   \   000145   AB..         MOV     R3,?V0 + 3
   \   000147   A9..         MOV     R1,?V0 + 6
   \   000149   12....       LCALL   ??calcChkF?relay
   \   00014C   8A..         MOV     ?V0 + 4,R2
   \   00014E   8B..         MOV     ?V0 + 5,R3
   \   000150   A8..         MOV     R0,?V0 + 4
   \   000152   A9..         MOV     R1,?V0 + 5
   \   000154   7406         MOV     A,#0x6
   \   000156   12....       LCALL   ?XSTACK_DISP0_8
   \   000159   E0           MOVX    A,@DPTR
   \   00015A   68           XRL     A,R0
   \   00015B   7003         JNZ     ??initPage_17
   \   00015D   A3           INC     DPTR
   \   00015E   E0           MOVX    A,@DPTR
   \   00015F   69           XRL     A,R1
   \                     ??initPage_17:
   \   000160   6003         JZ      $+5
   \   000162   02....       LJMP    ??initPage_1 & 0xFFFF
   \   000165   E5..         MOV     A,?V0 + 7
   \   000167   6038         JZ      ??initPage_18
   \   000169   7408         MOV     A,#0x8
   \   00016B   12....       LCALL   ?XSTACK_DISP0_8
   \   00016E   E0           MOVX    A,@DPTR
   \   00016F   64FF         XRL     A,#0xff
   \   000171   7004         JNZ     ??initPage_19
   \   000173   A3           INC     DPTR
   \   000174   E0           MOVX    A,@DPTR
   \   000175   64FF         XRL     A,#0xff
   \                     ??initPage_19:
   \   000177   6003         JZ      $+5
   \   000179   02....       LJMP    ??initPage_3 & 0xFFFF
   \   00017C                ; Setup parameters for call to function findItem
   \   00017C   7402         MOV     A,#0x2
   \   00017E   12....       LCALL   ?XSTACK_DISP0_8
   \   000181   E0           MOVX    A,@DPTR
   \   000182   FA           MOV     R2,A
   \   000183   A3           INC     DPTR
   \   000184   E0           MOVX    A,@DPTR
   \   000185   4480         ORL     A,#0x80
   \   000187   FB           MOV     R3,A
   \   000188   12....       LCALL   ??findItem?relay
   \   00018B   EA           MOV     A,R2
   \   00018C   7001         JNZ     ??initPage_20
   \   00018E   EB           MOV     A,R3
   \                     ??initPage_20:
   \   00018F   7003         JNZ     $+5
   \   000191   02....       LJMP    ??initPage_3 & 0xFFFF
   \   000194                ; Setup parameters for call to function setItem
   \   000194   7C01         MOV     R4,#0x1
   \   000196   90....       MOV     DPTR,#findPg
   \   000199   E0           MOVX    A,@DPTR
   \   00019A   F9           MOV     R1,A
   \   00019B   12....       LCALL   ??setItem?relay
   \   00019E   02....       LJMP    ??initPage_3 & 0xFFFF
   \                     ??initPage_18:
   \   0001A1   7408         MOV     A,#0x8
   \   0001A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A6   E0           MOVX    A,@DPTR
   \   0001A7   64FF         XRL     A,#0xff
   \   0001A9   7004         JNZ     ??initPage_21
   \   0001AB   A3           INC     DPTR
   \   0001AC   E0           MOVX    A,@DPTR
   \   0001AD   64FF         XRL     A,#0xff
   \                     ??initPage_21:
   \   0001AF   7003         JNZ     $+5
   \   0001B1   02....       LJMP    ??initPage_3 & 0xFFFF
   \   0001B4   7AFF         MOV     R2,#-0x1
   \   0001B6   7BFF         MOV     R3,#-0x1
   \   0001B8   02....       LJMP    ??initPage_7 & 0xFFFF
    543          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   EE           MOV     A,R6
   \                     ??Subroutine25_0:
   \   000001   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   E8           MOV     A,R0
   \   000001   24..         ADD     A,#((pgLost + 136) & 0xff)
   \   000003   F582         MOV     DPL,A
   \   000005   E9           MOV     A,R1
   \   000006   34..         ADDC    A,#(((pgLost - 120) >> 8) & 0xff)
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2403         ADD     A,#0x3
   \   000003   F8           MOV     R0,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   F9           MOV     R1,A
   \   000009   74FC         MOV     A,#-0x4
   \   00000B   58           ANL     A,R0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   C3           CLR     C
   \   000001   33           RLC     A
   \   000002   F8           MOV     R0,A
   \   000003   E4           CLR     A
   \   000004   33           RLC     A
   \   000005   F9           MOV     R1,A
   \   000006   E8           MOV     A,R0
   \   000007   24..         ADD     A,#((pgOff + 136) & 0xff)
   \   000009   F582         MOV     DPL,A
   \   00000B   E9           MOV     A,R1
   \   00000C   34..         ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
   \   00000E   F583         MOV     DPH,A
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   740A         MOV     A,#0xa
   \                     ??Subroutine38_0:
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??Subroutine38_1:
   \   000005   7F08         MOV     R7,#0x8
   \   000007   02....       LJMP    ?BANKED_LEAVE_XDATA
    544          
    545          /*********************************************************************
    546           * @fn      erasePage
    547           *
    548           * @brief   Erases a page in Flash.
    549           *
    550           * @param   pg - Valid NV page to erase.
    551           *
    552           * @return  none
    553           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    554          static void erasePage( uint8 pg )
   \                     erasePage:
    555          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    556            halIntState_t intState;
    557            osalNvHdr_t ieee;
    558          
    559            if ( !OSAL_NV_CHECK_BUS_VOLTAGE )
   \   00000C                ; Setup parameters for call to function HalAdcCheckVdd
   \   00000C   7904         MOV     R1,#0x4
   \   00000E   12....       LCALL   ??HalAdcCheckVdd?relay
   \   000011   E9           MOV     A,R1
   \   000012   7008         JNZ     ??erasePage_0
    560            {
    561              failF = TRUE;
   \   000014   7401         MOV     A,#0x1
   \   000016   90....       MOV     DPTR,#failF
   \   000019   F0           MOVX    @DPTR,A
    562              return;
   \   00001A   8046         SJMP    ??erasePage_1
    563            }
    564          
    565            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \                     ??erasePage_0:
   \   00001C   A2AF         MOV     C,0xa8.7
   \   00001E   E4           CLR     A
   \   00001F   92E0         MOV     0xE0 /* A   */.0,C
   \   000021   FA           MOV     R2,A
   \   000022   C2AF         CLR     0xa8.7
    566            FADDRH = (pg) << 1;
   \   000024   EE           MOV     A,R6
   \   000025   C3           CLR     C
   \   000026   33           RLC     A
   \   000027   F5AD         MOV     0xad,A
    567            FCTL = 0x01;
   \   000029   75AE01       MOV     0xae,#0x1
    568            asm("NOP");
   \   00002C   00           NOP
    569            while(FCTL == 0x80);
   \                     ??erasePage_2:
   \   00002D   7480         MOV     A,#-0x80
   \   00002F   65AE         XRL     A,0xae
   \   000031   60FA         JZ      ??erasePage_2
    570            HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \   000033   EA           MOV     A,R2
   \   000034   A2E0         MOV     C,0xE0 /* A   */.0
   \   000036   92AF         MOV     0xa8.7,C
    571          
    572            pgOff[pg - OSAL_NV_PAGE_BEG] = OSAL_NV_PAGE_HDR_SIZE;
   \   000038   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   00003B   7408         MOV     A,#0x8
   \   00003D   F0           MOVX    @DPTR,A
   \   00003E   A3           INC     DPTR
   \   00003F   E4           CLR     A
   \   000040   12....       LCALL   ?Subroutine19 & 0xFFFF
    573            pgLost[pg - OSAL_NV_PAGE_BEG] = 0;
   \                     ??CrossCallReturnLabel_61:
   \   000043   12....       LCALL   ??Subroutine17_0 & 0xFFFF
    574          
    575            nvReadHdr( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee) );
   \                     ??CrossCallReturnLabel_55:
   \   000046   7AF8         MOV     R2,#-0x8
   \   000048   7B07         MOV     R3,#0x7
   \   00004A   793F         MOV     R1,#0x3f
   \   00004C   12....       LCALL   nvReadHdr & 0xFFFF
    576            writeWordM( pg, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee), 2 );
   \   00004F                ; Setup parameters for call to function writeWordM
   \   00004F   75..02       MOV     ?V0 + 0,#0x2
   \   000052   78..         MOV     R0,#?V0 + 0
   \   000054   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000057   7401         MOV     A,#0x1
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
    577          }
   \                     ??erasePage_1:
   \   000062   7408         MOV     A,#0x8
   \   000064                REQUIRE ?Subroutine39
   \   000064                REQUIRE _A_IEN0
   \   000064                REQUIRE FADDRH
   \   000064                REQUIRE FCTL
   \   000064                ; // Fall through to label ?Subroutine39

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F01         MOV     R7,#0x1
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
    578          
    579          /*********************************************************************
    580           * @fn      compactPage
    581           *
    582           * @brief   Compacts the page specified.
    583           *
    584           * @param   srcPg - Valid NV page to erase.
    585           *
    586           * @return  none
    587           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    588          static void compactPage( uint8 srcPg )
   \                     compactPage:
    589          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    590            uint16 dstOff = pgOff[pgRes-OSAL_NV_PAGE_BEG];
   \   00000C   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   00000F   12....       LCALL   ?Subroutine6 & 0xFFFF
    591            uint16 srcOff = OSAL_NV_ZEROED_ID;
   \                     ??CrossCallReturnLabel_21:
   \   000012   12....       LCALL   ?Subroutine17 & 0xFFFF
    592            osalNvHdr_t hdr;
    593          
    594            // Mark page as being in process of compaction.
    595            writeWordH( srcPg, OSAL_NV_PG_XFER, (uint8*)(&srcOff) );
   \                     ??CrossCallReturnLabel_53:
   \   000015   7A04         MOV     R2,#0x4
   \   000017   FB           MOV     R3,A
   \   000018   EE           MOV     A,R6
   \   000019   F9           MOV     R1,A
   \   00001A   12....       LCALL   ??writeWordH?relay
    596          
    597            srcOff = OSAL_NV_PAGE_HDR_SIZE;
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   7408         MOV     A,#0x8
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   E4           CLR     A
   \   000028   02....       LJMP    ??compactPage_0 & 0xFFFF
    598          
    599            do
    600            {
    601              uint16 sz;
    602              nvReadHdr( srcPg, srcOff, (uint8 *)(&hdr) );
    603          
    604              if ( hdr.id == OSAL_NV_ERASED_ID )
    605              {
    606                break;
    607              }
    608          
    609              srcOff += OSAL_NV_HDR_SIZE;
    610          
    611              if ( (srcOff + hdr.len) > OSAL_NV_PAGE_FREE )
    612              {
    613                break;
    614              }
    615          
    616              sz = OSAL_NV_DATA_SIZE( hdr.len );
   \                     ??compactPage_1:
   \   00002B   7404         MOV     A,#0x4
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000033   F5..         MOV     ?V0 + 4,A
   \   000035   74FF         MOV     A,#-0x1
   \   000037   59           ANL     A,R1
   \   000038   F5..         MOV     ?V0 + 5,A
    617          
    618              if ( hdr.id != OSAL_NV_ZEROED_ID )
   \   00003A   7402         MOV     A,#0x2
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   7002         JNZ     ??compactPage_2
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \                     ??compactPage_2:
   \   000044   6079         JZ      ??CrossCallReturnLabel_32
    619              {
    620                if ( hdr.chk == calcChkF( srcPg, srcOff, hdr.len ) )
   \   000046                ; Setup parameters for call to function calcChkF
   \   000046   7404         MOV     A,#0x4
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   00004E   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000051   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000054   7406         MOV     A,#0x6
   \   000056   12....       LCALL   ?XSTACK_DISP0_8
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   68           XRL     A,R0
   \   00005B   7003         JNZ     ??compactPage_3
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   69           XRL     A,R1
   \                     ??compactPage_3:
   \   000060   7058         JNZ     ??compactPage_4
    621                {
    622                  setItem( srcPg, srcOff, eNvXfer );
   \   000062                ; Setup parameters for call to function setItem
   \   000062   7C00         MOV     R4,#0x0
   \   000064   12....       LCALL   ?Subroutine9 & 0xFFFF
    623                  writeBuf( pgRes, dstOff, OSAL_NV_HDR_SIZE, (byte *)(&hdr) );
   \                     ??CrossCallReturnLabel_31:
   \   000067                ; Setup parameters for call to function writeBuf
   \   000067   7402         MOV     A,#0x2
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   8582..       MOV     ?V0 + 2,DPL
   \   00006F   8583..       MOV     ?V0 + 3,DPH
   \   000072   78..         MOV     R0,#?V0 + 2
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000077   7C08         MOV     R4,#0x8
   \   000079   7D00         MOV     R5,#0x0
   \   00007B   AA..         MOV     R2,?V0 + 0
   \   00007D   AB..         MOV     R3,?V0 + 1
   \   00007F   90....       MOV     DPTR,#pgRes
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F9           MOV     R1,A
   \   000084   12....       LCALL   ??writeBuf?relay
   \   000087   7402         MOV     A,#0x2
   \   000089   12....       LCALL   ?DEALLOC_XSTACK8
    624                  dstOff += OSAL_NV_HDR_SIZE;
   \   00008C   12....       LCALL   ?Subroutine23 & 0xFFFF
    625                  xferBuf( srcPg, srcOff, pgRes, dstOff, sz );
   \                     ??CrossCallReturnLabel_71:
   \   00008F                ; Setup parameters for call to function xferBuf
   \   00008F   78..         MOV     R0,#?V0 + 4
   \   000091   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000094   78..         MOV     R0,#?V0 + 0
   \   000096   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000099   90....       MOV     DPTR,#pgRes
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   FC           MOV     R4,A
   \   00009E   7404         MOV     A,#0x4
   \   0000A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A3   12....       LCALL   ??Subroutine10_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   0000A6   12....       LCALL   ??xferBuf?relay
   \   0000A9   7404         MOV     A,#0x4
   \   0000AB   12....       LCALL   ?DEALLOC_XSTACK8
    626                  dstOff += sz;
   \   0000AE   E5..         MOV     A,?V0 + 0
   \   0000B0   25..         ADD     A,?V0 + 4
   \   0000B2   F5..         MOV     ?V0 + 0,A
   \   0000B4   E5..         MOV     A,?V0 + 1
   \   0000B6   35..         ADDC    A,?V0 + 5
   \   0000B8   F5..         MOV     ?V0 + 1,A
    627                }
    628          
    629                setItem( srcPg, srcOff, eNvZero );  // Mark old location as invalid.
   \                     ??compactPage_4:
   \   0000BA                ; Setup parameters for call to function setItem
   \   0000BA   7C01         MOV     R4,#0x1
   \   0000BC   12....       LCALL   ?Subroutine9 & 0xFFFF
    630              }
    631          
    632              srcOff += sz;
   \                     ??CrossCallReturnLabel_32:
   \   0000BF   85..82       MOV     DPL,?XSP + 0
   \   0000C2   85..83       MOV     DPH,?XSP + 1
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   25..         ADD     A,?V0 + 4
   \   0000C8   F0           MOVX    @DPTR,A
   \   0000C9   A3           INC     DPTR
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   35..         ADDC    A,?V0 + 5
   \                     ??compactPage_0:
   \   0000CD   F0           MOVX    @DPTR,A
    633          
    634            } while ( TRUE );
   \   0000CE                ; Setup parameters for call to function nvReadHdr
   \   0000CE   7402         MOV     A,#0x2
   \   0000D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D3   AC82         MOV     R4,DPL
   \   0000D5   AD83         MOV     R5,DPH
   \   0000D7   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0000DA   12....       LCALL   nvReadHdr & 0xFFFF
   \   0000DD   7402         MOV     A,#0x2
   \   0000DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   64FF         XRL     A,#0xff
   \   0000E5   7004         JNZ     ??compactPage_5
   \   0000E7   A3           INC     DPTR
   \   0000E8   E0           MOVX    A,@DPTR
   \   0000E9   64FF         XRL     A,#0xff
   \                     ??compactPage_5:
   \   0000EB   602F         JZ      ??compactPage_6
   \   0000ED   85..82       MOV     DPL,?XSP + 0
   \   0000F0   85..83       MOV     DPH,?XSP + 1
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   2408         ADD     A,#0x8
   \   0000F6   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   0000F9   85..82       MOV     DPL,?XSP + 0
   \   0000FC   85..83       MOV     DPH,?XSP + 1
   \   0000FF   C082         PUSH    DPL
   \   000101   C083         PUSH    DPH
   \   000103   7404         MOV     A,#0x4
   \   000105   12....       LCALL   ?XSTACK_DISP0_8
   \   000108   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   00010B   D083         POP     DPH
   \   00010D   D082         POP     DPL
   \   00010F   E0           MOVX    A,@DPTR
   \   000110   28           ADD     A,R0
   \   000111   F8           MOV     R0,A
   \   000112   A3           INC     DPTR
   \   000113   E0           MOVX    A,@DPTR
   \   000114   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000117   5003         JNC     $+5
   \   000119   02....       LJMP    ??compactPage_1 & 0xFFFF
    635          
    636            pgOff[pgRes-OSAL_NV_PAGE_BEG] = dstOff;
   \                     ??compactPage_6:
   \   00011C   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   00011F   E5..         MOV     A,?V0 + 0
   \   000121   F0           MOVX    @DPTR,A
   \   000122   A3           INC     DPTR
   \   000123   E5..         MOV     A,?V0 + 1
   \   000125   F0           MOVX    @DPTR,A
    637          
    638            /* In order to recover from a page compaction that is interrupted,
    639             * the logic in osal_nv_init() depends upon the following order:
    640             * 1. Compacted page is erased.
    641             * 2. State of the target of compaction is changed ePgActive to ePgInUse.
    642             */
    643            erasePage( srcPg );
   \   000126                ; Setup parameters for call to function erasePage
   \   000126   EE           MOV     A,R6
   \   000127   F9           MOV     R1,A
   \   000128   12....       LCALL   ??erasePage?relay
    644          
    645            // Mark the reserve page as being in use.
    646            setPageUse( pgRes, TRUE );
   \   00012B                ; Setup parameters for call to function setPageUse
   \   00012B   7A01         MOV     R2,#0x1
   \   00012D   90....       MOV     DPTR,#pgRes
   \   000130   E0           MOVX    A,@DPTR
   \   000131   F9           MOV     R1,A
   \   000132   12....       LCALL   ??setPageUse?relay
    647          
    648            // Set the reserve page to be the newly erased page.
    649            pgRes = srcPg;
   \   000135   EE           MOV     A,R6
   \   000136   90....       MOV     DPTR,#pgRes
   \   000139   F0           MOVX    @DPTR,A
    650          }
   \   00013A   740A         MOV     A,#0xa
   \   00013C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00013F                REQUIRE ?Subroutine40
   \   00013F                ; // Fall through to label ?Subroutine40

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \                     ??Subroutine10_0:
   \   000006   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000009   EE           MOV     A,R6
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000003   EE           MOV     A,R6
   \   000004   F9           MOV     R1,A
   \   000005   12....       LCALL   ??setItem?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   90....       MOV     DPTR,#pgRes
   \   000003   E0           MOVX    A,@DPTR
   \   000004   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   39           ADDC    A,R1
   \   000001   F9           MOV     R1,A
   \   000002   C3           CLR     C
   \   000003   E8           MOV     A,R0
   \   000004   94F9         SUBB    A,#-0x7
   \   000006   E9           MOV     A,R1
   \   000007   9407         SUBB    A,#0x7
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   3400         ADDC    A,#0x0
   \   000005   F0           MOVX    @DPTR,A
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL   ??calcChkF?relay
   \   000003   8A..         MOV     ?V0 + 2,R2
   \   000005   8B..         MOV     ?V0 + 3,R3
   \   000007   A8..         MOV     R0,?V0 + 2
   \   000009   A9..         MOV     R1,?V0 + 3
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   2408         ADD     A,#0x8
   \   000004   F5..         MOV     ?V0 + 0,A
   \   000006   E5..         MOV     A,?V0 + 1
   \   000008   3400         ADDC    A,#0x0
   \   00000A   F5..         MOV     ?V0 + 1,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \                     ??Subroutine32_0:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FA           MOV     R2,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FB           MOV     R3,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007   22           RET
    651          
    652          /*********************************************************************
    653           * @fn      findItem
    654           *
    655           * @brief   Find an item Id in NV and return the page and offset to its data.
    656           *
    657           * @param   id - Valid NV item Id.
    658           *
    659           * @return  Offset of data corresponding to item Id, if found;
    660           *          otherwise OSAL_NV_ITEM_NULL.
    661           *
    662           *          The page containing the item, if found;
    663           *          otherwise no valid assignment made - left equal to item Id.
    664           *
    665           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    666          static uint16 findItem( uint16 id )
   \                     findItem:
    667          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   8003         SJMP    ??findItem_0
    668            uint16 off;
    669            uint8 pg;
    670          
    671            for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
    672            {
    673              if ( (off = initPage( pg, id, FALSE )) != OSAL_NV_ITEM_NULL )
    674              {
    675                findPg = pg;
    676                return off;
    677              }
    678            }
    679          
    680            // Now attempt to find the item as the "old" item of a failed/interrupted NV write.
    681            if ( (id & OSAL_NV_SOURCE_ID) == 0 )
    682            {
    683              return findItem( id | OSAL_NV_SOURCE_ID );
   \                     ??findItem_1:
   \   00000A   7480         MOV     A,#-0x80
   \   00000C   4F           ORL     A,R7
   \                     ??findItem_0:
   \   00000D   FF           MOV     R7,A
    684            }
   \   00000E   75..3C       MOV     ?V0 + 0,#0x3c
   \                     ??findItem_2:
   \   000011                ; Setup parameters for call to function initPage
   \   000011   7C00         MOV     R4,#0x0
   \   000013   EE           MOV     A,R6
   \   000014   FA           MOV     R2,A
   \   000015   EF           MOV     A,R7
   \   000016   FB           MOV     R3,A
   \   000017   A9..         MOV     R1,?V0 + 0
   \   000019   12....       LCALL   ??initPage?relay
   \   00001C   EA           MOV     A,R2
   \   00001D   7001         JNZ     ??findItem_3
   \   00001F   EB           MOV     A,R3
   \                     ??findItem_3:
   \   000020   6008         JZ      ??findItem_4
   \   000022   E5..         MOV     A,?V0 + 0
   \   000024   90....       MOV     DPTR,#findPg
   \   000027   F0           MOVX    @DPTR,A
   \   000028   801A         SJMP    ??findItem_5
   \                     ??findItem_4:
   \   00002A   05..         INC     ?V0 + 0
   \   00002C   E5..         MOV     A,?V0 + 0
   \   00002E   C3           CLR     C
   \   00002F   943E         SUBB    A,#0x3e
   \   000031   40DE         JC      ??findItem_2
   \   000033   7480         MOV     A,#-0x80
   \   000035   5F           ANL     A,R7
   \   000036   F9           MOV     R1,A
   \   000037   E4           CLR     A
   \   000038   7001         JNZ     ??findItem_6
   \   00003A   E9           MOV     A,R1
   \                     ??findItem_6:
   \   00003B   60CD         JZ      ??findItem_1
    685            else
    686            {
    687              findPg = OSAL_NV_PAGE_NULL;
   \   00003D   E4           CLR     A
   \   00003E   90....       MOV     DPTR,#findPg
   \   000041   F0           MOVX    @DPTR,A
    688              return OSAL_NV_ITEM_NULL;
   \   000042   FA           MOV     R2,A
   \   000043   FB           MOV     R3,A
   \                     ??findItem_5:
   \   000044                REQUIRE ?Subroutine41
   \   000044                ; // Fall through to label ?Subroutine41
    689            }
    690          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    691          
    692          /*********************************************************************
    693           * @fn      initItem
    694           *
    695           * @brief   An NV item is created and initialized with the data passed to the function, if any.
    696           *
    697           * @param   id  - Valid NV item Id.
    698           * @param   len - Item data length.
    699           * @param  *buf - Pointer to item initalization data. Set to NULL if none.
    700           *
    701           * @return  TRUE if item write and read back checksums ok; FALSE otherwise.
    702           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    703          static uint8 initItem( uint8 flag, uint16 id, uint16 len, void *buf )
   \                     initItem:
    704          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   8A..         MOV     ?V0 + 4,R2
   \   000009   8B..         MOV     ?V0 + 5,R3
   \   00000B   7410         MOV     A,#0x10
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F5..         MOV     ?V0 + 6,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 7,A
    705            uint16 sz = OSAL_NV_ITEM_SIZE( len );
   \   000017   7403         MOV     A,#0x3
   \   000019   2C           ADD     A,R4
   \   00001A   F8           MOV     R0,A
   \   00001B   E4           CLR     A
   \   00001C   3D           ADDC    A,R5
   \   00001D   F9           MOV     R1,A
   \   00001E   74FC         MOV     A,#-0x4
   \   000020   58           ANL     A,R0
   \   000021   F8           MOV     R0,A
   \   000022   7408         MOV     A,#0x8
   \   000024   28           ADD     A,R0
   \   000025   FA           MOV     R2,A
   \   000026   E4           CLR     A
   \   000027   39           ADDC    A,R1
   \   000028   FB           MOV     R3,A
    706            uint8 rtrn = FALSE;
   \   000029   75..00       MOV     ?V0 + 1,#0x0
    707            uint8 cnt = OSAL_NV_PAGES_USED;
   \   00002C   75..02       MOV     ?V0 + 2,#0x2
    708            uint8 pg = pgRes+1;  // Set to 1 after the reserve page to even wear across all available pages.
   \   00002F   90....       MOV     DPTR,#pgRes
   \   000032   E0           MOVX    A,@DPTR
   \   000033   04           INC     A
   \   000034   FF           MOV     R7,A
    709            uint8 idx;
    710          
    711            do {
    712              if (pg >= OSAL_NV_PAGE_BEG+OSAL_NV_PAGES_USED)
   \                     ??initItem_0:
   \   000035   EF           MOV     A,R7
   \   000036   C3           CLR     C
   \   000037   943E         SUBB    A,#0x3e
   \   000039   4002         JC      ??initItem_1
    713              {
    714                pg = OSAL_NV_PAGE_BEG;
   \   00003B   7F3C         MOV     R7,#0x3c
    715              }
    716              if ( pg != pgRes )
   \                     ??initItem_1:
   \   00003D   90....       MOV     DPTR,#pgRes
   \   000040   E0           MOVX    A,@DPTR
   \   000041   6F           XRL     A,R7
   \   000042   602D         JZ      ??initItem_2
    717              {
    718                idx = pg - OSAL_NV_PAGE_BEG;
   \   000044   74C4         MOV     A,#-0x3c
   \   000046   2F           ADD     A,R7
   \   000047   FE           MOV     R6,A
    719                if ( (pgOff[idx] - pgLost[idx] + sz) <= OSAL_NV_PAGE_FREE )
   \   000048   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   00004B   C082         PUSH    DPL
   \   00004D   C083         PUSH    DPH
   \   00004F   E8           MOV     A,R0
   \   000050   24..         ADD     A,#(pgLost & 0xff)
   \   000052   F582         MOV     DPL,A
   \   000054   E9           MOV     A,R1
   \   000055   34..         ADDC    A,#((pgLost >> 8) & 0xff)
   \   000057   F583         MOV     DPH,A
   \   000059   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00005C   D083         POP     DPH
   \   00005E   D082         POP     DPL
   \   000060   E0           MOVX    A,@DPTR
   \   000061   C3           CLR     C
   \   000062   98           SUBB    A,R0
   \   000063   F8           MOV     R0,A
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   99           SUBB    A,R1
   \   000067   F9           MOV     R1,A
   \   000068   EA           MOV     A,R2
   \   000069   28           ADD     A,R0
   \   00006A   F8           MOV     R0,A
   \   00006B   EB           MOV     A,R3
   \   00006C   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   00006F   4007         JC      ??initItem_3
    720                {
    721                  break;
    722                }
    723              }
    724              pg++;
   \                     ??initItem_2:
   \   000071   0F           INC     R7
    725            } while (--cnt);
   \   000072   15..         DEC     ?V0 + 2
   \   000074   E5..         MOV     A,?V0 + 2
   \   000076   70BD         JNZ     ??initItem_0
    726          
    727            if (cnt)
   \                     ??initItem_3:
   \   000078   E5..         MOV     A,?V0 + 2
   \   00007A   605C         JZ      ??initItem_4
    728            {
    729              // Item fits if an old page is compacted.
    730              if ( (pgOff[idx] + sz) > OSAL_NV_PAGE_FREE )
   \   00007C   EE           MOV     A,R6
   \   00007D   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000080   E0           MOVX    A,@DPTR
   \   000081   2A           ADD     A,R2
   \   000082   F8           MOV     R0,A
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   3B           ADDC    A,R3
   \   000086   F9           MOV     R1,A
   \   000087   C3           CLR     C
   \   000088   E8           MOV     A,R0
   \   000089   94F9         SUBB    A,#-0x7
   \   00008B   E9           MOV     A,R1
   \   00008C   9407         SUBB    A,#0x7
   \   00008E   4005         JC      ??initItem_5
    731              {
    732                pg = pgRes;
   \   000090   90....       MOV     DPTR,#pgRes
   \   000093   E0           MOVX    A,@DPTR
   \   000094   FF           MOV     R7,A
    733              }
    734          
    735              // New item is the first one written to the reserved page, then the old page is compacted.
    736              rtrn = writeItem( pg, id, len, buf, flag );
   \                     ??initItem_5:
   \   000095                ; Setup parameters for call to function writeItem
   \   000095   E5..         MOV     A,?V0 + 0
   \   000097   F5..         MOV     ?V0 + 1,A
   \   000099   78..         MOV     R0,#?V0 + 1
   \   00009B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009E   85....       MOV     ?V0 + 2,?V0 + 6
   \   0000A1   85....       MOV     ?V0 + 3,?V0 + 7
   \   0000A4   78..         MOV     R0,#?V0 + 2
   \   0000A6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A9   AA..         MOV     R2,?V0 + 4
   \   0000AB   AB..         MOV     R3,?V0 + 5
   \   0000AD   EF           MOV     A,R7
   \   0000AE   F9           MOV     R1,A
   \   0000AF   12....       LCALL   ??writeItem?relay
   \   0000B2   7403         MOV     A,#0x3
   \   0000B4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B7   E9           MOV     A,R1
   \   0000B8   F5..         MOV     ?V0 + 1,A
    737          
    738              if ( pg == pgRes )
   \   0000BA   90....       MOV     DPTR,#pgRes
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   6F           XRL     A,R7
   \   0000BF   7017         JNZ     ??initItem_4
    739              {
    740                if ( flag )
   \   0000C1   E5..         MOV     A,?V0 + 0
   \   0000C3   6009         JZ      ??initItem_6
    741                {
    742                  compactPage( OSAL_NV_PAGE_BEG+idx );
   \   0000C5                ; Setup parameters for call to function compactPage
   \   0000C5   743C         MOV     A,#0x3c
   \   0000C7   2E           ADD     A,R6
   \   0000C8   F9           MOV     R1,A
   \   0000C9   12....       LCALL   ??compactPage?relay
   \   0000CC   800A         SJMP    ??initItem_4
    743                }
    744                else
    745                {
    746                  *(uint8 *)buf = OSAL_NV_PAGE_BEG+idx;
   \                     ??initItem_6:
   \   0000CE   743C         MOV     A,#0x3c
   \   0000D0   2E           ADD     A,R6
   \   0000D1   85..82       MOV     DPL,?V0 + 6
   \   0000D4   85..83       MOV     DPH,?V0 + 7
   \   0000D7   F0           MOVX    @DPTR,A
    747                }
    748              }
    749            }
    750          
    751            return rtrn;
   \                     ??initItem_4:
   \   0000D8   A9..         MOV     R1,?V0 + 1
   \   0000DA   02....       LJMP    ??Subroutine38_1 & 0xFFFF
    752          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   C3           CLR     C
   \   000001   33           RLC     A
   \   000002   F8           MOV     R0,A
   \   000003   E4           CLR     A
   \   000004   33           RLC     A
   \   000005   F9           MOV     R1,A
   \   000006   E8           MOV     A,R0
   \   000007   24..         ADD     A,#(pgOff & 0xff)
   \   000009   F582         MOV     DPL,A
   \   00000B   E9           MOV     A,R1
   \   00000C   34..         ADDC    A,#((pgOff >> 8) & 0xff)
   \   00000E   F583         MOV     DPH,A
   \   000010   22           RET
    753          
    754          /*********************************************************************
    755           * @fn      setItem
    756           *
    757           * @brief   Set an item Id or status to mark its state.
    758           *
    759           * @param   pg - Valid NV page.
    760           * @param   offset - Valid offset into the page of the item data - the header
    761           *                   offset is calculated from this.
    762           * @param   stat - Valid enum value for the item status.
    763           *
    764           * @return  none
    765           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    766          static void setItem( uint8 pg, uint16 offset, eNvHdrEnum stat )
   \                     setItem:
    767          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 0,R1
   \   00000C   EC           MOV     A,R4
   \   00000D   FE           MOV     R6,A
    768            osalNvHdr_t hdr;
    769          
    770            offset -= OSAL_NV_HDR_SIZE;
   \   00000E   EA           MOV     A,R2
   \   00000F   24F8         ADD     A,#-0x8
   \   000011   F5..         MOV     ?V0 + 2,A
   \   000013   EB           MOV     A,R3
   \   000014   34FF         ADDC    A,#-0x1
   \   000016   F5..         MOV     ?V0 + 3,A
    771            nvReadHdr( pg, offset, (uint8 *)(&hdr) );
   \   000018                ; Setup parameters for call to function nvReadHdr
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   AC82         MOV     R4,DPL
   \   000020   AD83         MOV     R5,DPH
   \   000022   AA..         MOV     R2,?V0 + 2
   \   000024   FB           MOV     R3,A
   \   000025   12....       LCALL   nvReadHdr & 0xFFFF
    772          
    773            if ( stat == eNvXfer )
   \   000028   EE           MOV     A,R6
   \   000029   7022         JNZ     ??setItem_0
    774            {
    775              hdr.stat = OSAL_NV_ACTIVE;
   \   00002B   7406         MOV     A,#0x6
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   E4           CLR     A
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \   000033   F0           MOVX    @DPTR,A
    776              writeWord( pg, offset+OSAL_NV_HDR_CHK, (uint8*)(&(hdr.chk)) );
   \   000034                ; Setup parameters for call to function writeWord
   \   000034   7404         MOV     A,#0x4
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   AC82         MOV     R4,DPL
   \   00003B   AD83         MOV     R5,DPH
   \   00003D   7404         MOV     A,#0x4
   \   00003F   25..         ADD     A,?V0 + 2
   \   000041   FA           MOV     R2,A
   \   000042   E4           CLR     A
   \   000043   35..         ADDC    A,?V0 + 3
   \   000045   FB           MOV     R3,A
   \   000046   A9..         MOV     R1,?V0 + 0
   \   000048   12....       LCALL   ??writeWord?relay
   \   00004B   802A         SJMP    ??setItem_1
    777            }
    778            else // if ( stat == eNvZero )
    779            {
    780              uint16 sz = ((hdr.len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE +
    781                                                                                    OSAL_NV_HDR_SIZE;
   \                     ??setItem_0:
   \   00004D   7402         MOV     A,#0x2
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000055   FE           MOV     R6,A
   \   000056   E4           CLR     A
   \   000057   39           ADDC    A,R1
   \   000058   FF           MOV     R7,A
    782              hdr.id = 0;
   \   000059   12....       LCALL   ?Subroutine17 & 0xFFFF
    783              writeWord( pg, offset, (uint8 *)(&hdr) );
   \                     ??CrossCallReturnLabel_54:
   \   00005C   AA..         MOV     R2,?V0 + 2
   \   00005E   AB..         MOV     R3,?V0 + 3
   \   000060   A9..         MOV     R1,?V0 + 0
   \   000062   12....       LCALL   ??writeWord?relay
    784              pgLost[pg-OSAL_NV_PAGE_BEG] += sz;
   \   000065   E5..         MOV     A,?V0 + 0
   \   000067   C3           CLR     C
   \   000068   33           RLC     A
   \   000069   F8           MOV     R0,A
   \   00006A   E4           CLR     A
   \   00006B   33           RLC     A
   \   00006C   F9           MOV     R1,A
   \   00006D   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000070   E0           MOVX    A,@DPTR
   \   000071   2E           ADD     A,R6
   \   000072   F0           MOVX    @DPTR,A
   \   000073   A3           INC     DPTR
   \   000074   E0           MOVX    A,@DPTR
   \   000075   3F           ADDC    A,R7
   \   000076   F0           MOVX    @DPTR,A
    785            }
    786          }
   \                     ??setItem_1:
   \   000077   7408         MOV     A,#0x8
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007C   02....       LJMP    ?Subroutine41 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000003   F8           MOV     R0,A
   \   000004   7408         MOV     A,#0x8
   \   000006   28           ADD     A,R0
   \   000007   22           RET
    787          
    788          /*********************************************************************
    789           * @fn      calcChkB
    790           *
    791           * @brief   Calculates the data checksum over the 'buf' parameter.
    792           *
    793           * @param   pg - A valid NV Flash page.
    794           * @param   offset - A valid offset into the page.
    795           * @param   len - Byte count of the data to be checksummed.
    796           *
    797           * @return  Calculated checksum of the data bytes.
    798           */
    799          static uint16 calcChkB( uint16 len, uint8 *buf )
    800          {
    801            uint8 fill = len % OSAL_NV_WORD_SIZE;
    802            uint16 chk;
    803          
    804            if ( !buf )
    805            {
    806              chk = len * OSAL_NV_ERASED;
    807            }
    808            else
    809            {
    810              chk = 0;
    811              while ( len-- )
    812              {
    813                chk += *buf++;
    814              }
    815            }
    816          
    817            // calcChkF() will calculate over OSAL_NV_WORD_SIZE alignment.
    818            if ( fill )
    819            {
    820              chk += (OSAL_NV_WORD_SIZE - fill) * OSAL_NV_ERASED;
    821            }
    822          
    823            return chk;
    824          }
    825          
    826          /*********************************************************************
    827           * @fn      calcChkF
    828           *
    829           * @brief   Calculates the data checksum by reading the data bytes from NV.
    830           *
    831           * @param   pg - A valid NV Flash page.
    832           * @param   offset - A valid offset into the page.
    833           * @param   len - Byte count of the data to be checksummed.
    834           *
    835           * @return  Calculated checksum of the data bytes.
    836           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    837          static uint16 calcChkF( byte pg, uint16 offset, uint16 len )
   \                     calcChkF:
    838          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 0,R1
   \   00000C   8A..         MOV     ?V0 + 2,R2
   \   00000E   8B..         MOV     ?V0 + 3,R3
   \   000010   EC           MOV     A,R4
   \   000011   FE           MOV     R6,A
   \   000012   ED           MOV     A,R5
   \   000013   FF           MOV     R7,A
    839            uint16 chk = 0;
   \   000014   75..00       MOV     ?V0 + 6,#0x0
   \   000017   75..00       MOV     ?V0 + 7,#0x0
    840          
    841            len = (len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE;
   \   00001A   7403         MOV     A,#0x3
   \   00001C   2E           ADD     A,R6
   \   00001D   F5..         MOV     ?V0 + 4,A
   \   00001F   E4           CLR     A
   \   000020   3F           ADDC    A,R7
   \   000021   F5..         MOV     ?V0 + 5,A
   \   000023   7402         MOV     A,#0x2
   \   000025   78..         MOV     R0,#?V0 + 4
   \   000027   12....       LCALL   ?US_SHR
   \   00002A   AE..         MOV     R6,?V0 + 4
   \   00002C   AF..         MOV     R7,?V0 + 5
   \   00002E   8031         SJMP    ??calcChkF_0
    842          
    843            while ( len-- )
    844            {
    845              uint8 cnt, tmp[OSAL_NV_WORD_SIZE];
    846          
    847              nvReadWord( pg, offset, tmp );
   \                     ??calcChkF_1:
   \   000030                ; Setup parameters for call to function nvReadWord
   \   000030   85..82       MOV     DPL,?XSP + 0
   \   000033   85..83       MOV     DPH,?XSP + 1
   \   000036   AC82         MOV     R4,DPL
   \   000038   AD83         MOV     R5,DPH
   \   00003A   AA..         MOV     R2,?V0 + 2
   \   00003C   AB..         MOV     R3,?V0 + 3
   \   00003E   A9..         MOV     R1,?V0 + 0
   \   000040   12....       LCALL   nvReadWord & 0xFFFF
    848              offset += OSAL_NV_WORD_SIZE;
   \   000043   12....       LCALL   ?Subroutine34 & 0xFFFF
    849          
    850              for ( cnt = 0; cnt < OSAL_NV_WORD_SIZE; cnt++ )
   \                     ??CrossCallReturnLabel_100:
   \   000046   7A00         MOV     R2,#0x0
    851              {
    852                chk += tmp[cnt];
   \                     ??calcChkF_2:
   \   000048   8A..         MOV     ?V0 + 4,R2
   \   00004A   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   F8           MOV     R0,A
   \   00004F   E5..         MOV     A,?V0 + 6
   \   000051   28           ADD     A,R0
   \   000052   F5..         MOV     ?V0 + 6,A
   \   000054   E5..         MOV     A,?V0 + 7
   \   000056   3400         ADDC    A,#0x0
   \   000058   F5..         MOV     ?V0 + 7,A
    853              }
   \   00005A   0A           INC     R2
   \   00005B   EA           MOV     A,R2
   \   00005C   C3           CLR     C
   \   00005D   9404         SUBB    A,#0x4
   \   00005F   40E7         JC      ??calcChkF_2
    854            }
   \                     ??calcChkF_0:
   \   000061   EE           MOV     A,R6
   \   000062   F8           MOV     R0,A
   \   000063   EF           MOV     A,R7
   \   000064   F9           MOV     R1,A
   \   000065   74FF         MOV     A,#-0x1
   \   000067   28           ADD     A,R0
   \   000068   1E           DEC     R6
   \   000069   74FF         MOV     A,#-0x1
   \   00006B   39           ADDC    A,R1
   \   00006C   FF           MOV     R7,A
   \   00006D   E8           MOV     A,R0
   \   00006E   7001         JNZ     ??calcChkF_3
   \   000070   E9           MOV     A,R1
   \                     ??calcChkF_3:
   \   000071   70BD         JNZ     ??calcChkF_1
    855          
    856            return chk;
   \   000073   AA..         MOV     R2,?V0 + 6
   \   000075   AB..         MOV     R3,?V0 + 7
   \   000077                REQUIRE ?Subroutine43
   \   000077                ; // Fall through to label ?Subroutine43
    857          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   7404         MOV     A,#0x4
   \   000002   02....       LJMP    ??Subroutine38_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E582         MOV     A,DPL
   \   000008   25..         ADD     A,?V0 + 4
   \   00000A   F582         MOV     DPL,A
   \   00000C   E583         MOV     A,DPH
   \   00000E   3400         ADDC    A,#0x0
   \   000010   F583         MOV     DPH,A
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   E5..         MOV     A,?V0 + 2
   \   000002   2404         ADD     A,#0x4
   \   000004   F5..         MOV     ?V0 + 2,A
   \   000006   E5..         MOV     A,?V0 + 3
   \   000008   3400         ADDC    A,#0x0
   \   00000A   F5..         MOV     ?V0 + 3,A
   \   00000C   22           RET
    858          
    859          /*********************************************************************
    860           * @fn      writeWord
    861           *
    862           * @brief   Writes a Flash-WORD to NV.
    863           *
    864           * @param   pg - A valid NV Flash page.
    865           * @param   offset - A valid offset into the page.
    866           * @param   buf - Pointer to source buffer.
    867           *
    868           * @return  none
    869           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    870          static void writeWord( uint8 pg, uint16 offset, uint8 *buf )
   \                     writeWord:
    871          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    872              offset = (offset >> 2) + ((uint16)pg << 9);
   \   00000D   7402         MOV     A,#0x2
   \   00000F   78..         MOV     R0,#?V0 + 2
   \   000011   12....       LCALL   ?US_SHR
   \   000014   89..         MOV     ?V0 + 0,R1
   \   000016   F5..         MOV     ?V0 + 1,A
   \   000018   7409         MOV     A,#0x9
   \   00001A   78..         MOV     R0,#?V0 + 0
   \   00001C   12....       LCALL   ?S_SHL
   \   00001F   25..         ADD     A,?V0 + 2
   \   000021   E5..         MOV     A,?V0 + 1
   \   000023   35..         ADDC    A,?V0 + 3
   \   000025   F5..         MOV     ?V0 + 3,A
    873          
    874              if ( OSAL_NV_CHECK_BUS_VOLTAGE )
   \   000027                ; Setup parameters for call to function HalAdcCheckVdd
   \   000027   7904         MOV     R1,#0x4
   \   000029   12....       LCALL   ??HalAdcCheckVdd?relay
   \   00002C   E9           MOV     A,R1
   \   00002D   600F         JZ      ??writeWord_0
    875              {
    876              flashWriteBuf(1, (uint16)buf, offset);
   \   00002F                ; Setup parameters for call to function flashWriteBuf
   \   00002F   AC..         MOV     R4,?V0 + 2
   \   000031   AD..         MOV     R5,?V0 + 3
   \   000033   EE           MOV     A,R6
   \   000034   FA           MOV     R2,A
   \   000035   EF           MOV     A,R7
   \   000036   FB           MOV     R3,A
   \   000037   7901         MOV     R1,#0x1
   \   000039   12....       LCALL   flashWriteBuf & 0xFFFF
   \   00003C   8006         SJMP    ??writeWord_1
    877              }
    878              else
    879              {
    880                failF = TRUE;
   \                     ??writeWord_0:
   \   00003E   7401         MOV     A,#0x1
   \   000040   90....       MOV     DPTR,#failF
   \   000043   F0           MOVX    @DPTR,A
    881              }
    882          }
   \                     ??writeWord_1:
   \   000044   02....       LJMP    ?Subroutine41 & 0xFFFF
    883          
    884          /*********************************************************************
    885           * @fn      writeWordM
    886           *
    887           * @brief   Writes multiple Flash-WORDs to NV.
    888           *
    889           * @param   pg - A valid NV Flash page.
    890           * @param   offset - A valid offset into the page.
    891           * @param   buf - Pointer to source buffer.
    892           * @param   cnt - Number of 4-byte blocks to write.
    893           *
    894           * @return  none
    895           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    896          static void writeWordM( uint8 pg, uint16 offset, uint8 *buf, uint8 cnt )
   \                     writeWordM:
    897          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 4,R2
   \   000007   8B..         MOV     ?V0 + 5,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   \   00000D   740E         MOV     A,#0xe
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 2,A
    898            offset = (offset >> 2) + ((uint16)pg << 9);
   \   000015   7402         MOV     A,#0x2
   \   000017   78..         MOV     R0,#?V0 + 4
   \   000019   12....       LCALL   ?US_SHR
   \   00001C   89..         MOV     ?V0 + 0,R1
   \   00001E   F5..         MOV     ?V0 + 1,A
   \   000020   7409         MOV     A,#0x9
   \   000022   78..         MOV     R0,#?V0 + 0
   \   000024   12....       LCALL   ?S_SHL
   \   000027   25..         ADD     A,?V0 + 4
   \   000029   E5..         MOV     A,?V0 + 1
   \   00002B   35..         ADDC    A,?V0 + 5
   \   00002D   F5..         MOV     ?V0 + 5,A
    899          
    900            if ( OSAL_NV_CHECK_BUS_VOLTAGE )
   \   00002F                ; Setup parameters for call to function HalAdcCheckVdd
   \   00002F   7904         MOV     R1,#0x4
   \   000031   12....       LCALL   ??HalAdcCheckVdd?relay
   \   000034   E9           MOV     A,R1
   \   000035   600F         JZ      ??writeWordM_0
    901            {
    902              flashWriteBuf(cnt, (uint16)buf, offset);
   \   000037                ; Setup parameters for call to function flashWriteBuf
   \   000037   AC..         MOV     R4,?V0 + 4
   \   000039   AD..         MOV     R5,?V0 + 5
   \   00003B   EE           MOV     A,R6
   \   00003C   FA           MOV     R2,A
   \   00003D   EF           MOV     A,R7
   \   00003E   FB           MOV     R3,A
   \   00003F   A9..         MOV     R1,?V0 + 2
   \   000041   12....       LCALL   flashWriteBuf & 0xFFFF
   \   000044   8006         SJMP    ??writeWordM_1
    903            }
    904            else
    905            {
    906              failF = TRUE;
   \                     ??writeWordM_0:
   \   000046   7401         MOV     A,#0x1
   \   000048   90....       MOV     DPTR,#failF
   \   00004B   F0           MOVX    @DPTR,A
    907            }
    908          }
   \                     ??writeWordM_1:
   \   00004C   02....       LJMP    ?Subroutine40 & 0xFFFF
    909          
    910          /*********************************************************************
    911           * @fn      writeWordH
    912           *
    913           * @brief   Writes the 1st half of a Flash-WORD to NV (filling 2nd half with 0xffff).
    914           *
    915           * @param   pg - A valid NV Flash page.
    916           * @param   offset - A valid offset into the page.
    917           * @param   buf - Pointer to source buffer.
    918           *
    919           * @return  none
    920           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    921          static void writeWordH( uint8 pg, uint16 offset, uint8 *buf )
   \                     writeWordH:
    922          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    923            uint8 tmp[4];
    924          
    925            tmp[0] = buf[0];
   \   00000A   8C82         MOV     DPL,R4
   \   00000C   8D83         MOV     DPH,R5
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   85..82       MOV     DPL,?XSP + 0
   \   000012   85..83       MOV     DPH,?XSP + 1
   \   000015   F0           MOVX    @DPTR,A
    926            tmp[1] = buf[1];
   \   000016   8C82         MOV     DPL,R4
   \   000018   8D83         MOV     DPH,R5
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   C0E0         PUSH    A
   \   00001E   7401         MOV     A,#0x1
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   D0E0         POP     A
   \   000025   F0           MOVX    @DPTR,A
    927            tmp[2] = OSAL_NV_ERASED;
   \   000026   7402         MOV     A,#0x2
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   74FF         MOV     A,#-0x1
   \   00002D   F0           MOVX    @DPTR,A
    928            tmp[3] = OSAL_NV_ERASED;
   \   00002E   7403         MOV     A,#0x3
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   74FF         MOV     A,#-0x1
   \   000035   12....       LCALL   ??Subroutine17_2 & 0xFFFF
    929          
    930            writeWord( pg, offset, tmp );
   \                     ??CrossCallReturnLabel_57:
   \   000038   12....       LCALL   ??writeWord?relay
    931          }
   \   00003B   7404         MOV     A,#0x4
   \   00003D   02....       LJMP    ?Subroutine39 & 0xFFFF
    932          
    933          /*********************************************************************
    934           * @fn      writeBuf
    935           *
    936           * @brief   Writes a data buffer to NV.
    937           *
    938           * @param   dstPg - A valid NV Flash page.
    939           * @param   offset - A valid offset into the page.
    940           * @param   len  - Byte count of the data to write.
    941           * @param   buf  - The data to write.
    942           *
    943           * @return  TRUE if data buf checksum matches read back checksum, else FALSE.
    944           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    945          static void writeBuf( uint8 dstPg, uint16 dstOff, uint16 len, uint8 *buf )
   \                     writeBuf:
    946          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 2,R1
   \   00000C   8A..         MOV     ?V0 + 0,R2
   \   00000E   8B..         MOV     ?V0 + 1,R3
   \   000010   EC           MOV     A,R4
   \   000011   FE           MOV     R6,A
   \   000012   ED           MOV     A,R5
   \   000013   FF           MOV     R7,A
   \   000014   7414         MOV     A,#0x14
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F5..         MOV     ?V0 + 6,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F5..         MOV     ?V0 + 7,A
    947            uint8 rem = dstOff % OSAL_NV_WORD_SIZE;
   \   000020   EA           MOV     A,R2
   \   000021   5403         ANL     A,#0x3
   \   000023   F5..         MOV     ?V0 + 3,A
    948            uint8 tmp[OSAL_NV_WORD_SIZE];
    949          
    950            if ( rem )
   \   000025   6060         JZ      ??writeBuf_0
    951            {
    952              dstOff = (dstOff / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE;
   \   000027   74FC         MOV     A,#-0x4
   \   000029   55..         ANL     A,?V0 + 0
   \   00002B   F5..         MOV     ?V0 + 0,A
    953              nvReadWord( dstPg, dstOff, tmp );
   \   00002D                ; Setup parameters for call to function nvReadWord
   \   00002D   85..82       MOV     DPL,?XSP + 0
   \   000030   85..83       MOV     DPH,?XSP + 1
   \   000033   AC82         MOV     R4,DPL
   \   000035   AD83         MOV     R5,DPH
   \   000037   FA           MOV     R2,A
   \   000038   12....       LCALL   nvReadWord & 0xFFFF
   \   00003B   801E         SJMP    ??writeBuf_1
    954          
    955              while ( (rem < OSAL_NV_WORD_SIZE) && len )
    956              {
    957                tmp[rem++] = *buf++;
   \                     ??writeBuf_2:
   \   00003D   85..82       MOV     DPL,?V0 + 6
   \   000040   85..83       MOV     DPH,?V0 + 7
   \   000043   E0           MOVX    A,@DPTR
   \   000044   C0E0         PUSH    A
   \   000046   85....       MOV     ?V0 + 4,?V0 + 3
   \   000049   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   00004C   D0E0         POP     A
   \   00004E   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000051   05..         INC     ?V0 + 3
    958                len--;
   \   000053   EE           MOV     A,R6
   \   000054   24FF         ADD     A,#-0x1
   \   000056   1E           DEC     R6
   \   000057   EF           MOV     A,R7
   \   000058   34FF         ADDC    A,#-0x1
   \   00005A   FF           MOV     R7,A
    959              }
   \                     ??writeBuf_1:
   \   00005B   E5..         MOV     A,?V0 + 3
   \   00005D   C3           CLR     C
   \   00005E   9404         SUBB    A,#0x4
   \   000060   5006         JNC     ??writeBuf_3
   \   000062   EE           MOV     A,R6
   \   000063   7001         JNZ     ??writeBuf_4
   \   000065   EF           MOV     A,R7
   \                     ??writeBuf_4:
   \   000066   70D5         JNZ     ??writeBuf_2
    960          
    961              writeWord( dstPg, dstOff, tmp );
   \                     ??writeBuf_3:
   \   000068                ; Setup parameters for call to function writeWord
   \   000068   85..82       MOV     DPL,?XSP + 0
   \   00006B   85..83       MOV     DPH,?XSP + 1
   \   00006E   AC82         MOV     R4,DPL
   \   000070   AD83         MOV     R5,DPH
   \   000072   AA..         MOV     R2,?V0 + 0
   \   000074   AB..         MOV     R3,?V0 + 1
   \   000076   A9..         MOV     R1,?V0 + 2
   \   000078   12....       LCALL   ??writeWord?relay
    962              dstOff += OSAL_NV_WORD_SIZE;
   \   00007B   E5..         MOV     A,?V0 + 0
   \   00007D   2404         ADD     A,#0x4
   \   00007F   F5..         MOV     ?V0 + 0,A
   \   000081   E5..         MOV     A,?V0 + 1
   \   000083   3400         ADDC    A,#0x0
   \   000085   F5..         MOV     ?V0 + 1,A
    963            }
    964          
    965            rem = len % OSAL_NV_WORD_SIZE;
   \                     ??writeBuf_0:
   \   000087   EE           MOV     A,R6
   \   000088   5403         ANL     A,#0x3
   \   00008A   F5..         MOV     ?V0 + 3,A
    966            len /= OSAL_NV_WORD_SIZE;
   \   00008C   8E..         MOV     ?V0 + 4,R6
   \   00008E   8F..         MOV     ?V0 + 5,R7
   \   000090   7402         MOV     A,#0x2
   \   000092   78..         MOV     R0,#?V0 + 4
   \   000094   12....       LCALL   ?US_SHR
    967          
    968            if ( len )
   \   000097   E5..         MOV     A,?V0 + 4
   \   000099   7002         JNZ     ??writeBuf_5
   \   00009B   E5..         MOV     A,?V0 + 5
   \                     ??writeBuf_5:
   \   00009D   6034         JZ      ??writeBuf_6
    969            {
    970              writeWordM( dstPg, dstOff, buf, (uint8)len );
   \   00009F                ; Setup parameters for call to function writeWordM
   \   00009F   78..         MOV     R0,#?V0 + 4
   \   0000A1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A4   AC..         MOV     R4,?V0 + 6
   \   0000A6   AD..         MOV     R5,?V0 + 7
   \   0000A8   AA..         MOV     R2,?V0 + 0
   \   0000AA   AB..         MOV     R3,?V0 + 1
   \   0000AC   A9..         MOV     R1,?V0 + 2
   \   0000AE   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   0000B1   12....       LCALL   ?DEALLOC_XSTACK8
    971              dstOff += OSAL_NV_WORD_SIZE * len;
   \   0000B4   7402         MOV     A,#0x2
   \   0000B6   78..         MOV     R0,#?V0 + 4
   \   0000B8   12....       LCALL   ?S_SHL
   \   0000BB   A8..         MOV     R0,?V0 + 4
   \   0000BD   A9..         MOV     R1,?V0 + 5
   \   0000BF   E5..         MOV     A,?V0 + 0
   \   0000C1   28           ADD     A,R0
   \   0000C2   F5..         MOV     ?V0 + 0,A
   \   0000C4   E5..         MOV     A,?V0 + 1
   \   0000C6   39           ADDC    A,R1
   \   0000C7   F5..         MOV     ?V0 + 1,A
    972              buf += OSAL_NV_WORD_SIZE * len;
   \   0000C9   E5..         MOV     A,?V0 + 6
   \   0000CB   28           ADD     A,R0
   \   0000CC   F5..         MOV     ?V0 + 6,A
   \   0000CE   E5..         MOV     A,?V0 + 7
   \   0000D0   39           ADDC    A,R1
   \   0000D1   F5..         MOV     ?V0 + 7,A
    973            }
    974          
    975            if ( rem )
   \                     ??writeBuf_6:
   \   0000D3   E5..         MOV     A,?V0 + 3
   \   0000D5   6048         JZ      ??writeBuf_7
    976            {
    977              uint8 idx = 0;
   \   0000D7   7E00         MOV     R6,#0x0
    978              nvReadWord( dstPg, dstOff, tmp );
   \   0000D9                ; Setup parameters for call to function nvReadWord
   \   0000D9   85..82       MOV     DPL,?XSP + 0
   \   0000DC   85..83       MOV     DPH,?XSP + 1
   \   0000DF   AC82         MOV     R4,DPL
   \   0000E1   AD83         MOV     R5,DPH
   \   0000E3   AA..         MOV     R2,?V0 + 0
   \   0000E5   AB..         MOV     R3,?V0 + 1
   \   0000E7   A9..         MOV     R1,?V0 + 2
   \   0000E9   12....       LCALL   nvReadWord & 0xFFFF
   \   0000EC   8014         SJMP    ??writeBuf_8
    979              while ( rem-- )
    980              {
    981                tmp[idx++] = *buf++;
   \                     ??writeBuf_9:
   \   0000EE   85..82       MOV     DPL,?V0 + 6
   \   0000F1   85..83       MOV     DPH,?V0 + 7
   \   0000F4   E0           MOVX    A,@DPTR
   \   0000F5   C0E0         PUSH    A
   \   0000F7   8E..         MOV     ?V0 + 4,R6
   \   0000F9   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   0000FC   D0E0         POP     A
   \   0000FE   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000101   0E           INC     R6
    982              }
   \                     ??writeBuf_8:
   \   000102   AA..         MOV     R2,?V0 + 3
   \   000104   74FF         MOV     A,#-0x1
   \   000106   2A           ADD     A,R2
   \   000107   F5..         MOV     ?V0 + 3,A
   \   000109   EA           MOV     A,R2
   \   00010A   70E2         JNZ     ??writeBuf_9
    983              writeWord( dstPg, dstOff, tmp );
   \   00010C                ; Setup parameters for call to function writeWord
   \   00010C   85..82       MOV     DPL,?XSP + 0
   \   00010F   85..83       MOV     DPH,?XSP + 1
   \   000112   AC82         MOV     R4,DPL
   \   000114   AD83         MOV     R5,DPH
   \   000116   AA..         MOV     R2,?V0 + 0
   \   000118   AB..         MOV     R3,?V0 + 1
   \   00011A   A9..         MOV     R1,?V0 + 2
   \   00011C   12....       LCALL   ??writeWord?relay
    984            }
    985          }
   \                     ??writeBuf_7:
   \   00011F   02....       LJMP    ?Subroutine43 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V0 + 6
   \   000004   85..83       MOV     DPH,?V0 + 7
   \   000007   A3           INC     DPTR
   \   000008   8582..       MOV     ?V0 + 6,DPL
   \   00000B   8583..       MOV     ?V0 + 7,DPH
   \   00000E   22           RET
    986          
    987          /*********************************************************************
    988           * @fn      xferBuf
    989           *
    990           * @brief   Xfers an NV buffer from one location to another, enforcing OSAL_NV_WORD_SIZE writes.
    991           *
    992           * @return  none
    993           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    994          static void xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len )
   \                     xferBuf:
    995          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   89..         MOV     ?V0 + 6,R1
   \   000017   8C..         MOV     ?V0 + 1,R4
   \   000019   7415         MOV     A,#0x15
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000021   7417         MOV     A,#0x17
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FE           MOV     R6,A
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   FF           MOV     R7,A
    996            uint8 rem = dstOff % OSAL_NV_WORD_SIZE;
   \   00002B   E5..         MOV     A,?V0 + 2
   \   00002D   5403         ANL     A,#0x3
   \   00002F   F5..         MOV     ?V0 + 0,A
    997            uint8 tmp[OSAL_NV_WORD_SIZE];
    998          
    999            if ( rem )
   \   000031   604D         JZ      ??CrossCallReturnLabel_67
   1000            {
   1001              dstOff -= rem;
   \   000033   F5..         MOV     ?V0 + 4,A
   \   000035   C3           CLR     C
   \   000036   E5..         MOV     A,?V0 + 2
   \   000038   95..         SUBB    A,?V0 + 4
   \   00003A   F5..         MOV     ?V0 + 2,A
   \   00003C   E5..         MOV     A,?V0 + 3
   \   00003E   9400         SUBB    A,#0x0
   \   000040   F5..         MOV     ?V0 + 3,A
   1002              nvReadWord( dstPg, dstOff, tmp );
   \   000042                ; Setup parameters for call to function nvReadWord
   \   000042   7402         MOV     A,#0x2
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   AC82         MOV     R4,DPL
   \   000049   AD83         MOV     R5,DPH
   \   00004B   AA..         MOV     R2,?V0 + 2
   \   00004D   AB..         MOV     R3,?V0 + 3
   \   00004F   A9..         MOV     R1,?V0 + 1
   \   000051   12....       LCALL   nvReadWord & 0xFFFF
   \   000054   8015         SJMP    ??xferBuf_0
   1003          
   1004              while ( (rem < OSAL_NV_WORD_SIZE) && len )
   1005              {
   1006                nvReadByte( srcPg, srcOff, tmp+rem );
   \                     ??xferBuf_1:
   \   000056                ; Setup parameters for call to function nvReadByte
   \   000056   85....       MOV     ?V0 + 4,?V0 + 0
   \   000059   7402         MOV     A,#0x2
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   12....       LCALL   ?Subroutine1 & 0xFFFF
   1007                srcOff++;
   1008                rem++;
   \                     ??CrossCallReturnLabel_4:
   \   000061   05..         INC     ?V0 + 0
   1009                len--;
   \   000063   EE           MOV     A,R6
   \   000064   24FF         ADD     A,#-0x1
   \   000066   1E           DEC     R6
   \   000067   EF           MOV     A,R7
   \   000068   34FF         ADDC    A,#-0x1
   \   00006A   FF           MOV     R7,A
   1010              }
   \                     ??xferBuf_0:
   \   00006B   E5..         MOV     A,?V0 + 0
   \   00006D   C3           CLR     C
   \   00006E   9404         SUBB    A,#0x4
   \   000070   5006         JNC     ??xferBuf_2
   \   000072   EE           MOV     A,R6
   \   000073   7001         JNZ     ??xferBuf_3
   \   000075   EF           MOV     A,R7
   \                     ??xferBuf_3:
   \   000076   70DE         JNZ     ??xferBuf_1
   1011          
   1012              writeWord( dstPg, dstOff, tmp );
   \                     ??xferBuf_2:
   \   000078                ; Setup parameters for call to function writeWord
   \   000078   7402         MOV     A,#0x2
   \   00007A   12....       LCALL   ?XSTACK_DISP0_8
   \   00007D   12....       LCALL   ?Subroutine21 & 0xFFFF
   1013              dstOff += OSAL_NV_WORD_SIZE;
   1014            }
   1015          
   1016            rem = len % OSAL_NV_WORD_SIZE;
   \                     ??CrossCallReturnLabel_67:
   \   000080   EE           MOV     A,R6
   \   000081   5403         ANL     A,#0x3
   \   000083   F5..         MOV     ?V0 + 0,A
   1017            len /= OSAL_NV_WORD_SIZE;
   \   000085   8E..         MOV     ?V0 + 4,R6
   \   000087   8F..         MOV     ?V0 + 5,R7
   \   000089   7402         MOV     A,#0x2
   \   00008B   78..         MOV     R0,#?V0 + 4
   \   00008D   12....       LCALL   ?US_SHR
   \   000090   AE..         MOV     R6,?V0 + 4
   \   000092   AF..         MOV     R7,?V0 + 5
   \   000094   802B         SJMP    ??CrossCallReturnLabel_68
   1018          
   1019            while ( len-- )
   1020            {
   1021              nvReadWord( srcPg, srcOff, tmp );
   \                     ??xferBuf_4:
   \   000096                ; Setup parameters for call to function nvReadWord
   \   000096   7402         MOV     A,#0x2
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   AC82         MOV     R4,DPL
   \   00009D   AD83         MOV     R5,DPH
   \   00009F   85..82       MOV     DPL,?XSP + 0
   \   0000A2   85..83       MOV     DPH,?XSP + 1
   \   0000A5   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   0000A8   A9..         MOV     R1,?V0 + 6
   \   0000AA   12....       LCALL   nvReadWord & 0xFFFF
   1022              srcOff += OSAL_NV_WORD_SIZE;
   \   0000AD   85..82       MOV     DPL,?XSP + 0
   \   0000B0   85..83       MOV     DPH,?XSP + 1
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   2404         ADD     A,#0x4
   \   0000B6   12....       LCALL   ?Subroutine33 & 0xFFFF
   1023              writeWord( dstPg, dstOff, tmp );
   \                     ??CrossCallReturnLabel_98:
   \   0000B9                ; Setup parameters for call to function writeWord
   \   0000B9   7402         MOV     A,#0x2
   \   0000BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BE   12....       LCALL   ?Subroutine21 & 0xFFFF
   1024              dstOff += OSAL_NV_WORD_SIZE;
   1025            }
   \                     ??CrossCallReturnLabel_68:
   \   0000C1   EE           MOV     A,R6
   \   0000C2   F8           MOV     R0,A
   \   0000C3   EF           MOV     A,R7
   \   0000C4   F9           MOV     R1,A
   \   0000C5   74FF         MOV     A,#-0x1
   \   0000C7   28           ADD     A,R0
   \   0000C8   1E           DEC     R6
   \   0000C9   74FF         MOV     A,#-0x1
   \   0000CB   39           ADDC    A,R1
   \   0000CC   FF           MOV     R7,A
   \   0000CD   E8           MOV     A,R0
   \   0000CE   7001         JNZ     ??xferBuf_5
   \   0000D0   E9           MOV     A,R1
   \                     ??xferBuf_5:
   \   0000D1   70C3         JNZ     ??xferBuf_4
   1026          
   1027            if ( rem )
   \   0000D3   E5..         MOV     A,?V0 + 0
   \   0000D5   603D         JZ      ??xferBuf_6
   1028            {
   1029              uint8 idx = 0;
   \   0000D7   7E00         MOV     R6,#0x0
   1030              nvReadWord( dstPg, dstOff, tmp );
   \   0000D9                ; Setup parameters for call to function nvReadWord
   \   0000D9   7402         MOV     A,#0x2
   \   0000DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DE   AC82         MOV     R4,DPL
   \   0000E0   AD83         MOV     R5,DPH
   \   0000E2   AA..         MOV     R2,?V0 + 2
   \   0000E4   AB..         MOV     R3,?V0 + 3
   \   0000E6   A9..         MOV     R1,?V0 + 1
   \   0000E8   12....       LCALL   nvReadWord & 0xFFFF
   \   0000EB   800B         SJMP    ??xferBuf_7
   1031              while ( rem-- )
   1032              {
   1033                nvReadByte( srcPg, srcOff, tmp+idx );
   \                     ??xferBuf_8:
   \   0000ED                ; Setup parameters for call to function nvReadByte
   \   0000ED   8E..         MOV     ?V0 + 4,R6
   \   0000EF   7402         MOV     A,#0x2
   \   0000F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F4   12....       LCALL   ?Subroutine1 & 0xFFFF
   1034                srcOff++;
   1035                idx++;
   \                     ??CrossCallReturnLabel_5:
   \   0000F7   0E           INC     R6
   1036              }
   \                     ??xferBuf_7:
   \   0000F8   AA..         MOV     R2,?V0 + 0
   \   0000FA   74FF         MOV     A,#-0x1
   \   0000FC   2A           ADD     A,R2
   \   0000FD   F5..         MOV     ?V0 + 0,A
   \   0000FF   EA           MOV     A,R2
   \   000100   70EB         JNZ     ??xferBuf_8
   1037              writeWord( dstPg, dstOff, tmp );
   \   000102                ; Setup parameters for call to function writeWord
   \   000102   7402         MOV     A,#0x2
   \   000104   12....       LCALL   ?XSTACK_DISP0_8
   \   000107   AC82         MOV     R4,DPL
   \   000109   AD83         MOV     R5,DPH
   \   00010B   AA..         MOV     R2,?V0 + 2
   \   00010D   AB..         MOV     R3,?V0 + 3
   \   00010F   A9..         MOV     R1,?V0 + 1
   \   000111   12....       LCALL   ??writeWord?relay
   1038            }
   1039          }
   \                     ??xferBuf_6:
   \   000114   7406         MOV     A,#0x6
   \   000116                REQUIRE ?Subroutine42
   \   000116                ; // Fall through to label ?Subroutine42

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F07         MOV     R7,#0x7
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   AA..         MOV     R2,?V0 + 2
   \   000006   AB..         MOV     R3,?V0 + 3
   \   000008   A9..         MOV     R1,?V0 + 1
   \   00000A   12....       LCALL   ??writeWord?relay
   \   00000D   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E582         MOV     A,DPL
   \   000002   25..         ADD     A,?V0 + 4
   \   000004   FC           MOV     R4,A
   \   000005   E583         MOV     A,DPH
   \   000007   3400         ADDC    A,#0x0
   \   000009   FD           MOV     R5,A
   \   00000A   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   00000D   A9..         MOV     R1,?V0 + 6
   \   00000F   12....       LCALL   nvReadByte & 0xFFFF
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   E0           MOVX    A,@DPTR
   \   000019   2401         ADD     A,#0x1
   \   00001B   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   00001E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 3,A
   \   000007   22           RET
   1040          
   1041          /*********************************************************************
   1042           * @fn      writeItem
   1043           *
   1044           * @brief   Writes an item header/data combo to the specified NV page.
   1045           *
   1046           * @param   pg - Valid NV Flash page.
   1047           * @param   id - Valid NV item Id.
   1048           * @param   len  - Byte count of the data to write.
   1049           * @param   buf  - The data to write. If NULL, no data/checksum write.
   1050           * @param   flag - TRUE if the checksum should be written, FALSE otherwise.
   1051           *
   1052           * @return  TRUE if header/data to write matches header/data read back, else FALSE.
   1053           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1054          static uint8 writeItem( uint8 pg, uint16 id, uint16 len, void *buf, uint8 flag )
   \                     writeItem:
   1055          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   8A..         MOV     ?V0 + 6,R2
   \   00000E   8B..         MOV     ?V0 + 7,R3
   \   000010   8C..         MOV     ?V0 + 4,R4
   \   000012   8D..         MOV     ?V0 + 5,R5
   \   000014   741C         MOV     A,#0x1c
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F5..         MOV     ?V0 + 2,A
   1056            uint16 offset = pgOff[pg-OSAL_NV_PAGE_BEG];
   \   00001C   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   00001F   12....       LCALL   ?Subroutine6 & 0xFFFF
   1057            uint8 rtrn = FALSE;
   \                     ??CrossCallReturnLabel_22:
   \   000022   7F00         MOV     R7,#0x0
   1058            osalNvHdr_t hdr;
   1059          
   1060            if ( pg == pgRes )
   \   000024   90....       MOV     DPTR,#pgRes
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6E           XRL     A,R6
   \   000029   7007         JNZ     ??writeItem_0
   1061            {
   1062              /* Mark reserve page as being active, in process of receiving items.
   1063               * Invoking function must effect a page compaction.
   1064               */
   1065              setPageUse( pg, FALSE );
   \   00002B                ; Setup parameters for call to function setPageUse
   \   00002B   7A00         MOV     R2,#0x0
   \   00002D   EE           MOV     A,R6
   \   00002E   F9           MOV     R1,A
   \   00002F   12....       LCALL   ??setPageUse?relay
   1066            }
   1067          
   1068            hdr.id = id;
   \                     ??writeItem_0:
   \   000032   7402         MOV     A,#0x2
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   E5..         MOV     A,?V0 + 6
   \   000039   F0           MOVX    @DPTR,A
   \   00003A   A3           INC     DPTR
   \   00003B   E5..         MOV     A,?V0 + 7
   \   00003D   F0           MOVX    @DPTR,A
   1069            hdr.len = len;
   \   00003E   7404         MOV     A,#0x4
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   E5..         MOV     A,?V0 + 4
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
   \   000047   E5..         MOV     A,?V0 + 5
   \   000049   F0           MOVX    @DPTR,A
   1070          
   1071            writeWord( pg, offset, (uint8 *)&hdr );
   \   00004A                ; Setup parameters for call to function writeWord
   \   00004A   7402         MOV     A,#0x2
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   AC82         MOV     R4,DPL
   \   000051   AD83         MOV     R5,DPH
   \   000053   AA..         MOV     R2,?V0 + 0
   \   000055   AB..         MOV     R3,?V0 + 1
   \   000057   EE           MOV     A,R6
   \   000058   F9           MOV     R1,A
   \   000059   12....       LCALL   ??writeWord?relay
   1072            nvReadHdr( pg, offset, (uint8 *)(&hdr) );
   \   00005C                ; Setup parameters for call to function nvReadHdr
   \   00005C   7402         MOV     A,#0x2
   \   00005E   12....       LCALL   ?XSTACK_DISP0_8
   \   000061   AC82         MOV     R4,DPL
   \   000063   AD83         MOV     R5,DPH
   \   000065   AA..         MOV     R2,?V0 + 0
   \   000067   AB..         MOV     R3,?V0 + 1
   \   000069   EE           MOV     A,R6
   \   00006A   F9           MOV     R1,A
   \   00006B   12....       LCALL   nvReadHdr & 0xFFFF
   1073          
   1074            if ( (hdr.id == id) && (hdr.len == len) )
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   65..         XRL     A,?V0 + 6
   \   000071   7004         JNZ     ??writeItem_1
   \   000073   A3           INC     DPTR
   \   000074   E0           MOVX    A,@DPTR
   \   000075   65..         XRL     A,?V0 + 7
   \                     ??writeItem_1:
   \   000077   6003         JZ      $+5
   \   000079   02....       LJMP    ??writeItem_2 & 0xFFFF
   \   00007C   7404         MOV     A,#0x4
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   E0           MOVX    A,@DPTR
   \   000082   65..         XRL     A,?V0 + 4
   \   000084   7004         JNZ     ??writeItem_3
   \   000086   A3           INC     DPTR
   \   000087   E0           MOVX    A,@DPTR
   \   000088   65..         XRL     A,?V0 + 5
   \                     ??writeItem_3:
   \   00008A   6003         JZ      $+5
   \   00008C   02....       LJMP    ??writeItem_2 & 0xFFFF
   1075            {
   1076              if ( flag )
   \   00008F   E5..         MOV     A,?V0 + 2
   \   000091   7003         JNZ     $+5
   \   000093   02....       LJMP    ??writeItem_4 & 0xFFFF
   1077              {
   1078                uint16 chk = calcChkB( len, buf );
   \   000096   741A         MOV     A,#0x1a
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   00009E   8882         MOV     DPL,R0
   \   0000A0   8983         MOV     DPH,R1
   \   0000A2   A8..         MOV     R0,?V0 + 4
   \   0000A4   A9..         MOV     R1,?V0 + 5
   \   0000A6   E8           MOV     A,R0
   \   0000A7   5403         ANL     A,#0x3
   \   0000A9   F5..         MOV     ?V0 + 2,A
   \   0000AB   E582         MOV     A,DPL
   \   0000AD   7002         JNZ     ??writeItem_5
   \   0000AF   E583         MOV     A,DPH
   \                     ??writeItem_5:
   \   0000B1   7015         JNZ     ??writeItem_6
   \   0000B3   E8           MOV     A,R0
   \   0000B4   75F0FF       MOV     B,#-0x1
   \   0000B7   A4           MUL     AB
   \   0000B8   F8           MOV     R0,A
   \   0000B9   AAF0         MOV     R2,B
   \   0000BB   75F0FF       MOV     B,#-0x1
   \   0000BE   E9           MOV     A,R1
   \   0000BF   A4           MUL     AB
   \   0000C0   2A           ADD     A,R2
   \   0000C1   F9           MOV     R1,A
   \   0000C2   E8           MOV     A,R0
   \   0000C3   FA           MOV     R2,A
   \   0000C4   E9           MOV     A,R1
   \   0000C5   FB           MOV     R3,A
   \   0000C6   8022         SJMP    ??writeItem_7
   \                     ??writeItem_6:
   \   0000C8   7A00         MOV     R2,#0x0
   \   0000CA   7B00         MOV     R3,#0x0
   \   0000CC   800A         SJMP    ??writeItem_8
   \                     ??writeItem_9:
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   FC           MOV     R4,A
   \   0000D0   EA           MOV     A,R2
   \   0000D1   2C           ADD     A,R4
   \   0000D2   FA           MOV     R2,A
   \   0000D3   EB           MOV     A,R3
   \   0000D4   3400         ADDC    A,#0x0
   \   0000D6   FB           MOV     R3,A
   \   0000D7   A3           INC     DPTR
   \                     ??writeItem_8:
   \   0000D8   E8           MOV     A,R0
   \   0000D9   FC           MOV     R4,A
   \   0000DA   E9           MOV     A,R1
   \   0000DB   FD           MOV     R5,A
   \   0000DC   74FF         MOV     A,#-0x1
   \   0000DE   2C           ADD     A,R4
   \   0000DF   18           DEC     R0
   \   0000E0   74FF         MOV     A,#-0x1
   \   0000E2   3D           ADDC    A,R5
   \   0000E3   F9           MOV     R1,A
   \   0000E4   EC           MOV     A,R4
   \   0000E5   7001         JNZ     ??writeItem_10
   \   0000E7   ED           MOV     A,R5
   \                     ??writeItem_10:
   \   0000E8   70E4         JNZ     ??writeItem_9
   \                     ??writeItem_7:
   \   0000EA   E5..         MOV     A,?V0 + 2
   \   0000EC   601F         JZ      ??writeItem_11
   \   0000EE   7404         MOV     A,#0x4
   \   0000F0   C3           CLR     C
   \   0000F1   95..         SUBB    A,?V0 + 2
   \   0000F3   F8           MOV     R0,A
   \   0000F4   E4           CLR     A
   \   0000F5   9400         SUBB    A,#0x0
   \   0000F7   F9           MOV     R1,A
   \   0000F8   E8           MOV     A,R0
   \   0000F9   75F0FF       MOV     B,#-0x1
   \   0000FC   A4           MUL     AB
   \   0000FD   F8           MOV     R0,A
   \   0000FE   ACF0         MOV     R4,B
   \   000100   75F0FF       MOV     B,#-0x1
   \   000103   E9           MOV     A,R1
   \   000104   A4           MUL     AB
   \   000105   2C           ADD     A,R4
   \   000106   F9           MOV     R1,A
   \   000107   EA           MOV     A,R2
   \   000108   28           ADD     A,R0
   \   000109   FA           MOV     R2,A
   \   00010A   EB           MOV     A,R3
   \   00010B   39           ADDC    A,R1
   \   00010C   FB           MOV     R3,A
   \                     ??writeItem_11:
   \   00010D   85..82       MOV     DPL,?XSP + 0
   \   000110   85..83       MOV     DPH,?XSP + 1
   \   000113   EA           MOV     A,R2
   \   000114   F0           MOVX    @DPTR,A
   \   000115   A3           INC     DPTR
   \   000116   EB           MOV     A,R3
   \   000117   F0           MOVX    @DPTR,A
   1079            
   1080                offset += OSAL_NV_HDR_SIZE;
   \   000118   12....       LCALL   ?Subroutine23 & 0xFFFF
   1081                if ( buf != NULL )
   \                     ??CrossCallReturnLabel_72:
   \   00011B   741A         MOV     A,#0x1a
   \   00011D   12....       LCALL   ?XSTACK_DISP0_8
   \   000120   E0           MOVX    A,@DPTR
   \   000121   7002         JNZ     ??writeItem_12
   \   000123   A3           INC     DPTR
   \   000124   E0           MOVX    A,@DPTR
   \                     ??writeItem_12:
   \   000125   601A         JZ      ??writeItem_13
   1082                {
   1083                  writeBuf( pg, offset, len, buf );
   \   000127                ; Setup parameters for call to function writeBuf
   \   000127   741A         MOV     A,#0x1a
   \   000129   12....       LCALL   ?XSTACK_DISP0_8
   \   00012C   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00012F   AC..         MOV     R4,?V0 + 4
   \   000131   AD..         MOV     R5,?V0 + 5
   \   000133   AA..         MOV     R2,?V0 + 0
   \   000135   AB..         MOV     R3,?V0 + 1
   \   000137   EE           MOV     A,R6
   \   000138   F9           MOV     R1,A
   \   000139   12....       LCALL   ??writeBuf?relay
   \   00013C   7402         MOV     A,#0x2
   \   00013E   12....       LCALL   ?DEALLOC_XSTACK8
   1084                }
   1085            
   1086                if ( chk == calcChkF( pg, offset, len ) )
   \                     ??writeItem_13:
   \   000141                ; Setup parameters for call to function calcChkF
   \   000141   AC..         MOV     R4,?V0 + 4
   \   000143   AD..         MOV     R5,?V0 + 5
   \   000145   AA..         MOV     R2,?V0 + 0
   \   000147   AB..         MOV     R3,?V0 + 1
   \   000149   EE           MOV     A,R6
   \   00014A   F9           MOV     R1,A
   \   00014B   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   00014E   85..82       MOV     DPL,?XSP + 0
   \   000151   85..83       MOV     DPH,?XSP + 1
   \   000154   E0           MOVX    A,@DPTR
   \   000155   68           XRL     A,R0
   \   000156   7003         JNZ     ??writeItem_14
   \   000158   A3           INC     DPTR
   \   000159   E0           MOVX    A,@DPTR
   \   00015A   69           XRL     A,R1
   \                     ??writeItem_14:
   \   00015B   703C         JNZ     ??writeItem_2
   1087                {
   1088                  writeWordH( pg, (offset-OSAL_NV_WORD_SIZE), (uint8 *)&chk );
   \   00015D                ; Setup parameters for call to function writeWordH
   \   00015D   85..82       MOV     DPL,?XSP + 0
   \   000160   85..83       MOV     DPH,?XSP + 1
   \   000163   AC82         MOV     R4,DPL
   \   000165   AD83         MOV     R5,DPH
   \   000167   74FC         MOV     A,#-0x4
   \   000169   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   00016C   12....       LCALL   ??writeWordH?relay
   1089                  nvReadHdr( pg, (offset-OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
   \   00016F                ; Setup parameters for call to function nvReadHdr
   \   00016F   7402         MOV     A,#0x2
   \   000171   12....       LCALL   ?XSTACK_DISP0_8
   \   000174   AC82         MOV     R4,DPL
   \   000176   AD83         MOV     R5,DPH
   \   000178   74F8         MOV     A,#-0x8
   \   00017A   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   00017D   12....       LCALL   nvReadHdr & 0xFFFF
   1090            
   1091                  if ( chk == hdr.chk )
   \   000180   85..82       MOV     DPL,?XSP + 0
   \   000183   85..83       MOV     DPH,?XSP + 1
   \   000186   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000189   7406         MOV     A,#0x6
   \   00018B   12....       LCALL   ?XSTACK_DISP0_8
   \   00018E   E0           MOVX    A,@DPTR
   \   00018F   68           XRL     A,R0
   \   000190   7003         JNZ     ??writeItem_15
   \   000192   A3           INC     DPTR
   \   000193   E0           MOVX    A,@DPTR
   \   000194   69           XRL     A,R1
   \                     ??writeItem_15:
   \   000195   7002         JNZ     ??writeItem_2
   1092                  {
   1093                    rtrn = pg;
   \                     ??writeItem_4:
   \   000197   EE           MOV     A,R6
   \   000198   FF           MOV     R7,A
   1094                  }
   1095                }
   1096              }
   1097              else
   1098              {
   1099                rtrn = pg;
   1100              }
   1101            }
   1102          
   1103            len = OSAL_NV_ITEM_SIZE( hdr.len );
   1104            pgOff[pg-OSAL_NV_PAGE_BEG] += len;
   \                     ??writeItem_2:
   \   000199   7404         MOV     A,#0x4
   \   00019B   12....       LCALL   ?XSTACK_DISP0_8
   \   00019E   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0001A1   FA           MOV     R2,A
   \   0001A2   E4           CLR     A
   \   0001A3   39           ADDC    A,R1
   \   0001A4   FB           MOV     R3,A
   \   0001A5   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   0001A8   E0           MOVX    A,@DPTR
   \   0001A9   2A           ADD     A,R2
   \   0001AA   F0           MOVX    @DPTR,A
   \   0001AB   A3           INC     DPTR
   \   0001AC   E0           MOVX    A,@DPTR
   \   0001AD   3B           ADDC    A,R3
   \   0001AE   F0           MOVX    @DPTR,A
   1105          
   1106            return rtrn;
   \   0001AF   EF           MOV     A,R7
   \   0001B0   F9           MOV     R1,A
   \   0001B1   02....       LJMP    ?Subroutine38 & 0xFFFF
   1107          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   25..         ADD     A,?V0 + 0
   \   000002   FA           MOV     R2,A
   \   000003   74FF         MOV     A,#-0x1
   \   000005   35..         ADDC    A,?V0 + 1
   \   000007   FB           MOV     R3,A
   \   000008   EE           MOV     A,R6
   \   000009   F9           MOV     R1,A
   \   00000A   22           RET
   1108          
   1109          /*********************************************************************
   1110           * @fn      writeIEEE
   1111           *
   1112           * @brief   Writes special location / protocol for the IEEE. The global 'failF' should have been
   1113           *          cleared before invoking.
   1114           *
   1115           * @param   buf  - The data to write.
   1116           *
   1117           * @return  TRUE if header/data to write matches header/data read back, else FALSE.
   1118           */
   1119          static uint8 writeIEEE( void *buf )
   1120          {
   1121            osalNvHdr_t hdr;
   1122            nvReadHdr( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&hdr) );
   1123          
   1124            if ( (hdr.id == OSAL_NV_ERASED_ID) && (hdr.len == OSAL_NV_ERASED_ID) &&
   1125                 (hdr.chk == OSAL_NV_ERASED_ID) && (hdr.stat == OSAL_NV_ERASED_ID) )
   1126            {
   1127              writeWordM( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, buf, 2 );
   1128              return ((failF) ? NV_OPER_FAILED : ZSUCCESS);
   1129            }
   1130            else
   1131            {
   1132              return NV_OPER_FAILED;
   1133            }
   1134          }
   1135          
   1136          /*********************************************************************
   1137           * @fn      osal_nv_init
   1138           *
   1139           * @brief   Initialize NV service.
   1140           *
   1141           * @param   p - Not used.
   1142           *
   1143           * @return  none
   1144           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1145          void osal_nv_init( void *p )
   \                     osal_nv_init:
   1146          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1147            (void)p;  // Suppress Lint warning.
   1148          
   1149            // Set Flash write timing based on CPU speed.
   1150          #ifdef CPU16MHZ
   1151            FWT = 0x15;
   1152          #else
   1153            FWT = 0x2A;
   \   000004   75AB2A       MOV     0xab,#0x2a
   1154          #endif
   1155          
   1156            (void)initNV();  // Always returns TRUE after pages have been erased.
   \   000007                ; Setup parameters for call to function initNV
   \   000007   12....       LCALL   ??initNV?relay
   1157          }
   \   00000A   02....       LJMP    ?Subroutine37 & 0xFFFF
   \   00000D                REQUIRE FWT
   1158          
   1159          /*********************************************************************
   1160           * @fn      osal_nv_item_init
   1161           *
   1162           * @brief   If the NV item does not already exist, it is created and
   1163           *          initialized with the data passed to the function, if any.
   1164           *          This function must be called before calling osal_nv_read() or
   1165           *          osal_nv_write().
   1166           *
   1167           * @param   id  - Valid NV item Id.
   1168           * @param   len - Item length.
   1169           * @param  *buf - Pointer to item initalization data. Set to NULL if none.
   1170           *
   1171           * @return  NV_ITEM_UNINIT - Id did not exist and was created successfully.
   1172           *          ZSUCCESS       - Id already existed, no action taken.
   1173           *          NV_OPER_FAILED - Failure to find or create Id.
   1174           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1175          uint8 osal_nv_item_init( uint16 id, uint16 len, void *buf )
   \                     osal_nv_item_init:
   1176          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   \   00000D   740E         MOV     A,#0xe
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   12....       LCALL   ?Subroutine7 & 0xFFFF
   1177            /* Global fail flag for fail due to low bus voltage has less impact on code
   1178             * size than passing back a return value all the way from the lowest level.
   1179             */
   1180            failF = FALSE;
   \                     ??CrossCallReturnLabel_26:
   \   000015   E4           CLR     A
   \   000016   90....       MOV     DPTR,#failF
   \   000019   F0           MOVX    @DPTR,A
   1181          
   1182            // ZCD_NV_EXTADDR is maintained without an osalNvHdr_t, so it is always already initialized.
   1183            if ( (id == ZCD_NV_EXTADDR) || (findItem( id ) != OSAL_NV_ITEM_NULL) )
   \   00001A   7401         MOV     A,#0x1
   \   00001C   6E           XRL     A,R6
   \   00001D   7001         JNZ     ??osal_nv_item_init_0
   \   00001F   EF           MOV     A,R7
   \                     ??osal_nv_item_init_0:
   \   000020   6009         JZ      ??osal_nv_item_init_1
   \   000022                ; Setup parameters for call to function findItem
   \   000022   12....       LCALL   ??findItem?relay
   \   000025   EA           MOV     A,R2
   \   000026   7001         JNZ     ??osal_nv_item_init_2
   \   000028   EB           MOV     A,R3
   \                     ??osal_nv_item_init_2:
   \   000029   6004         JZ      ??osal_nv_item_init_3
   1184            {
   1185              return ZSUCCESS;
   \                     ??osal_nv_item_init_1:
   \   00002B   7900         MOV     R1,#0x0
   \   00002D   8025         SJMP    ??osal_nv_item_init_4
   1186            }
   1187            else if ( initItem( TRUE, id, len, buf ) )
   \                     ??osal_nv_item_init_3:
   \   00002F                ; Setup parameters for call to function initItem
   \   00002F   78..         MOV     R0,#?V0 + 2
   \   000031   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000034   AC..         MOV     R4,?V0 + 0
   \   000036   AD..         MOV     R5,?V0 + 1
   \   000038   EE           MOV     A,R6
   \   000039   FA           MOV     R2,A
   \   00003A   EF           MOV     A,R7
   \   00003B   FB           MOV     R3,A
   \   00003C   7901         MOV     R1,#0x1
   \   00003E   12....       LCALL   ??initItem?relay
   \   000041   7402         MOV     A,#0x2
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   \   000046   E9           MOV     A,R1
   \   000047   6009         JZ      ??osal_nv_item_init_5
   1188            {
   1189              if ( failF )
   \   000049   90....       MOV     DPTR,#failF
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   6008         JZ      ??osal_nv_item_init_6
   1190              {
   1191                (void)initNV();  // See comment at the declaration of failF.
   \   00004F                ; Setup parameters for call to function initNV
   \   00004F   12....       LCALL   ??initNV?relay
   1192                return NV_OPER_FAILED;
   1193              }
   1194              else
   1195              {
   1196                return NV_ITEM_UNINIT;
   1197              }
   1198            }
   1199            else
   1200            {
   1201              return NV_OPER_FAILED;
   \                     ??osal_nv_item_init_5:
   \   000052   7910         MOV     R1,#0x10
   \                     ??osal_nv_item_init_4:
   \   000054   02....       LJMP    ?Subroutine40 & 0xFFFF
   1202            }
   \                     ??osal_nv_item_init_6:
   \   000057   790F         MOV     R1,#0xf
   \   000059   80F9         SJMP    ??osal_nv_item_init_4
   1203          }
   1204          
   1205          /*********************************************************************
   1206           * @fn      osal_nv_item_len
   1207           *
   1208           * @brief   Get the data length of the item stored in NV memory.
   1209           *
   1210           * @param   id  - Valid NV item Id.
   1211           *
   1212           * @return  Item length, if found; zero otherwise.
   1213           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1214          uint16 osal_nv_item_len( uint16 id )
   \                     osal_nv_item_len:
   1215          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1216            if ( id == ZCD_NV_EXTADDR )
   \   00000A   7401         MOV     A,#0x1
   \   00000C   6A           XRL     A,R2
   \   00000D   7001         JNZ     ??osal_nv_item_len_0
   \   00000F   EB           MOV     A,R3
   \                     ??osal_nv_item_len_0:
   \   000010   7006         JNZ     ??osal_nv_item_len_1
   1217            {
   1218              return Z_EXTADDR_LEN;
   \   000012   7A08         MOV     R2,#0x8
   \                     ??osal_nv_item_len_2:
   \   000014   7B00         MOV     R3,#0x0
   \   000016   802E         SJMP    ??CrossCallReturnLabel_39
   1219            }
   1220            else
   1221            {
   1222              uint16 offset = findItem( id );
   \                     ??osal_nv_item_len_1:
   \   000018                ; Setup parameters for call to function findItem
   \   000018   12....       LCALL   ?Subroutine27 & 0xFFFF
   1223          
   1224              if ( offset == OSAL_NV_ITEM_NULL )
   \                     ??CrossCallReturnLabel_82:
   \   00001B   7001         JNZ     ??osal_nv_item_len_3
   \   00001D   E9           MOV     A,R1
   \                     ??osal_nv_item_len_3:
   \   00001E   7004         JNZ     ??osal_nv_item_len_4
   1225              {
   1226                return 0;
   \   000020   7A00         MOV     R2,#0x0
   \   000022   80F0         SJMP    ??osal_nv_item_len_2
   1227              }
   1228              else
   1229              {
   1230                osalNvHdr_t hdr;
   1231                nvReadHdr( findPg, (offset - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
   \                     ??osal_nv_item_len_4:
   \   000024                ; Setup parameters for call to function nvReadHdr
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   AC82         MOV     R4,DPL
   \   00002C   AD83         MOV     R5,DPH
   \   00002E   74F8         MOV     A,#-0x8
   \   000030   28           ADD     A,R0
   \   000031   FA           MOV     R2,A
   \   000032   74FF         MOV     A,#-0x1
   \   000034   39           ADDC    A,R1
   \   000035   FB           MOV     R3,A
   \   000036   90....       MOV     DPTR,#findPg
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F9           MOV     R1,A
   \   00003B   12....       LCALL   nvReadHdr & 0xFFFF
   1232                return hdr.len;
   \   00003E   7402         MOV     A,#0x2
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000046   7408         MOV     A,#0x8
   \   000048   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004B   7F02         MOV     R7,#0x2
   \   00004D   02....       LJMP    ?BANKED_LEAVE_XDATA
   1233              }
   1234            }
   1235          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ??findItem?relay
   \   000003   8A..         MOV     ?V0 + 0,R2
   \   000005   8B..         MOV     ?V0 + 1,R3
   \   000007   A8..         MOV     R0,?V0 + 0
   \   000009   A9..         MOV     R1,?V0 + 1
   \   00000B   E8           MOV     A,R0
   \   00000C   22           RET
   1236          
   1237          /*********************************************************************
   1238           * @fn      osal_nv_write
   1239           *
   1240           * @brief   Write a data item to NV. Function can write an entire item to NV or
   1241           *          an element of an item by indexing into the item with an offset.
   1242           *
   1243           * @param   id  - Valid NV item Id.
   1244           * @param   ndx - Index offset into item
   1245           * @param   len - Length of data to write.
   1246           * @param  *buf - Data to write.
   1247           *
   1248           * @return  ZSUCCESS if successful, NV_ITEM_UNINIT if item did not
   1249           *          exist in NV and offset is non-zero, NV_OPER_FAILED if failure.
   1250           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1251          uint8 osal_nv_write( uint16 id, uint16 ndx, uint16 len, void *buf )
   \                     osal_nv_write:
   1252          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 15
   \   000005   74F1         MOV     A,#-0xf
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7401         MOV     A,#0x1
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   8C..         MOV     ?V0 + 4,R4
   \   000016   8D..         MOV     ?V0 + 5,R5
   1253            uint8 rtrn = ZSUCCESS;
   \   000018   75..00       MOV     ?V0 + 6,#0x0
   1254          
   1255            /* Global fail flag for fail due to low bus voltage has less impact on code
   1256             * size than passing back a return value all the way from the lowest level.
   1257             */
   1258            failF = FALSE;
   \   00001B   E4           CLR     A
   \   00001C   90....       MOV     DPTR,#failF
   \   00001F   F0           MOVX    @DPTR,A
   1259          
   1260            if ( id == ZCD_NV_EXTADDR )
   \   000020   7401         MOV     A,#0x1
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   E0           MOVX    A,@DPTR
   \   000026   6401         XRL     A,#0x1
   \   000028   7002         JNZ     ??osal_nv_write_0
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \                     ??osal_nv_write_0:
   \   00002C   7071         JNZ     ??osal_nv_write_1
   1261            {
   1262              return writeIEEE( buf );
   \   00002E                ; Setup parameters for call to function nvReadHdr
   \   00002E   7407         MOV     A,#0x7
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000036   7004         JNZ     ??osal_nv_write_2
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   64FF         XRL     A,#0xff
   \                     ??osal_nv_write_2:
   \   00003C   705C         JNZ     ??osal_nv_write_3
   \   00003E   7409         MOV     A,#0x9
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   E0           MOVX    A,@DPTR
   \   000044   64FF         XRL     A,#0xff
   \   000046   7004         JNZ     ??osal_nv_write_4
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   64FF         XRL     A,#0xff
   \                     ??osal_nv_write_4:
   \   00004C   704C         JNZ     ??osal_nv_write_3
   \   00004E   740B         MOV     A,#0xb
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   E0           MOVX    A,@DPTR
   \   000054   64FF         XRL     A,#0xff
   \   000056   7004         JNZ     ??osal_nv_write_5
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   64FF         XRL     A,#0xff
   \                     ??osal_nv_write_5:
   \   00005C   703C         JNZ     ??osal_nv_write_3
   \   00005E   740D         MOV     A,#0xd
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   E0           MOVX    A,@DPTR
   \   000064   64FF         XRL     A,#0xff
   \   000066   7004         JNZ     ??osal_nv_write_6
   \   000068   A3           INC     DPTR
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   64FF         XRL     A,#0xff
   \                     ??osal_nv_write_6:
   \   00006C   702C         JNZ     ??osal_nv_write_3
   \   00006E                ; Setup parameters for call to function writeWordM
   \   00006E   75..02       MOV     ?V0 + 0,#0x2
   \   000071   78..         MOV     R0,#?V0 + 0
   \   000073   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000076   7421         MOV     A,#0x21
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   00007E   7AF8         MOV     R2,#-0x8
   \   000080   7B07         MOV     R3,#0x7
   \   000082   793F         MOV     R1,#0x3f
   \   000084   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000087   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008A   90....       MOV     DPTR,#failF
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   6004         JZ      ??osal_nv_write_7
   \   000090   7A10         MOV     R2,#0x10
   \   000092   8002         SJMP    ??osal_nv_write_8
   \                     ??osal_nv_write_7:
   \   000094   7A00         MOV     R2,#0x0
   \                     ??osal_nv_write_8:
   \   000096   EA           MOV     A,R2
   \   000097   F9           MOV     R1,A
   \   000098   8002         SJMP    ??osal_nv_write_9
   \                     ??osal_nv_write_3:
   \   00009A   7910         MOV     R1,#0x10
   \                     ??osal_nv_write_9:
   \   00009C   02....       LJMP    ??osal_nv_write_10 & 0xFFFF
   1263            }
   1264          
   1265            if ( len != 0 )
   \                     ??osal_nv_write_1:
   \   00009F   741E         MOV     A,#0x1e
   \   0000A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   7002         JNZ     ??osal_nv_write_11
   \   0000A7   A3           INC     DPTR
   \   0000A8   E0           MOVX    A,@DPTR
   \                     ??osal_nv_write_11:
   \   0000A9   7003         JNZ     $+5
   \   0000AB   02....       LJMP    ??osal_nv_write_12 & 0xFFFF
   1266            {
   1267              osalNvHdr_t hdr;
   1268              uint16 origOff, srcOff;
   1269              uint16 cnt;
   1270              uint8 *ptr;
   1271          
   1272              origOff = srcOff = findItem( id );
   \   0000AE                ; Setup parameters for call to function findItem
   \   0000AE   7401         MOV     A,#0x1
   \   0000B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B3   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   0000B6   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   0000B9   FE           MOV     R6,A
   \   0000BA   E9           MOV     A,R1
   \   0000BB   FF           MOV     R7,A
   \   0000BC   7405         MOV     A,#0x5
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   E8           MOV     A,R0
   \   0000C2   F0           MOVX    @DPTR,A
   \   0000C3   A3           INC     DPTR
   \   0000C4   E9           MOV     A,R1
   \   0000C5   F0           MOVX    @DPTR,A
   1273              if ( srcOff == OSAL_NV_ITEM_NULL )
   \   0000C6   EE           MOV     A,R6
   \   0000C7   7001         JNZ     ??osal_nv_write_13
   \   0000C9   EF           MOV     A,R7
   \                     ??osal_nv_write_13:
   \   0000CA   7005         JNZ     ??osal_nv_write_14
   1274              {
   1275                return NV_ITEM_UNINIT;
   \   0000CC   790F         MOV     R1,#0xf
   \   0000CE   02....       LJMP    ??osal_nv_write_10 & 0xFFFF
   1276              }
   1277          
   1278              nvReadHdr( findPg, (srcOff - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
   \                     ??osal_nv_write_14:
   \   0000D1                ; Setup parameters for call to function nvReadHdr
   \   0000D1   7407         MOV     A,#0x7
   \   0000D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D6   AC82         MOV     R4,DPL
   \   0000D8   AD83         MOV     R5,DPH
   \   0000DA   74F8         MOV     A,#-0x8
   \   0000DC   2E           ADD     A,R6
   \   0000DD   FA           MOV     R2,A
   \   0000DE   74FF         MOV     A,#-0x1
   \   0000E0   3F           ADDC    A,R7
   \   0000E1   FB           MOV     R3,A
   \   0000E2   90....       MOV     DPTR,#findPg
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   F9           MOV     R1,A
   \   0000E7   12....       LCALL   nvReadHdr & 0xFFFF
   1279              if ( hdr.len < (ndx + len) )
   \   0000EA   7409         MOV     A,#0x9
   \   0000EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EF   C082         PUSH    DPL
   \   0000F1   C083         PUSH    DPH
   \   0000F3   741E         MOV     A,#0x1e
   \   0000F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F8   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   0000FB   D083         POP     DPH
   \   0000FD   D082         POP     DPL
   \   0000FF   C3           CLR     C
   \   000100   E0           MOVX    A,@DPTR
   \   000101   98           SUBB    A,R0
   \   000102   A3           INC     DPTR
   \   000103   E0           MOVX    A,@DPTR
   \   000104   99           SUBB    A,R1
   \   000105   5005         JNC     ??osal_nv_write_15
   1280              {
   1281                return NV_OPER_FAILED;
   \   000107   7910         MOV     R1,#0x10
   \   000109   02....       LJMP    ??osal_nv_write_10 & 0xFFFF
   1282              }
   1283          
   1284              srcOff += ndx;
   \                     ??osal_nv_write_15:
   \   00010C   12....       LCALL   ?Subroutine29 & 0xFFFF
   1285              ptr = buf;
   \                     ??CrossCallReturnLabel_86:
   \   00010F   12....       LCALL   ?XSTACK_DISP0_8
   \   000112   12....       LCALL   ?Subroutine6 & 0xFFFF
   1286              cnt = len;
   \                     ??CrossCallReturnLabel_23:
   \   000115   741E         MOV     A,#0x1e
   \   000117   12....       LCALL   ?XSTACK_DISP0_8
   \   00011A   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   00011D   8017         SJMP    ??osal_nv_write_16
   1287              while ( cnt )
   1288              {
   1289                uint8 tmp;
   1290                nvReadByte( findPg, srcOff++, &tmp );
   1291                if ( tmp != *ptr++ )
   1292                {
   1293                  break;
   1294                }
   1295                cnt--;
   \                     ??osal_nv_write_17:
   \   00011F   E5..         MOV     A,?V0 + 2
   \   000121   24FF         ADD     A,#-0x1
   \   000123   F5..         MOV     ?V0 + 2,A
   \   000125   E5..         MOV     A,?V0 + 3
   \   000127   34FF         ADDC    A,#-0x1
   \   000129   F5..         MOV     ?V0 + 3,A
   \   00012B   E5..         MOV     A,?V0 + 2
   \   00012D   7002         JNZ     ??osal_nv_write_18
   \   00012F   E5..         MOV     A,?V0 + 3
   \                     ??osal_nv_write_18:
   \   000131   7003         JNZ     $+5
   \   000133   02....       LJMP    ??osal_nv_write_19 & 0xFFFF
   \                     ??osal_nv_write_16:
   \   000136                ; Setup parameters for call to function nvReadByte
   \   000136   85..82       MOV     DPL,?XSP + 0
   \   000139   85..83       MOV     DPH,?XSP + 1
   \   00013C   AC82         MOV     R4,DPL
   \   00013E   AD83         MOV     R5,DPH
   \   000140   EE           MOV     A,R6
   \   000141   FA           MOV     R2,A
   \   000142   EF           MOV     A,R7
   \   000143   FB           MOV     R3,A
   \   000144   90....       MOV     DPTR,#findPg
   \   000147   E0           MOVX    A,@DPTR
   \   000148   F9           MOV     R1,A
   \   000149   12....       LCALL   nvReadByte & 0xFFFF
   \   00014C   EE           MOV     A,R6
   \   00014D   2401         ADD     A,#0x1
   \   00014F   0E           INC     R6
   \   000150   EF           MOV     A,R7
   \   000151   3400         ADDC    A,#0x0
   \   000153   FF           MOV     R7,A
   \   000154   A8..         MOV     R0,?V0 + 0
   \   000156   A9..         MOV     R1,?V0 + 1
   \   000158   8882         MOV     DPL,R0
   \   00015A   8983         MOV     DPH,R1
   \   00015C   A3           INC     DPTR
   \   00015D   8582..       MOV     ?V0 + 0,DPL
   \   000160   8583..       MOV     ?V0 + 1,DPH
   \   000163   85..82       MOV     DPL,?XSP + 0
   \   000166   85..83       MOV     DPH,?XSP + 1
   \   000169   E0           MOVX    A,@DPTR
   \   00016A   FA           MOV     R2,A
   \   00016B   8882         MOV     DPL,R0
   \   00016D   8983         MOV     DPH,R1
   \   00016F   E0           MOVX    A,@DPTR
   \   000170   6A           XRL     A,R2
   \   000171   60AC         JZ      ??osal_nv_write_17
   1296              }
   1297          
   1298              if ( cnt != 0 )  // If the buffer to write is different in one or more bytes.
   1299              {
   1300                uint8 comPg, dstPg = initItem( FALSE, id, hdr.len, &comPg );
   \   000173                ; Setup parameters for call to function initItem
   \   000173   85..82       MOV     DPL,?XSP + 0
   \   000176   85..83       MOV     DPH,?XSP + 1
   \   000179   8582..       MOV     ?V0 + 0,DPL
   \   00017C   8583..       MOV     ?V0 + 1,DPH
   \   00017F   78..         MOV     R0,#?V0 + 0
   \   000181   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000184   740B         MOV     A,#0xb
   \   000186   12....       LCALL   ?XSTACK_DISP0_8
   \   000189   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   00018C   7403         MOV     A,#0x3
   \   00018E   12....       LCALL   ?XSTACK_DISP0_8
   \   000191   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000194   7900         MOV     R1,#0x0
   \   000196   12....       LCALL   ??initItem?relay
   \   000199   7402         MOV     A,#0x2
   \   00019B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00019E   E9           MOV     A,R1
   \   00019F   F5..         MOV     ?V0 + 0,A
   1301          
   1302                if ( dstPg != OSAL_NV_PAGE_NULL )
   \   0001A1   7003         JNZ     $+5
   \   0001A3   02....       LJMP    ??osal_nv_write_20 & 0xFFFF
   1303                {
   1304                  uint16 tmp = OSAL_NV_DATA_SIZE( hdr.len );
   \   0001A6   7409         MOV     A,#0x9
   \   0001A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AB   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   0001AE   F8           MOV     R0,A
   \   0001AF   7403         MOV     A,#0x3
   \   0001B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B4   E8           MOV     A,R0
   \   0001B5   F0           MOVX    @DPTR,A
   \   0001B6   A3           INC     DPTR
   \   0001B7   E9           MOV     A,R1
   \   0001B8   F0           MOVX    @DPTR,A
   1305                  uint16 dstOff = pgOff[dstPg-OSAL_NV_PAGE_BEG] - tmp;
   \   0001B9   E5..         MOV     A,?V0 + 0
   \   0001BB   C3           CLR     C
   \   0001BC   33           RLC     A
   \   0001BD   F8           MOV     R0,A
   \   0001BE   E4           CLR     A
   \   0001BF   33           RLC     A
   \   0001C0   F9           MOV     R1,A
   \   0001C1   E8           MOV     A,R0
   \   0001C2   24..         ADD     A,#((pgOff + 136) & 0xff)
   \   0001C4   F8           MOV     R0,A
   \   0001C5   E9           MOV     A,R1
   \   0001C6   34..         ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
   \   0001C8   F9           MOV     R1,A
   \   0001C9   7401         MOV     A,#0x1
   \   0001CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CE   E8           MOV     A,R0
   \   0001CF   F0           MOVX    @DPTR,A
   \   0001D0   A3           INC     DPTR
   \   0001D1   E9           MOV     A,R1
   \   0001D2   F0           MOVX    @DPTR,A
   \   0001D3   7401         MOV     A,#0x1
   \   0001D5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D8   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   0001DB   C082         PUSH    DPL
   \   0001DD   C083         PUSH    DPH
   \   0001DF   7403         MOV     A,#0x3
   \   0001E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E4   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   0001E7   D083         POP     DPH
   \   0001E9   D082         POP     DPL
   \   0001EB   12....       LCALL   ?Subroutine16 & 0xFFFF
   1306                  uint8 srcPg = findPg;
   \                     ??CrossCallReturnLabel_51:
   \   0001EE   90....       MOV     DPTR,#findPg
   \   0001F1   E0           MOVX    A,@DPTR
   \   0001F2   F5..         MOV     ?V0 + 1,A
   1307                  srcOff = origOff;
   1308          
   1309                  setItem( srcPg, srcOff, eNvXfer );
   \   0001F4                ; Setup parameters for call to function setItem
   \   0001F4   7C00         MOV     R4,#0x0
   \   0001F6   7405         MOV     A,#0x5
   \   0001F8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FB   12....       LCALL   ?Subroutine11 & 0xFFFF
   1310          
   1311                  xferBuf( srcPg, srcOff, dstPg, dstOff, ndx );
   \                     ??CrossCallReturnLabel_36:
   \   0001FE                ; Setup parameters for call to function xferBuf
   \   0001FE   78..         MOV     R0,#?V0 + 4
   \   000200   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000203   8E..         MOV     ?V0 + 2,R6
   \   000205   8F..         MOV     ?V0 + 3,R7
   \   000207   78..         MOV     R0,#?V0 + 2
   \   000209   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00020C   AC..         MOV     R4,?V0 + 0
   \   00020E   7409         MOV     A,#0x9
   \   000210   12....       LCALL   ?XSTACK_DISP0_8
   \   000213   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000216   A9..         MOV     R1,?V0 + 1
   \   000218   12....       LCALL   ??xferBuf?relay
   \   00021B   7404         MOV     A,#0x4
   \   00021D   12....       LCALL   ?DEALLOC_XSTACK8
   1312                  srcOff += ndx;
   1313                  dstOff += ndx;
   \   000220   12....       LCALL   ?Subroutine29 & 0xFFFF
   1314          
   1315                  writeBuf( dstPg, dstOff, len, buf );
   \                     ??CrossCallReturnLabel_87:
   \   000223   12....       LCALL   ?XSTACK_DISP0_8
   \   000226   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000229   7420         MOV     A,#0x20
   \   00022B   12....       LCALL   ?XSTACK_DISP0_8
   \   00022E   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000231   12....       LCALL   ??writeBuf?relay
   \   000234   7402         MOV     A,#0x2
   \   000236   12....       LCALL   ?DEALLOC_XSTACK8
   1316                  srcOff += len;
   1317                  dstOff += len;
   1318          
   1319                  xferBuf( srcPg, srcOff, dstPg, dstOff, (hdr.len-ndx-len) );
   \   000239                ; Setup parameters for call to function xferBuf
   \   000239   7409         MOV     A,#0x9
   \   00023B   12....       LCALL   ?XSTACK_DISP0_8
   \   00023E   E0           MOVX    A,@DPTR
   \   00023F   C3           CLR     C
   \   000240   95..         SUBB    A,?V0 + 4
   \   000242   FA           MOV     R2,A
   \   000243   A3           INC     DPTR
   \   000244   E0           MOVX    A,@DPTR
   \   000245   95..         SUBB    A,?V0 + 5
   \   000247   FB           MOV     R3,A
   \   000248   741E         MOV     A,#0x1e
   \   00024A   12....       LCALL   ?XSTACK_DISP0_8
   \   00024D   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000250   EA           MOV     A,R2
   \   000251   C3           CLR     C
   \   000252   98           SUBB    A,R0
   \   000253   F5..         MOV     ?V0 + 2,A
   \   000255   EB           MOV     A,R3
   \   000256   99           SUBB    A,R1
   \   000257   F5..         MOV     ?V0 + 3,A
   \   000259   78..         MOV     R0,#?V0 + 2
   \   00025B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00025E   7420         MOV     A,#0x20
   \   000260   12....       LCALL   ?XSTACK_DISP0_8
   \   000263   E0           MOVX    A,@DPTR
   \   000264   2E           ADD     A,R6
   \   000265   F5..         MOV     ?V0 + 2,A
   \   000267   A3           INC     DPTR
   \   000268   E0           MOVX    A,@DPTR
   \   000269   3F           ADDC    A,R7
   \   00026A   F5..         MOV     ?V0 + 3,A
   \   00026C   78..         MOV     R0,#?V0 + 2
   \   00026E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000271   AC..         MOV     R4,?V0 + 0
   \   000273   7409         MOV     A,#0x9
   \   000275   12....       LCALL   ?XSTACK_DISP0_8
   \   000278   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   00027B   7422         MOV     A,#0x22
   \   00027D   12....       LCALL   ?XSTACK_DISP0_8
   \   000280   E0           MOVX    A,@DPTR
   \   000281   28           ADD     A,R0
   \   000282   FA           MOV     R2,A
   \   000283   A3           INC     DPTR
   \   000284   E0           MOVX    A,@DPTR
   \   000285   39           ADDC    A,R1
   \   000286   FB           MOV     R3,A
   \   000287   A9..         MOV     R1,?V0 + 1
   \   000289   12....       LCALL   ??xferBuf?relay
   \   00028C   7404         MOV     A,#0x4
   \   00028E   12....       LCALL   ?DEALLOC_XSTACK8
   1320          
   1321                  // Calculate and write the new checksum.
   1322                  dstOff = pgOff[dstPg-OSAL_NV_PAGE_BEG] - tmp;
   \   000291   7401         MOV     A,#0x1
   \   000293   12....       LCALL   ?XSTACK_DISP0_8
   \   000296   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000299   C082         PUSH    DPL
   \   00029B   C083         PUSH    DPH
   \   00029D   7403         MOV     A,#0x3
   \   00029F   12....       LCALL   ?XSTACK_DISP0_8
   \   0002A2   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   0002A5   D083         POP     DPH
   \   0002A7   D082         POP     DPL
   \   0002A9   12....       LCALL   ?Subroutine16 & 0xFFFF
   1323                  tmp = calcChkF( dstPg, dstOff, hdr.len );
   \                     ??CrossCallReturnLabel_52:
   \   0002AC                ; Setup parameters for call to function calcChkF
   \   0002AC   7409         MOV     A,#0x9
   \   0002AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B1   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   0002B4   12....       LCALL   ??calcChkF?relay
   \   0002B7   7403         MOV     A,#0x3
   \   0002B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0002BC   EA           MOV     A,R2
   \   0002BD   F0           MOVX    @DPTR,A
   \   0002BE   A3           INC     DPTR
   \   0002BF   EB           MOV     A,R3
   \   0002C0   F0           MOVX    @DPTR,A
   1324                  dstOff -= OSAL_NV_HDR_SIZE;
   \   0002C1   EE           MOV     A,R6
   \   0002C2   24F8         ADD     A,#-0x8
   \   0002C4   FE           MOV     R6,A
   \   0002C5   EF           MOV     A,R7
   \   0002C6   34FF         ADDC    A,#-0x1
   \   0002C8   FF           MOV     R7,A
   1325                  writeWordH( dstPg, (dstOff+OSAL_NV_HDR_CHK), (uint8 *)&tmp );
   \   0002C9                ; Setup parameters for call to function writeWordH
   \   0002C9   7403         MOV     A,#0x3
   \   0002CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0002CE   AC82         MOV     R4,DPL
   \   0002D0   AD83         MOV     R5,DPH
   \   0002D2   7404         MOV     A,#0x4
   \   0002D4   2E           ADD     A,R6
   \   0002D5   FA           MOV     R2,A
   \   0002D6   E4           CLR     A
   \   0002D7   3F           ADDC    A,R7
   \   0002D8   FB           MOV     R3,A
   \   0002D9   A9..         MOV     R1,?V0 + 0
   \   0002DB   12....       LCALL   ??writeWordH?relay
   1326                  nvReadHdr( dstPg, dstOff, (uint8 *)(&hdr) );
   \   0002DE                ; Setup parameters for call to function nvReadHdr
   \   0002DE   7407         MOV     A,#0x7
   \   0002E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0002E3   AC82         MOV     R4,DPL
   \   0002E5   AD83         MOV     R5,DPH
   \   0002E7   EE           MOV     A,R6
   \   0002E8   FA           MOV     R2,A
   \   0002E9   EF           MOV     A,R7
   \   0002EA   FB           MOV     R3,A
   \   0002EB   A9..         MOV     R1,?V0 + 0
   \   0002ED   12....       LCALL   nvReadHdr & 0xFFFF
   1327          
   1328                  if ( tmp == hdr.chk )
   \   0002F0   7403         MOV     A,#0x3
   \   0002F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0002F5   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   0002F8   740B         MOV     A,#0xb
   \   0002FA   12....       LCALL   ?XSTACK_DISP0_8
   \   0002FD   E0           MOVX    A,@DPTR
   \   0002FE   68           XRL     A,R0
   \   0002FF   7003         JNZ     ??osal_nv_write_21
   \   000301   A3           INC     DPTR
   \   000302   E0           MOVX    A,@DPTR
   \   000303   69           XRL     A,R1
   \                     ??osal_nv_write_21:
   \   000304   700C         JNZ     ??osal_nv_write_22
   1329                  {
   1330                    setItem( srcPg, origOff, eNvZero );
   \   000306                ; Setup parameters for call to function setItem
   \   000306   7C01         MOV     R4,#0x1
   \   000308   7405         MOV     A,#0x5
   \   00030A   12....       LCALL   ?XSTACK_DISP0_8
   \   00030D   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000310   8003         SJMP    ??osal_nv_write_23
   1331                  }
   1332                  else
   1333                  {
   1334                    rtrn = NV_OPER_FAILED;
   \                     ??osal_nv_write_22:
   \   000312   75..10       MOV     ?V0 + 6,#0x10
   1335                  }
   1336          
   1337                  if ( dstPg == pgRes )
   \                     ??osal_nv_write_23:
   \   000315   90....       MOV     DPTR,#pgRes
   \   000318   E0           MOVX    A,@DPTR
   \   000319   65..         XRL     A,?V0 + 0
   \   00031B   7010         JNZ     ??osal_nv_write_19
   1338                  {
   1339                    compactPage( comPg );
   \   00031D                ; Setup parameters for call to function compactPage
   \   00031D   85..82       MOV     DPL,?XSP + 0
   \   000320   85..83       MOV     DPH,?XSP + 1
   \   000323   E0           MOVX    A,@DPTR
   \   000324   F9           MOV     R1,A
   \   000325   12....       LCALL   ??compactPage?relay
   \   000328   8003         SJMP    ??osal_nv_write_19
   1340                  }
   1341                }
   1342                else
   1343                {
   1344                  rtrn = NV_OPER_FAILED;
   \                     ??osal_nv_write_20:
   \   00032A   75..10       MOV     ?V0 + 6,#0x10
   1345                }
   1346              }
   1347            }
   1348          
   1349            if ( failF )
   \                     ??osal_nv_write_19:
   \   00032D   90....       MOV     DPTR,#failF
   \   000330   E0           MOVX    A,@DPTR
   \   000331   6006         JZ      ??osal_nv_write_12
   1350            {
   1351              (void)initNV();  // See comment at the declaration of failF.
   \   000333                ; Setup parameters for call to function initNV
   \   000333   12....       LCALL   ??initNV?relay
   1352              rtrn = NV_OPER_FAILED;
   \   000336   75..10       MOV     ?V0 + 6,#0x10
   1353            }
   1354          
   1355            return rtrn;
   \                     ??osal_nv_write_12:
   \   000339   A9..         MOV     R1,?V0 + 6
   \                     ??osal_nv_write_10:
   \   00033B   740F         MOV     A,#0xf
   \   00033D   02....       LJMP    ?Subroutine42 & 0xFFFF
   1356          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   EE           MOV     A,R6
   \   000001   25..         ADD     A,?V0 + 4
   \   000003   FE           MOV     R6,A
   \   000004   EF           MOV     A,R7
   \   000005   35..         ADDC    A,?V0 + 5
   \   000007   FF           MOV     R7,A
   \   000008                ; Setup parameters for call to function writeBuf
   \   000008   7420         MOV     A,#0x20
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C3           CLR     C
   \   000002   98           SUBB    A,R0
   \   000003   FE           MOV     R6,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   99           SUBB    A,R1
   \   000007   FF           MOV     R7,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   25..         ADD     A,?V0 + 4
   \   000003   F8           MOV     R0,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   35..         ADDC    A,?V0 + 5
   \   000008   F9           MOV     R1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000003   A9..         MOV     R1,?V0 + 1
   \   000005   12....       LCALL   ??setItem?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   EE           MOV     A,R6
   \   000006   FA           MOV     R2,A
   \   000007   EF           MOV     A,R7
   \   000008   FB           MOV     R3,A
   \   000009   A9..         MOV     R1,?V0 + 0
   \   00000B   22           RET
   1357          
   1358          /*********************************************************************
   1359           * @fn      osal_nv_read
   1360           *
   1361           * @brief   Read data from NV. This function can be used to read an entire item from NV or
   1362           *          an element of an item by indexing into the item with an offset.
   1363           *          Read data is copied into *buf.
   1364           *
   1365           * @param   id  - Valid NV item Id.
   1366           * @param   ndx - Index offset into item
   1367           * @param   len - Length of data to read.
   1368           * @param  *buf - Data is read into this buffer.
   1369           *
   1370           * @return  ZSUCCESS if NV data was copied to the parameter 'buf'.
   1371           *          Otherwise, NV_OPER_FAILED for failure.
   1372           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1373          uint8 osal_nv_read( uint16 id, uint16 ndx, uint16 len, void *buf )
   \                     osal_nv_read:
   1374          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   \   000009   740E         MOV     A,#0xe
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000011   7410         MOV     A,#0x10
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   12....       LCALL   ?Subroutine6 & 0xFFFF
   1375            uint16 offset;
   1376          
   1377            if ( id == ZCD_NV_EXTADDR )
   \                     ??CrossCallReturnLabel_24:
   \   000019   7401         MOV     A,#0x1
   \   00001B   6A           XRL     A,R2
   \   00001C   7001         JNZ     ??osal_nv_read_0
   \   00001E   EB           MOV     A,R3
   \                     ??osal_nv_read_0:
   \   00001F   702B         JNZ     ??osal_nv_read_1
   1378            {
   1379              offset = OSAL_NV_IEEE_OFFSET;
   \   000021   7AF8         MOV     R2,#-0x8
   \   000023   7B07         MOV     R3,#0x7
   1380              findPg = OSAL_NV_IEEE_PAGE;
   \   000025   743F         MOV     A,#0x3f
   \   000027   90....       MOV     DPTR,#findPg
   \   00002A   F0           MOVX    @DPTR,A
   1381            }
   1382            else
   1383            {
   1384              offset = findItem( id );
   1385              if ( offset == OSAL_NV_ITEM_NULL )
   1386              {
   1387                return NV_OPER_FAILED;
   1388              }
   1389            }
   1390          
   1391            nvReadBuf(findPg, offset+ndx, buf, len);
   \                     ??osal_nv_read_2:
   \   00002B                ; Setup parameters for call to function nvReadBuf
   \   00002B   78..         MOV     R0,#?V0 + 2
   \   00002D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000030   AC..         MOV     R4,?V0 + 0
   \   000032   AD..         MOV     R5,?V0 + 1
   \   000034   EE           MOV     A,R6
   \   000035   2A           ADD     A,R2
   \   000036   FA           MOV     R2,A
   \   000037   EF           MOV     A,R7
   \   000038   3B           ADDC    A,R3
   \   000039   FB           MOV     R3,A
   \   00003A   90....       MOV     DPTR,#findPg
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F9           MOV     R1,A
   \   00003F   12....       LCALL   nvReadBuf & 0xFFFF
   \   000042   7402         MOV     A,#0x2
   \   000044   12....       LCALL   ?DEALLOC_XSTACK8
   1392          
   1393            return ZSUCCESS;
   \   000047   7900         MOV     R1,#0x0
   \                     ??osal_nv_read_3:
   \   000049   02....       LJMP    ?Subroutine40 & 0xFFFF
   \                     ??osal_nv_read_1:
   \   00004C                ; Setup parameters for call to function findItem
   \   00004C   12....       LCALL   ??findItem?relay
   \   00004F   EA           MOV     A,R2
   \   000050   7001         JNZ     ??osal_nv_read_4
   \   000052   EB           MOV     A,R3
   \                     ??osal_nv_read_4:
   \   000053   70D6         JNZ     ??osal_nv_read_2
   \   000055   7910         MOV     R1,#0x10
   \   000057   80F0         SJMP    ??osal_nv_read_3
   1394          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??initNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    initNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??setPageUse?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    setPageUse

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??initPage?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    initPage

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??erasePage?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    erasePage

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??compactPage?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    compactPage

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??findItem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    findItem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??initItem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    initItem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??setItem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    setItem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??calcChkF?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    calcChkF

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??writeWord?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    writeWord

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??writeWordM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    writeWordM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??writeWordH?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    writeWordH

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??writeBuf?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    writeBuf

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??xferBuf?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    xferBuf

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??writeItem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    writeItem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_nv_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_nv_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_nv_item_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_nv_item_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_nv_item_len?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_nv_item_len

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_nv_write?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_nv_write

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_nv_read?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_nv_read
   1395          
   1396          /*********************************************************************
   1397          *********************************************************************/

   Maximum stack usage in bytes:

     Function            ISTACK PSTACK XSTACK
     --------            ------ ------ ------
     calcChkF                0      0     50
       -> nvReadWord         0      0     40
     compactPage             2      0     58
       -> writeWordH         0      0     48
       -> calcChkF           0      0     48
       -> setItem            0      0     48
       -> writeBuf           0      0     52
       -> xferBuf            0      0     56
       -> setItem            0      0     48
       -> nvReadHdr          0      0     48
       -> erasePage          0      0     48
       -> setPageUse         0      0     48
     erasePage               0      0     47
       -> HalAdcCheckVdd     0      0     34
       -> nvReadHdr          0      0     34
       -> writeWordM         0      0     36
     findItem                0      0     42
       -> initPage           0      0     24
     initItem                2      0     51
       -> writeItem          0      0     38
       -> compactPage        0      0     32
     initNV                  0      0     60
       -> nvReadHdr          0      0     58
       -> nvReadHdr          0      0     58
       -> setPageUse         0      0     58
       -> initPage           0      0     58
       -> nvReadHdr          0      0     58
       -> writeWordM         0      0     60
       -> writeWordM         0      0     60
       -> setPageUse         0      0     58
       -> compactPage        0      0     58
       -> erasePage          0      0     58
       -> initNV             0      0     58
     initPage                0      0     55
       -> setItem            0      0     52
       -> nvReadHdr          0      0     52
       -> calcChkF           0      0     52
       -> findItem           0      0     52
       -> setItem            0      0     52
     osal_nv_init            2      0      0
       -> initNV             4      0      0
     osal_nv_item_init       0      0     18
       -> findItem           0      0     28
       -> initItem           0      0     32
       -> initNV             0      0     28
     osal_nv_item_len        0      0     18
       -> findItem           0      0     36
       -> nvReadHdr          0      0     36
     osal_nv_read            0      0     20
       -> nvReadBuf          0      0     32
       -> findItem           0      0     28
     osal_nv_write           2      0     38
       -> nvReadHdr          0      0     60
       -> writeWordM         0      0     62
       -> findItem           0      0     60
       -> nvReadHdr          0      0     60
       -> nvReadByte         0      0     60
       -> initItem           0      0     64
       -> setItem            0      0     60
       -> xferBuf            0      0     68
       -> writeBuf           0      0     64
       -> xferBuf            0      0     68
       -> calcChkF           0      0     60
       -> writeWordH         0      0     60
       -> nvReadHdr          0      0     60
       -> setItem            0      0     60
       -> compactPage        0      0     60
       -> initNV             0      0     60
     setItem                 0      0     50
       -> nvReadHdr          0      0     40
       -> writeWord          0      0     40
       -> writeWord          0      0     40
     setPageUse              2      0     37
       -> writeWord          4      0     16
     writeBuf                1      0     53
       -> nvReadWord         0      0     40
       -> writeWord          0      0     40
       -> writeWordM         0      0     42
       -> nvReadWord         0      0     40
       -> writeWord          0      0     40
     writeItem               0      0     47
       -> setPageUse         0      0     52
       -> writeWord          0      0     52
       -> nvReadHdr          0      0     52
       -> writeBuf           0      0     56
       -> calcChkF           0      0     52
       -> writeWordH         0      0     52
       -> nvReadHdr          0      0     52
     writeWord               0      0     38
       -> HalAdcCheckVdd     0      0     24
       -> flashWriteBuf      0      0     24
     writeWordH              1      0     43
       -> writeWord          0      0     26
     writeWordM              0      0     45
       -> HalAdcCheckVdd     0      0     28
       -> flashWriteBuf      0      0     28
     xferBuf                 0      0     55
       -> nvReadWord         0      0     42
       -> nvReadByte         0      0     42
       -> writeWord          0      0     42
       -> nvReadWord         0      0     42
       -> writeWord          0      0     42
       -> nvReadWord         0      0     42
       -> nvReadByte         0      0     42
       -> writeWord          0      0     42


   Segment part sizes:

     Function/Label            Bytes
     --------------            -----
     _A_IEN0                      1
     FWT                          1
     FADDRH                       1
     FCTL                         1
     flashXdataBuf               22
     pgOff                        4
     pgLost                       4
     pgRes                        1
     findPg                       1
     failF                        1
     initNV                     417
     ?Subroutine0                17
     ?Subroutine20               16
     setPageUse                  52
     ?Subroutine37                7
     ?Subroutine17               21
     initPage                   443
     ?Subroutine25                5
     ?Subroutine19                5
     ?Subroutine36               11
     ?Subroutine13                6
     ?Subroutine5                 4
     ?Subroutine31               13
     ?Subroutine35               17
     ?Subroutine38               10
     erasePage                  100
     ?Subroutine39                8
     compactPage                319
     ?Subroutine40                5
     ?Subroutine10               12
     ?Subroutine9                 9
     ?Subroutine3                 8
     ?Subroutine24               10
     ?Subroutine33                7
     ?Subroutine28               12
     ?Subroutine23               13
     ?Subroutine2                 6
     ?Subroutine32               12
     ?Subroutine6                 8
     findItem                    68
     ?Subroutine41                5
     initItem                   221
     ?Subroutine30               17
     setItem                    127
     ?Subroutine4                 8
     calcChkF                   119
     ?Subroutine43                5
     ?Subroutine26               19
     ?Subroutine34               13
     writeWord                   71
     writeWordM                  79
     writeWordH                  64
     writeBuf                   290
     ?Subroutine18               15
     xferBuf                    278
     ?Subroutine42                8
     ?Subroutine21               17
     ?Subroutine1                31
     ?Subroutine12                4
     ?Subroutine7                 8
     writeItem                  436
     ?Subroutine22               11
     osal_nv_init                13
     osal_nv_item_init           91
     osal_nv_item_len            80
     ?Subroutine27               13
     osal_nv_write              832
     ?Subroutine29               11
     ?Subroutine16                9
     ?Subroutine15                9
     ?Subroutine14               10
     ?Subroutine11                9
     ?Subroutine8                12
     osal_nv_read                89
     ??initNV?relay               6
     ??setPageUse?relay           6
     ??initPage?relay             6
     ??erasePage?relay            6
     ??compactPage?relay          6
     ??findItem?relay             6
     ??initItem?relay             6
     ??setItem?relay              6
     ??calcChkF?relay             6
     ??writeWord?relay            6
     ??writeWordM?relay           6
     ??writeWordH?relay           6
     ??writeBuf?relay             6
     ??xferBuf?relay              6
     ??writeItem?relay            6
     ??osal_nv_init?relay         6
     ??osal_nv_item_init?relay    6
     ??osal_nv_item_len?relay     6
     ??osal_nv_write?relay        6
     ??osal_nv_read?relay         6

 
 4 665 bytes in segment BANKED_CODE
   120 bytes in segment BANK_RELAYS
     4 bytes in segment SFR_AN
    33 bytes in segment XDATA_Z
 
 4 785 bytes of CODE  memory
     0 bytes of DATA  memory (+ 4 bytes shared)
    33 bytes of XDATA memory

Errors: none
Warnings: none

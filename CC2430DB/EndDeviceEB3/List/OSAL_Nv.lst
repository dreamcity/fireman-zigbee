###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    18/Mar/2013  18:21:46 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \osal\mcu\ccsoc\OSAL_Nv.c                          #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\. #
#                          .\..\..\Tools\CC2430DB\f8wEndev.cfg" (-DCPU32MHZ   #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_OPT_FFD=0 -DBLINK_LEDS "-DCONST=const        #
#                          __code" -DGENERIC=__generic) -f "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\Tools #
#                          \CC2430DB\f8wConfig.cfg" (-DSECURE=0               #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\osal\mcu #
#                          \ccsoc\OSAL_Nv.c" -D CC2430EB -D AXD_END3 -D       #
#                          NWK_AUTO_POLL -D REFLECTOR -D xZTOOL_P1 -D         #
#                          xMT_TASK -D xMT_ZDO_FUNC -D xLCD_SUPPORTED=DEBUG   #
#                          -D xPOWER_SAVING -lC "C:\Texas                     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\EndDeviceEB3\L #
#                          ist\" -lA "C:\Texas Instruments\ZStack-1.4.3-1.2.1 #
#                          \Projects\zstack\Samples\cc2430-zstack-adxl345\CC2 #
#                          430DB\EndDeviceEB3\List\" --diag_suppress          #
#                          Pe001,Pa010 --diag_remark pe550 -o "C:\Texas       #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\EndDeviceEB3\O #
#                          bj\" -e --require_prototypes -z2 --no_cse          #
#                          --no_unroll --no_inline --no_code_motion           #
#                          --no_tbaa --debug --core=plain --dptr=16,1         #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\cc2430-zstack-adxl345\CC2430DB\"    #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\. #
#                          .\SOURCE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\cc2430-zstack-adxl345 #
#                          \CC2430DB\..\Drivers\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\ZMAIN #
#                          \TI2430DB\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MT\" -I "C:\Texas                      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\INCLUDE\" -I "C:\Texas             #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\TARGET\CC2430EB\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\OSAL\INCLUDE\" -I "C:\Texas            #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\AF\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\NWK\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SEC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SYS\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\ZDO\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\ZMAC\F8W\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\ZMAC\" -I "C:\Texas                    #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SADDR\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SDATA\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\INCLUDE\" -I "C:\Texas             #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\HIGH_LEVEL\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\LOW_LEVEL\SRF03\SINGLE_CHIP\" -I   #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          4.0 Evaluation version\8051\INC\" -I "C:\Program   #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\CC2430DB\EndDe #
#                          viceEB3\List\OSAL_Nv.lst                           #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\CC2430DB\EndDe #
#                          viceEB3\Obj\OSAL_Nv.r51                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\osal\mcu\ccsoc\OSAL_Nv.c
      1          /**************************************************************************************************
      2            Filename:       OSAL_Nv.c
      3            Revised:        $Date: 2007-10-28 18:43:04 -0700 (Sun, 28 Oct 2007) $
      4            Revision:       $Revision: 15800 $
      5          
      6            Description:    This module contains the OSAL non-volatile memory functions.
      7          
      8          
      9            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /**************************************************************************************************
     41            Notes:
     42              - A trick buried deep in initPage() requires that the MSB of the NV Item Id is to
     43                be reserved for use by this module.
     44              - Due to .s51 code and code-size saving tricks, the max NV item size is 1024 bytes.
     45          **************************************************************************************************/
     46          
     47          /*********************************************************************
     48           * INCLUDES
     49           */
     50          
     51          #include "ZComDef.h"
     52          #include "hal_adc.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xab
   \   unsigned char volatile __sfr FWT
   \                     FWT:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xad
   \   unsigned char volatile __sfr FADDRH
   \                     FADDRH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xae
   \   unsigned char volatile __sfr FCTL
   \                     FCTL:
   \   000000                DS 1
     53          #include "osal.h"
     54          #include "OSAL_Nv.h"
     55          #include <ioCC2430.h>
     56          
     57          /*********************************************************************
     58           * CONSTANTS
     59           */
     60          
     61          #define OSAL_NV_ACTIVE          0x00
     62          #define OSAL_NV_ERASED          0xFF
     63          #define OSAL_NV_ERASED_ID       0xFFFF
     64          #define OSAL_NV_ZEROED_ID       0x0000
     65          // Reserve MSB of Id to signal a search for the "old" source copy (new write interrupted/failed.)
     66          #define OSAL_NV_SOURCE_ID       0x8000
     67          
     68          #define OSAL_NV_PAGE_FREE      (OSAL_NV_PAGE_SIZE - Z_EXTADDR_LEN)
     69          
     70          /* The last Flash page will reserve an IEEE addr block at the end of the page where the tools know
     71           * to program the IEEE.
     72           */
     73          #define OSAL_NV_IEEE_OFFSET    (OSAL_NV_PAGE_SIZE - Z_EXTADDR_LEN)
     74          #define OSAL_NV_IEEE_PAGE       63
     75          
     76          // In case pages 0-1 are ever used, define a null page value.
     77          #define OSAL_NV_PAGE_NULL       0
     78          
     79          // In case item Id 0 is ever used, define a null item value.
     80          #define OSAL_NV_ITEM_NULL       0
     81          
     82          #define OSAL_NV_WORD_SIZE       4
     83          
     84          #define OSAL_NV_PAGE_HDR_OFFSET 0
     85          
     86          /*********************************************************************
     87           * MACROS
     88           */
     89          
     90          #define  OSAL_NV_CHECK_BUS_VOLTAGE  (HalAdcCheckVdd( HAL_ADC_VDD_LIMIT_4 ))
     91          
     92          #define OSAL_NV_DATA_SIZE( LEN )  \
     93             ((((LEN) + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE)
     94          
     95          #define OSAL_NV_ITEM_SIZE( LEN )  \
     96            (((((LEN) + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE) + OSAL_NV_HDR_SIZE)
     97          
     98          /*********************************************************************
     99           * TYPEDEFS
    100           */
    101          
    102          typedef struct
    103          {
    104            uint16 id;
    105            uint16 len;   // Enforce Flash-WORD size on len.
    106            uint16 chk;   // Byte-wise checksum of the 'len' data bytes of the item.
    107            uint16 stat;  // Item status.
    108          } osalNvHdr_t;
    109          // Struct member offsets.
    110          #define OSAL_NV_HDR_ID    0
    111          #define OSAL_NV_HDR_LEN   2
    112          #define OSAL_NV_HDR_CHK   4
    113          #define OSAL_NV_HDR_STAT  6
    114          
    115          #define OSAL_NV_HDR_ITEM  2  // Length of any item of a header struct.
    116          #define OSAL_NV_HDR_SIZE  8
    117          #define OSAL_NV_HDR_HALF (OSAL_NV_HDR_SIZE / 2)
    118          
    119          typedef struct
    120          {
    121            uint16 active;
    122            uint16 inUse;
    123            uint16 xfer;
    124            uint16 spare;
    125          } osalNvPgHdr_t;
    126          // Struct member offsets.
    127          #define OSAL_NV_PG_ACTIVE 0
    128          #define OSAL_NV_PG_INUSE  2
    129          #define OSAL_NV_PG_XFER   4
    130          #define OSAL_NV_PG_SPARE  6
    131          
    132          #define OSAL_NV_PAGE_HDR_SIZE  8
    133          #define OSAL_NV_PAGE_HDR_HALF (OSAL_NV_PAGE_HDR_SIZE / 2)
    134          
    135          typedef enum
    136          {
    137            eNvXfer,
    138            eNvZero
    139          } eNvHdrEnum;
    140          
    141          typedef enum
    142          {
    143            ePgActive,
    144            ePgInUse,
    145            ePgXfer,
    146            ePgSpare
    147          } ePgHdrEnum;
    148          
    149          /*********************************************************************
    150           * GLOBAL VARIABLES
    151           */
    152          
    153          /* This can be placed in the non-retention RAM - the assembly routine is copied from Flash to XDATA
    154           * on every call. If enough retention RAM is available, or if on a mains-powered device, could
    155           * easily change to copy Flash to XDATA only on initialization.
    156           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    157          uint8 __xdata flashXdataBuf[22];
   \                     flashXdataBuf:
   \   000000                DS 22
   \   000016                REQUIRE __INIT_XDATA_Z
    158          
    159          /*********************************************************************
    160           * EXTERNAL FUNCTIONS
    161           */
    162          
    163          /*********************************************************************
    164           * @fn      nvRead...
    165           *
    166           * @brief   Reads a byte, OSAL_NV_WORD_SIZE, or OSAL_NV_HDR_SIZE bytes from NV.
    167           *
    168           * @param   pg - Valid NV page.
    169           * @param   offset - Valid offset into the page.
    170           * @param   buf - Valid buffer space at least as big as the read request.
    171           *
    172           * @return  none
    173           */
    174          extern __near_func void nvReadByte( uint8 pg, uint16 offset, uint8 *buf );
    175          extern __near_func void nvReadWord( uint8 pg, uint16 offset, uint8 *buf );
    176          extern __near_func void nvReadHdr(uint8 pg, uint16 offset, uint8 *buf);
    177          
    178          /*********************************************************************
    179           * @fn      nvReadBuf
    180           *
    181           * @brief   Reads N bytes from NV.
    182           *
    183           * @param   pg - Valid NV page.
    184           * @param   offset - Valid offset into the page.
    185           * @param   buf - Valid buffer space at least as big as the read request.
    186           * @param   cnt - Number of bytes to read.
    187           *
    188           * @return  none
    189           */
    190          extern __near_func void nvReadBuf(uint8 pg, uint16 offset, uint8 *buf, uint16 cnt);
    191          
    192          /*********************************************************************
    193           * @fn      flashWriteBuf
    194           *
    195           * @brief   Writes N blocks of 4-bytes to NV.
    196           *
    197           * @param   cnt - Number of blocks of 4-bytes to write.
    198           * @param   buf - Valid buffer space at least as big as the write request.
    199           * @param   addr - Valid FADDRH/L address: 3-byte addr / 4 = 2-byte addr.
    200           *
    201           * @return  none
    202           */
    203          extern __near_func void flashWriteBuf(uint8 cnt, uint16 buf, uint16 addr);
    204          
    205          extern bool HalAdcCheckVdd(uint8 limit);
    206          
    207          /*********************************************************************
    208           * LOCAL VARIABLES
    209           */
    210          
    211          // Offset into the page of the first available erased space.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    212          static uint16 pgOff[OSAL_NV_PAGES_USED];
   \                     pgOff:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    213          
    214          // Count of the bytes lost for the zeroed-out items.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    215          static uint16 pgLost[OSAL_NV_PAGES_USED];
   \                     pgLost:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    216          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    217          static uint8 pgRes;  // Page reserved for item compacting transfer.
   \                     pgRes:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    218          
    219          // Saving ~100 code bytes to move a uint8* parameter/return value from findItem() to a global.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    220          static uint8 findPg;
   \                     findPg:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    221          
    222          /* Immediately before the voltage critical operations of a page erase or
    223           * a word write, check bus voltage. If less than min, set global flag & abort.
    224           * Since this is to be done at the lowest level, many void functions would have to be changed to
    225           * return a value and code added to check that value before proceeding, resulting in a very
    226           * expensive code size hit for implementing this properly. Therefore, use this global as follows:
    227           * at the start of osal_nv_item_init/osal_nv_write, set to FALSE, and at the end, before returning,
    228           * check the value. Thus, the global is an accumulator of any error that occurred in any of the
    229           * attempts to modify Flash with a low bus voltage during the complicated sequence of events that
    230           * may occur on any item init or write. This is much more expedient and code saving than adding
    231           * return values and checking return values to early out. No matter which method is used, an NV
    232           * data record may end up mangled due to the low VCC conditions. The strategy is that the headers
    233           * and checksums will detect and allow recovery from such a condition.
    234           *
    235           * One unfortunate side-effect of using the global fail flag vice adding and checking return
    236           * values, is that when setting an item Id to zero has failed due to the low VCC check,
    237           * the page lost-bytes counter is still updated. Having an artificially high lost-byte
    238           * count makes it look like there are more bytes to recover from compacting a page than there may
    239           * actually be. The easy work-around implemented is it to invoke initNV() from osal_nv_item_init or
    240           * osal_nv_write anytime that the failF gets set - this will re-walk all of the pages and set the
    241           * page offset count and page lost bytes count to their actual values.
    242           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    243          static uint8 failF;
   \                     failF:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    244          
    245          /*********************************************************************
    246           * LOCAL FUNCTIONS
    247           */
    248          
    249          static uint8  initNV( void );
    250          
    251          static void   setPageUse( uint8 pg, uint8 inUse );
    252          static uint16 initPage( uint8 pg, uint16 id, uint8 findDups );
    253          static void   erasePage( uint8 pg );
    254          static void   compactPage( uint8 pg );
    255          
    256          static uint16 findItem( uint16 id );
    257          static uint8  initItem( uint8 flag, uint16 id, uint16 len, void *buf );
    258          static void   setItem( uint8 pg, uint16 offset, eNvHdrEnum stat );
    259          
    260          static uint16 calcChkB( uint16 len, uint8 *buf );
    261          static uint16 calcChkF( byte pg, uint16 offset, uint16 len );
    262          
    263          static void   writeWord( uint8 pg, uint16 offset, uint8 *buf );
    264          static void   writeWordH( uint8 pg, uint16 offset, uint8 *buf );
    265          static void   writeWordM( uint8 pg, uint16 offset, uint8 *buf, uint8 cnt );
    266          static void   writeBuf( uint8 pg, uint16 offset, uint16 len, uint8 *buf );
    267          static void   xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len );
    268          
    269          static uint8  writeItem( uint8 pg, uint16 id, uint16 len, void *buf, uint8 flag );
    270          
    271          static uint8  writeIEEE( void *buf );
    272          
    273          /*********************************************************************
    274           * @fn      initNV
    275           *
    276           * @brief   Initialize the NV flash pages.
    277           *
    278           * @param   none
    279           *
    280           * @return  TRUE
    281           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    282          static uint8 initNV( void )
   \                     initNV:
    283          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    284            osalNvPgHdr_t pgHdr, ieee;
    285            uint8 oldPg = OSAL_NV_PAGE_NULL;
   \   00000A   75..00       MOV     ?V0 + 0,#0x0
    286            uint8 newPg = OSAL_NV_PAGE_NULL;
   \   00000D   7F00         MOV     R7,#0x0
    287            uint8 findDups = FALSE;
   \   00000F   75..00       MOV     ?V0 + 4,#0x0
    288            uint8 xBad;
    289            uint8 pg;
    290          
    291            nvReadHdr( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee) );
   \   000012                ; Setup parameters for call to function nvReadHdr
   \   000012   7408         MOV     A,#0x8
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   AC82         MOV     R4,DPL
   \   000019   AD83         MOV     R5,DPH
   \   00001B   7AF8         MOV     R2,#-0x8
   \   00001D   7B07         MOV     R3,#0x7
   \   00001F   793F         MOV     R1,#0x3f
   \   000021   12....       LCALL   nvReadHdr & 0xFFFF
    292            if ( (ieee.active == OSAL_NV_ERASED_ID) &&
    293                 (ieee.inUse == OSAL_NV_ERASED_ID) &&
    294                 (ieee.xfer == OSAL_NV_ERASED_ID) &&
    295                 (ieee.spare == OSAL_NV_ERASED_ID) )
   \   000024   7408         MOV     A,#0x8
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   64FF         XRL     A,#0xff
   \   00002C   7004         JNZ     ??initNV_0
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   64FF         XRL     A,#0xff
   \                     ??initNV_0:
   \   000032   7035         JNZ     ??initNV_1
   \   000034   740A         MOV     A,#0xa
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   64FF         XRL     A,#0xff
   \   00003C   7004         JNZ     ??initNV_2
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   64FF         XRL     A,#0xff
   \                     ??initNV_2:
   \   000042   7025         JNZ     ??initNV_1
   \   000044   740C         MOV     A,#0xc
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   64FF         XRL     A,#0xff
   \   00004C   7004         JNZ     ??initNV_3
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   64FF         XRL     A,#0xff
   \                     ??initNV_3:
   \   000052   7015         JNZ     ??initNV_1
   \   000054   740E         MOV     A,#0xe
   \   000056   12....       LCALL   ?XSTACK_DISP0_8
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   64FF         XRL     A,#0xff
   \   00005C   7004         JNZ     ??initNV_4
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   64FF         XRL     A,#0xff
   \                     ??initNV_4:
   \   000062   7005         JNZ     ??initNV_1
    296            {
    297              xBad = TRUE;
   \   000064   75..01       MOV     ?V0 + 1,#0x1
   \   000067   8003         SJMP    ??initNV_5
    298            }
    299            else
    300            {
    301              xBad = FALSE;
   \                     ??initNV_1:
   \   000069   75..00       MOV     ?V0 + 1,#0x0
    302            }
    303          
    304            pgRes = OSAL_NV_PAGE_NULL;
   \                     ??initNV_5:
   \   00006C   7400         MOV     A,#0x0
   \   00006E   90....       MOV     DPTR,#pgRes
   \   000071   F0           MOVX    @DPTR,A
    305          
    306            for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
   \   000072   7E3C         MOV     R6,#0x3c
   \                     ??initNV_6:
   \   000074   EE           MOV     A,R6
   \   000075   C3           CLR     C
   \   000076   943E         SUBB    A,#0x3e
   \   000078   4003         JC      $+5
   \   00007A   02....       LJMP    ??initNV_7 & 0xFFFF
    307            {
    308              nvReadHdr( pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8 *)(&pgHdr) );
   \   00007D                ; Setup parameters for call to function nvReadHdr
   \   00007D   85..82       MOV     DPL,?XSP + 0
   \   000080   85..83       MOV     DPH,?XSP + 1
   \   000083   AC82         MOV     R4,DPL
   \   000085   AD83         MOV     R5,DPH
   \   000087   7A00         MOV     R2,#0x0
   \   000089   7B00         MOV     R3,#0x0
   \   00008B   EE           MOV     A,R6
   \   00008C   F9           MOV     R1,A
   \   00008D   12....       LCALL   nvReadHdr & 0xFFFF
    309          
    310              if ( pgHdr.active == OSAL_NV_ERASED_ID )
   \   000090   85..82       MOV     DPL,?XSP + 0
   \   000093   85..83       MOV     DPH,?XSP + 1
   \   000096   E0           MOVX    A,@DPTR
   \   000097   64FF         XRL     A,#0xff
   \   000099   7004         JNZ     ??initNV_8
   \   00009B   A3           INC     DPTR
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   64FF         XRL     A,#0xff
   \                     ??initNV_8:
   \   00009F   7016         JNZ     ??initNV_9
    311              {
    312                if ( pgRes == OSAL_NV_PAGE_NULL )
   \   0000A1   90....       MOV     DPTR,#pgRes
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   7007         JNZ     ??initNV_10
    313                {
    314                  pgRes = pg;
   \   0000A7   EE           MOV     A,R6
   \   0000A8   90....       MOV     DPTR,#pgRes
   \   0000AB   F0           MOVX    @DPTR,A
   \   0000AC   802F         SJMP    ??initNV_11
    315                }
    316                else
    317                {
    318                  setPageUse( pg, TRUE );
   \                     ??initNV_10:
   \   0000AE                ; Setup parameters for call to function setPageUse
   \   0000AE   7A01         MOV     R2,#0x1
   \   0000B0   EE           MOV     A,R6
   \   0000B1   F9           MOV     R1,A
   \   0000B2   12....       LCALL   ??setPageUse?relay
   \   0000B5   8026         SJMP    ??initNV_11
    319                }
    320              }
    321              else  // Page is active.
    322              {
    323                // If the page is not yet in use, it is the tgt of items from an xfer.
    324                if ( pgHdr.inUse == OSAL_NV_ERASED_ID )
   \                     ??initNV_9:
   \   0000B7   7402         MOV     A,#0x2
   \   0000B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   64FF         XRL     A,#0xff
   \   0000BF   7004         JNZ     ??initNV_12
   \   0000C1   A3           INC     DPTR
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   64FF         XRL     A,#0xff
   \                     ??initNV_12:
   \   0000C5   7004         JNZ     ??initNV_13
    325                {
    326                  newPg = pg;
   \   0000C7   EE           MOV     A,R6
   \   0000C8   FF           MOV     R7,A
   \   0000C9   8012         SJMP    ??initNV_11
    327                }
    328                // An Xfer from this page was in progress.
    329                else if ( pgHdr.xfer != OSAL_NV_ERASED_ID )
   \                     ??initNV_13:
   \   0000CB   7404         MOV     A,#0x4
   \   0000CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D0   E0           MOVX    A,@DPTR
   \   0000D1   64FF         XRL     A,#0xff
   \   0000D3   7004         JNZ     ??initNV_14
   \   0000D5   A3           INC     DPTR
   \   0000D6   E0           MOVX    A,@DPTR
   \   0000D7   64FF         XRL     A,#0xff
   \                     ??initNV_14:
   \   0000D9   6002         JZ      ??initNV_11
    330                {
    331                  oldPg = pg;
   \   0000DB   8E..         MOV     ?V0 + 0,R6
    332                }
    333              }
    334          
    335              // Calculate page offset and lost bytes - any "old" item triggers an N^2 re-scan from start.
    336              if ( initPage( pg, OSAL_NV_ITEM_NULL, findDups ) != OSAL_NV_ITEM_NULL )
   \                     ??initNV_11:
   \   0000DD                ; Setup parameters for call to function initPage
   \   0000DD   AC..         MOV     R4,?V0 + 4
   \   0000DF   7A00         MOV     R2,#0x0
   \   0000E1   7B00         MOV     R3,#0x0
   \   0000E3   EE           MOV     A,R6
   \   0000E4   F9           MOV     R1,A
   \   0000E5   12....       LCALL   ??initPage?relay
   \   0000E8   8A..         MOV     ?V0 + 2,R2
   \   0000EA   8B..         MOV     ?V0 + 3,R3
   \   0000EC   7400         MOV     A,#0x0
   \   0000EE   65..         XRL     A,?V0 + 2
   \   0000F0   7004         JNZ     ??initNV_15
   \   0000F2   7400         MOV     A,#0x0
   \   0000F4   65..         XRL     A,?V0 + 3
   \                     ??initNV_15:
   \   0000F6   6008         JZ      ??initNV_16
    337              {
    338                findDups = TRUE;
   \   0000F8   75..01       MOV     ?V0 + 4,#0x1
    339                pg = OSAL_NV_PAGE_BEG-1;
   \   0000FB   7E3B         MOV     R6,#0x3b
    340                continue;
   \   0000FD   02....       LJMP    ??initNV_17 & 0xFFFF
    341              }
    342          
    343              nvReadHdr( pg, OSAL_NV_IEEE_OFFSET, (uint8 *)(&pgHdr) );
   \                     ??initNV_16:
   \   000100                ; Setup parameters for call to function nvReadHdr
   \   000100   85..82       MOV     DPL,?XSP + 0
   \   000103   85..83       MOV     DPH,?XSP + 1
   \   000106   AC82         MOV     R4,DPL
   \   000108   AD83         MOV     R5,DPH
   \   00010A   7AF8         MOV     R2,#-0x8
   \   00010C   7B07         MOV     R3,#0x7
   \   00010E   EE           MOV     A,R6
   \   00010F   F9           MOV     R1,A
   \   000110   12....       LCALL   nvReadHdr & 0xFFFF
    344              if ( xBad )
   \   000113   E5..         MOV     A,?V0 + 1
   \   000115   6065         JZ      ??initNV_18
    345              {
    346                /* TBD - For the cost of more code space, the IEEE could be checksummed & then tested here
    347                 * before installing to the erased IEEE on page 63.
    348                 */
    349                if ( (pgHdr.active != OSAL_NV_ERASED_ID) ||
    350                     (pgHdr.inUse != OSAL_NV_ERASED_ID) ||
    351                     (pgHdr.xfer != OSAL_NV_ERASED_ID) ||
    352                     (pgHdr.spare != OSAL_NV_ERASED_ID) )
   \   000117   85..82       MOV     DPL,?XSP + 0
   \   00011A   85..83       MOV     DPH,?XSP + 1
   \   00011D   E0           MOVX    A,@DPTR
   \   00011E   64FF         XRL     A,#0xff
   \   000120   7004         JNZ     ??initNV_19
   \   000122   A3           INC     DPTR
   \   000123   E0           MOVX    A,@DPTR
   \   000124   64FF         XRL     A,#0xff
   \                     ??initNV_19:
   \   000126   7030         JNZ     ??initNV_20
   \   000128   7402         MOV     A,#0x2
   \   00012A   12....       LCALL   ?XSTACK_DISP0_8
   \   00012D   E0           MOVX    A,@DPTR
   \   00012E   64FF         XRL     A,#0xff
   \   000130   7004         JNZ     ??initNV_21
   \   000132   A3           INC     DPTR
   \   000133   E0           MOVX    A,@DPTR
   \   000134   64FF         XRL     A,#0xff
   \                     ??initNV_21:
   \   000136   7020         JNZ     ??initNV_20
   \   000138   7404         MOV     A,#0x4
   \   00013A   12....       LCALL   ?XSTACK_DISP0_8
   \   00013D   E0           MOVX    A,@DPTR
   \   00013E   64FF         XRL     A,#0xff
   \   000140   7004         JNZ     ??initNV_22
   \   000142   A3           INC     DPTR
   \   000143   E0           MOVX    A,@DPTR
   \   000144   64FF         XRL     A,#0xff
   \                     ??initNV_22:
   \   000146   7010         JNZ     ??initNV_20
   \   000148   7406         MOV     A,#0x6
   \   00014A   12....       LCALL   ?XSTACK_DISP0_8
   \   00014D   E0           MOVX    A,@DPTR
   \   00014E   64FF         XRL     A,#0xff
   \   000150   7004         JNZ     ??initNV_23
   \   000152   A3           INC     DPTR
   \   000153   E0           MOVX    A,@DPTR
   \   000154   64FF         XRL     A,#0xff
   \                     ??initNV_23:
   \   000156   6043         JZ      ??initNV_17
    353                {
    354                  writeWordM( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&pgHdr), 2 );
   \                     ??initNV_20:
   \   000158                ; Setup parameters for call to function writeWordM
   \   000158   75..02       MOV     ?V0 + 2,#0x2
   \   00015B   78..         MOV     R0,#?V0 + 2
   \   00015D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000160   7401         MOV     A,#0x1
   \   000162   12....       LCALL   ?XSTACK_DISP0_8
   \   000165   AC82         MOV     R4,DPL
   \   000167   AD83         MOV     R5,DPH
   \   000169   7AF8         MOV     R2,#-0x8
   \   00016B   7B07         MOV     R3,#0x7
   \   00016D   793F         MOV     R1,#0x3f
   \   00016F   12....       LCALL   ??writeWordM?relay
   \   000172   7401         MOV     A,#0x1
   \   000174   12....       LCALL   ?DEALLOC_XSTACK8
    355                  xBad = FALSE;
   \   000177   75..00       MOV     ?V0 + 1,#0x0
   \   00017A   801F         SJMP    ??initNV_17
    356                }
    357              }
    358              else
    359              {
    360                writeWordM( pg, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee), 2 );
   \                     ??initNV_18:
   \   00017C                ; Setup parameters for call to function writeWordM
   \   00017C   75..02       MOV     ?V0 + 2,#0x2
   \   00017F   78..         MOV     R0,#?V0 + 2
   \   000181   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000184   7409         MOV     A,#0x9
   \   000186   12....       LCALL   ?XSTACK_DISP0_8
   \   000189   AC82         MOV     R4,DPL
   \   00018B   AD83         MOV     R5,DPH
   \   00018D   7AF8         MOV     R2,#-0x8
   \   00018F   7B07         MOV     R3,#0x7
   \   000191   EE           MOV     A,R6
   \   000192   F9           MOV     R1,A
   \   000193   12....       LCALL   ??writeWordM?relay
   \   000196   7401         MOV     A,#0x1
   \   000198   12....       LCALL   ?DEALLOC_XSTACK8
    361              }
    362            }  // for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
   \                     ??initNV_17:
   \   00019B   0E           INC     R6
   \   00019C   02....       LJMP    ??initNV_6 & 0xFFFF
    363          
    364            /* First the old page is erased, and then the new page is put into use.
    365             * So if a transfer was in progress, the new page will always not yet be
    366             * marked as in use, since that is the last step to ending a transfer.
    367             */
    368            if ( newPg != OSAL_NV_PAGE_NULL )
   \                     ??initNV_7:
   \   00019F   EF           MOV     A,R7
   \   0001A0   6021         JZ      ??initNV_24
    369            {
    370              /* If there is already a fallow page reserved, keep it and put the newPg in use.
    371               * An unfinished compaction will finish to the new reserve page and the old page
    372               * will be erased and reserved.
    373               */
    374              if ( pgRes != OSAL_NV_PAGE_NULL )
   \   0001A2   90....       MOV     DPTR,#pgRes
   \   0001A5   E0           MOVX    A,@DPTR
   \   0001A6   6009         JZ      ??initNV_25
    375              {
    376                setPageUse( newPg, TRUE );
   \   0001A8                ; Setup parameters for call to function setPageUse
   \   0001A8   7A01         MOV     R2,#0x1
   \   0001AA   EF           MOV     A,R7
   \   0001AB   F9           MOV     R1,A
   \   0001AC   12....       LCALL   ??setPageUse?relay
   \   0001AF   8009         SJMP    ??initNV_26
    377              }
    378              /* If setting old page to 'xfer' failed or board reset before it was effected, there is no way
    379               * to know which page was the 'old page' - so just reset all NV pages to start clean.
    380               */
    381              else if ( oldPg != OSAL_NV_PAGE_NULL )
   \                     ??initNV_25:
   \   0001B1   E5..         MOV     A,?V0 + 0
   \   0001B3   6005         JZ      ??initNV_26
    382              {
    383                pgRes = newPg;
   \   0001B5   EF           MOV     A,R7
   \   0001B6   90....       MOV     DPTR,#pgRes
   \   0001B9   F0           MOVX    @DPTR,A
    384              }
    385          
    386              /* If a page compaction was interrupted and the page being compacted is not
    387               * yet erased, then there may be items remaining to xfer before erasing.
    388               */
    389              if ( oldPg != OSAL_NV_PAGE_NULL )
   \                     ??initNV_26:
   \   0001BA   E5..         MOV     A,?V0 + 0
   \   0001BC   6005         JZ      ??initNV_24
    390              {
    391                compactPage( oldPg );
   \   0001BE                ; Setup parameters for call to function compactPage
   \   0001BE   A9..         MOV     R1,?V0 + 0
   \   0001C0   12....       LCALL   ??compactPage?relay
    392              }
    393            }
    394          
    395            /* If no page met the criteria to be the reserve page:
    396             *  - A compactPage() failed or board reset before doing so.
    397             *  - Perhaps the user changed which Flash pages are dedicated to NV and downloaded the code
    398             *    without erasing Flash?
    399             */
    400            if ( pgRes == OSAL_NV_PAGE_NULL )
   \                     ??initNV_24:
   \   0001C3   90....       MOV     DPTR,#pgRes
   \   0001C6   E0           MOVX    A,@DPTR
   \   0001C7   7013         JNZ     ??initNV_27
    401            {
    402              for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
   \   0001C9   7E3C         MOV     R6,#0x3c
   \                     ??initNV_28:
   \   0001CB   EE           MOV     A,R6
   \   0001CC   C3           CLR     C
   \   0001CD   943E         SUBB    A,#0x3e
   \   0001CF   5008         JNC     ??initNV_29
    403              {
    404                erasePage( pg );
   \   0001D1                ; Setup parameters for call to function erasePage
   \   0001D1   EE           MOV     A,R6
   \   0001D2   F9           MOV     R1,A
   \   0001D3   12....       LCALL   ??erasePage?relay
    405              }
   \   0001D6   0E           INC     R6
   \   0001D7   80F2         SJMP    ??initNV_28
    406              initNV();
   \                     ??initNV_29:
   \   0001D9                ; Setup parameters for call to function initNV
   \   0001D9   12....       LCALL   ??initNV?relay
    407            }
    408          
    409            return TRUE;
   \                     ??initNV_27:
   \   0001DC   7901         MOV     R1,#0x1
   \   0001DE   7410         MOV     A,#0x10
   \   0001E0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001E3   7F05         MOV     R7,#0x5
   \   0001E5   02....       LJMP    ?BANKED_LEAVE_XDATA
    410          }
    411          
    412          /*********************************************************************
    413           * @fn      setPageUse
    414           *
    415           * @brief   Set page header active/inUse state according to 'inUse'.
    416           *
    417           * @param   pg - Valid NV page to verify and init.
    418           * @param   inUse - Boolean TRUE if inUse, FALSE if only active.
    419           *
    420           * @return  none
    421           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    422          static void setPageUse( uint8 pg, uint8 inUse )
   \                     setPageUse:
    423          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   EA           MOV     A,R2
   \   00000D   FF           MOV     R7,A
    424            osalNvPgHdr_t pgHdr;
    425          
    426            pgHdr.active = OSAL_NV_ZEROED_ID;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7400         MOV     A,#0x0
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   7400         MOV     A,#0x0
   \   00001A   F0           MOVX    @DPTR,A
    427          
    428            if ( inUse )
   \   00001B   EF           MOV     A,R7
   \   00001C   600E         JZ      ??setPageUse_0
    429            {
    430              pgHdr.inUse = OSAL_NV_ZEROED_ID;
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   7400         MOV     A,#0x0
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   7400         MOV     A,#0x0
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   800C         SJMP    ??setPageUse_1
    431            }
    432            else
    433            {
    434              pgHdr.inUse = OSAL_NV_ERASED_ID;
   \                     ??setPageUse_0:
   \   00002C   7402         MOV     A,#0x2
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   74FF         MOV     A,#-0x1
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   74FF         MOV     A,#-0x1
   \   000037   F0           MOVX    @DPTR,A
    435            }
    436          
    437            writeWord( pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8*)(&pgHdr) );
   \                     ??setPageUse_1:
   \   000038                ; Setup parameters for call to function writeWord
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   AC82         MOV     R4,DPL
   \   000040   AD83         MOV     R5,DPH
   \   000042   7A00         MOV     R2,#0x0
   \   000044   7B00         MOV     R3,#0x0
   \   000046   EE           MOV     A,R6
   \   000047   F9           MOV     R1,A
   \   000048   12....       LCALL   ??writeWord?relay
    438          }
   \   00004B   7408         MOV     A,#0x8
   \   00004D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000050   7F01         MOV     R7,#0x1
   \   000052   02....       LJMP    ?BANKED_LEAVE_XDATA
    439          
    440          /*********************************************************************
    441           * @fn      initPage
    442           *
    443           * @brief   Walk the page items; calculate checksums, lost bytes & page offset.
    444           *
    445           * @param   pg - Valid NV page to verify and init.
    446           * @param   id - Valid NV item Id to use function as a "findItem".
    447           *               If set to NULL then just perform the page initialization.
    448           *
    449           * @return  If 'id' is non-NULL and good checksums are found, return the offset
    450           *          of the data corresponding to item Id; else OSAL_NV_ITEM_NULL.
    451           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    452          static uint16 initPage( uint8 pg, uint16 id, uint8 findDups )
   \                     initPage:
    453          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   89..         MOV     ?V0 + 0,R1
   \   000016   8C..         MOV     ?V0 + 1,R4
    454            uint16 offset = OSAL_NV_PAGE_HDR_SIZE;
   \   000018   75..08       MOV     ?V0 + 2,#0x8
   \   00001B   75..00       MOV     ?V0 + 3,#0x0
    455            uint16 sz, lost = 0;
   \   00001E   7E00         MOV     R6,#0x0
   \   000020   7F00         MOV     R7,#0x0
    456            osalNvHdr_t hdr;
    457          
    458            do
    459            {
    460              nvReadHdr( pg, offset, (uint8 *)(&hdr) );
   \                     ??initPage_0:
   \   000022                ; Setup parameters for call to function nvReadHdr
   \   000022   7404         MOV     A,#0x4
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   AC82         MOV     R4,DPL
   \   000029   AD83         MOV     R5,DPH
   \   00002B   AA..         MOV     R2,?V0 + 2
   \   00002D   AB..         MOV     R3,?V0 + 3
   \   00002F   A9..         MOV     R1,?V0 + 0
   \   000031   12....       LCALL   nvReadHdr & 0xFFFF
    461          
    462              if ( hdr.id == OSAL_NV_ERASED_ID )
   \   000034   7404         MOV     A,#0x4
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   64FF         XRL     A,#0xff
   \   00003C   7004         JNZ     ??initPage_1
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   64FF         XRL     A,#0xff
   \                     ??initPage_1:
   \   000042   7003         JNZ     $+5
   \   000044   02....       LJMP    ??initPage_2 & 0xFFFF
    463              {
    464                break;
    465              }
    466              offset += OSAL_NV_HDR_SIZE;
   \   000047   E5..         MOV     A,?V0 + 2
   \   000049   2408         ADD     A,#0x8
   \   00004B   F5..         MOV     ?V0 + 2,A
   \   00004D   E5..         MOV     A,?V0 + 3
   \   00004F   3400         ADDC    A,#0x0
   \   000051   F5..         MOV     ?V0 + 3,A
    467              sz = OSAL_NV_DATA_SIZE( hdr.len );
   \   000053   7406         MOV     A,#0x6
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   E0           MOVX    A,@DPTR
   \   000059   2403         ADD     A,#0x3
   \   00005B   F5..         MOV     ?V0 + 4,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   3400         ADDC    A,#0x0
   \   000061   F5..         MOV     ?V0 + 5,A
   \   000063   7402         MOV     A,#0x2
   \   000065   78..         MOV     R0,#?V0 + 4
   \   000067   12....       LCALL   ?US_SHR
   \   00006A   E5..         MOV     A,?V0 + 4
   \   00006C   75F004       MOV     B,#0x4
   \   00006F   A4           MUL     AB
   \   000070   C5..         XCH     A,?V0 + 4
   \   000072   AAF0         MOV     R2,B
   \   000074   75F000       MOV     B,#0x0
   \   000077   A4           MUL     AB
   \   000078   2A           ADD     A,R2
   \   000079   FA           MOV     R2,A
   \   00007A   75F004       MOV     B,#0x4
   \   00007D   E5..         MOV     A,?V0 + 5
   \   00007F   A4           MUL     AB
   \   000080   2A           ADD     A,R2
   \   000081   F5..         MOV     ?V0 + 5,A
   \   000083   85..82       MOV     DPL,?XSP + 0
   \   000086   85..83       MOV     DPH,?XSP + 1
   \   000089   E5..         MOV     A,?V0 + 4
   \   00008B   F0           MOVX    @DPTR,A
   \   00008C   A3           INC     DPTR
   \   00008D   E5..         MOV     A,?V0 + 5
   \   00008F   F0           MOVX    @DPTR,A
    468          
    469              // A bad 'len' write has blown away the rest of the page.
    470              if ( (offset + sz) > OSAL_NV_PAGE_FREE )
   \   000090   85..82       MOV     DPL,?XSP + 0
   \   000093   85..83       MOV     DPH,?XSP + 1
   \   000096   E0           MOVX    A,@DPTR
   \   000097   25..         ADD     A,?V0 + 2
   \   000099   F8           MOV     R0,A
   \   00009A   A3           INC     DPTR
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   35..         ADDC    A,?V0 + 3
   \   00009E   F9           MOV     R1,A
   \   00009F   C3           CLR     C
   \   0000A0   E8           MOV     A,R0
   \   0000A1   94F9         SUBB    A,#-0x7
   \   0000A3   E9           MOV     A,R1
   \   0000A4   9407         SUBB    A,#0x7
   \   0000A6   401A         JC      ??initPage_3
    471              {
    472                lost += (OSAL_NV_PAGE_FREE - offset + OSAL_NV_HDR_SIZE);
   \   0000A8   7400         MOV     A,#0x0
   \   0000AA   2E           ADD     A,R6
   \   0000AB   F8           MOV     R0,A
   \   0000AC   7408         MOV     A,#0x8
   \   0000AE   3F           ADDC    A,R7
   \   0000AF   F9           MOV     R1,A
   \   0000B0   E8           MOV     A,R0
   \   0000B1   C3           CLR     C
   \   0000B2   95..         SUBB    A,?V0 + 2
   \   0000B4   FE           MOV     R6,A
   \   0000B5   E9           MOV     A,R1
   \   0000B6   95..         SUBB    A,?V0 + 3
   \   0000B8   FF           MOV     R7,A
    473                offset = OSAL_NV_PAGE_FREE;
   \   0000B9   75..F8       MOV     ?V0 + 2,#-0x8
   \   0000BC   75..07       MOV     ?V0 + 3,#0x7
    474                break;
   \   0000BF   02....       LJMP    ??initPage_2 & 0xFFFF
    475              }
    476          
    477              if ( hdr.id != OSAL_NV_ZEROED_ID )
   \                     ??initPage_3:
   \   0000C2   7404         MOV     A,#0x4
   \   0000C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   6400         XRL     A,#0x0
   \   0000CA   7004         JNZ     ??initPage_4
   \   0000CC   A3           INC     DPTR
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   6400         XRL     A,#0x0
   \                     ??initPage_4:
   \   0000D0   7003         JNZ     $+5
   \   0000D2   02....       LJMP    ??initPage_5 & 0xFFFF
    478              {
    479                /* This trick allows function to do double duty for findItem() without
    480                 * compromising its essential functionality at powerup initialization.
    481                 */
    482                if ( id != OSAL_NV_ITEM_NULL )
   \   0000D5   7402         MOV     A,#0x2
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   6400         XRL     A,#0x0
   \   0000DD   7004         JNZ     ??initPage_6
   \   0000DF   A3           INC     DPTR
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   6400         XRL     A,#0x0
   \                     ??initPage_6:
   \   0000E3   607C         JZ      ??initPage_7
    483                {
    484                  /* This trick allows asking to find the old/transferred item in case
    485                   * of a successful new item write that gets interrupted before the
    486                   * old item can be zeroed out.
    487                   */
    488                  if ( (id & 0x7fff) == hdr.id )
   \   0000E5   7402         MOV     A,#0x2
   \   0000E7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   54FF         ANL     A,#0xff
   \   0000ED   F8           MOV     R0,A
   \   0000EE   A3           INC     DPTR
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   547F         ANL     A,#0x7f
   \   0000F2   F9           MOV     R1,A
   \   0000F3   7404         MOV     A,#0x4
   \   0000F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F8   E0           MOVX    A,@DPTR
   \   0000F9   68           XRL     A,R0
   \   0000FA   7003         JNZ     ??initPage_8
   \   0000FC   A3           INC     DPTR
   \   0000FD   E0           MOVX    A,@DPTR
   \   0000FE   69           XRL     A,R1
   \                     ??initPage_8:
   \   0000FF   6003         JZ      $+5
   \   000101   02....       LJMP    ??initPage_9 & 0xFFFF
    489                  {
    490                    if ( (((id & OSAL_NV_SOURCE_ID) == 0) && (hdr.stat == OSAL_NV_ERASED_ID)) ||
    491                         (((id & OSAL_NV_SOURCE_ID) != 0) && (hdr.stat != OSAL_NV_ERASED_ID)) )
   \   000104   7402         MOV     A,#0x2
   \   000106   12....       LCALL   ?XSTACK_DISP0_8
   \   000109   E0           MOVX    A,@DPTR
   \   00010A   5400         ANL     A,#0x0
   \   00010C   F8           MOV     R0,A
   \   00010D   A3           INC     DPTR
   \   00010E   E0           MOVX    A,@DPTR
   \   00010F   5480         ANL     A,#0x80
   \   000111   F9           MOV     R1,A
   \   000112   7400         MOV     A,#0x0
   \   000114   68           XRL     A,R0
   \   000115   7003         JNZ     ??initPage_10
   \   000117   7400         MOV     A,#0x0
   \   000119   69           XRL     A,R1
   \                     ??initPage_10:
   \   00011A   7010         JNZ     ??initPage_11
   \   00011C   740A         MOV     A,#0xa
   \   00011E   12....       LCALL   ?XSTACK_DISP0_8
   \   000121   E0           MOVX    A,@DPTR
   \   000122   64FF         XRL     A,#0xff
   \   000124   7004         JNZ     ??initPage_12
   \   000126   A3           INC     DPTR
   \   000127   E0           MOVX    A,@DPTR
   \   000128   64FF         XRL     A,#0xff
   \                     ??initPage_12:
   \   00012A   602E         JZ      ??initPage_13
   \                     ??initPage_11:
   \   00012C   7402         MOV     A,#0x2
   \   00012E   12....       LCALL   ?XSTACK_DISP0_8
   \   000131   E0           MOVX    A,@DPTR
   \   000132   5400         ANL     A,#0x0
   \   000134   F8           MOV     R0,A
   \   000135   A3           INC     DPTR
   \   000136   E0           MOVX    A,@DPTR
   \   000137   5480         ANL     A,#0x80
   \   000139   F9           MOV     R1,A
   \   00013A   7400         MOV     A,#0x0
   \   00013C   68           XRL     A,R0
   \   00013D   7003         JNZ     ??initPage_14
   \   00013F   7400         MOV     A,#0x0
   \   000141   69           XRL     A,R1
   \                     ??initPage_14:
   \   000142   7003         JNZ     $+5
   \   000144   02....       LJMP    ??initPage_9 & 0xFFFF
   \   000147   740A         MOV     A,#0xa
   \   000149   12....       LCALL   ?XSTACK_DISP0_8
   \   00014C   E0           MOVX    A,@DPTR
   \   00014D   64FF         XRL     A,#0xff
   \   00014F   7004         JNZ     ??initPage_15
   \   000151   A3           INC     DPTR
   \   000152   E0           MOVX    A,@DPTR
   \   000153   64FF         XRL     A,#0xff
   \                     ??initPage_15:
   \   000155   7003         JNZ     $+5
   \   000157   02....       LJMP    ??initPage_9 & 0xFFFF
    492                    {
    493                      return offset;
   \                     ??initPage_13:
   \   00015A   AA..         MOV     R2,?V0 + 2
   \   00015C   AB..         MOV     R3,?V0 + 3
   \   00015E   02....       LJMP    ??initPage_16 & 0xFFFF
    494                    }
    495                  }
    496                }
    497                // When invoked from the osal_nv_init(), verify checksums and find & zero any duplicates.
    498                else
    499                {
    500                  if ( hdr.chk == calcChkF( pg, offset, hdr.len ) )
   \                     ??initPage_7:
   \   000161                ; Setup parameters for call to function calcChkF
   \   000161   7406         MOV     A,#0x6
   \   000163   12....       LCALL   ?XSTACK_DISP0_8
   \   000166   E0           MOVX    A,@DPTR
   \   000167   FC           MOV     R4,A
   \   000168   A3           INC     DPTR
   \   000169   E0           MOVX    A,@DPTR
   \   00016A   FD           MOV     R5,A
   \   00016B   AA..         MOV     R2,?V0 + 2
   \   00016D   AB..         MOV     R3,?V0 + 3
   \   00016F   A9..         MOV     R1,?V0 + 0
   \   000171   12....       LCALL   ??calcChkF?relay
   \   000174   8A..         MOV     ?V0 + 4,R2
   \   000176   8B..         MOV     ?V0 + 5,R3
   \   000178   A8..         MOV     R0,?V0 + 4
   \   00017A   A9..         MOV     R1,?V0 + 5
   \   00017C   7408         MOV     A,#0x8
   \   00017E   12....       LCALL   ?XSTACK_DISP0_8
   \   000181   E0           MOVX    A,@DPTR
   \   000182   68           XRL     A,R0
   \   000183   7003         JNZ     ??initPage_17
   \   000185   A3           INC     DPTR
   \   000186   E0           MOVX    A,@DPTR
   \   000187   69           XRL     A,R1
   \                     ??initPage_17:
   \   000188   7065         JNZ     ??initPage_18
    501                  {
    502                    if ( findDups )
   \   00018A   E5..         MOV     A,?V0 + 1
   \   00018C   604A         JZ      ??initPage_19
    503                    {
    504                      if ( hdr.stat == OSAL_NV_ERASED_ID )
   \   00018E   740A         MOV     A,#0xa
   \   000190   12....       LCALL   ?XSTACK_DISP0_8
   \   000193   E0           MOVX    A,@DPTR
   \   000194   64FF         XRL     A,#0xff
   \   000196   7004         JNZ     ??initPage_20
   \   000198   A3           INC     DPTR
   \   000199   E0           MOVX    A,@DPTR
   \   00019A   64FF         XRL     A,#0xff
   \                     ??initPage_20:
   \   00019C   6003         JZ      $+5
   \   00019E   02....       LJMP    ??initPage_9 & 0xFFFF
    505                      {
    506                        /* The trick of setting the MSB of the item Id causes the logic
    507                         * immediately above to return a valid page only if the header 'stat'
    508                         * indicates that it was the older item being transferred.
    509                         */
    510                        uint16 off = findItem( (hdr.id | OSAL_NV_SOURCE_ID) );
   \   0001A1                ; Setup parameters for call to function findItem
   \   0001A1   7404         MOV     A,#0x4
   \   0001A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A6   E0           MOVX    A,@DPTR
   \   0001A7   4400         ORL     A,#0x0
   \   0001A9   FA           MOV     R2,A
   \   0001AA   A3           INC     DPTR
   \   0001AB   E0           MOVX    A,@DPTR
   \   0001AC   4480         ORL     A,#0x80
   \   0001AE   FB           MOV     R3,A
   \   0001AF   12....       LCALL   ??findItem?relay
   \   0001B2   8A..         MOV     ?V0 + 4,R2
   \   0001B4   8B..         MOV     ?V0 + 5,R3
   \   0001B6   85....       MOV     ?V0 + 6,?V0 + 4
   \   0001B9   85....       MOV     ?V0 + 7,?V0 + 5
    511            
    512                        if ( off != OSAL_NV_ITEM_NULL )
   \   0001BC   7400         MOV     A,#0x0
   \   0001BE   65..         XRL     A,?V0 + 6
   \   0001C0   7004         JNZ     ??initPage_21
   \   0001C2   7400         MOV     A,#0x0
   \   0001C4   65..         XRL     A,?V0 + 7
   \                     ??initPage_21:
   \   0001C6   605E         JZ      ??initPage_9
    513                        {
    514                          setItem( findPg, off, eNvZero );  // Mark old duplicate as invalid.
   \   0001C8                ; Setup parameters for call to function setItem
   \   0001C8   7C01         MOV     R4,#0x1
   \   0001CA   AA..         MOV     R2,?V0 + 6
   \   0001CC   AB..         MOV     R3,?V0 + 7
   \   0001CE   90....       MOV     DPTR,#findPg
   \   0001D1   E0           MOVX    A,@DPTR
   \   0001D2   F9           MOV     R1,A
   \   0001D3   12....       LCALL   ??setItem?relay
   \   0001D6   804E         SJMP    ??initPage_9
    515                        }
    516                      }
    517                    }
    518                    // Any "old" item immediately exits and triggers the N^2 exhaustive initialization.
    519                    else if ( hdr.stat != OSAL_NV_ERASED_ID )
   \                     ??initPage_19:
   \   0001D8   740A         MOV     A,#0xa
   \   0001DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DD   E0           MOVX    A,@DPTR
   \   0001DE   64FF         XRL     A,#0xff
   \   0001E0   7004         JNZ     ??initPage_22
   \   0001E2   A3           INC     DPTR
   \   0001E3   E0           MOVX    A,@DPTR
   \   0001E4   64FF         XRL     A,#0xff
   \                     ??initPage_22:
   \   0001E6   603E         JZ      ??initPage_9
    520                    {
    521                      return OSAL_NV_ERASED_ID;
   \   0001E8   7AFF         MOV     R2,#-0x1
   \   0001EA   7BFF         MOV     R3,#-0x1
   \   0001EC   02....       LJMP    ??initPage_16 & 0xFFFF
    522                    }
    523                  }
    524                  else
    525                  {
    526                    setItem( pg, offset, eNvZero );  // Mark bad checksum as invalid.
   \                     ??initPage_18:
   \   0001EF                ; Setup parameters for call to function setItem
   \   0001EF   7C01         MOV     R4,#0x1
   \   0001F1   AA..         MOV     R2,?V0 + 2
   \   0001F3   AB..         MOV     R3,?V0 + 3
   \   0001F5   A9..         MOV     R1,?V0 + 0
   \   0001F7   12....       LCALL   ??setItem?relay
    527                    lost += (OSAL_NV_HDR_SIZE + sz);
   \   0001FA   85..82       MOV     DPL,?XSP + 0
   \   0001FD   85..83       MOV     DPH,?XSP + 1
   \   000200   E0           MOVX    A,@DPTR
   \   000201   2408         ADD     A,#0x8
   \   000203   F8           MOV     R0,A
   \   000204   A3           INC     DPTR
   \   000205   E0           MOVX    A,@DPTR
   \   000206   3400         ADDC    A,#0x0
   \   000208   F9           MOV     R1,A
   \   000209   EE           MOV     A,R6
   \   00020A   28           ADD     A,R0
   \   00020B   FE           MOV     R6,A
   \   00020C   EF           MOV     A,R7
   \   00020D   39           ADDC    A,R1
   \   00020E   FF           MOV     R7,A
   \   00020F   8015         SJMP    ??initPage_9
    528                  }
    529                }
    530              }
    531              else
    532              {
    533                lost += (OSAL_NV_HDR_SIZE + sz);
   \                     ??initPage_5:
   \   000211   85..82       MOV     DPL,?XSP + 0
   \   000214   85..83       MOV     DPH,?XSP + 1
   \   000217   E0           MOVX    A,@DPTR
   \   000218   2408         ADD     A,#0x8
   \   00021A   F8           MOV     R0,A
   \   00021B   A3           INC     DPTR
   \   00021C   E0           MOVX    A,@DPTR
   \   00021D   3400         ADDC    A,#0x0
   \   00021F   F9           MOV     R1,A
   \   000220   EE           MOV     A,R6
   \   000221   28           ADD     A,R0
   \   000222   FE           MOV     R6,A
   \   000223   EF           MOV     A,R7
   \   000224   39           ADDC    A,R1
   \   000225   FF           MOV     R7,A
    534              }
    535              offset += sz;
   \                     ??initPage_9:
   \   000226   85..82       MOV     DPL,?XSP + 0
   \   000229   85..83       MOV     DPH,?XSP + 1
   \   00022C   E0           MOVX    A,@DPTR
   \   00022D   25..         ADD     A,?V0 + 2
   \   00022F   F5..         MOV     ?V0 + 2,A
   \   000231   A3           INC     DPTR
   \   000232   E0           MOVX    A,@DPTR
   \   000233   35..         ADDC    A,?V0 + 3
   \   000235   F5..         MOV     ?V0 + 3,A
    536          
    537            } while ( TRUE );
   \   000237   02....       LJMP    ??initPage_0 & 0xFFFF
    538          
    539            pgOff[pg - OSAL_NV_PAGE_BEG] = offset;
   \                     ??initPage_2:
   \   00023A   A8..         MOV     R0,?V0 + 0
   \   00023C   7900         MOV     R1,#0x0
   \   00023E   E8           MOV     A,R0
   \   00023F   75F002       MOV     B,#0x2
   \   000242   A4           MUL     AB
   \   000243   C8           XCH     A,R0
   \   000244   AAF0         MOV     R2,B
   \   000246   75F000       MOV     B,#0x0
   \   000249   A4           MUL     AB
   \   00024A   2A           ADD     A,R2
   \   00024B   FA           MOV     R2,A
   \   00024C   75F002       MOV     B,#0x2
   \   00024F   E9           MOV     A,R1
   \   000250   A4           MUL     AB
   \   000251   2A           ADD     A,R2
   \   000252   F9           MOV     R1,A
   \   000253   E8           MOV     A,R0
   \   000254   24..         ADD     A,#((pgOff + 136) & 0xff)
   \   000256   F582         MOV     DPL,A
   \   000258   E9           MOV     A,R1
   \   000259   34..         ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
   \   00025B   F583         MOV     DPH,A
   \   00025D   E5..         MOV     A,?V0 + 2
   \   00025F   F0           MOVX    @DPTR,A
   \   000260   A3           INC     DPTR
   \   000261   E5..         MOV     A,?V0 + 3
   \   000263   F0           MOVX    @DPTR,A
    540            pgLost[pg - OSAL_NV_PAGE_BEG] = lost;
   \   000264   A8..         MOV     R0,?V0 + 0
   \   000266   7900         MOV     R1,#0x0
   \   000268   E8           MOV     A,R0
   \   000269   75F002       MOV     B,#0x2
   \   00026C   A4           MUL     AB
   \   00026D   C8           XCH     A,R0
   \   00026E   AAF0         MOV     R2,B
   \   000270   75F000       MOV     B,#0x0
   \   000273   A4           MUL     AB
   \   000274   2A           ADD     A,R2
   \   000275   FA           MOV     R2,A
   \   000276   75F002       MOV     B,#0x2
   \   000279   E9           MOV     A,R1
   \   00027A   A4           MUL     AB
   \   00027B   2A           ADD     A,R2
   \   00027C   F9           MOV     R1,A
   \   00027D   E8           MOV     A,R0
   \   00027E   24..         ADD     A,#((pgLost + 136) & 0xff)
   \   000280   F582         MOV     DPL,A
   \   000282   E9           MOV     A,R1
   \   000283   34..         ADDC    A,#(((pgLost - 120) >> 8) & 0xff)
   \   000285   F583         MOV     DPH,A
   \   000287   EE           MOV     A,R6
   \   000288   F0           MOVX    @DPTR,A
   \   000289   A3           INC     DPTR
   \   00028A   EF           MOV     A,R7
   \   00028B   F0           MOVX    @DPTR,A
    541          
    542            return OSAL_NV_ITEM_NULL;
   \   00028C   7A00         MOV     R2,#0x0
   \   00028E   7B00         MOV     R3,#0x0
   \                     ??initPage_16:
   \   000290   740C         MOV     A,#0xc
   \   000292   12....       LCALL   ?DEALLOC_XSTACK8
   \   000295   7F08         MOV     R7,#0x8
   \   000297   02....       LJMP    ?BANKED_LEAVE_XDATA
    543          }
    544          
    545          /*********************************************************************
    546           * @fn      erasePage
    547           *
    548           * @brief   Erases a page in Flash.
    549           *
    550           * @param   pg - Valid NV page to erase.
    551           *
    552           * @return  none
    553           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    554          static void erasePage( uint8 pg )
   \                     erasePage:
    555          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    556            halIntState_t intState;
    557            osalNvHdr_t ieee;
    558          
    559            if ( !OSAL_NV_CHECK_BUS_VOLTAGE )
   \   00000C                ; Setup parameters for call to function HalAdcCheckVdd
   \   00000C   7904         MOV     R1,#0x4
   \   00000E   12....       LCALL   ??HalAdcCheckVdd?relay
   \   000011   E9           MOV     A,R1
   \   000012   7009         JNZ     ??erasePage_0
    560            {
    561              failF = TRUE;
   \   000014   7401         MOV     A,#0x1
   \   000016   90....       MOV     DPTR,#failF
   \   000019   F0           MOVX    @DPTR,A
    562              return;
   \   00001A   02....       LJMP    ??erasePage_1 & 0xFFFF
    563            }
    564          
    565            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \                     ??erasePage_0:
   \   00001D   A2AF         MOV     C,0xa8.7
   \   00001F   E4           CLR     A
   \   000020   92E0         MOV     0xE0 /* A   */.0,C
   \   000022   FF           MOV     R7,A
   \   000023   C2AF         CLR     0xa8.7
    566            FADDRH = (pg) << 1;
   \   000025   EE           MOV     A,R6
   \   000026   C3           CLR     C
   \   000027   33           RLC     A
   \   000028   F5AD         MOV     0xad,A
    567            FCTL = 0x01;
   \   00002A   75AE01       MOV     0xae,#0x1
    568            asm("NOP");
   \   00002D   00           NOP
    569            while(FCTL == 0x80);
   \                     ??erasePage_2:
   \   00002E   7480         MOV     A,#-0x80
   \   000030   65AE         XRL     A,0xae
   \   000032   60FA         JZ      ??erasePage_2
    570            HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \   000034   EF           MOV     A,R7
   \   000035   A2E0         MOV     C,0xE0 /* A   */.0
   \   000037   92AF         MOV     0xa8.7,C
    571          
    572            pgOff[pg - OSAL_NV_PAGE_BEG] = OSAL_NV_PAGE_HDR_SIZE;
   \   000039   EE           MOV     A,R6
   \   00003A   F8           MOV     R0,A
   \   00003B   7900         MOV     R1,#0x0
   \   00003D   E8           MOV     A,R0
   \   00003E   75F002       MOV     B,#0x2
   \   000041   A4           MUL     AB
   \   000042   C8           XCH     A,R0
   \   000043   AAF0         MOV     R2,B
   \   000045   75F000       MOV     B,#0x0
   \   000048   A4           MUL     AB
   \   000049   2A           ADD     A,R2
   \   00004A   FA           MOV     R2,A
   \   00004B   75F002       MOV     B,#0x2
   \   00004E   E9           MOV     A,R1
   \   00004F   A4           MUL     AB
   \   000050   2A           ADD     A,R2
   \   000051   F9           MOV     R1,A
   \   000052   E8           MOV     A,R0
   \   000053   24..         ADD     A,#((pgOff + 136) & 0xff)
   \   000055   F582         MOV     DPL,A
   \   000057   E9           MOV     A,R1
   \   000058   34..         ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
   \   00005A   F583         MOV     DPH,A
   \   00005C   7408         MOV     A,#0x8
   \   00005E   F0           MOVX    @DPTR,A
   \   00005F   A3           INC     DPTR
   \   000060   7400         MOV     A,#0x0
   \   000062   F0           MOVX    @DPTR,A
    573            pgLost[pg - OSAL_NV_PAGE_BEG] = 0;
   \   000063   EE           MOV     A,R6
   \   000064   F8           MOV     R0,A
   \   000065   7900         MOV     R1,#0x0
   \   000067   E8           MOV     A,R0
   \   000068   75F002       MOV     B,#0x2
   \   00006B   A4           MUL     AB
   \   00006C   C8           XCH     A,R0
   \   00006D   AAF0         MOV     R2,B
   \   00006F   75F000       MOV     B,#0x0
   \   000072   A4           MUL     AB
   \   000073   2A           ADD     A,R2
   \   000074   FA           MOV     R2,A
   \   000075   75F002       MOV     B,#0x2
   \   000078   E9           MOV     A,R1
   \   000079   A4           MUL     AB
   \   00007A   2A           ADD     A,R2
   \   00007B   F9           MOV     R1,A
   \   00007C   E8           MOV     A,R0
   \   00007D   24..         ADD     A,#((pgLost + 136) & 0xff)
   \   00007F   F582         MOV     DPL,A
   \   000081   E9           MOV     A,R1
   \   000082   34..         ADDC    A,#(((pgLost - 120) >> 8) & 0xff)
   \   000084   F583         MOV     DPH,A
   \   000086   7400         MOV     A,#0x0
   \   000088   F0           MOVX    @DPTR,A
   \   000089   A3           INC     DPTR
   \   00008A   7400         MOV     A,#0x0
   \   00008C   F0           MOVX    @DPTR,A
    574          
    575            nvReadHdr( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee) );
   \   00008D                ; Setup parameters for call to function nvReadHdr
   \   00008D   85..82       MOV     DPL,?XSP + 0
   \   000090   85..83       MOV     DPH,?XSP + 1
   \   000093   AC82         MOV     R4,DPL
   \   000095   AD83         MOV     R5,DPH
   \   000097   7AF8         MOV     R2,#-0x8
   \   000099   7B07         MOV     R3,#0x7
   \   00009B   793F         MOV     R1,#0x3f
   \   00009D   12....       LCALL   nvReadHdr & 0xFFFF
    576            writeWordM( pg, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee), 2 );
   \   0000A0                ; Setup parameters for call to function writeWordM
   \   0000A0   75..02       MOV     ?V0 + 0,#0x2
   \   0000A3   78..         MOV     R0,#?V0 + 0
   \   0000A5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A8   7401         MOV     A,#0x1
   \   0000AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AD   AC82         MOV     R4,DPL
   \   0000AF   AD83         MOV     R5,DPH
   \   0000B1   7AF8         MOV     R2,#-0x8
   \   0000B3   7B07         MOV     R3,#0x7
   \   0000B5   EE           MOV     A,R6
   \   0000B6   F9           MOV     R1,A
   \   0000B7   12....       LCALL   ??writeWordM?relay
   \   0000BA   7401         MOV     A,#0x1
   \   0000BC   12....       LCALL   ?DEALLOC_XSTACK8
    577          }
   \                     ??erasePage_1:
   \   0000BF   7408         MOV     A,#0x8
   \   0000C1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C4   7F01         MOV     R7,#0x1
   \   0000C6   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   0000C9                REQUIRE _A_IEN0
   \   0000C9                REQUIRE FADDRH
   \   0000C9                REQUIRE FCTL
    578          
    579          /*********************************************************************
    580           * @fn      compactPage
    581           *
    582           * @brief   Compacts the page specified.
    583           *
    584           * @param   srcPg - Valid NV page to erase.
    585           *
    586           * @return  none
    587           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    588          static void compactPage( uint8 srcPg )
   \                     compactPage:
    589          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    590            uint16 dstOff = pgOff[pgRes-OSAL_NV_PAGE_BEG];
   \   00000C   90....       MOV     DPTR,#pgRes
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F8           MOV     R0,A
   \   000011   7900         MOV     R1,#0x0
   \   000013   E8           MOV     A,R0
   \   000014   75F002       MOV     B,#0x2
   \   000017   A4           MUL     AB
   \   000018   C8           XCH     A,R0
   \   000019   AAF0         MOV     R2,B
   \   00001B   75F000       MOV     B,#0x0
   \   00001E   A4           MUL     AB
   \   00001F   2A           ADD     A,R2
   \   000020   FA           MOV     R2,A
   \   000021   75F002       MOV     B,#0x2
   \   000024   E9           MOV     A,R1
   \   000025   A4           MUL     AB
   \   000026   2A           ADD     A,R2
   \   000027   F9           MOV     R1,A
   \   000028   E8           MOV     A,R0
   \   000029   24..         ADD     A,#((pgOff + 136) & 0xff)
   \   00002B   F582         MOV     DPL,A
   \   00002D   E9           MOV     A,R1
   \   00002E   34..         ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
   \   000030   F583         MOV     DPH,A
   \   000032   E0           MOVX    A,@DPTR
   \   000033   F5..         MOV     ?V0 + 0,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F5..         MOV     ?V0 + 1,A
    591            uint16 srcOff = OSAL_NV_ZEROED_ID;
   \   000039   85..82       MOV     DPL,?XSP + 0
   \   00003C   85..83       MOV     DPH,?XSP + 1
   \   00003F   7400         MOV     A,#0x0
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   7400         MOV     A,#0x0
   \   000045   F0           MOVX    @DPTR,A
    592            osalNvHdr_t hdr;
    593          
    594            // Mark page as being in process of compaction.
    595            writeWordH( srcPg, OSAL_NV_PG_XFER, (uint8*)(&srcOff) );
   \   000046                ; Setup parameters for call to function writeWordH
   \   000046   85..82       MOV     DPL,?XSP + 0
   \   000049   85..83       MOV     DPH,?XSP + 1
   \   00004C   AC82         MOV     R4,DPL
   \   00004E   AD83         MOV     R5,DPH
   \   000050   7A04         MOV     R2,#0x4
   \   000052   7B00         MOV     R3,#0x0
   \   000054   EE           MOV     A,R6
   \   000055   F9           MOV     R1,A
   \   000056   12....       LCALL   ??writeWordH?relay
    596          
    597            srcOff = OSAL_NV_PAGE_HDR_SIZE;
   \   000059   85..82       MOV     DPL,?XSP + 0
   \   00005C   85..83       MOV     DPH,?XSP + 1
   \   00005F   7408         MOV     A,#0x8
   \   000061   F0           MOVX    @DPTR,A
   \   000062   A3           INC     DPTR
   \   000063   7400         MOV     A,#0x0
   \   000065   F0           MOVX    @DPTR,A
    598          
    599            do
    600            {
    601              uint16 sz;
    602              nvReadHdr( srcPg, srcOff, (uint8 *)(&hdr) );
   \                     ??compactPage_0:
   \   000066                ; Setup parameters for call to function nvReadHdr
   \   000066   7402         MOV     A,#0x2
   \   000068   12....       LCALL   ?XSTACK_DISP0_8
   \   00006B   AC82         MOV     R4,DPL
   \   00006D   AD83         MOV     R5,DPH
   \   00006F   85..82       MOV     DPL,?XSP + 0
   \   000072   85..83       MOV     DPH,?XSP + 1
   \   000075   E0           MOVX    A,@DPTR
   \   000076   FA           MOV     R2,A
   \   000077   A3           INC     DPTR
   \   000078   E0           MOVX    A,@DPTR
   \   000079   FB           MOV     R3,A
   \   00007A   EE           MOV     A,R6
   \   00007B   F9           MOV     R1,A
   \   00007C   12....       LCALL   nvReadHdr & 0xFFFF
    603          
    604              if ( hdr.id == OSAL_NV_ERASED_ID )
   \   00007F   7402         MOV     A,#0x2
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   E0           MOVX    A,@DPTR
   \   000085   64FF         XRL     A,#0xff
   \   000087   7004         JNZ     ??compactPage_1
   \   000089   A3           INC     DPTR
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   64FF         XRL     A,#0xff
   \                     ??compactPage_1:
   \   00008D   7003         JNZ     $+5
   \   00008F   02....       LJMP    ??compactPage_2 & 0xFFFF
    605              {
    606                break;
    607              }
    608          
    609              srcOff += OSAL_NV_HDR_SIZE;
   \   000092   85..82       MOV     DPL,?XSP + 0
   \   000095   85..83       MOV     DPH,?XSP + 1
   \   000098   E0           MOVX    A,@DPTR
   \   000099   2408         ADD     A,#0x8
   \   00009B   F0           MOVX    @DPTR,A
   \   00009C   A3           INC     DPTR
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   3400         ADDC    A,#0x0
   \   0000A0   F0           MOVX    @DPTR,A
    610          
    611              if ( (srcOff + hdr.len) > OSAL_NV_PAGE_FREE )
   \   0000A1   85..82       MOV     DPL,?XSP + 0
   \   0000A4   85..83       MOV     DPH,?XSP + 1
   \   0000A7   C082         PUSH    DPL
   \   0000A9   C083         PUSH    DPH
   \   0000AB   7404         MOV     A,#0x4
   \   0000AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   F8           MOV     R0,A
   \   0000B2   A3           INC     DPTR
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   F9           MOV     R1,A
   \   0000B5   D083         POP     DPH
   \   0000B7   D082         POP     DPL
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   28           ADD     A,R0
   \   0000BB   F8           MOV     R0,A
   \   0000BC   A3           INC     DPTR
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   39           ADDC    A,R1
   \   0000BF   F9           MOV     R1,A
   \   0000C0   C3           CLR     C
   \   0000C1   E8           MOV     A,R0
   \   0000C2   94F9         SUBB    A,#-0x7
   \   0000C4   E9           MOV     A,R1
   \   0000C5   9407         SUBB    A,#0x7
   \   0000C7   4003         JC      $+5
   \   0000C9   02....       LJMP    ??compactPage_2 & 0xFFFF
    612              {
    613                break;
    614              }
    615          
    616              sz = OSAL_NV_DATA_SIZE( hdr.len );
   \   0000CC   7404         MOV     A,#0x4
   \   0000CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   2403         ADD     A,#0x3
   \   0000D4   F5..         MOV     ?V0 + 4,A
   \   0000D6   A3           INC     DPTR
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   3400         ADDC    A,#0x0
   \   0000DA   F5..         MOV     ?V0 + 5,A
   \   0000DC   7402         MOV     A,#0x2
   \   0000DE   78..         MOV     R0,#?V0 + 4
   \   0000E0   12....       LCALL   ?US_SHR
   \   0000E3   E5..         MOV     A,?V0 + 4
   \   0000E5   75F004       MOV     B,#0x4
   \   0000E8   A4           MUL     AB
   \   0000E9   C5..         XCH     A,?V0 + 4
   \   0000EB   AAF0         MOV     R2,B
   \   0000ED   75F000       MOV     B,#0x0
   \   0000F0   A4           MUL     AB
   \   0000F1   2A           ADD     A,R2
   \   0000F2   FA           MOV     R2,A
   \   0000F3   75F004       MOV     B,#0x4
   \   0000F6   E5..         MOV     A,?V0 + 5
   \   0000F8   A4           MUL     AB
   \   0000F9   2A           ADD     A,R2
   \   0000FA   F5..         MOV     ?V0 + 5,A
   \   0000FC   85....       MOV     ?V0 + 2,?V0 + 4
   \   0000FF   85....       MOV     ?V0 + 3,?V0 + 5
    617          
    618              if ( hdr.id != OSAL_NV_ZEROED_ID )
   \   000102   7402         MOV     A,#0x2
   \   000104   12....       LCALL   ?XSTACK_DISP0_8
   \   000107   E0           MOVX    A,@DPTR
   \   000108   6400         XRL     A,#0x0
   \   00010A   7004         JNZ     ??compactPage_3
   \   00010C   A3           INC     DPTR
   \   00010D   E0           MOVX    A,@DPTR
   \   00010E   6400         XRL     A,#0x0
   \                     ??compactPage_3:
   \   000110   7003         JNZ     $+5
   \   000112   02....       LJMP    ??compactPage_4 & 0xFFFF
    619              {
    620                if ( hdr.chk == calcChkF( srcPg, srcOff, hdr.len ) )
   \   000115                ; Setup parameters for call to function calcChkF
   \   000115   7404         MOV     A,#0x4
   \   000117   12....       LCALL   ?XSTACK_DISP0_8
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   FC           MOV     R4,A
   \   00011C   A3           INC     DPTR
   \   00011D   E0           MOVX    A,@DPTR
   \   00011E   FD           MOV     R5,A
   \   00011F   85..82       MOV     DPL,?XSP + 0
   \   000122   85..83       MOV     DPH,?XSP + 1
   \   000125   E0           MOVX    A,@DPTR
   \   000126   FA           MOV     R2,A
   \   000127   A3           INC     DPTR
   \   000128   E0           MOVX    A,@DPTR
   \   000129   FB           MOV     R3,A
   \   00012A   EE           MOV     A,R6
   \   00012B   F9           MOV     R1,A
   \   00012C   12....       LCALL   ??calcChkF?relay
   \   00012F   8A..         MOV     ?V0 + 4,R2
   \   000131   8B..         MOV     ?V0 + 5,R3
   \   000133   A8..         MOV     R0,?V0 + 4
   \   000135   A9..         MOV     R1,?V0 + 5
   \   000137   7406         MOV     A,#0x6
   \   000139   12....       LCALL   ?XSTACK_DISP0_8
   \   00013C   E0           MOVX    A,@DPTR
   \   00013D   68           XRL     A,R0
   \   00013E   7003         JNZ     ??compactPage_5
   \   000140   A3           INC     DPTR
   \   000141   E0           MOVX    A,@DPTR
   \   000142   69           XRL     A,R1
   \                     ??compactPage_5:
   \   000143   7072         JNZ     ??compactPage_6
    621                {
    622                  setItem( srcPg, srcOff, eNvXfer );
   \   000145                ; Setup parameters for call to function setItem
   \   000145   7C00         MOV     R4,#0x0
   \   000147   85..82       MOV     DPL,?XSP + 0
   \   00014A   85..83       MOV     DPH,?XSP + 1
   \   00014D   E0           MOVX    A,@DPTR
   \   00014E   FA           MOV     R2,A
   \   00014F   A3           INC     DPTR
   \   000150   E0           MOVX    A,@DPTR
   \   000151   FB           MOV     R3,A
   \   000152   EE           MOV     A,R6
   \   000153   F9           MOV     R1,A
   \   000154   12....       LCALL   ??setItem?relay
    623                  writeBuf( pgRes, dstOff, OSAL_NV_HDR_SIZE, (byte *)(&hdr) );
   \   000157                ; Setup parameters for call to function writeBuf
   \   000157   7402         MOV     A,#0x2
   \   000159   12....       LCALL   ?XSTACK_DISP0_8
   \   00015C   8582..       MOV     ?V0 + 4,DPL
   \   00015F   8583..       MOV     ?V0 + 5,DPH
   \   000162   78..         MOV     R0,#?V0 + 4
   \   000164   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000167   7C08         MOV     R4,#0x8
   \   000169   7D00         MOV     R5,#0x0
   \   00016B   AA..         MOV     R2,?V0 + 0
   \   00016D   AB..         MOV     R3,?V0 + 1
   \   00016F   90....       MOV     DPTR,#pgRes
   \   000172   E0           MOVX    A,@DPTR
   \   000173   F9           MOV     R1,A
   \   000174   12....       LCALL   ??writeBuf?relay
   \   000177   7402         MOV     A,#0x2
   \   000179   12....       LCALL   ?DEALLOC_XSTACK8
    624                  dstOff += OSAL_NV_HDR_SIZE;
   \   00017C   E5..         MOV     A,?V0 + 0
   \   00017E   2408         ADD     A,#0x8
   \   000180   F5..         MOV     ?V0 + 0,A
   \   000182   E5..         MOV     A,?V0 + 1
   \   000184   3400         ADDC    A,#0x0
   \   000186   F5..         MOV     ?V0 + 1,A
    625                  xferBuf( srcPg, srcOff, pgRes, dstOff, sz );
   \   000188                ; Setup parameters for call to function xferBuf
   \   000188   78..         MOV     R0,#?V0 + 2
   \   00018A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00018D   78..         MOV     R0,#?V0 + 0
   \   00018F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000192   90....       MOV     DPTR,#pgRes
   \   000195   E0           MOVX    A,@DPTR
   \   000196   FC           MOV     R4,A
   \   000197   7404         MOV     A,#0x4
   \   000199   12....       LCALL   ?XSTACK_DISP0_8
   \   00019C   E0           MOVX    A,@DPTR
   \   00019D   FA           MOV     R2,A
   \   00019E   A3           INC     DPTR
   \   00019F   E0           MOVX    A,@DPTR
   \   0001A0   FB           MOV     R3,A
   \   0001A1   EE           MOV     A,R6
   \   0001A2   F9           MOV     R1,A
   \   0001A3   12....       LCALL   ??xferBuf?relay
   \   0001A6   7404         MOV     A,#0x4
   \   0001A8   12....       LCALL   ?DEALLOC_XSTACK8
    626                  dstOff += sz;
   \   0001AB   E5..         MOV     A,?V0 + 0
   \   0001AD   25..         ADD     A,?V0 + 2
   \   0001AF   F5..         MOV     ?V0 + 0,A
   \   0001B1   E5..         MOV     A,?V0 + 1
   \   0001B3   35..         ADDC    A,?V0 + 3
   \   0001B5   F5..         MOV     ?V0 + 1,A
    627                }
    628          
    629                setItem( srcPg, srcOff, eNvZero );  // Mark old location as invalid.
   \                     ??compactPage_6:
   \   0001B7                ; Setup parameters for call to function setItem
   \   0001B7   7C01         MOV     R4,#0x1
   \   0001B9   85..82       MOV     DPL,?XSP + 0
   \   0001BC   85..83       MOV     DPH,?XSP + 1
   \   0001BF   E0           MOVX    A,@DPTR
   \   0001C0   FA           MOV     R2,A
   \   0001C1   A3           INC     DPTR
   \   0001C2   E0           MOVX    A,@DPTR
   \   0001C3   FB           MOV     R3,A
   \   0001C4   EE           MOV     A,R6
   \   0001C5   F9           MOV     R1,A
   \   0001C6   12....       LCALL   ??setItem?relay
    630              }
    631          
    632              srcOff += sz;
   \                     ??compactPage_4:
   \   0001C9   85..82       MOV     DPL,?XSP + 0
   \   0001CC   85..83       MOV     DPH,?XSP + 1
   \   0001CF   E0           MOVX    A,@DPTR
   \   0001D0   25..         ADD     A,?V0 + 2
   \   0001D2   F0           MOVX    @DPTR,A
   \   0001D3   A3           INC     DPTR
   \   0001D4   E0           MOVX    A,@DPTR
   \   0001D5   35..         ADDC    A,?V0 + 3
   \   0001D7   F0           MOVX    @DPTR,A
    633          
    634            } while ( TRUE );
   \   0001D8   02....       LJMP    ??compactPage_0 & 0xFFFF
    635          
    636            pgOff[pgRes-OSAL_NV_PAGE_BEG] = dstOff;
   \                     ??compactPage_2:
   \   0001DB   90....       MOV     DPTR,#pgRes
   \   0001DE   E0           MOVX    A,@DPTR
   \   0001DF   F8           MOV     R0,A
   \   0001E0   7900         MOV     R1,#0x0
   \   0001E2   E8           MOV     A,R0
   \   0001E3   75F002       MOV     B,#0x2
   \   0001E6   A4           MUL     AB
   \   0001E7   C8           XCH     A,R0
   \   0001E8   AAF0         MOV     R2,B
   \   0001EA   75F000       MOV     B,#0x0
   \   0001ED   A4           MUL     AB
   \   0001EE   2A           ADD     A,R2
   \   0001EF   FA           MOV     R2,A
   \   0001F0   75F002       MOV     B,#0x2
   \   0001F3   E9           MOV     A,R1
   \   0001F4   A4           MUL     AB
   \   0001F5   2A           ADD     A,R2
   \   0001F6   F9           MOV     R1,A
   \   0001F7   E8           MOV     A,R0
   \   0001F8   24..         ADD     A,#((pgOff + 136) & 0xff)
   \   0001FA   F582         MOV     DPL,A
   \   0001FC   E9           MOV     A,R1
   \   0001FD   34..         ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
   \   0001FF   F583         MOV     DPH,A
   \   000201   E5..         MOV     A,?V0 + 0
   \   000203   F0           MOVX    @DPTR,A
   \   000204   A3           INC     DPTR
   \   000205   E5..         MOV     A,?V0 + 1
   \   000207   F0           MOVX    @DPTR,A
    637          
    638            /* In order to recover from a page compaction that is interrupted,
    639             * the logic in osal_nv_init() depends upon the following order:
    640             * 1. Compacted page is erased.
    641             * 2. State of the target of compaction is changed ePgActive to ePgInUse.
    642             */
    643            erasePage( srcPg );
   \   000208                ; Setup parameters for call to function erasePage
   \   000208   EE           MOV     A,R6
   \   000209   F9           MOV     R1,A
   \   00020A   12....       LCALL   ??erasePage?relay
    644          
    645            // Mark the reserve page as being in use.
    646            setPageUse( pgRes, TRUE );
   \   00020D                ; Setup parameters for call to function setPageUse
   \   00020D   7A01         MOV     R2,#0x1
   \   00020F   90....       MOV     DPTR,#pgRes
   \   000212   E0           MOVX    A,@DPTR
   \   000213   F9           MOV     R1,A
   \   000214   12....       LCALL   ??setPageUse?relay
    647          
    648            // Set the reserve page to be the newly erased page.
    649            pgRes = srcPg;
   \   000217   EE           MOV     A,R6
   \   000218   90....       MOV     DPTR,#pgRes
   \   00021B   F0           MOVX    @DPTR,A
    650          }
   \   00021C   740A         MOV     A,#0xa
   \   00021E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000221   7F06         MOV     R7,#0x6
   \   000223   02....       LJMP    ?BANKED_LEAVE_XDATA
    651          
    652          /*********************************************************************
    653           * @fn      findItem
    654           *
    655           * @brief   Find an item Id in NV and return the page and offset to its data.
    656           *
    657           * @param   id - Valid NV item Id.
    658           *
    659           * @return  Offset of data corresponding to item Id, if found;
    660           *          otherwise OSAL_NV_ITEM_NULL.
    661           *
    662           *          The page containing the item, if found;
    663           *          otherwise no valid assignment made - left equal to item Id.
    664           *
    665           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    666          static uint16 findItem( uint16 id )
   \                     findItem:
    667          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    668            uint16 off;
    669            uint8 pg;
    670          
    671            for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
   \   000009   75..3C       MOV     ?V0 + 0,#0x3c
   \                     ??findItem_0:
   \   00000C   E5..         MOV     A,?V0 + 0
   \   00000E   C3           CLR     C
   \   00000F   943E         SUBB    A,#0x3e
   \   000011   5031         JNC     ??findItem_1
    672            {
    673              if ( (off = initPage( pg, id, FALSE )) != OSAL_NV_ITEM_NULL )
   \   000013                ; Setup parameters for call to function initPage
   \   000013   7C00         MOV     R4,#0x0
   \   000015   EE           MOV     A,R6
   \   000016   FA           MOV     R2,A
   \   000017   EF           MOV     A,R7
   \   000018   FB           MOV     R3,A
   \   000019   A9..         MOV     R1,?V0 + 0
   \   00001B   12....       LCALL   ??initPage?relay
   \   00001E   8A..         MOV     ?V0 + 4,R2
   \   000020   8B..         MOV     ?V0 + 5,R3
   \   000022   A8..         MOV     R0,?V0 + 4
   \   000024   A9..         MOV     R1,?V0 + 5
   \   000026   88..         MOV     ?V0 + 2,R0
   \   000028   89..         MOV     ?V0 + 3,R1
   \   00002A   7400         MOV     A,#0x0
   \   00002C   68           XRL     A,R0
   \   00002D   7003         JNZ     ??findItem_2
   \   00002F   7400         MOV     A,#0x0
   \   000031   69           XRL     A,R1
   \                     ??findItem_2:
   \   000032   600C         JZ      ??findItem_3
    674              {
    675                findPg = pg;
   \   000034   E5..         MOV     A,?V0 + 0
   \   000036   90....       MOV     DPTR,#findPg
   \   000039   F0           MOVX    @DPTR,A
    676                return off;
   \   00003A   AA..         MOV     R2,?V0 + 2
   \   00003C   AB..         MOV     R3,?V0 + 3
   \   00003E   802D         SJMP    ??findItem_4
    677              }
    678            }
   \                     ??findItem_3:
   \   000040   05..         INC     ?V0 + 0
   \   000042   80C8         SJMP    ??findItem_0
    679          
    680            // Now attempt to find the item as the "old" item of a failed/interrupted NV write.
    681            if ( (id & OSAL_NV_SOURCE_ID) == 0 )
   \                     ??findItem_1:
   \   000044   7400         MOV     A,#0x0
   \   000046   5E           ANL     A,R6
   \   000047   F8           MOV     R0,A
   \   000048   7480         MOV     A,#-0x80
   \   00004A   5F           ANL     A,R7
   \   00004B   F9           MOV     R1,A
   \   00004C   7400         MOV     A,#0x0
   \   00004E   68           XRL     A,R0
   \   00004F   7003         JNZ     ??findItem_5
   \   000051   7400         MOV     A,#0x0
   \   000053   69           XRL     A,R1
   \                     ??findItem_5:
   \   000054   700D         JNZ     ??findItem_6
    682            {
    683              return findItem( id | OSAL_NV_SOURCE_ID );
   \   000056                ; Setup parameters for call to function findItem
   \   000056   7400         MOV     A,#0x0
   \   000058   4E           ORL     A,R6
   \   000059   FA           MOV     R2,A
   \   00005A   7480         MOV     A,#-0x80
   \   00005C   4F           ORL     A,R7
   \   00005D   FB           MOV     R3,A
   \   00005E   12....       LCALL   ??findItem?relay
   \   000061   800A         SJMP    ??findItem_4
    684            }
    685            else
    686            {
    687              findPg = OSAL_NV_PAGE_NULL;
   \                     ??findItem_6:
   \   000063   7400         MOV     A,#0x0
   \   000065   90....       MOV     DPTR,#findPg
   \   000068   F0           MOVX    @DPTR,A
    688              return OSAL_NV_ITEM_NULL;
   \   000069   7A00         MOV     R2,#0x0
   \   00006B   7B00         MOV     R3,#0x0
   \                     ??findItem_4:
   \   00006D   7F06         MOV     R7,#0x6
   \   00006F   02....       LJMP    ?BANKED_LEAVE_XDATA
    689            }
    690          }
    691          
    692          /*********************************************************************
    693           * @fn      initItem
    694           *
    695           * @brief   An NV item is created and initialized with the data passed to the function, if any.
    696           *
    697           * @param   id  - Valid NV item Id.
    698           * @param   len - Item data length.
    699           * @param  *buf - Pointer to item initalization data. Set to NULL if none.
    700           *
    701           * @return  TRUE if item write and read back checksums ok; FALSE otherwise.
    702           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    703          static uint8 initItem( uint8 flag, uint16 id, uint16 len, void *buf )
   \                     initItem:
    704          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   89..         MOV     ?V0 + 4,R1
   \   000016   8C..         MOV     ?V0 + 6,R4
   \   000018   8D..         MOV     ?V0 + 7,R5
    705            uint16 sz = OSAL_NV_ITEM_SIZE( len );
   \   00001A   7403         MOV     A,#0x3
   \   00001C   25..         ADD     A,?V0 + 6
   \   00001E   F5..         MOV     ?V0 + 2,A
   \   000020   7400         MOV     A,#0x0
   \   000022   35..         ADDC    A,?V0 + 7
   \   000024   F5..         MOV     ?V0 + 3,A
   \   000026   7402         MOV     A,#0x2
   \   000028   78..         MOV     R0,#?V0 + 2
   \   00002A   12....       LCALL   ?US_SHR
   \   00002D   E5..         MOV     A,?V0 + 2
   \   00002F   75F004       MOV     B,#0x4
   \   000032   A4           MUL     AB
   \   000033   C5..         XCH     A,?V0 + 2
   \   000035   AAF0         MOV     R2,B
   \   000037   75F000       MOV     B,#0x0
   \   00003A   A4           MUL     AB
   \   00003B   2A           ADD     A,R2
   \   00003C   FA           MOV     R2,A
   \   00003D   75F004       MOV     B,#0x4
   \   000040   E5..         MOV     A,?V0 + 3
   \   000042   A4           MUL     AB
   \   000043   2A           ADD     A,R2
   \   000044   F5..         MOV     ?V0 + 3,A
   \   000046   7408         MOV     A,#0x8
   \   000048   25..         ADD     A,?V0 + 2
   \   00004A   F8           MOV     R0,A
   \   00004B   7400         MOV     A,#0x0
   \   00004D   35..         ADDC    A,?V0 + 3
   \   00004F   F9           MOV     R1,A
   \   000050   85..82       MOV     DPL,?XSP + 0
   \   000053   85..83       MOV     DPH,?XSP + 1
   \   000056   E8           MOV     A,R0
   \   000057   F0           MOVX    @DPTR,A
   \   000058   A3           INC     DPTR
   \   000059   E9           MOV     A,R1
   \   00005A   F0           MOVX    @DPTR,A
    706            uint8 rtrn = FALSE;
   \   00005B   7E00         MOV     R6,#0x0
    707            uint8 cnt = OSAL_NV_PAGES_USED;
   \   00005D   75..02       MOV     ?V0 + 1,#0x2
    708            uint8 pg = pgRes+1;  // Set to 1 after the reserve page to even wear across all available pages.
   \   000060   90....       MOV     DPTR,#pgRes
   \   000063   E0           MOVX    A,@DPTR
   \   000064   2401         ADD     A,#0x1
   \   000066   FF           MOV     R7,A
    709            uint8 idx;
    710          
    711            do {
    712              if (pg >= OSAL_NV_PAGE_BEG+OSAL_NV_PAGES_USED)
   \                     ??initItem_0:
   \   000067   EF           MOV     A,R7
   \   000068   C3           CLR     C
   \   000069   943E         SUBB    A,#0x3e
   \   00006B   4002         JC      ??initItem_1
    713              {
    714                pg = OSAL_NV_PAGE_BEG;
   \   00006D   7F3C         MOV     R7,#0x3c
    715              }
    716              if ( pg != pgRes )
   \                     ??initItem_1:
   \   00006F   90....       MOV     DPTR,#pgRes
   \   000072   E0           MOVX    A,@DPTR
   \   000073   6F           XRL     A,R7
   \   000074   6076         JZ      ??initItem_2
    717              {
    718                idx = pg - OSAL_NV_PAGE_BEG;
   \   000076   74C4         MOV     A,#-0x3c
   \   000078   2F           ADD     A,R7
   \   000079   F5..         MOV     ?V0 + 0,A
    719                if ( (pgOff[idx] - pgLost[idx] + sz) <= OSAL_NV_PAGE_FREE )
   \   00007B   A8..         MOV     R0,?V0 + 0
   \   00007D   7900         MOV     R1,#0x0
   \   00007F   E8           MOV     A,R0
   \   000080   75F002       MOV     B,#0x2
   \   000083   A4           MUL     AB
   \   000084   C8           XCH     A,R0
   \   000085   AAF0         MOV     R2,B
   \   000087   75F000       MOV     B,#0x0
   \   00008A   A4           MUL     AB
   \   00008B   2A           ADD     A,R2
   \   00008C   FA           MOV     R2,A
   \   00008D   75F002       MOV     B,#0x2
   \   000090   E9           MOV     A,R1
   \   000091   A4           MUL     AB
   \   000092   2A           ADD     A,R2
   \   000093   F9           MOV     R1,A
   \   000094   E8           MOV     A,R0
   \   000095   24..         ADD     A,#(pgOff & 0xff)
   \   000097   F582         MOV     DPL,A
   \   000099   E9           MOV     A,R1
   \   00009A   34..         ADDC    A,#((pgOff >> 8) & 0xff)
   \   00009C   F583         MOV     DPH,A
   \   00009E   C082         PUSH    DPL
   \   0000A0   C083         PUSH    DPH
   \   0000A2   A8..         MOV     R0,?V0 + 0
   \   0000A4   7900         MOV     R1,#0x0
   \   0000A6   E8           MOV     A,R0
   \   0000A7   75F002       MOV     B,#0x2
   \   0000AA   A4           MUL     AB
   \   0000AB   C8           XCH     A,R0
   \   0000AC   AAF0         MOV     R2,B
   \   0000AE   75F000       MOV     B,#0x0
   \   0000B1   A4           MUL     AB
   \   0000B2   2A           ADD     A,R2
   \   0000B3   FA           MOV     R2,A
   \   0000B4   75F002       MOV     B,#0x2
   \   0000B7   E9           MOV     A,R1
   \   0000B8   A4           MUL     AB
   \   0000B9   2A           ADD     A,R2
   \   0000BA   F9           MOV     R1,A
   \   0000BB   E8           MOV     A,R0
   \   0000BC   24..         ADD     A,#(pgLost & 0xff)
   \   0000BE   F582         MOV     DPL,A
   \   0000C0   E9           MOV     A,R1
   \   0000C1   34..         ADDC    A,#((pgLost >> 8) & 0xff)
   \   0000C3   F583         MOV     DPH,A
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   F8           MOV     R0,A
   \   0000C7   A3           INC     DPTR
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   F9           MOV     R1,A
   \   0000CA   D083         POP     DPH
   \   0000CC   D082         POP     DPL
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   C3           CLR     C
   \   0000D0   98           SUBB    A,R0
   \   0000D1   F8           MOV     R0,A
   \   0000D2   A3           INC     DPTR
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   99           SUBB    A,R1
   \   0000D5   F9           MOV     R1,A
   \   0000D6   85..82       MOV     DPL,?XSP + 0
   \   0000D9   85..83       MOV     DPH,?XSP + 1
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   28           ADD     A,R0
   \   0000DE   F8           MOV     R0,A
   \   0000DF   A3           INC     DPTR
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   39           ADDC    A,R1
   \   0000E2   F9           MOV     R1,A
   \   0000E3   C3           CLR     C
   \   0000E4   E8           MOV     A,R0
   \   0000E5   94F9         SUBB    A,#-0x7
   \   0000E7   E9           MOV     A,R1
   \   0000E8   9407         SUBB    A,#0x7
   \   0000EA   400E         JC      ??initItem_3
    720                {
    721                  break;
    722                }
    723              }
    724              pg++;
   \                     ??initItem_2:
   \   0000EC   0F           INC     R7
    725            } while (--cnt);
   \   0000ED   74FF         MOV     A,#-0x1
   \   0000EF   25..         ADD     A,?V0 + 1
   \   0000F1   FA           MOV     R2,A
   \   0000F2   8A..         MOV     ?V0 + 1,R2
   \   0000F4   EA           MOV     A,R2
   \   0000F5   6003         JZ      $+5
   \   0000F7   02....       LJMP    ??initItem_0 & 0xFFFF
    726          
    727            if (cnt)
   \                     ??initItem_3:
   \   0000FA   E5..         MOV     A,?V0 + 1
   \   0000FC   7003         JNZ     $+5
   \   0000FE   02....       LJMP    ??initItem_4 & 0xFFFF
    728            {
    729              // Item fits if an old page is compacted.
    730              if ( (pgOff[idx] + sz) > OSAL_NV_PAGE_FREE )
   \   000101   A8..         MOV     R0,?V0 + 0
   \   000103   7900         MOV     R1,#0x0
   \   000105   E8           MOV     A,R0
   \   000106   75F002       MOV     B,#0x2
   \   000109   A4           MUL     AB
   \   00010A   C8           XCH     A,R0
   \   00010B   AAF0         MOV     R2,B
   \   00010D   75F000       MOV     B,#0x0
   \   000110   A4           MUL     AB
   \   000111   2A           ADD     A,R2
   \   000112   FA           MOV     R2,A
   \   000113   75F002       MOV     B,#0x2
   \   000116   E9           MOV     A,R1
   \   000117   A4           MUL     AB
   \   000118   2A           ADD     A,R2
   \   000119   F9           MOV     R1,A
   \   00011A   E8           MOV     A,R0
   \   00011B   24..         ADD     A,#(pgOff & 0xff)
   \   00011D   F582         MOV     DPL,A
   \   00011F   E9           MOV     A,R1
   \   000120   34..         ADDC    A,#((pgOff >> 8) & 0xff)
   \   000122   F583         MOV     DPH,A
   \   000124   C082         PUSH    DPL
   \   000126   C083         PUSH    DPH
   \   000128   85..82       MOV     DPL,?XSP + 0
   \   00012B   85..83       MOV     DPH,?XSP + 1
   \   00012E   E0           MOVX    A,@DPTR
   \   00012F   F8           MOV     R0,A
   \   000130   A3           INC     DPTR
   \   000131   E0           MOVX    A,@DPTR
   \   000132   F9           MOV     R1,A
   \   000133   D083         POP     DPH
   \   000135   D082         POP     DPL
   \   000137   E0           MOVX    A,@DPTR
   \   000138   28           ADD     A,R0
   \   000139   F8           MOV     R0,A
   \   00013A   A3           INC     DPTR
   \   00013B   E0           MOVX    A,@DPTR
   \   00013C   39           ADDC    A,R1
   \   00013D   F9           MOV     R1,A
   \   00013E   C3           CLR     C
   \   00013F   E8           MOV     A,R0
   \   000140   94F9         SUBB    A,#-0x7
   \   000142   E9           MOV     A,R1
   \   000143   9407         SUBB    A,#0x7
   \   000145   4005         JC      ??initItem_5
    731              {
    732                pg = pgRes;
   \   000147   90....       MOV     DPTR,#pgRes
   \   00014A   E0           MOVX    A,@DPTR
   \   00014B   FF           MOV     R7,A
    733              }
    734          
    735              // New item is the first one written to the reserved page, then the old page is compacted.
    736              rtrn = writeItem( pg, id, len, buf, flag );
   \                     ??initItem_5:
   \   00014C                ; Setup parameters for call to function writeItem
   \   00014C   E5..         MOV     A,?V0 + 4
   \   00014E   F5..         MOV     ?V0 + 2,A
   \   000150   78..         MOV     R0,#?V0 + 2
   \   000152   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000155   7415         MOV     A,#0x15
   \   000157   12....       LCALL   ?XSTACK_DISP0_8
   \   00015A   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00015D   AC..         MOV     R4,?V0 + 6
   \   00015F   AD..         MOV     R5,?V0 + 7
   \   000161   7405         MOV     A,#0x5
   \   000163   12....       LCALL   ?XSTACK_DISP0_8
   \   000166   E0           MOVX    A,@DPTR
   \   000167   FA           MOV     R2,A
   \   000168   A3           INC     DPTR
   \   000169   E0           MOVX    A,@DPTR
   \   00016A   FB           MOV     R3,A
   \   00016B   EF           MOV     A,R7
   \   00016C   F9           MOV     R1,A
   \   00016D   12....       LCALL   ??writeItem?relay
   \   000170   7403         MOV     A,#0x3
   \   000172   12....       LCALL   ?DEALLOC_XSTACK8
   \   000175   E9           MOV     A,R1
   \   000176   FE           MOV     R6,A
    737          
    738              if ( pg == pgRes )
   \   000177   90....       MOV     DPTR,#pgRes
   \   00017A   E0           MOVX    A,@DPTR
   \   00017B   6F           XRL     A,R7
   \   00017C   7024         JNZ     ??initItem_4
    739              {
    740                if ( flag )
   \   00017E   E5..         MOV     A,?V0 + 4
   \   000180   600A         JZ      ??initItem_6
    741                {
    742                  compactPage( OSAL_NV_PAGE_BEG+idx );
   \   000182                ; Setup parameters for call to function compactPage
   \   000182   743C         MOV     A,#0x3c
   \   000184   25..         ADD     A,?V0 + 0
   \   000186   F9           MOV     R1,A
   \   000187   12....       LCALL   ??compactPage?relay
   \   00018A   8016         SJMP    ??initItem_4
    743                }
    744                else
    745                {
    746                  *(uint8 *)buf = OSAL_NV_PAGE_BEG+idx;
   \                     ??initItem_6:
   \   00018C   743C         MOV     A,#0x3c
   \   00018E   25..         ADD     A,?V0 + 0
   \   000190   C0E0         PUSH    A
   \   000192   7414         MOV     A,#0x14
   \   000194   12....       LCALL   ?XSTACK_DISP0_8
   \   000197   E0           MOVX    A,@DPTR
   \   000198   F8           MOV     R0,A
   \   000199   A3           INC     DPTR
   \   00019A   E0           MOVX    A,@DPTR
   \   00019B   F583         MOV     DPH,A
   \   00019D   8882         MOV     DPL,R0
   \   00019F   D0E0         POP     A
   \   0001A1   F0           MOVX    @DPTR,A
    747                }
    748              }
    749            }
    750          
    751            return rtrn;
   \                     ??initItem_4:
   \   0001A2   EE           MOV     A,R6
   \   0001A3   F9           MOV     R1,A
   \   0001A4   7404         MOV     A,#0x4
   \   0001A6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001A9   7F08         MOV     R7,#0x8
   \   0001AB   02....       LJMP    ?BANKED_LEAVE_XDATA
    752          }
    753          
    754          /*********************************************************************
    755           * @fn      setItem
    756           *
    757           * @brief   Set an item Id or status to mark its state.
    758           *
    759           * @param   pg - Valid NV page.
    760           * @param   offset - Valid offset into the page of the item data - the header
    761           *                   offset is calculated from this.
    762           * @param   stat - Valid enum value for the item status.
    763           *
    764           * @return  none
    765           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    766          static void setItem( uint8 pg, uint16 offset, eNvHdrEnum stat )
   \                     setItem:
    767          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   8A..         MOV     ?V0 + 0,R2
   \   00000E   8B..         MOV     ?V0 + 1,R3
   \   000010   EC           MOV     A,R4
   \   000011   FF           MOV     R7,A
    768            osalNvHdr_t hdr;
    769          
    770            offset -= OSAL_NV_HDR_SIZE;
   \   000012   E5..         MOV     A,?V0 + 0
   \   000014   24F8         ADD     A,#-0x8
   \   000016   F5..         MOV     ?V0 + 0,A
   \   000018   E5..         MOV     A,?V0 + 1
   \   00001A   34FF         ADDC    A,#-0x1
   \   00001C   F5..         MOV     ?V0 + 1,A
    771            nvReadHdr( pg, offset, (uint8 *)(&hdr) );
   \   00001E                ; Setup parameters for call to function nvReadHdr
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   AC82         MOV     R4,DPL
   \   000026   AD83         MOV     R5,DPH
   \   000028   AA..         MOV     R2,?V0 + 0
   \   00002A   AB..         MOV     R3,?V0 + 1
   \   00002C   EE           MOV     A,R6
   \   00002D   F9           MOV     R1,A
   \   00002E   12....       LCALL   nvReadHdr & 0xFFFF
    772          
    773            if ( stat == eNvXfer )
   \   000031   EF           MOV     A,R7
   \   000032   7027         JNZ     ??setItem_0
    774            {
    775              hdr.stat = OSAL_NV_ACTIVE;
   \   000034   7406         MOV     A,#0x6
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   7400         MOV     A,#0x0
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   7400         MOV     A,#0x0
   \   00003F   F0           MOVX    @DPTR,A
    776              writeWord( pg, offset+OSAL_NV_HDR_CHK, (uint8*)(&(hdr.chk)) );
   \   000040                ; Setup parameters for call to function writeWord
   \   000040   7404         MOV     A,#0x4
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   AC82         MOV     R4,DPL
   \   000047   AD83         MOV     R5,DPH
   \   000049   7404         MOV     A,#0x4
   \   00004B   25..         ADD     A,?V0 + 0
   \   00004D   FA           MOV     R2,A
   \   00004E   7400         MOV     A,#0x0
   \   000050   35..         ADDC    A,?V0 + 1
   \   000052   FB           MOV     R3,A
   \   000053   EE           MOV     A,R6
   \   000054   F9           MOV     R1,A
   \   000055   12....       LCALL   ??writeWord?relay
   \   000058   02....       LJMP    ??setItem_1 & 0xFFFF
    777            }
    778            else // if ( stat == eNvZero )
    779            {
    780              uint16 sz = ((hdr.len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE +
    781                                                                                    OSAL_NV_HDR_SIZE;
   \                     ??setItem_0:
   \   00005B   7402         MOV     A,#0x2
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   E0           MOVX    A,@DPTR
   \   000061   2403         ADD     A,#0x3
   \   000063   F5..         MOV     ?V0 + 2,A
   \   000065   A3           INC     DPTR
   \   000066   E0           MOVX    A,@DPTR
   \   000067   3400         ADDC    A,#0x0
   \   000069   F5..         MOV     ?V0 + 3,A
   \   00006B   7402         MOV     A,#0x2
   \   00006D   78..         MOV     R0,#?V0 + 2
   \   00006F   12....       LCALL   ?US_SHR
   \   000072   E5..         MOV     A,?V0 + 2
   \   000074   75F004       MOV     B,#0x4
   \   000077   A4           MUL     AB
   \   000078   C5..         XCH     A,?V0 + 2
   \   00007A   AAF0         MOV     R2,B
   \   00007C   75F000       MOV     B,#0x0
   \   00007F   A4           MUL     AB
   \   000080   2A           ADD     A,R2
   \   000081   FA           MOV     R2,A
   \   000082   75F004       MOV     B,#0x4
   \   000085   E5..         MOV     A,?V0 + 3
   \   000087   A4           MUL     AB
   \   000088   2A           ADD     A,R2
   \   000089   F5..         MOV     ?V0 + 3,A
   \   00008B   7408         MOV     A,#0x8
   \   00008D   25..         ADD     A,?V0 + 2
   \   00008F   F8           MOV     R0,A
   \   000090   7400         MOV     A,#0x0
   \   000092   35..         ADDC    A,?V0 + 3
   \   000094   F9           MOV     R1,A
   \   000095   88..         MOV     ?V0 + 4,R0
   \   000097   89..         MOV     ?V0 + 5,R1
    782              hdr.id = 0;
   \   000099   85..82       MOV     DPL,?XSP + 0
   \   00009C   85..83       MOV     DPH,?XSP + 1
   \   00009F   7400         MOV     A,#0x0
   \   0000A1   F0           MOVX    @DPTR,A
   \   0000A2   A3           INC     DPTR
   \   0000A3   7400         MOV     A,#0x0
   \   0000A5   F0           MOVX    @DPTR,A
    783              writeWord( pg, offset, (uint8 *)(&hdr) );
   \   0000A6                ; Setup parameters for call to function writeWord
   \   0000A6   85..82       MOV     DPL,?XSP + 0
   \   0000A9   85..83       MOV     DPH,?XSP + 1
   \   0000AC   AC82         MOV     R4,DPL
   \   0000AE   AD83         MOV     R5,DPH
   \   0000B0   AA..         MOV     R2,?V0 + 0
   \   0000B2   AB..         MOV     R3,?V0 + 1
   \   0000B4   EE           MOV     A,R6
   \   0000B5   F9           MOV     R1,A
   \   0000B6   12....       LCALL   ??writeWord?relay
    784              pgLost[pg-OSAL_NV_PAGE_BEG] += sz;
   \   0000B9   EE           MOV     A,R6
   \   0000BA   F8           MOV     R0,A
   \   0000BB   7900         MOV     R1,#0x0
   \   0000BD   E8           MOV     A,R0
   \   0000BE   75F002       MOV     B,#0x2
   \   0000C1   A4           MUL     AB
   \   0000C2   C8           XCH     A,R0
   \   0000C3   AAF0         MOV     R2,B
   \   0000C5   75F000       MOV     B,#0x0
   \   0000C8   A4           MUL     AB
   \   0000C9   2A           ADD     A,R2
   \   0000CA   FA           MOV     R2,A
   \   0000CB   75F002       MOV     B,#0x2
   \   0000CE   E9           MOV     A,R1
   \   0000CF   A4           MUL     AB
   \   0000D0   2A           ADD     A,R2
   \   0000D1   F9           MOV     R1,A
   \   0000D2   E8           MOV     A,R0
   \   0000D3   24..         ADD     A,#((pgLost + 136) & 0xff)
   \   0000D5   F582         MOV     DPL,A
   \   0000D7   E9           MOV     A,R1
   \   0000D8   34..         ADDC    A,#(((pgLost - 120) >> 8) & 0xff)
   \   0000DA   F583         MOV     DPH,A
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   25..         ADD     A,?V0 + 4
   \   0000DF   F0           MOVX    @DPTR,A
   \   0000E0   A3           INC     DPTR
   \   0000E1   E0           MOVX    A,@DPTR
   \   0000E2   35..         ADDC    A,?V0 + 5
   \   0000E4   F0           MOVX    @DPTR,A
    785            }
    786          }
   \                     ??setItem_1:
   \   0000E5   7408         MOV     A,#0x8
   \   0000E7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EA   7F06         MOV     R7,#0x6
   \   0000EC   02....       LJMP    ?BANKED_LEAVE_XDATA
    787          
    788          /*********************************************************************
    789           * @fn      calcChkB
    790           *
    791           * @brief   Calculates the data checksum over the 'buf' parameter.
    792           *
    793           * @param   pg - A valid NV Flash page.
    794           * @param   offset - A valid offset into the page.
    795           * @param   len - Byte count of the data to be checksummed.
    796           *
    797           * @return  Calculated checksum of the data bytes.
    798           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    799          static uint16 calcChkB( uint16 len, uint8 *buf )
   \                     calcChkB:
    800          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
    801            uint8 fill = len % OSAL_NV_WORD_SIZE;
   \   00000D   EE           MOV     A,R6
   \   00000E   F8           MOV     R0,A
   \   00000F   EF           MOV     A,R7
   \   000010   F9           MOV     R1,A
   \   000011   7A04         MOV     R2,#0x4
   \   000013   7B00         MOV     R3,#0x0
   \   000015   12....       LCALL   ?US_DIV_MOD
   \   000018   EA           MOV     A,R2
   \   000019   F5..         MOV     ?V0 + 0,A
    802            uint16 chk;
    803          
    804            if ( !buf )
   \   00001B   E582         MOV     A,DPL
   \   00001D   6400         XRL     A,#0x0
   \   00001F   7004         JNZ     ??calcChkB_0
   \   000021   E583         MOV     A,DPH
   \   000023   6400         XRL     A,#0x0
   \                     ??calcChkB_0:
   \   000025   701F         JNZ     ??calcChkB_1
    805            {
    806              chk = len * OSAL_NV_ERASED;
   \   000027   EE           MOV     A,R6
   \   000028   F8           MOV     R0,A
   \   000029   EF           MOV     A,R7
   \   00002A   F9           MOV     R1,A
   \   00002B   E8           MOV     A,R0
   \   00002C   75F0FF       MOV     B,#-0x1
   \   00002F   A4           MUL     AB
   \   000030   C8           XCH     A,R0
   \   000031   AAF0         MOV     R2,B
   \   000033   75F000       MOV     B,#0x0
   \   000036   A4           MUL     AB
   \   000037   2A           ADD     A,R2
   \   000038   FA           MOV     R2,A
   \   000039   75F0FF       MOV     B,#-0x1
   \   00003C   E9           MOV     A,R1
   \   00003D   A4           MUL     AB
   \   00003E   2A           ADD     A,R2
   \   00003F   F9           MOV     R1,A
   \   000040   E8           MOV     A,R0
   \   000041   FC           MOV     R4,A
   \   000042   E9           MOV     A,R1
   \   000043   FD           MOV     R5,A
   \   000044   8027         SJMP    ??calcChkB_2
    807            }
    808            else
    809            {
    810              chk = 0;
   \                     ??calcChkB_1:
   \   000046   7C00         MOV     R4,#0x0
   \   000048   7D00         MOV     R5,#0x0
    811              while ( len-- )
   \                     ??calcChkB_3:
   \   00004A   EE           MOV     A,R6
   \   00004B   F8           MOV     R0,A
   \   00004C   EF           MOV     A,R7
   \   00004D   F9           MOV     R1,A
   \   00004E   74FF         MOV     A,#-0x1
   \   000050   28           ADD     A,R0
   \   000051   FE           MOV     R6,A
   \   000052   74FF         MOV     A,#-0x1
   \   000054   39           ADDC    A,R1
   \   000055   FF           MOV     R7,A
   \   000056   7400         MOV     A,#0x0
   \   000058   68           XRL     A,R0
   \   000059   7003         JNZ     ??calcChkB_4
   \   00005B   7400         MOV     A,#0x0
   \   00005D   69           XRL     A,R1
   \                     ??calcChkB_4:
   \   00005E   600D         JZ      ??calcChkB_2
    812              {
    813                chk += *buf++;
   \   000060   E0           MOVX    A,@DPTR
   \   000061   F8           MOV     R0,A
   \   000062   7900         MOV     R1,#0x0
   \   000064   EC           MOV     A,R4
   \   000065   28           ADD     A,R0
   \   000066   FC           MOV     R4,A
   \   000067   ED           MOV     A,R5
   \   000068   39           ADDC    A,R1
   \   000069   FD           MOV     R5,A
   \   00006A   A3           INC     DPTR
   \   00006B   80DD         SJMP    ??calcChkB_3
    814              }
    815            }
    816          
    817            // calcChkF() will calculate over OSAL_NV_WORD_SIZE alignment.
    818            if ( fill )
   \                     ??calcChkB_2:
   \   00006D   E5..         MOV     A,?V0 + 0
   \   00006F   602C         JZ      ??calcChkB_5
    819            {
    820              chk += (OSAL_NV_WORD_SIZE - fill) * OSAL_NV_ERASED;
   \   000071   85....       MOV     ?V0 + 2,?V0 + 0
   \   000074   75..00       MOV     ?V0 + 3,#0x0
   \   000077   7404         MOV     A,#0x4
   \   000079   C3           CLR     C
   \   00007A   95..         SUBB    A,?V0 + 2
   \   00007C   F8           MOV     R0,A
   \   00007D   7400         MOV     A,#0x0
   \   00007F   95..         SUBB    A,?V0 + 3
   \   000081   F9           MOV     R1,A
   \   000082   E8           MOV     A,R0
   \   000083   75F0FF       MOV     B,#-0x1
   \   000086   A4           MUL     AB
   \   000087   C8           XCH     A,R0
   \   000088   AAF0         MOV     R2,B
   \   00008A   75F000       MOV     B,#0x0
   \   00008D   A4           MUL     AB
   \   00008E   2A           ADD     A,R2
   \   00008F   FA           MOV     R2,A
   \   000090   75F0FF       MOV     B,#-0x1
   \   000093   E9           MOV     A,R1
   \   000094   A4           MUL     AB
   \   000095   2A           ADD     A,R2
   \   000096   F9           MOV     R1,A
   \   000097   EC           MOV     A,R4
   \   000098   28           ADD     A,R0
   \   000099   FC           MOV     R4,A
   \   00009A   ED           MOV     A,R5
   \   00009B   39           ADDC    A,R1
   \   00009C   FD           MOV     R5,A
    821            }
    822          
    823            return chk;
   \                     ??calcChkB_5:
   \   00009D   EC           MOV     A,R4
   \   00009E   FA           MOV     R2,A
   \   00009F   ED           MOV     A,R5
   \   0000A0   FB           MOV     R3,A
   \   0000A1   7F04         MOV     R7,#0x4
   \   0000A3   02....       LJMP    ?BANKED_LEAVE_XDATA
    824          }
    825          
    826          /*********************************************************************
    827           * @fn      calcChkF
    828           *
    829           * @brief   Calculates the data checksum by reading the data bytes from NV.
    830           *
    831           * @param   pg - A valid NV Flash page.
    832           * @param   offset - A valid offset into the page.
    833           * @param   len - Byte count of the data to be checksummed.
    834           *
    835           * @return  Calculated checksum of the data bytes.
    836           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    837          static uint16 calcChkF( byte pg, uint16 offset, uint16 len )
   \                     calcChkF:
    838          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 1,R1
   \   00000C   8A..         MOV     ?V0 + 4,R2
   \   00000E   8B..         MOV     ?V0 + 5,R3
   \   000010   EC           MOV     A,R4
   \   000011   FE           MOV     R6,A
   \   000012   ED           MOV     A,R5
   \   000013   FF           MOV     R7,A
    839            uint16 chk = 0;
   \   000014   75..00       MOV     ?V0 + 6,#0x0
   \   000017   75..00       MOV     ?V0 + 7,#0x0
    840          
    841            len = (len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE;
   \   00001A   7403         MOV     A,#0x3
   \   00001C   2E           ADD     A,R6
   \   00001D   F5..         MOV     ?V0 + 2,A
   \   00001F   7400         MOV     A,#0x0
   \   000021   3F           ADDC    A,R7
   \   000022   F5..         MOV     ?V0 + 3,A
   \   000024   7402         MOV     A,#0x2
   \   000026   78..         MOV     R0,#?V0 + 2
   \   000028   12....       LCALL   ?US_SHR
   \   00002B   AE..         MOV     R6,?V0 + 2
   \   00002D   AF..         MOV     R7,?V0 + 3
    842          
    843            while ( len-- )
   \                     ??calcChkF_0:
   \   00002F   EE           MOV     A,R6
   \   000030   F8           MOV     R0,A
   \   000031   EF           MOV     A,R7
   \   000032   F9           MOV     R1,A
   \   000033   74FF         MOV     A,#-0x1
   \   000035   28           ADD     A,R0
   \   000036   FE           MOV     R6,A
   \   000037   74FF         MOV     A,#-0x1
   \   000039   39           ADDC    A,R1
   \   00003A   FF           MOV     R7,A
   \   00003B   7400         MOV     A,#0x0
   \   00003D   68           XRL     A,R0
   \   00003E   7003         JNZ     ??calcChkF_1
   \   000040   7400         MOV     A,#0x0
   \   000042   69           XRL     A,R1
   \                     ??calcChkF_1:
   \   000043   6053         JZ      ??calcChkF_2
    844            {
    845              uint8 cnt, tmp[OSAL_NV_WORD_SIZE];
    846          
    847              nvReadWord( pg, offset, tmp );
   \   000045                ; Setup parameters for call to function nvReadWord
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   AC82         MOV     R4,DPL
   \   00004D   AD83         MOV     R5,DPH
   \   00004F   AA..         MOV     R2,?V0 + 4
   \   000051   AB..         MOV     R3,?V0 + 5
   \   000053   A9..         MOV     R1,?V0 + 1
   \   000055   12....       LCALL   nvReadWord & 0xFFFF
    848              offset += OSAL_NV_WORD_SIZE;
   \   000058   E5..         MOV     A,?V0 + 4
   \   00005A   2404         ADD     A,#0x4
   \   00005C   F5..         MOV     ?V0 + 4,A
   \   00005E   E5..         MOV     A,?V0 + 5
   \   000060   3400         ADDC    A,#0x0
   \   000062   F5..         MOV     ?V0 + 5,A
    849          
    850              for ( cnt = 0; cnt < OSAL_NV_WORD_SIZE; cnt++ )
   \   000064   75..00       MOV     ?V0 + 0,#0x0
   \                     ??calcChkF_3:
   \   000067   E5..         MOV     A,?V0 + 0
   \   000069   C3           CLR     C
   \   00006A   9404         SUBB    A,#0x4
   \   00006C   50C1         JNC     ??calcChkF_0
    851              {
    852                chk += tmp[cnt];
   \   00006E   85....       MOV     ?V0 + 2,?V0 + 0
   \   000071   75..00       MOV     ?V0 + 3,#0x0
   \   000074   85..82       MOV     DPL,?XSP + 0
   \   000077   85..83       MOV     DPH,?XSP + 1
   \   00007A   E582         MOV     A,DPL
   \   00007C   25..         ADD     A,?V0 + 2
   \   00007E   F582         MOV     DPL,A
   \   000080   E583         MOV     A,DPH
   \   000082   35..         ADDC    A,?V0 + 3
   \   000084   F583         MOV     DPH,A
   \   000086   E0           MOVX    A,@DPTR
   \   000087   F8           MOV     R0,A
   \   000088   7900         MOV     R1,#0x0
   \   00008A   E5..         MOV     A,?V0 + 6
   \   00008C   28           ADD     A,R0
   \   00008D   F5..         MOV     ?V0 + 6,A
   \   00008F   E5..         MOV     A,?V0 + 7
   \   000091   39           ADDC    A,R1
   \   000092   F5..         MOV     ?V0 + 7,A
    853              }
   \   000094   05..         INC     ?V0 + 0
   \   000096   80CF         SJMP    ??calcChkF_3
    854            }
    855          
    856            return chk;
   \                     ??calcChkF_2:
   \   000098   AA..         MOV     R2,?V0 + 6
   \   00009A   AB..         MOV     R3,?V0 + 7
   \   00009C   7404         MOV     A,#0x4
   \   00009E   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A1   7F08         MOV     R7,#0x8
   \   0000A3   02....       LJMP    ?BANKED_LEAVE_XDATA
    857          }
    858          
    859          /*********************************************************************
    860           * @fn      writeWord
    861           *
    862           * @brief   Writes a Flash-WORD to NV.
    863           *
    864           * @param   pg - A valid NV Flash page.
    865           * @param   offset - A valid offset into the page.
    866           * @param   buf - Pointer to source buffer.
    867           *
    868           * @return  none
    869           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    870          static void writeWord( uint8 pg, uint16 offset, uint8 *buf )
   \                     writeWord:
    871          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   8A..         MOV     ?V0 + 2,R2
   \   000009   8B..         MOV     ?V0 + 3,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
    872              offset = (offset >> 2) + ((uint16)pg << 9);
   \   00000F   7402         MOV     A,#0x2
   \   000011   78..         MOV     R0,#?V0 + 2
   \   000013   12....       LCALL   ?US_SHR
   \   000016   85....       MOV     ?V0 + 4,?V0 + 0
   \   000019   75..00       MOV     ?V0 + 5,#0x0
   \   00001C   7409         MOV     A,#0x9
   \   00001E   78..         MOV     R0,#?V0 + 4
   \   000020   12....       LCALL   ?S_SHL
   \   000023   E5..         MOV     A,?V0 + 4
   \   000025   25..         ADD     A,?V0 + 2
   \   000027   F5..         MOV     ?V0 + 2,A
   \   000029   E5..         MOV     A,?V0 + 5
   \   00002B   35..         ADDC    A,?V0 + 3
   \   00002D   F5..         MOV     ?V0 + 3,A
    873          
    874              if ( OSAL_NV_CHECK_BUS_VOLTAGE )
   \   00002F                ; Setup parameters for call to function HalAdcCheckVdd
   \   00002F   7904         MOV     R1,#0x4
   \   000031   12....       LCALL   ??HalAdcCheckVdd?relay
   \   000034   E9           MOV     A,R1
   \   000035   600F         JZ      ??writeWord_0
    875              {
    876              flashWriteBuf(1, (uint16)buf, offset);
   \   000037                ; Setup parameters for call to function flashWriteBuf
   \   000037   AC..         MOV     R4,?V0 + 2
   \   000039   AD..         MOV     R5,?V0 + 3
   \   00003B   EE           MOV     A,R6
   \   00003C   FA           MOV     R2,A
   \   00003D   EF           MOV     A,R7
   \   00003E   FB           MOV     R3,A
   \   00003F   7901         MOV     R1,#0x1
   \   000041   12....       LCALL   flashWriteBuf & 0xFFFF
   \   000044   8006         SJMP    ??writeWord_1
    877              }
    878              else
    879              {
    880                failF = TRUE;
   \                     ??writeWord_0:
   \   000046   7401         MOV     A,#0x1
   \   000048   90....       MOV     DPTR,#failF
   \   00004B   F0           MOVX    @DPTR,A
    881              }
    882          }
   \                     ??writeWord_1:
   \   00004C   7F06         MOV     R7,#0x6
   \   00004E   02....       LJMP    ?BANKED_LEAVE_XDATA
    883          
    884          /*********************************************************************
    885           * @fn      writeWordM
    886           *
    887           * @brief   Writes multiple Flash-WORDs to NV.
    888           *
    889           * @param   pg - A valid NV Flash page.
    890           * @param   offset - A valid offset into the page.
    891           * @param   buf - Pointer to source buffer.
    892           * @param   cnt - Number of 4-byte blocks to write.
    893           *
    894           * @return  none
    895           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    896          static void writeWordM( uint8 pg, uint16 offset, uint8 *buf, uint8 cnt )
   \                     writeWordM:
    897          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   8A..         MOV     ?V0 + 0,R2
   \   000009   8B..         MOV     ?V0 + 1,R3
   \   00000B   8C..         MOV     ?V0 + 4,R4
   \   00000D   8D..         MOV     ?V0 + 5,R5
   \   00000F   740E         MOV     A,#0xe
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   FF           MOV     R7,A
    898            offset = (offset >> 2) + ((uint16)pg << 9);
   \   000016   7402         MOV     A,#0x2
   \   000018   78..         MOV     R0,#?V0 + 0
   \   00001A   12....       LCALL   ?US_SHR
   \   00001D   8E..         MOV     ?V0 + 2,R6
   \   00001F   75..00       MOV     ?V0 + 3,#0x0
   \   000022   7409         MOV     A,#0x9
   \   000024   78..         MOV     R0,#?V0 + 2
   \   000026   12....       LCALL   ?S_SHL
   \   000029   E5..         MOV     A,?V0 + 2
   \   00002B   25..         ADD     A,?V0 + 0
   \   00002D   F5..         MOV     ?V0 + 0,A
   \   00002F   E5..         MOV     A,?V0 + 3
   \   000031   35..         ADDC    A,?V0 + 1
   \   000033   F5..         MOV     ?V0 + 1,A
    899          
    900            if ( OSAL_NV_CHECK_BUS_VOLTAGE )
   \   000035                ; Setup parameters for call to function HalAdcCheckVdd
   \   000035   7904         MOV     R1,#0x4
   \   000037   12....       LCALL   ??HalAdcCheckVdd?relay
   \   00003A   E9           MOV     A,R1
   \   00003B   600F         JZ      ??writeWordM_0
    901            {
    902              flashWriteBuf(cnt, (uint16)buf, offset);
   \   00003D                ; Setup parameters for call to function flashWriteBuf
   \   00003D   AC..         MOV     R4,?V0 + 0
   \   00003F   AD..         MOV     R5,?V0 + 1
   \   000041   AA..         MOV     R2,?V0 + 4
   \   000043   AB..         MOV     R3,?V0 + 5
   \   000045   EF           MOV     A,R7
   \   000046   F9           MOV     R1,A
   \   000047   12....       LCALL   flashWriteBuf & 0xFFFF
   \   00004A   8006         SJMP    ??writeWordM_1
    903            }
    904            else
    905            {
    906              failF = TRUE;
   \                     ??writeWordM_0:
   \   00004C   7401         MOV     A,#0x1
   \   00004E   90....       MOV     DPTR,#failF
   \   000051   F0           MOVX    @DPTR,A
    907            }
    908          }
   \                     ??writeWordM_1:
   \   000052   7F06         MOV     R7,#0x6
   \   000054   02....       LJMP    ?BANKED_LEAVE_XDATA
    909          
    910          /*********************************************************************
    911           * @fn      writeWordH
    912           *
    913           * @brief   Writes the 1st half of a Flash-WORD to NV (filling 2nd half with 0xffff).
    914           *
    915           * @param   pg - A valid NV Flash page.
    916           * @param   offset - A valid offset into the page.
    917           * @param   buf - Pointer to source buffer.
    918           *
    919           * @return  none
    920           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    921          static void writeWordH( uint8 pg, uint16 offset, uint8 *buf )
   \                     writeWordH:
    922          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 0,R1
   \   00000C   EA           MOV     A,R2
   \   00000D   FE           MOV     R6,A
   \   00000E   EB           MOV     A,R3
   \   00000F   FF           MOV     R7,A
   \   000010   8C..         MOV     ?V0 + 2,R4
   \   000012   8D..         MOV     ?V0 + 3,R5
    923            uint8 tmp[4];
    924          
    925            tmp[0] = buf[0];
   \   000014   85..82       MOV     DPL,?V0 + 2
   \   000017   85..83       MOV     DPH,?V0 + 3
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   85..82       MOV     DPL,?XSP + 0
   \   00001E   85..83       MOV     DPH,?XSP + 1
   \   000021   F0           MOVX    @DPTR,A
    926            tmp[1] = buf[1];
   \   000022   85..82       MOV     DPL,?V0 + 2
   \   000025   85..83       MOV     DPH,?V0 + 3
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   C0E0         PUSH    A
   \   00002C   7401         MOV     A,#0x1
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   D0E0         POP     A
   \   000033   F0           MOVX    @DPTR,A
    927            tmp[2] = OSAL_NV_ERASED;
   \   000034   74FF         MOV     A,#-0x1
   \   000036   C0E0         PUSH    A
   \   000038   7402         MOV     A,#0x2
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   D0E0         POP     A
   \   00003F   F0           MOVX    @DPTR,A
    928            tmp[3] = OSAL_NV_ERASED;
   \   000040   74FF         MOV     A,#-0x1
   \   000042   C0E0         PUSH    A
   \   000044   7403         MOV     A,#0x3
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   D0E0         POP     A
   \   00004B   F0           MOVX    @DPTR,A
    929          
    930            writeWord( pg, offset, tmp );
   \   00004C                ; Setup parameters for call to function writeWord
   \   00004C   85..82       MOV     DPL,?XSP + 0
   \   00004F   85..83       MOV     DPH,?XSP + 1
   \   000052   AC82         MOV     R4,DPL
   \   000054   AD83         MOV     R5,DPH
   \   000056   EE           MOV     A,R6
   \   000057   FA           MOV     R2,A
   \   000058   EF           MOV     A,R7
   \   000059   FB           MOV     R3,A
   \   00005A   A9..         MOV     R1,?V0 + 0
   \   00005C   12....       LCALL   ??writeWord?relay
    931          }
   \   00005F   7404         MOV     A,#0x4
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
   \   000064   7F04         MOV     R7,#0x4
   \   000066   02....       LJMP    ?BANKED_LEAVE_XDATA
    932          
    933          /*********************************************************************
    934           * @fn      writeBuf
    935           *
    936           * @brief   Writes a data buffer to NV.
    937           *
    938           * @param   dstPg - A valid NV Flash page.
    939           * @param   offset - A valid offset into the page.
    940           * @param   len  - Byte count of the data to write.
    941           * @param   buf  - The data to write.
    942           *
    943           * @return  TRUE if data buf checksum matches read back checksum, else FALSE.
    944           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    945          static void writeBuf( uint8 dstPg, uint16 dstOff, uint16 len, uint8 *buf )
   \                     writeBuf:
    946          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 2,R1
   \   00000C   EA           MOV     A,R2
   \   00000D   FE           MOV     R6,A
   \   00000E   EB           MOV     A,R3
   \   00000F   FF           MOV     R7,A
   \   000010   8C..         MOV     ?V0 + 0,R4
   \   000012   8D..         MOV     ?V0 + 1,R5
    947            uint8 rem = dstOff % OSAL_NV_WORD_SIZE;
   \   000014   EE           MOV     A,R6
   \   000015   F8           MOV     R0,A
   \   000016   EF           MOV     A,R7
   \   000017   F9           MOV     R1,A
   \   000018   7A04         MOV     R2,#0x4
   \   00001A   7B00         MOV     R3,#0x0
   \   00001C   12....       LCALL   ?US_DIV_MOD
   \   00001F   EA           MOV     A,R2
   \   000020   F5..         MOV     ?V0 + 3,A
    948            uint8 tmp[OSAL_NV_WORD_SIZE];
    949          
    950            if ( rem )
   \   000022   E5..         MOV     A,?V0 + 3
   \   000024   7003         JNZ     $+5
   \   000026   02....       LJMP    ??writeBuf_0 & 0xFFFF
    951            {
    952              dstOff = (dstOff / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE;
   \   000029   8E..         MOV     ?V0 + 4,R6
   \   00002B   8F..         MOV     ?V0 + 5,R7
   \   00002D   7402         MOV     A,#0x2
   \   00002F   78..         MOV     R0,#?V0 + 4
   \   000031   12....       LCALL   ?US_SHR
   \   000034   AE..         MOV     R6,?V0 + 4
   \   000036   EE           MOV     A,R6
   \   000037   75F004       MOV     B,#0x4
   \   00003A   A4           MUL     AB
   \   00003B   CE           XCH     A,R6
   \   00003C   AAF0         MOV     R2,B
   \   00003E   75F000       MOV     B,#0x0
   \   000041   A4           MUL     AB
   \   000042   2A           ADD     A,R2
   \   000043   FA           MOV     R2,A
   \   000044   75F004       MOV     B,#0x4
   \   000047   E5..         MOV     A,?V0 + 5
   \   000049   A4           MUL     AB
   \   00004A   2A           ADD     A,R2
   \   00004B   FF           MOV     R7,A
    953              nvReadWord( dstPg, dstOff, tmp );
   \   00004C                ; Setup parameters for call to function nvReadWord
   \   00004C   85..82       MOV     DPL,?XSP + 0
   \   00004F   85..83       MOV     DPH,?XSP + 1
   \   000052   AC82         MOV     R4,DPL
   \   000054   AD83         MOV     R5,DPH
   \   000056   EE           MOV     A,R6
   \   000057   FA           MOV     R2,A
   \   000058   EF           MOV     A,R7
   \   000059   FB           MOV     R3,A
   \   00005A   A9..         MOV     R1,?V0 + 2
   \   00005C   12....       LCALL   nvReadWord & 0xFFFF
    954          
    955              while ( (rem < OSAL_NV_WORD_SIZE) && len )
   \                     ??writeBuf_1:
   \   00005F   E5..         MOV     A,?V0 + 3
   \   000061   C3           CLR     C
   \   000062   9404         SUBB    A,#0x4
   \   000064   505F         JNC     ??writeBuf_2
   \   000066   7400         MOV     A,#0x0
   \   000068   65..         XRL     A,?V0 + 0
   \   00006A   7004         JNZ     ??writeBuf_3
   \   00006C   7400         MOV     A,#0x0
   \   00006E   65..         XRL     A,?V0 + 1
   \                     ??writeBuf_3:
   \   000070   6053         JZ      ??writeBuf_2
    956              {
    957                tmp[rem++] = *buf++;
   \   000072   7413         MOV     A,#0x13
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   E0           MOVX    A,@DPTR
   \   000078   F8           MOV     R0,A
   \   000079   A3           INC     DPTR
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   F583         MOV     DPH,A
   \   00007D   8882         MOV     DPL,R0
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   C0E0         PUSH    A
   \   000082   85....       MOV     ?V0 + 4,?V0 + 3
   \   000085   75..00       MOV     ?V0 + 5,#0x0
   \   000088   85..82       MOV     DPL,?XSP + 0
   \   00008B   85..83       MOV     DPH,?XSP + 1
   \   00008E   E582         MOV     A,DPL
   \   000090   25..         ADD     A,?V0 + 4
   \   000092   F582         MOV     DPL,A
   \   000094   E583         MOV     A,DPH
   \   000096   35..         ADDC    A,?V0 + 5
   \   000098   F583         MOV     DPH,A
   \   00009A   D0E0         POP     A
   \   00009C   F0           MOVX    @DPTR,A
   \   00009D   7413         MOV     A,#0x13
   \   00009F   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   2401         ADD     A,#0x1
   \   0000A5   F8           MOV     R0,A
   \   0000A6   A3           INC     DPTR
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   3400         ADDC    A,#0x0
   \   0000AA   F9           MOV     R1,A
   \   0000AB   7413         MOV     A,#0x13
   \   0000AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B0   E8           MOV     A,R0
   \   0000B1   F0           MOVX    @DPTR,A
   \   0000B2   A3           INC     DPTR
   \   0000B3   E9           MOV     A,R1
   \   0000B4   F0           MOVX    @DPTR,A
   \   0000B5   05..         INC     ?V0 + 3
    958                len--;
   \   0000B7   E5..         MOV     A,?V0 + 0
   \   0000B9   24FF         ADD     A,#-0x1
   \   0000BB   F5..         MOV     ?V0 + 0,A
   \   0000BD   E5..         MOV     A,?V0 + 1
   \   0000BF   34FF         ADDC    A,#-0x1
   \   0000C1   F5..         MOV     ?V0 + 1,A
   \   0000C3   809A         SJMP    ??writeBuf_1
    959              }
    960          
    961              writeWord( dstPg, dstOff, tmp );
   \                     ??writeBuf_2:
   \   0000C5                ; Setup parameters for call to function writeWord
   \   0000C5   85..82       MOV     DPL,?XSP + 0
   \   0000C8   85..83       MOV     DPH,?XSP + 1
   \   0000CB   AC82         MOV     R4,DPL
   \   0000CD   AD83         MOV     R5,DPH
   \   0000CF   EE           MOV     A,R6
   \   0000D0   FA           MOV     R2,A
   \   0000D1   EF           MOV     A,R7
   \   0000D2   FB           MOV     R3,A
   \   0000D3   A9..         MOV     R1,?V0 + 2
   \   0000D5   12....       LCALL   ??writeWord?relay
    962              dstOff += OSAL_NV_WORD_SIZE;
   \   0000D8   EE           MOV     A,R6
   \   0000D9   2404         ADD     A,#0x4
   \   0000DB   FE           MOV     R6,A
   \   0000DC   EF           MOV     A,R7
   \   0000DD   3400         ADDC    A,#0x0
   \   0000DF   FF           MOV     R7,A
    963            }
    964          
    965            rem = len % OSAL_NV_WORD_SIZE;
   \                     ??writeBuf_0:
   \   0000E0   A8..         MOV     R0,?V0 + 0
   \   0000E2   A9..         MOV     R1,?V0 + 1
   \   0000E4   7A04         MOV     R2,#0x4
   \   0000E6   7B00         MOV     R3,#0x0
   \   0000E8   12....       LCALL   ?US_DIV_MOD
   \   0000EB   EA           MOV     A,R2
   \   0000EC   F5..         MOV     ?V0 + 3,A
    966            len /= OSAL_NV_WORD_SIZE;
   \   0000EE   85....       MOV     ?V0 + 4,?V0 + 0
   \   0000F1   85....       MOV     ?V0 + 5,?V0 + 1
   \   0000F4   7402         MOV     A,#0x2
   \   0000F6   78..         MOV     R0,#?V0 + 4
   \   0000F8   12....       LCALL   ?US_SHR
   \   0000FB   85....       MOV     ?V0 + 0,?V0 + 4
   \   0000FE   85....       MOV     ?V0 + 1,?V0 + 5
    967          
    968            if ( len )
   \   000101   7400         MOV     A,#0x0
   \   000103   65..         XRL     A,?V0 + 0
   \   000105   7004         JNZ     ??writeBuf_4
   \   000107   7400         MOV     A,#0x0
   \   000109   65..         XRL     A,?V0 + 1
   \                     ??writeBuf_4:
   \   00010B   606D         JZ      ??writeBuf_5
    969            {
    970              writeWordM( dstPg, dstOff, buf, (uint8)len );
   \   00010D                ; Setup parameters for call to function writeWordM
   \   00010D   E5..         MOV     A,?V0 + 0
   \   00010F   F5..         MOV     ?V0 + 4,A
   \   000111   78..         MOV     R0,#?V0 + 4
   \   000113   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000116   7414         MOV     A,#0x14
   \   000118   12....       LCALL   ?XSTACK_DISP0_8
   \   00011B   E0           MOVX    A,@DPTR
   \   00011C   FC           MOV     R4,A
   \   00011D   A3           INC     DPTR
   \   00011E   E0           MOVX    A,@DPTR
   \   00011F   FD           MOV     R5,A
   \   000120   EE           MOV     A,R6
   \   000121   FA           MOV     R2,A
   \   000122   EF           MOV     A,R7
   \   000123   FB           MOV     R3,A
   \   000124   A9..         MOV     R1,?V0 + 2
   \   000126   12....       LCALL   ??writeWordM?relay
   \   000129   7401         MOV     A,#0x1
   \   00012B   12....       LCALL   ?DEALLOC_XSTACK8
    971              dstOff += OSAL_NV_WORD_SIZE * len;
   \   00012E   A8..         MOV     R0,?V0 + 0
   \   000130   E8           MOV     A,R0
   \   000131   75F004       MOV     B,#0x4
   \   000134   A4           MUL     AB
   \   000135   C8           XCH     A,R0
   \   000136   AAF0         MOV     R2,B
   \   000138   75F000       MOV     B,#0x0
   \   00013B   A4           MUL     AB
   \   00013C   2A           ADD     A,R2
   \   00013D   FA           MOV     R2,A
   \   00013E   75F004       MOV     B,#0x4
   \   000141   E5..         MOV     A,?V0 + 1
   \   000143   A4           MUL     AB
   \   000144   2A           ADD     A,R2
   \   000145   F9           MOV     R1,A
   \   000146   EE           MOV     A,R6
   \   000147   28           ADD     A,R0
   \   000148   FE           MOV     R6,A
   \   000149   EF           MOV     A,R7
   \   00014A   39           ADDC    A,R1
   \   00014B   FF           MOV     R7,A
    972              buf += OSAL_NV_WORD_SIZE * len;
   \   00014C   A8..         MOV     R0,?V0 + 0
   \   00014E   E8           MOV     A,R0
   \   00014F   75F004       MOV     B,#0x4
   \   000152   A4           MUL     AB
   \   000153   C8           XCH     A,R0
   \   000154   AAF0         MOV     R2,B
   \   000156   75F000       MOV     B,#0x0
   \   000159   A4           MUL     AB
   \   00015A   2A           ADD     A,R2
   \   00015B   FA           MOV     R2,A
   \   00015C   75F004       MOV     B,#0x4
   \   00015F   E5..         MOV     A,?V0 + 1
   \   000161   A4           MUL     AB
   \   000162   2A           ADD     A,R2
   \   000163   F9           MOV     R1,A
   \   000164   7413         MOV     A,#0x13
   \   000166   12....       LCALL   ?XSTACK_DISP0_8
   \   000169   E0           MOVX    A,@DPTR
   \   00016A   28           ADD     A,R0
   \   00016B   F8           MOV     R0,A
   \   00016C   A3           INC     DPTR
   \   00016D   E0           MOVX    A,@DPTR
   \   00016E   39           ADDC    A,R1
   \   00016F   F9           MOV     R1,A
   \   000170   7413         MOV     A,#0x13
   \   000172   12....       LCALL   ?XSTACK_DISP0_8
   \   000175   E8           MOV     A,R0
   \   000176   F0           MOVX    @DPTR,A
   \   000177   A3           INC     DPTR
   \   000178   E9           MOV     A,R1
   \   000179   F0           MOVX    @DPTR,A
    973            }
    974          
    975            if ( rem )
   \                     ??writeBuf_5:
   \   00017A   E5..         MOV     A,?V0 + 3
   \   00017C   607A         JZ      ??writeBuf_6
    976            {
    977              uint8 idx = 0;
   \   00017E   75..00       MOV     ?V0 + 6,#0x0
    978              nvReadWord( dstPg, dstOff, tmp );
   \   000181                ; Setup parameters for call to function nvReadWord
   \   000181   85..82       MOV     DPL,?XSP + 0
   \   000184   85..83       MOV     DPH,?XSP + 1
   \   000187   AC82         MOV     R4,DPL
   \   000189   AD83         MOV     R5,DPH
   \   00018B   EE           MOV     A,R6
   \   00018C   FA           MOV     R2,A
   \   00018D   EF           MOV     A,R7
   \   00018E   FB           MOV     R3,A
   \   00018F   A9..         MOV     R1,?V0 + 2
   \   000191   12....       LCALL   nvReadWord & 0xFFFF
    979              while ( rem-- )
   \                     ??writeBuf_7:
   \   000194   AA..         MOV     R2,?V0 + 3
   \   000196   74FF         MOV     A,#-0x1
   \   000198   2A           ADD     A,R2
   \   000199   F5..         MOV     ?V0 + 3,A
   \   00019B   EA           MOV     A,R2
   \   00019C   6047         JZ      ??writeBuf_8
    980              {
    981                tmp[idx++] = *buf++;
   \   00019E   7413         MOV     A,#0x13
   \   0001A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   F8           MOV     R0,A
   \   0001A5   A3           INC     DPTR
   \   0001A6   E0           MOVX    A,@DPTR
   \   0001A7   F583         MOV     DPH,A
   \   0001A9   8882         MOV     DPL,R0
   \   0001AB   E0           MOVX    A,@DPTR
   \   0001AC   C0E0         PUSH    A
   \   0001AE   85....       MOV     ?V0 + 4,?V0 + 6
   \   0001B1   75..00       MOV     ?V0 + 5,#0x0
   \   0001B4   85..82       MOV     DPL,?XSP + 0
   \   0001B7   85..83       MOV     DPH,?XSP + 1
   \   0001BA   E582         MOV     A,DPL
   \   0001BC   25..         ADD     A,?V0 + 4
   \   0001BE   F582         MOV     DPL,A
   \   0001C0   E583         MOV     A,DPH
   \   0001C2   35..         ADDC    A,?V0 + 5
   \   0001C4   F583         MOV     DPH,A
   \   0001C6   D0E0         POP     A
   \   0001C8   F0           MOVX    @DPTR,A
   \   0001C9   7413         MOV     A,#0x13
   \   0001CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CE   E0           MOVX    A,@DPTR
   \   0001CF   2401         ADD     A,#0x1
   \   0001D1   F8           MOV     R0,A
   \   0001D2   A3           INC     DPTR
   \   0001D3   E0           MOVX    A,@DPTR
   \   0001D4   3400         ADDC    A,#0x0
   \   0001D6   F9           MOV     R1,A
   \   0001D7   7413         MOV     A,#0x13
   \   0001D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DC   E8           MOV     A,R0
   \   0001DD   F0           MOVX    @DPTR,A
   \   0001DE   A3           INC     DPTR
   \   0001DF   E9           MOV     A,R1
   \   0001E0   F0           MOVX    @DPTR,A
   \   0001E1   05..         INC     ?V0 + 6
   \   0001E3   80AF         SJMP    ??writeBuf_7
    982              }
    983              writeWord( dstPg, dstOff, tmp );
   \                     ??writeBuf_8:
   \   0001E5                ; Setup parameters for call to function writeWord
   \   0001E5   85..82       MOV     DPL,?XSP + 0
   \   0001E8   85..83       MOV     DPH,?XSP + 1
   \   0001EB   AC82         MOV     R4,DPL
   \   0001ED   AD83         MOV     R5,DPH
   \   0001EF   EE           MOV     A,R6
   \   0001F0   FA           MOV     R2,A
   \   0001F1   EF           MOV     A,R7
   \   0001F2   FB           MOV     R3,A
   \   0001F3   A9..         MOV     R1,?V0 + 2
   \   0001F5   12....       LCALL   ??writeWord?relay
    984            }
    985          }
   \                     ??writeBuf_6:
   \   0001F8   7404         MOV     A,#0x4
   \   0001FA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001FD   7F07         MOV     R7,#0x7
   \   0001FF   02....       LJMP    ?BANKED_LEAVE_XDATA
    986          
    987          /*********************************************************************
    988           * @fn      xferBuf
    989           *
    990           * @brief   Xfers an NV buffer from one location to another, enforcing OSAL_NV_WORD_SIZE writes.
    991           *
    992           * @return  none
    993           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    994          static void xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len )
   \                     xferBuf:
    995          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   89..         MOV     ?V0 + 7,R1
   \   000017   8C..         MOV     ?V0 + 3,R4
   \   000019   7416         MOV     A,#0x16
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F5..         MOV     ?V0 + 0,A
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 1,A
   \   000025   7418         MOV     A,#0x18
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   FE           MOV     R6,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   FF           MOV     R7,A
    996            uint8 rem = dstOff % OSAL_NV_WORD_SIZE;
   \   00002F   A8..         MOV     R0,?V0 + 0
   \   000031   A9..         MOV     R1,?V0 + 1
   \   000033   7A04         MOV     R2,#0x4
   \   000035   7B00         MOV     R3,#0x0
   \   000037   12....       LCALL   ?US_DIV_MOD
   \   00003A   EA           MOV     A,R2
   \   00003B   F5..         MOV     ?V0 + 2,A
    997            uint8 tmp[OSAL_NV_WORD_SIZE];
    998          
    999            if ( rem )
   \   00003D   E5..         MOV     A,?V0 + 2
   \   00003F   7003         JNZ     $+5
   \   000041   02....       LJMP    ??xferBuf_0 & 0xFFFF
   1000            {
   1001              dstOff -= rem;
   \   000044   85....       MOV     ?V0 + 4,?V0 + 2
   \   000047   75..00       MOV     ?V0 + 5,#0x0
   \   00004A   C3           CLR     C
   \   00004B   E5..         MOV     A,?V0 + 0
   \   00004D   95..         SUBB    A,?V0 + 4
   \   00004F   F5..         MOV     ?V0 + 0,A
   \   000051   E5..         MOV     A,?V0 + 1
   \   000053   95..         SUBB    A,?V0 + 5
   \   000055   F5..         MOV     ?V0 + 1,A
   1002              nvReadWord( dstPg, dstOff, tmp );
   \   000057                ; Setup parameters for call to function nvReadWord
   \   000057   7402         MOV     A,#0x2
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   AC82         MOV     R4,DPL
   \   00005E   AD83         MOV     R5,DPH
   \   000060   AA..         MOV     R2,?V0 + 0
   \   000062   AB..         MOV     R3,?V0 + 1
   \   000064   A9..         MOV     R1,?V0 + 3
   \   000066   12....       LCALL   nvReadWord & 0xFFFF
   1003          
   1004              while ( (rem < OSAL_NV_WORD_SIZE) && len )
   \                     ??xferBuf_1:
   \   000069   E5..         MOV     A,?V0 + 2
   \   00006B   C3           CLR     C
   \   00006C   9404         SUBB    A,#0x4
   \   00006E   504A         JNC     ??xferBuf_2
   \   000070   7400         MOV     A,#0x0
   \   000072   6E           XRL     A,R6
   \   000073   7003         JNZ     ??xferBuf_3
   \   000075   7400         MOV     A,#0x0
   \   000077   6F           XRL     A,R7
   \                     ??xferBuf_3:
   \   000078   6040         JZ      ??xferBuf_2
   1005              {
   1006                nvReadByte( srcPg, srcOff, tmp+rem );
   \   00007A                ; Setup parameters for call to function nvReadByte
   \   00007A   85....       MOV     ?V0 + 4,?V0 + 2
   \   00007D   75..00       MOV     ?V0 + 5,#0x0
   \   000080   7402         MOV     A,#0x2
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   E582         MOV     A,DPL
   \   000087   25..         ADD     A,?V0 + 4
   \   000089   FC           MOV     R4,A
   \   00008A   E583         MOV     A,DPH
   \   00008C   35..         ADDC    A,?V0 + 5
   \   00008E   FD           MOV     R5,A
   \   00008F   85..82       MOV     DPL,?XSP + 0
   \   000092   85..83       MOV     DPH,?XSP + 1
   \   000095   E0           MOVX    A,@DPTR
   \   000096   FA           MOV     R2,A
   \   000097   A3           INC     DPTR
   \   000098   E0           MOVX    A,@DPTR
   \   000099   FB           MOV     R3,A
   \   00009A   A9..         MOV     R1,?V0 + 7
   \   00009C   12....       LCALL   nvReadByte & 0xFFFF
   1007                srcOff++;
   \   00009F   85..82       MOV     DPL,?XSP + 0
   \   0000A2   85..83       MOV     DPH,?XSP + 1
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   2401         ADD     A,#0x1
   \   0000A8   F0           MOVX    @DPTR,A
   \   0000A9   A3           INC     DPTR
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   3400         ADDC    A,#0x0
   \   0000AD   F0           MOVX    @DPTR,A
   1008                rem++;
   \   0000AE   05..         INC     ?V0 + 2
   1009                len--;
   \   0000B0   EE           MOV     A,R6
   \   0000B1   24FF         ADD     A,#-0x1
   \   0000B3   FE           MOV     R6,A
   \   0000B4   EF           MOV     A,R7
   \   0000B5   34FF         ADDC    A,#-0x1
   \   0000B7   FF           MOV     R7,A
   \   0000B8   80AF         SJMP    ??xferBuf_1
   1010              }
   1011          
   1012              writeWord( dstPg, dstOff, tmp );
   \                     ??xferBuf_2:
   \   0000BA                ; Setup parameters for call to function writeWord
   \   0000BA   7402         MOV     A,#0x2
   \   0000BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BF   AC82         MOV     R4,DPL
   \   0000C1   AD83         MOV     R5,DPH
   \   0000C3   AA..         MOV     R2,?V0 + 0
   \   0000C5   AB..         MOV     R3,?V0 + 1
   \   0000C7   A9..         MOV     R1,?V0 + 3
   \   0000C9   12....       LCALL   ??writeWord?relay
   1013              dstOff += OSAL_NV_WORD_SIZE;
   \   0000CC   E5..         MOV     A,?V0 + 0
   \   0000CE   2404         ADD     A,#0x4
   \   0000D0   F5..         MOV     ?V0 + 0,A
   \   0000D2   E5..         MOV     A,?V0 + 1
   \   0000D4   3400         ADDC    A,#0x0
   \   0000D6   F5..         MOV     ?V0 + 1,A
   1014            }
   1015          
   1016            rem = len % OSAL_NV_WORD_SIZE;
   \                     ??xferBuf_0:
   \   0000D8   EE           MOV     A,R6
   \   0000D9   F8           MOV     R0,A
   \   0000DA   EF           MOV     A,R7
   \   0000DB   F9           MOV     R1,A
   \   0000DC   7A04         MOV     R2,#0x4
   \   0000DE   7B00         MOV     R3,#0x0
   \   0000E0   12....       LCALL   ?US_DIV_MOD
   \   0000E3   EA           MOV     A,R2
   \   0000E4   F5..         MOV     ?V0 + 2,A
   1017            len /= OSAL_NV_WORD_SIZE;
   \   0000E6   8E..         MOV     ?V0 + 4,R6
   \   0000E8   8F..         MOV     ?V0 + 5,R7
   \   0000EA   7402         MOV     A,#0x2
   \   0000EC   78..         MOV     R0,#?V0 + 4
   \   0000EE   12....       LCALL   ?US_SHR
   \   0000F1   AE..         MOV     R6,?V0 + 4
   \   0000F3   AF..         MOV     R7,?V0 + 5
   1018          
   1019            while ( len-- )
   \                     ??xferBuf_4:
   \   0000F5   EE           MOV     A,R6
   \   0000F6   F8           MOV     R0,A
   \   0000F7   EF           MOV     A,R7
   \   0000F8   F9           MOV     R1,A
   \   0000F9   74FF         MOV     A,#-0x1
   \   0000FB   28           ADD     A,R0
   \   0000FC   FE           MOV     R6,A
   \   0000FD   74FF         MOV     A,#-0x1
   \   0000FF   39           ADDC    A,R1
   \   000100   FF           MOV     R7,A
   \   000101   7400         MOV     A,#0x0
   \   000103   68           XRL     A,R0
   \   000104   7003         JNZ     ??xferBuf_5
   \   000106   7400         MOV     A,#0x0
   \   000108   69           XRL     A,R1
   \                     ??xferBuf_5:
   \   000109   6048         JZ      ??xferBuf_6
   1020            {
   1021              nvReadWord( srcPg, srcOff, tmp );
   \   00010B                ; Setup parameters for call to function nvReadWord
   \   00010B   7402         MOV     A,#0x2
   \   00010D   12....       LCALL   ?XSTACK_DISP0_8
   \   000110   AC82         MOV     R4,DPL
   \   000112   AD83         MOV     R5,DPH
   \   000114   85..82       MOV     DPL,?XSP + 0
   \   000117   85..83       MOV     DPH,?XSP + 1
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   FA           MOV     R2,A
   \   00011C   A3           INC     DPTR
   \   00011D   E0           MOVX    A,@DPTR
   \   00011E   FB           MOV     R3,A
   \   00011F   A9..         MOV     R1,?V0 + 7
   \   000121   12....       LCALL   nvReadWord & 0xFFFF
   1022              srcOff += OSAL_NV_WORD_SIZE;
   \   000124   85..82       MOV     DPL,?XSP + 0
   \   000127   85..83       MOV     DPH,?XSP + 1
   \   00012A   E0           MOVX    A,@DPTR
   \   00012B   2404         ADD     A,#0x4
   \   00012D   F0           MOVX    @DPTR,A
   \   00012E   A3           INC     DPTR
   \   00012F   E0           MOVX    A,@DPTR
   \   000130   3400         ADDC    A,#0x0
   \   000132   F0           MOVX    @DPTR,A
   1023              writeWord( dstPg, dstOff, tmp );
   \   000133                ; Setup parameters for call to function writeWord
   \   000133   7402         MOV     A,#0x2
   \   000135   12....       LCALL   ?XSTACK_DISP0_8
   \   000138   AC82         MOV     R4,DPL
   \   00013A   AD83         MOV     R5,DPH
   \   00013C   AA..         MOV     R2,?V0 + 0
   \   00013E   AB..         MOV     R3,?V0 + 1
   \   000140   A9..         MOV     R1,?V0 + 3
   \   000142   12....       LCALL   ??writeWord?relay
   1024              dstOff += OSAL_NV_WORD_SIZE;
   \   000145   E5..         MOV     A,?V0 + 0
   \   000147   2404         ADD     A,#0x4
   \   000149   F5..         MOV     ?V0 + 0,A
   \   00014B   E5..         MOV     A,?V0 + 1
   \   00014D   3400         ADDC    A,#0x0
   \   00014F   F5..         MOV     ?V0 + 1,A
   \   000151   80A2         SJMP    ??xferBuf_4
   1025            }
   1026          
   1027            if ( rem )
   \                     ??xferBuf_6:
   \   000153   E5..         MOV     A,?V0 + 2
   \   000155   6069         JZ      ??xferBuf_7
   1028            {
   1029              uint8 idx = 0;
   \   000157   75..00       MOV     ?V0 + 6,#0x0
   1030              nvReadWord( dstPg, dstOff, tmp );
   \   00015A                ; Setup parameters for call to function nvReadWord
   \   00015A   7402         MOV     A,#0x2
   \   00015C   12....       LCALL   ?XSTACK_DISP0_8
   \   00015F   AC82         MOV     R4,DPL
   \   000161   AD83         MOV     R5,DPH
   \   000163   AA..         MOV     R2,?V0 + 0
   \   000165   AB..         MOV     R3,?V0 + 1
   \   000167   A9..         MOV     R1,?V0 + 3
   \   000169   12....       LCALL   nvReadWord & 0xFFFF
   1031              while ( rem-- )
   \                     ??xferBuf_8:
   \   00016C   AA..         MOV     R2,?V0 + 2
   \   00016E   74FF         MOV     A,#-0x1
   \   000170   2A           ADD     A,R2
   \   000171   F5..         MOV     ?V0 + 2,A
   \   000173   EA           MOV     A,R2
   \   000174   6038         JZ      ??xferBuf_9
   1032              {
   1033                nvReadByte( srcPg, srcOff, tmp+idx );
   \   000176                ; Setup parameters for call to function nvReadByte
   \   000176   85....       MOV     ?V0 + 4,?V0 + 6
   \   000179   75..00       MOV     ?V0 + 5,#0x0
   \   00017C   7402         MOV     A,#0x2
   \   00017E   12....       LCALL   ?XSTACK_DISP0_8
   \   000181   E582         MOV     A,DPL
   \   000183   25..         ADD     A,?V0 + 4
   \   000185   FC           MOV     R4,A
   \   000186   E583         MOV     A,DPH
   \   000188   35..         ADDC    A,?V0 + 5
   \   00018A   FD           MOV     R5,A
   \   00018B   85..82       MOV     DPL,?XSP + 0
   \   00018E   85..83       MOV     DPH,?XSP + 1
   \   000191   E0           MOVX    A,@DPTR
   \   000192   FA           MOV     R2,A
   \   000193   A3           INC     DPTR
   \   000194   E0           MOVX    A,@DPTR
   \   000195   FB           MOV     R3,A
   \   000196   A9..         MOV     R1,?V0 + 7
   \   000198   12....       LCALL   nvReadByte & 0xFFFF
   1034                srcOff++;
   \   00019B   85..82       MOV     DPL,?XSP + 0
   \   00019E   85..83       MOV     DPH,?XSP + 1
   \   0001A1   E0           MOVX    A,@DPTR
   \   0001A2   2401         ADD     A,#0x1
   \   0001A4   F0           MOVX    @DPTR,A
   \   0001A5   A3           INC     DPTR
   \   0001A6   E0           MOVX    A,@DPTR
   \   0001A7   3400         ADDC    A,#0x0
   \   0001A9   F0           MOVX    @DPTR,A
   1035                idx++;
   \   0001AA   05..         INC     ?V0 + 6
   \   0001AC   80BE         SJMP    ??xferBuf_8
   1036              }
   1037              writeWord( dstPg, dstOff, tmp );
   \                     ??xferBuf_9:
   \   0001AE                ; Setup parameters for call to function writeWord
   \   0001AE   7402         MOV     A,#0x2
   \   0001B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B3   AC82         MOV     R4,DPL
   \   0001B5   AD83         MOV     R5,DPH
   \   0001B7   AA..         MOV     R2,?V0 + 0
   \   0001B9   AB..         MOV     R3,?V0 + 1
   \   0001BB   A9..         MOV     R1,?V0 + 3
   \   0001BD   12....       LCALL   ??writeWord?relay
   1038            }
   1039          }
   \                     ??xferBuf_7:
   \   0001C0   7406         MOV     A,#0x6
   \   0001C2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001C5   7F08         MOV     R7,#0x8
   \   0001C7   02....       LJMP    ?BANKED_LEAVE_XDATA
   1040          
   1041          /*********************************************************************
   1042           * @fn      writeItem
   1043           *
   1044           * @brief   Writes an item header/data combo to the specified NV page.
   1045           *
   1046           * @param   pg - Valid NV Flash page.
   1047           * @param   id - Valid NV item Id.
   1048           * @param   len  - Byte count of the data to write.
   1049           * @param   buf  - The data to write. If NULL, no data/checksum write.
   1050           * @param   flag - TRUE if the checksum should be written, FALSE otherwise.
   1051           *
   1052           * @return  TRUE if header/data to write matches header/data read back, else FALSE.
   1053           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1054          static uint8 writeItem( uint8 pg, uint16 id, uint16 len, void *buf, uint8 flag )
   \                     writeItem:
   1055          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   E9           MOV     A,R1
   \   000015   FE           MOV     R6,A
   \   000016   8C..         MOV     ?V0 + 4,R4
   \   000018   8D..         MOV     ?V0 + 5,R5
   \   00001A   741D         MOV     A,#0x1d
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F5..         MOV     ?V0 + 6,A
   1056            uint16 offset = pgOff[pg-OSAL_NV_PAGE_BEG];
   \   000022   EE           MOV     A,R6
   \   000023   F8           MOV     R0,A
   \   000024   7900         MOV     R1,#0x0
   \   000026   E8           MOV     A,R0
   \   000027   75F002       MOV     B,#0x2
   \   00002A   A4           MUL     AB
   \   00002B   C8           XCH     A,R0
   \   00002C   AAF0         MOV     R2,B
   \   00002E   75F000       MOV     B,#0x0
   \   000031   A4           MUL     AB
   \   000032   2A           ADD     A,R2
   \   000033   FA           MOV     R2,A
   \   000034   75F002       MOV     B,#0x2
   \   000037   E9           MOV     A,R1
   \   000038   A4           MUL     AB
   \   000039   2A           ADD     A,R2
   \   00003A   F9           MOV     R1,A
   \   00003B   E8           MOV     A,R0
   \   00003C   24..         ADD     A,#((pgOff + 136) & 0xff)
   \   00003E   F582         MOV     DPL,A
   \   000040   E9           MOV     A,R1
   \   000041   34..         ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
   \   000043   F583         MOV     DPH,A
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F5..         MOV     ?V0 + 0,A
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F5..         MOV     ?V0 + 1,A
   1057            uint8 rtrn = FALSE;
   \   00004C   7F00         MOV     R7,#0x0
   1058            osalNvHdr_t hdr;
   1059          
   1060            if ( pg == pgRes )
   \   00004E   90....       MOV     DPTR,#pgRes
   \   000051   E0           MOVX    A,@DPTR
   \   000052   6E           XRL     A,R6
   \   000053   7007         JNZ     ??writeItem_0
   1061            {
   1062              /* Mark reserve page as being active, in process of receiving items.
   1063               * Invoking function must effect a page compaction.
   1064               */
   1065              setPageUse( pg, FALSE );
   \   000055                ; Setup parameters for call to function setPageUse
   \   000055   7A00         MOV     R2,#0x0
   \   000057   EE           MOV     A,R6
   \   000058   F9           MOV     R1,A
   \   000059   12....       LCALL   ??setPageUse?relay
   1066            }
   1067          
   1068            hdr.id = id;
   \                     ??writeItem_0:
   \   00005C   7402         MOV     A,#0x2
   \   00005E   12....       LCALL   ?XSTACK_DISP0_8
   \   000061   E0           MOVX    A,@DPTR
   \   000062   F8           MOV     R0,A
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F9           MOV     R1,A
   \   000066   7404         MOV     A,#0x4
   \   000068   12....       LCALL   ?XSTACK_DISP0_8
   \   00006B   E8           MOV     A,R0
   \   00006C   F0           MOVX    @DPTR,A
   \   00006D   A3           INC     DPTR
   \   00006E   E9           MOV     A,R1
   \   00006F   F0           MOVX    @DPTR,A
   1069            hdr.len = len;
   \   000070   7406         MOV     A,#0x6
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   E5..         MOV     A,?V0 + 4
   \   000077   F0           MOVX    @DPTR,A
   \   000078   A3           INC     DPTR
   \   000079   E5..         MOV     A,?V0 + 5
   \   00007B   F0           MOVX    @DPTR,A
   1070          
   1071            writeWord( pg, offset, (uint8 *)&hdr );
   \   00007C                ; Setup parameters for call to function writeWord
   \   00007C   7404         MOV     A,#0x4
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   AC82         MOV     R4,DPL
   \   000083   AD83         MOV     R5,DPH
   \   000085   AA..         MOV     R2,?V0 + 0
   \   000087   AB..         MOV     R3,?V0 + 1
   \   000089   EE           MOV     A,R6
   \   00008A   F9           MOV     R1,A
   \   00008B   12....       LCALL   ??writeWord?relay
   1072            nvReadHdr( pg, offset, (uint8 *)(&hdr) );
   \   00008E                ; Setup parameters for call to function nvReadHdr
   \   00008E   7404         MOV     A,#0x4
   \   000090   12....       LCALL   ?XSTACK_DISP0_8
   \   000093   AC82         MOV     R4,DPL
   \   000095   AD83         MOV     R5,DPH
   \   000097   AA..         MOV     R2,?V0 + 0
   \   000099   AB..         MOV     R3,?V0 + 1
   \   00009B   EE           MOV     A,R6
   \   00009C   F9           MOV     R1,A
   \   00009D   12....       LCALL   nvReadHdr & 0xFFFF
   1073          
   1074            if ( (hdr.id == id) && (hdr.len == len) )
   \   0000A0   7404         MOV     A,#0x4
   \   0000A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   F8           MOV     R0,A
   \   0000A7   A3           INC     DPTR
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   F9           MOV     R1,A
   \   0000AA   7402         MOV     A,#0x2
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   68           XRL     A,R0
   \   0000B1   7003         JNZ     ??writeItem_1
   \   0000B3   A3           INC     DPTR
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   69           XRL     A,R1
   \                     ??writeItem_1:
   \   0000B6   6003         JZ      $+5
   \   0000B8   02....       LJMP    ??writeItem_2 & 0xFFFF
   \   0000BB   7406         MOV     A,#0x6
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   65..         XRL     A,?V0 + 4
   \   0000C3   7004         JNZ     ??writeItem_3
   \   0000C5   A3           INC     DPTR
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   65..         XRL     A,?V0 + 5
   \                     ??writeItem_3:
   \   0000C9   6003         JZ      $+5
   \   0000CB   02....       LJMP    ??writeItem_2 & 0xFFFF
   1075            {
   1076              if ( flag )
   \   0000CE   E5..         MOV     A,?V0 + 6
   \   0000D0   7003         JNZ     $+5
   \   0000D2   02....       LJMP    ??writeItem_4 & 0xFFFF
   1077              {
   1078                uint16 chk = calcChkB( len, buf );
   \   0000D5                ; Setup parameters for call to function calcChkB
   \   0000D5   741B         MOV     A,#0x1b
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   FC           MOV     R4,A
   \   0000DC   A3           INC     DPTR
   \   0000DD   E0           MOVX    A,@DPTR
   \   0000DE   FD           MOV     R5,A
   \   0000DF   AA..         MOV     R2,?V0 + 4
   \   0000E1   AB..         MOV     R3,?V0 + 5
   \   0000E3   12....       LCALL   ??calcChkB?relay
   \   0000E6   85..82       MOV     DPL,?XSP + 0
   \   0000E9   85..83       MOV     DPH,?XSP + 1
   \   0000EC   EA           MOV     A,R2
   \   0000ED   F0           MOVX    @DPTR,A
   \   0000EE   A3           INC     DPTR
   \   0000EF   EB           MOV     A,R3
   \   0000F0   F0           MOVX    @DPTR,A
   1079            
   1080                offset += OSAL_NV_HDR_SIZE;
   \   0000F1   E5..         MOV     A,?V0 + 0
   \   0000F3   2408         ADD     A,#0x8
   \   0000F5   F5..         MOV     ?V0 + 0,A
   \   0000F7   E5..         MOV     A,?V0 + 1
   \   0000F9   3400         ADDC    A,#0x0
   \   0000FB   F5..         MOV     ?V0 + 1,A
   1081                if ( buf != NULL )
   \   0000FD   741B         MOV     A,#0x1b
   \   0000FF   12....       LCALL   ?XSTACK_DISP0_8
   \   000102   E0           MOVX    A,@DPTR
   \   000103   6400         XRL     A,#0x0
   \   000105   7004         JNZ     ??writeItem_5
   \   000107   A3           INC     DPTR
   \   000108   E0           MOVX    A,@DPTR
   \   000109   6400         XRL     A,#0x0
   \                     ??writeItem_5:
   \   00010B   601A         JZ      ??writeItem_6
   1082                {
   1083                  writeBuf( pg, offset, len, buf );
   \   00010D                ; Setup parameters for call to function writeBuf
   \   00010D   741B         MOV     A,#0x1b
   \   00010F   12....       LCALL   ?XSTACK_DISP0_8
   \   000112   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000115   AC..         MOV     R4,?V0 + 4
   \   000117   AD..         MOV     R5,?V0 + 5
   \   000119   AA..         MOV     R2,?V0 + 0
   \   00011B   AB..         MOV     R3,?V0 + 1
   \   00011D   EE           MOV     A,R6
   \   00011E   F9           MOV     R1,A
   \   00011F   12....       LCALL   ??writeBuf?relay
   \   000122   7402         MOV     A,#0x2
   \   000124   12....       LCALL   ?DEALLOC_XSTACK8
   1084                }
   1085            
   1086                if ( chk == calcChkF( pg, offset, len ) )
   \                     ??writeItem_6:
   \   000127                ; Setup parameters for call to function calcChkF
   \   000127   AC..         MOV     R4,?V0 + 4
   \   000129   AD..         MOV     R5,?V0 + 5
   \   00012B   AA..         MOV     R2,?V0 + 0
   \   00012D   AB..         MOV     R3,?V0 + 1
   \   00012F   EE           MOV     A,R6
   \   000130   F9           MOV     R1,A
   \   000131   12....       LCALL   ??calcChkF?relay
   \   000134   8A..         MOV     ?V0 + 2,R2
   \   000136   8B..         MOV     ?V0 + 3,R3
   \   000138   A8..         MOV     R0,?V0 + 2
   \   00013A   A9..         MOV     R1,?V0 + 3
   \   00013C   85..82       MOV     DPL,?XSP + 0
   \   00013F   85..83       MOV     DPH,?XSP + 1
   \   000142   E0           MOVX    A,@DPTR
   \   000143   68           XRL     A,R0
   \   000144   7003         JNZ     ??writeItem_7
   \   000146   A3           INC     DPTR
   \   000147   E0           MOVX    A,@DPTR
   \   000148   69           XRL     A,R1
   \                     ??writeItem_7:
   \   000149   7050         JNZ     ??writeItem_2
   1087                {
   1088                  writeWordH( pg, (offset-OSAL_NV_WORD_SIZE), (uint8 *)&chk );
   \   00014B                ; Setup parameters for call to function writeWordH
   \   00014B   85..82       MOV     DPL,?XSP + 0
   \   00014E   85..83       MOV     DPH,?XSP + 1
   \   000151   AC82         MOV     R4,DPL
   \   000153   AD83         MOV     R5,DPH
   \   000155   74FC         MOV     A,#-0x4
   \   000157   25..         ADD     A,?V0 + 0
   \   000159   FA           MOV     R2,A
   \   00015A   74FF         MOV     A,#-0x1
   \   00015C   35..         ADDC    A,?V0 + 1
   \   00015E   FB           MOV     R3,A
   \   00015F   EE           MOV     A,R6
   \   000160   F9           MOV     R1,A
   \   000161   12....       LCALL   ??writeWordH?relay
   1089                  nvReadHdr( pg, (offset-OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
   \   000164                ; Setup parameters for call to function nvReadHdr
   \   000164   7404         MOV     A,#0x4
   \   000166   12....       LCALL   ?XSTACK_DISP0_8
   \   000169   AC82         MOV     R4,DPL
   \   00016B   AD83         MOV     R5,DPH
   \   00016D   74F8         MOV     A,#-0x8
   \   00016F   25..         ADD     A,?V0 + 0
   \   000171   FA           MOV     R2,A
   \   000172   74FF         MOV     A,#-0x1
   \   000174   35..         ADDC    A,?V0 + 1
   \   000176   FB           MOV     R3,A
   \   000177   EE           MOV     A,R6
   \   000178   F9           MOV     R1,A
   \   000179   12....       LCALL   nvReadHdr & 0xFFFF
   1090            
   1091                  if ( chk == hdr.chk )
   \   00017C   85..82       MOV     DPL,?XSP + 0
   \   00017F   85..83       MOV     DPH,?XSP + 1
   \   000182   E0           MOVX    A,@DPTR
   \   000183   F8           MOV     R0,A
   \   000184   A3           INC     DPTR
   \   000185   E0           MOVX    A,@DPTR
   \   000186   F9           MOV     R1,A
   \   000187   7408         MOV     A,#0x8
   \   000189   12....       LCALL   ?XSTACK_DISP0_8
   \   00018C   E0           MOVX    A,@DPTR
   \   00018D   68           XRL     A,R0
   \   00018E   7003         JNZ     ??writeItem_8
   \   000190   A3           INC     DPTR
   \   000191   E0           MOVX    A,@DPTR
   \   000192   69           XRL     A,R1
   \                     ??writeItem_8:
   \   000193   7006         JNZ     ??writeItem_2
   1092                  {
   1093                    rtrn = pg;
   \   000195   EE           MOV     A,R6
   \   000196   FF           MOV     R7,A
   \   000197   8002         SJMP    ??writeItem_2
   1094                  }
   1095                }
   1096              }
   1097              else
   1098              {
   1099                rtrn = pg;
   \                     ??writeItem_4:
   \   000199   EE           MOV     A,R6
   \   00019A   FF           MOV     R7,A
   1100              }
   1101            }
   1102          
   1103            len = OSAL_NV_ITEM_SIZE( hdr.len );
   \                     ??writeItem_2:
   \   00019B   7406         MOV     A,#0x6
   \   00019D   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A0   E0           MOVX    A,@DPTR
   \   0001A1   2403         ADD     A,#0x3
   \   0001A3   F5..         MOV     ?V0 + 2,A
   \   0001A5   A3           INC     DPTR
   \   0001A6   E0           MOVX    A,@DPTR
   \   0001A7   3400         ADDC    A,#0x0
   \   0001A9   F5..         MOV     ?V0 + 3,A
   \   0001AB   7402         MOV     A,#0x2
   \   0001AD   78..         MOV     R0,#?V0 + 2
   \   0001AF   12....       LCALL   ?US_SHR
   \   0001B2   E5..         MOV     A,?V0 + 2
   \   0001B4   75F004       MOV     B,#0x4
   \   0001B7   A4           MUL     AB
   \   0001B8   C5..         XCH     A,?V0 + 2
   \   0001BA   AAF0         MOV     R2,B
   \   0001BC   75F000       MOV     B,#0x0
   \   0001BF   A4           MUL     AB
   \   0001C0   2A           ADD     A,R2
   \   0001C1   FA           MOV     R2,A
   \   0001C2   75F004       MOV     B,#0x4
   \   0001C5   E5..         MOV     A,?V0 + 3
   \   0001C7   A4           MUL     AB
   \   0001C8   2A           ADD     A,R2
   \   0001C9   F5..         MOV     ?V0 + 3,A
   \   0001CB   7408         MOV     A,#0x8
   \   0001CD   25..         ADD     A,?V0 + 2
   \   0001CF   F8           MOV     R0,A
   \   0001D0   7400         MOV     A,#0x0
   \   0001D2   35..         ADDC    A,?V0 + 3
   \   0001D4   F9           MOV     R1,A
   \   0001D5   88..         MOV     ?V0 + 4,R0
   \   0001D7   89..         MOV     ?V0 + 5,R1
   1104            pgOff[pg-OSAL_NV_PAGE_BEG] += len;
   \   0001D9   EE           MOV     A,R6
   \   0001DA   F8           MOV     R0,A
   \   0001DB   7900         MOV     R1,#0x0
   \   0001DD   E8           MOV     A,R0
   \   0001DE   75F002       MOV     B,#0x2
   \   0001E1   A4           MUL     AB
   \   0001E2   C8           XCH     A,R0
   \   0001E3   AAF0         MOV     R2,B
   \   0001E5   75F000       MOV     B,#0x0
   \   0001E8   A4           MUL     AB
   \   0001E9   2A           ADD     A,R2
   \   0001EA   FA           MOV     R2,A
   \   0001EB   75F002       MOV     B,#0x2
   \   0001EE   E9           MOV     A,R1
   \   0001EF   A4           MUL     AB
   \   0001F0   2A           ADD     A,R2
   \   0001F1   F9           MOV     R1,A
   \   0001F2   E8           MOV     A,R0
   \   0001F3   24..         ADD     A,#((pgOff + 136) & 0xff)
   \   0001F5   F582         MOV     DPL,A
   \   0001F7   E9           MOV     A,R1
   \   0001F8   34..         ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
   \   0001FA   F583         MOV     DPH,A
   \   0001FC   E0           MOVX    A,@DPTR
   \   0001FD   25..         ADD     A,?V0 + 4
   \   0001FF   F0           MOVX    @DPTR,A
   \   000200   A3           INC     DPTR
   \   000201   E0           MOVX    A,@DPTR
   \   000202   35..         ADDC    A,?V0 + 5
   \   000204   F0           MOVX    @DPTR,A
   1105          
   1106            return rtrn;
   \   000205   EF           MOV     A,R7
   \   000206   F9           MOV     R1,A
   \   000207   740C         MOV     A,#0xc
   \   000209   12....       LCALL   ?DEALLOC_XSTACK8
   \   00020C   7F07         MOV     R7,#0x7
   \   00020E   02....       LJMP    ?BANKED_LEAVE_XDATA
   1107          }
   1108          
   1109          /*********************************************************************
   1110           * @fn      writeIEEE
   1111           *
   1112           * @brief   Writes special location / protocol for the IEEE. The global 'failF' should have been
   1113           *          cleared before invoking.
   1114           *
   1115           * @param   buf  - The data to write.
   1116           *
   1117           * @return  TRUE if header/data to write matches header/data read back, else FALSE.
   1118           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1119          static uint8 writeIEEE( void *buf )
   \                     writeIEEE:
   1120          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1121            osalNvHdr_t hdr;
   1122            nvReadHdr( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&hdr) );
   \   00000E                ; Setup parameters for call to function nvReadHdr
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   7AF8         MOV     R2,#-0x8
   \   00001A   7B07         MOV     R3,#0x7
   \   00001C   793F         MOV     R1,#0x3f
   \   00001E   12....       LCALL   nvReadHdr & 0xFFFF
   1123          
   1124            if ( (hdr.id == OSAL_NV_ERASED_ID) && (hdr.len == OSAL_NV_ERASED_ID) &&
   1125                 (hdr.chk == OSAL_NV_ERASED_ID) && (hdr.stat == OSAL_NV_ERASED_ID) )
   \   000021   85..82       MOV     DPL,?XSP + 0
   \   000024   85..83       MOV     DPH,?XSP + 1
   \   000027   E0           MOVX    A,@DPTR
   \   000028   64FF         XRL     A,#0xff
   \   00002A   7004         JNZ     ??writeIEEE_0
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   64FF         XRL     A,#0xff
   \                     ??writeIEEE_0:
   \   000030   7058         JNZ     ??writeIEEE_1
   \   000032   7402         MOV     A,#0x2
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   E0           MOVX    A,@DPTR
   \   000038   64FF         XRL     A,#0xff
   \   00003A   7004         JNZ     ??writeIEEE_2
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   64FF         XRL     A,#0xff
   \                     ??writeIEEE_2:
   \   000040   7048         JNZ     ??writeIEEE_1
   \   000042   7404         MOV     A,#0x4
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   E0           MOVX    A,@DPTR
   \   000048   64FF         XRL     A,#0xff
   \   00004A   7004         JNZ     ??writeIEEE_3
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   64FF         XRL     A,#0xff
   \                     ??writeIEEE_3:
   \   000050   7038         JNZ     ??writeIEEE_1
   \   000052   7406         MOV     A,#0x6
   \   000054   12....       LCALL   ?XSTACK_DISP0_8
   \   000057   E0           MOVX    A,@DPTR
   \   000058   64FF         XRL     A,#0xff
   \   00005A   7004         JNZ     ??writeIEEE_4
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   64FF         XRL     A,#0xff
   \                     ??writeIEEE_4:
   \   000060   7028         JNZ     ??writeIEEE_1
   1126            {
   1127              writeWordM( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, buf, 2 );
   \   000062                ; Setup parameters for call to function writeWordM
   \   000062   75..02       MOV     ?V0 + 0,#0x2
   \   000065   78..         MOV     R0,#?V0 + 0
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006A   EE           MOV     A,R6
   \   00006B   FC           MOV     R4,A
   \   00006C   EF           MOV     A,R7
   \   00006D   FD           MOV     R5,A
   \   00006E   7AF8         MOV     R2,#-0x8
   \   000070   7B07         MOV     R3,#0x7
   \   000072   793F         MOV     R1,#0x3f
   \   000074   12....       LCALL   ??writeWordM?relay
   \   000077   7401         MOV     A,#0x1
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   1128              return ((failF) ? NV_OPER_FAILED : ZSUCCESS);
   \   00007C   90....       MOV     DPTR,#failF
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   6004         JZ      ??writeIEEE_5
   \   000082   7910         MOV     R1,#0x10
   \   000084   8006         SJMP    ??writeIEEE_6
   \                     ??writeIEEE_5:
   \   000086   7900         MOV     R1,#0x0
   \   000088   8002         SJMP    ??writeIEEE_6
   1129            }
   1130            else
   1131            {
   1132              return NV_OPER_FAILED;
   \                     ??writeIEEE_1:
   \   00008A   7910         MOV     R1,#0x10
   \                     ??writeIEEE_6:
   \   00008C   7408         MOV     A,#0x8
   \   00008E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000091   7F01         MOV     R7,#0x1
   \   000093   02....       LJMP    ?BANKED_LEAVE_XDATA
   1133            }
   1134          }
   1135          
   1136          /*********************************************************************
   1137           * @fn      osal_nv_init
   1138           *
   1139           * @brief   Initialize NV service.
   1140           *
   1141           * @param   p - Not used.
   1142           *
   1143           * @return  none
   1144           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1145          void osal_nv_init( void *p )
   \                     osal_nv_init:
   1146          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1147            (void)p;  // Suppress Lint warning.
   1148          
   1149            // Set Flash write timing based on CPU speed.
   1150          #ifdef CPU16MHZ
   1151            FWT = 0x15;
   1152          #else
   1153            FWT = 0x2A;
   \   000005   75AB2A       MOV     0xab,#0x2a
   1154          #endif
   1155          
   1156            (void)initNV();  // Always returns TRUE after pages have been erased.
   \   000008                ; Setup parameters for call to function initNV
   \   000008   12....       LCALL   ??initNV?relay
   1157          }
   \   00000B   7F01         MOV     R7,#0x1
   \   00000D   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000010                REQUIRE FWT
   1158          
   1159          /*********************************************************************
   1160           * @fn      osal_nv_item_init
   1161           *
   1162           * @brief   If the NV item does not already exist, it is created and
   1163           *          initialized with the data passed to the function, if any.
   1164           *          This function must be called before calling osal_nv_read() or
   1165           *          osal_nv_write().
   1166           *
   1167           * @param   id  - Valid NV item Id.
   1168           * @param   len - Item length.
   1169           * @param  *buf - Pointer to item initalization data. Set to NULL if none.
   1170           *
   1171           * @return  NV_ITEM_UNINIT - Id did not exist and was created successfully.
   1172           *          ZSUCCESS       - Id already existed, no action taken.
   1173           *          NV_OPER_FAILED - Failure to find or create Id.
   1174           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1175          uint8 osal_nv_item_init( uint16 id, uint16 len, void *buf )
   \                     osal_nv_item_init:
   1176          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   \   00000D   740E         MOV     A,#0xe
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 2,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F5..         MOV     ?V0 + 3,A
   1177            /* Global fail flag for fail due to low bus voltage has less impact on code
   1178             * size than passing back a return value all the way from the lowest level.
   1179             */
   1180            failF = FALSE;
   \   000019   7400         MOV     A,#0x0
   \   00001B   90....       MOV     DPTR,#failF
   \   00001E   F0           MOVX    @DPTR,A
   1181          
   1182            // ZCD_NV_EXTADDR is maintained without an osalNvHdr_t, so it is always already initialized.
   1183            if ( (id == ZCD_NV_EXTADDR) || (findItem( id ) != OSAL_NV_ITEM_NULL) )
   \   00001F   7401         MOV     A,#0x1
   \   000021   6E           XRL     A,R6
   \   000022   7003         JNZ     ??osal_nv_item_init_0
   \   000024   7400         MOV     A,#0x0
   \   000026   6F           XRL     A,R7
   \                     ??osal_nv_item_init_0:
   \   000027   6017         JZ      ??osal_nv_item_init_1
   \   000029                ; Setup parameters for call to function findItem
   \   000029   EE           MOV     A,R6
   \   00002A   FA           MOV     R2,A
   \   00002B   EF           MOV     A,R7
   \   00002C   FB           MOV     R3,A
   \   00002D   12....       LCALL   ??findItem?relay
   \   000030   8A..         MOV     ?V0 + 4,R2
   \   000032   8B..         MOV     ?V0 + 5,R3
   \   000034   7400         MOV     A,#0x0
   \   000036   65..         XRL     A,?V0 + 4
   \   000038   7004         JNZ     ??osal_nv_item_init_2
   \   00003A   7400         MOV     A,#0x0
   \   00003C   65..         XRL     A,?V0 + 5
   \                     ??osal_nv_item_init_2:
   \   00003E   6004         JZ      ??osal_nv_item_init_3
   1184            {
   1185              return ZSUCCESS;
   \                     ??osal_nv_item_init_1:
   \   000040   7900         MOV     R1,#0x0
   \   000042   802D         SJMP    ??osal_nv_item_init_4
   1186            }
   1187            else if ( initItem( TRUE, id, len, buf ) )
   \                     ??osal_nv_item_init_3:
   \   000044                ; Setup parameters for call to function initItem
   \   000044   78..         MOV     R0,#?V0 + 2
   \   000046   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000049   AC..         MOV     R4,?V0 + 0
   \   00004B   AD..         MOV     R5,?V0 + 1
   \   00004D   EE           MOV     A,R6
   \   00004E   FA           MOV     R2,A
   \   00004F   EF           MOV     A,R7
   \   000050   FB           MOV     R3,A
   \   000051   7901         MOV     R1,#0x1
   \   000053   12....       LCALL   ??initItem?relay
   \   000056   7402         MOV     A,#0x2
   \   000058   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005B   E9           MOV     A,R1
   \   00005C   6011         JZ      ??osal_nv_item_init_5
   1188            {
   1189              if ( failF )
   \   00005E   90....       MOV     DPTR,#failF
   \   000061   E0           MOVX    A,@DPTR
   \   000062   6007         JZ      ??osal_nv_item_init_6
   1190              {
   1191                (void)initNV();  // See comment at the declaration of failF.
   \   000064                ; Setup parameters for call to function initNV
   \   000064   12....       LCALL   ??initNV?relay
   1192                return NV_OPER_FAILED;
   \   000067   7910         MOV     R1,#0x10
   \   000069   8006         SJMP    ??osal_nv_item_init_4
   1193              }
   1194              else
   1195              {
   1196                return NV_ITEM_UNINIT;
   \                     ??osal_nv_item_init_6:
   \   00006B   790F         MOV     R1,#0xf
   \   00006D   8002         SJMP    ??osal_nv_item_init_4
   1197              }
   1198            }
   1199            else
   1200            {
   1201              return NV_OPER_FAILED;
   \                     ??osal_nv_item_init_5:
   \   00006F   7910         MOV     R1,#0x10
   \                     ??osal_nv_item_init_4:
   \   000071   7F06         MOV     R7,#0x6
   \   000073   02....       LJMP    ?BANKED_LEAVE_XDATA
   1202            }
   1203          }
   1204          
   1205          /*********************************************************************
   1206           * @fn      osal_nv_item_len
   1207           *
   1208           * @brief   Get the data length of the item stored in NV memory.
   1209           *
   1210           * @param   id  - Valid NV item Id.
   1211           *
   1212           * @return  Item length, if found; zero otherwise.
   1213           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1214          uint16 osal_nv_item_len( uint16 id )
   \                     osal_nv_item_len:
   1215          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   1216            if ( id == ZCD_NV_EXTADDR )
   \   00000E   7401         MOV     A,#0x1
   \   000010   65..         XRL     A,?V0 + 0
   \   000012   7004         JNZ     ??osal_nv_item_len_0
   \   000014   7400         MOV     A,#0x0
   \   000016   65..         XRL     A,?V0 + 1
   \                     ??osal_nv_item_len_0:
   \   000018   7006         JNZ     ??osal_nv_item_len_1
   1217            {
   1218              return Z_EXTADDR_LEN;
   \   00001A   7A08         MOV     R2,#0x8
   \   00001C   7B00         MOV     R3,#0x0
   \   00001E   8043         SJMP    ??osal_nv_item_len_2
   1219            }
   1220            else
   1221            {
   1222              uint16 offset = findItem( id );
   \                     ??osal_nv_item_len_1:
   \   000020                ; Setup parameters for call to function findItem
   \   000020   AA..         MOV     R2,?V0 + 0
   \   000022   AB..         MOV     R3,?V0 + 1
   \   000024   12....       LCALL   ??findItem?relay
   \   000027   8A..         MOV     ?V0 + 2,R2
   \   000029   8B..         MOV     ?V0 + 3,R3
   \   00002B   AE..         MOV     R6,?V0 + 2
   \   00002D   AF..         MOV     R7,?V0 + 3
   1223          
   1224              if ( offset == OSAL_NV_ITEM_NULL )
   \   00002F   7400         MOV     A,#0x0
   \   000031   6E           XRL     A,R6
   \   000032   7003         JNZ     ??osal_nv_item_len_3
   \   000034   7400         MOV     A,#0x0
   \   000036   6F           XRL     A,R7
   \                     ??osal_nv_item_len_3:
   \   000037   7006         JNZ     ??osal_nv_item_len_4
   1225              {
   1226                return 0;
   \   000039   7A00         MOV     R2,#0x0
   \   00003B   7B00         MOV     R3,#0x0
   \   00003D   8024         SJMP    ??osal_nv_item_len_2
   1227              }
   1228              else
   1229              {
   1230                osalNvHdr_t hdr;
   1231                nvReadHdr( findPg, (offset - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
   \                     ??osal_nv_item_len_4:
   \   00003F                ; Setup parameters for call to function nvReadHdr
   \   00003F   85..82       MOV     DPL,?XSP + 0
   \   000042   85..83       MOV     DPH,?XSP + 1
   \   000045   AC82         MOV     R4,DPL
   \   000047   AD83         MOV     R5,DPH
   \   000049   74F8         MOV     A,#-0x8
   \   00004B   2E           ADD     A,R6
   \   00004C   FA           MOV     R2,A
   \   00004D   74FF         MOV     A,#-0x1
   \   00004F   3F           ADDC    A,R7
   \   000050   FB           MOV     R3,A
   \   000051   90....       MOV     DPTR,#findPg
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F9           MOV     R1,A
   \   000056   12....       LCALL   nvReadHdr & 0xFFFF
   1232                return hdr.len;
   \   000059   7402         MOV     A,#0x2
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   FA           MOV     R2,A
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   FB           MOV     R3,A
   \                     ??osal_nv_item_len_2:
   \   000063   7408         MOV     A,#0x8
   \   000065   12....       LCALL   ?DEALLOC_XSTACK8
   \   000068   7F04         MOV     R7,#0x4
   \   00006A   02....       LJMP    ?BANKED_LEAVE_XDATA
   1233              }
   1234            }
   1235          }
   1236          
   1237          /*********************************************************************
   1238           * @fn      osal_nv_write
   1239           *
   1240           * @brief   Write a data item to NV. Function can write an entire item to NV or
   1241           *          an element of an item by indexing into the item with an offset.
   1242           *
   1243           * @param   id  - Valid NV item Id.
   1244           * @param   ndx - Index offset into item
   1245           * @param   len - Length of data to write.
   1246           * @param  *buf - Data to write.
   1247           *
   1248           * @return  ZSUCCESS if successful, NV_ITEM_UNINIT if item did not
   1249           *          exist in NV and offset is non-zero, NV_OPER_FAILED if failure.
   1250           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1251          uint8 osal_nv_write( uint16 id, uint16 ndx, uint16 len, void *buf )
   \                     osal_nv_write:
   1252          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 22
   \   000005   74EA         MOV     A,#-0x16
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   740C         MOV     A,#0xc
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   EC           MOV     A,R4
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   ED           MOV     A,R5
   \   00001E   F0           MOVX    @DPTR,A
   1253            uint8 rtrn = ZSUCCESS;
   \   00001F   75..00       MOV     ?V0 + 6,#0x0
   1254          
   1255            /* Global fail flag for fail due to low bus voltage has less impact on code
   1256             * size than passing back a return value all the way from the lowest level.
   1257             */
   1258            failF = FALSE;
   \   000022   7400         MOV     A,#0x0
   \   000024   90....       MOV     DPTR,#failF
   \   000027   F0           MOVX    @DPTR,A
   1259          
   1260            if ( id == ZCD_NV_EXTADDR )
   \   000028   740C         MOV     A,#0xc
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   6401         XRL     A,#0x1
   \   000030   7004         JNZ     ??osal_nv_write_0
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   6400         XRL     A,#0x0
   \                     ??osal_nv_write_0:
   \   000036   7010         JNZ     ??osal_nv_write_1
   1261            {
   1262              return writeIEEE( buf );
   \   000038                ; Setup parameters for call to function writeIEEE
   \   000038   7427         MOV     A,#0x27
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FA           MOV     R2,A
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   FB           MOV     R3,A
   \   000042   12....       LCALL   ??writeIEEE?relay
   \   000045   02....       LJMP    ??osal_nv_write_2 & 0xFFFF
   1263            }
   1264          
   1265            if ( len != 0 )
   \                     ??osal_nv_write_1:
   \   000048   7425         MOV     A,#0x25
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   6400         XRL     A,#0x0
   \   000050   7004         JNZ     ??osal_nv_write_3
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   6400         XRL     A,#0x0
   \                     ??osal_nv_write_3:
   \   000056   7003         JNZ     $+5
   \   000058   02....       LJMP    ??osal_nv_write_4 & 0xFFFF
   1266            {
   1267              osalNvHdr_t hdr;
   1268              uint16 origOff, srcOff;
   1269              uint16 cnt;
   1270              uint8 *ptr;
   1271          
   1272              origOff = srcOff = findItem( id );
   \   00005B                ; Setup parameters for call to function findItem
   \   00005B   740C         MOV     A,#0xc
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   E0           MOVX    A,@DPTR
   \   000061   FA           MOV     R2,A
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   FB           MOV     R3,A
   \   000065   12....       LCALL   ??findItem?relay
   \   000068   8A..         MOV     ?V0 + 0,R2
   \   00006A   8B..         MOV     ?V0 + 1,R3
   \   00006C   A8..         MOV     R0,?V0 + 0
   \   00006E   A9..         MOV     R1,?V0 + 1
   \   000070   88..         MOV     ?V0 + 4,R0
   \   000072   89..         MOV     ?V0 + 5,R1
   \   000074   7408         MOV     A,#0x8
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   E8           MOV     A,R0
   \   00007A   F0           MOVX    @DPTR,A
   \   00007B   A3           INC     DPTR
   \   00007C   E9           MOV     A,R1
   \   00007D   F0           MOVX    @DPTR,A
   1273              if ( srcOff == OSAL_NV_ITEM_NULL )
   \   00007E   7400         MOV     A,#0x0
   \   000080   65..         XRL     A,?V0 + 4
   \   000082   7004         JNZ     ??osal_nv_write_5
   \   000084   7400         MOV     A,#0x0
   \   000086   65..         XRL     A,?V0 + 5
   \                     ??osal_nv_write_5:
   \   000088   7005         JNZ     ??osal_nv_write_6
   1274              {
   1275                return NV_ITEM_UNINIT;
   \   00008A   790F         MOV     R1,#0xf
   \   00008C   02....       LJMP    ??osal_nv_write_2 & 0xFFFF
   1276              }
   1277          
   1278              nvReadHdr( findPg, (srcOff - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
   \                     ??osal_nv_write_6:
   \   00008F                ; Setup parameters for call to function nvReadHdr
   \   00008F   740E         MOV     A,#0xe
   \   000091   12....       LCALL   ?XSTACK_DISP0_8
   \   000094   AC82         MOV     R4,DPL
   \   000096   AD83         MOV     R5,DPH
   \   000098   74F8         MOV     A,#-0x8
   \   00009A   25..         ADD     A,?V0 + 4
   \   00009C   FA           MOV     R2,A
   \   00009D   74FF         MOV     A,#-0x1
   \   00009F   35..         ADDC    A,?V0 + 5
   \   0000A1   FB           MOV     R3,A
   \   0000A2   90....       MOV     DPTR,#findPg
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   F9           MOV     R1,A
   \   0000A7   12....       LCALL   nvReadHdr & 0xFFFF
   1279              if ( hdr.len < (ndx + len) )
   \   0000AA   7410         MOV     A,#0x10
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   C082         PUSH    DPL
   \   0000B1   C083         PUSH    DPH
   \   0000B3   85..82       MOV     DPL,?XSP + 0
   \   0000B6   85..83       MOV     DPH,?XSP + 1
   \   0000B9   C082         PUSH    DPL
   \   0000BB   C083         PUSH    DPH
   \   0000BD   7425         MOV     A,#0x25
   \   0000BF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   F8           MOV     R0,A
   \   0000C4   A3           INC     DPTR
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   F9           MOV     R1,A
   \   0000C7   D083         POP     DPH
   \   0000C9   D082         POP     DPL
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   28           ADD     A,R0
   \   0000CD   F8           MOV     R0,A
   \   0000CE   A3           INC     DPTR
   \   0000CF   E0           MOVX    A,@DPTR
   \   0000D0   39           ADDC    A,R1
   \   0000D1   F9           MOV     R1,A
   \   0000D2   D083         POP     DPH
   \   0000D4   D082         POP     DPL
   \   0000D6   C3           CLR     C
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   98           SUBB    A,R0
   \   0000D9   A3           INC     DPTR
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   99           SUBB    A,R1
   \   0000DC   5005         JNC     ??osal_nv_write_7
   1280              {
   1281                return NV_OPER_FAILED;
   \   0000DE   7910         MOV     R1,#0x10
   \   0000E0   02....       LJMP    ??osal_nv_write_2 & 0xFFFF
   1282              }
   1283          
   1284              srcOff += ndx;
   \                     ??osal_nv_write_7:
   \   0000E3   85..82       MOV     DPL,?XSP + 0
   \   0000E6   85..83       MOV     DPH,?XSP + 1
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   25..         ADD     A,?V0 + 4
   \   0000EC   F5..         MOV     ?V0 + 4,A
   \   0000EE   A3           INC     DPTR
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   35..         ADDC    A,?V0 + 5
   \   0000F2   F5..         MOV     ?V0 + 5,A
   1285              ptr = buf;
   \   0000F4   7427         MOV     A,#0x27
   \   0000F6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F9   E0           MOVX    A,@DPTR
   \   0000FA   F8           MOV     R0,A
   \   0000FB   A3           INC     DPTR
   \   0000FC   E0           MOVX    A,@DPTR
   \   0000FD   F9           MOV     R1,A
   \   0000FE   740A         MOV     A,#0xa
   \   000100   12....       LCALL   ?XSTACK_DISP0_8
   \   000103   E8           MOV     A,R0
   \   000104   F0           MOVX    @DPTR,A
   \   000105   A3           INC     DPTR
   \   000106   E9           MOV     A,R1
   \   000107   F0           MOVX    @DPTR,A
   1286              cnt = len;
   \   000108   7425         MOV     A,#0x25
   \   00010A   12....       LCALL   ?XSTACK_DISP0_8
   \   00010D   E0           MOVX    A,@DPTR
   \   00010E   F8           MOV     R0,A
   \   00010F   A3           INC     DPTR
   \   000110   E0           MOVX    A,@DPTR
   \   000111   F9           MOV     R1,A
   \   000112   7406         MOV     A,#0x6
   \   000114   12....       LCALL   ?XSTACK_DISP0_8
   \   000117   E8           MOV     A,R0
   \   000118   F0           MOVX    @DPTR,A
   \   000119   A3           INC     DPTR
   \   00011A   E9           MOV     A,R1
   \   00011B   F0           MOVX    @DPTR,A
   1287              while ( cnt )
   \                     ??osal_nv_write_8:
   \   00011C   7406         MOV     A,#0x6
   \   00011E   12....       LCALL   ?XSTACK_DISP0_8
   \   000121   E0           MOVX    A,@DPTR
   \   000122   6400         XRL     A,#0x0
   \   000124   7004         JNZ     ??osal_nv_write_9
   \   000126   A3           INC     DPTR
   \   000127   E0           MOVX    A,@DPTR
   \   000128   6400         XRL     A,#0x0
   \                     ??osal_nv_write_9:
   \   00012A   605D         JZ      ??osal_nv_write_10
   1288              {
   1289                uint8 tmp;
   1290                nvReadByte( findPg, srcOff++, &tmp );
   \   00012C                ; Setup parameters for call to function nvReadByte
   \   00012C   7405         MOV     A,#0x5
   \   00012E   12....       LCALL   ?XSTACK_DISP0_8
   \   000131   AC82         MOV     R4,DPL
   \   000133   AD83         MOV     R5,DPH
   \   000135   AA..         MOV     R2,?V0 + 4
   \   000137   AB..         MOV     R3,?V0 + 5
   \   000139   90....       MOV     DPTR,#findPg
   \   00013C   E0           MOVX    A,@DPTR
   \   00013D   F9           MOV     R1,A
   \   00013E   12....       LCALL   nvReadByte & 0xFFFF
   \   000141   E5..         MOV     A,?V0 + 4
   \   000143   2401         ADD     A,#0x1
   \   000145   F5..         MOV     ?V0 + 4,A
   \   000147   E5..         MOV     A,?V0 + 5
   \   000149   3400         ADDC    A,#0x0
   \   00014B   F5..         MOV     ?V0 + 5,A
   1291                if ( tmp != *ptr++ )
   \   00014D   740A         MOV     A,#0xa
   \   00014F   12....       LCALL   ?XSTACK_DISP0_8
   \   000152   E0           MOVX    A,@DPTR
   \   000153   F8           MOV     R0,A
   \   000154   A3           INC     DPTR
   \   000155   E0           MOVX    A,@DPTR
   \   000156   F9           MOV     R1,A
   \   000157   8882         MOV     DPL,R0
   \   000159   8983         MOV     DPH,R1
   \   00015B   A3           INC     DPTR
   \   00015C   AA82         MOV     R2,DPL
   \   00015E   AB83         MOV     R3,DPH
   \   000160   740A         MOV     A,#0xa
   \   000162   12....       LCALL   ?XSTACK_DISP0_8
   \   000165   EA           MOV     A,R2
   \   000166   F0           MOVX    @DPTR,A
   \   000167   A3           INC     DPTR
   \   000168   EB           MOV     A,R3
   \   000169   F0           MOVX    @DPTR,A
   \   00016A   7405         MOV     A,#0x5
   \   00016C   12....       LCALL   ?XSTACK_DISP0_8
   \   00016F   E0           MOVX    A,@DPTR
   \   000170   FA           MOV     R2,A
   \   000171   8882         MOV     DPL,R0
   \   000173   8983         MOV     DPH,R1
   \   000175   E0           MOVX    A,@DPTR
   \   000176   6A           XRL     A,R2
   \   000177   7010         JNZ     ??osal_nv_write_10
   1292                {
   1293                  break;
   1294                }
   1295                cnt--;
   \   000179   7406         MOV     A,#0x6
   \   00017B   12....       LCALL   ?XSTACK_DISP0_8
   \   00017E   E0           MOVX    A,@DPTR
   \   00017F   24FF         ADD     A,#-0x1
   \   000181   F0           MOVX    @DPTR,A
   \   000182   A3           INC     DPTR
   \   000183   E0           MOVX    A,@DPTR
   \   000184   34FF         ADDC    A,#-0x1
   \   000186   F0           MOVX    @DPTR,A
   \   000187   8093         SJMP    ??osal_nv_write_8
   1296              }
   1297          
   1298              if ( cnt != 0 )  // If the buffer to write is different in one or more bytes.
   \                     ??osal_nv_write_10:
   \   000189   7406         MOV     A,#0x6
   \   00018B   12....       LCALL   ?XSTACK_DISP0_8
   \   00018E   E0           MOVX    A,@DPTR
   \   00018F   6400         XRL     A,#0x0
   \   000191   7004         JNZ     ??osal_nv_write_11
   \   000193   A3           INC     DPTR
   \   000194   E0           MOVX    A,@DPTR
   \   000195   6400         XRL     A,#0x0
   \                     ??osal_nv_write_11:
   \   000197   7003         JNZ     $+5
   \   000199   02....       LJMP    ??osal_nv_write_4 & 0xFFFF
   1299              {
   1300                uint8 comPg, dstPg = initItem( FALSE, id, hdr.len, &comPg );
   \   00019C                ; Setup parameters for call to function initItem
   \   00019C   7404         MOV     A,#0x4
   \   00019E   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A1   8582..       MOV     ?V0 + 0,DPL
   \   0001A4   8583..       MOV     ?V0 + 1,DPH
   \   0001A7   78..         MOV     R0,#?V0 + 0
   \   0001A9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001AC   7412         MOV     A,#0x12
   \   0001AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B1   E0           MOVX    A,@DPTR
   \   0001B2   FC           MOV     R4,A
   \   0001B3   A3           INC     DPTR
   \   0001B4   E0           MOVX    A,@DPTR
   \   0001B5   FD           MOV     R5,A
   \   0001B6   740E         MOV     A,#0xe
   \   0001B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BB   E0           MOVX    A,@DPTR
   \   0001BC   FA           MOV     R2,A
   \   0001BD   A3           INC     DPTR
   \   0001BE   E0           MOVX    A,@DPTR
   \   0001BF   FB           MOV     R3,A
   \   0001C0   7900         MOV     R1,#0x0
   \   0001C2   12....       LCALL   ??initItem?relay
   \   0001C5   7402         MOV     A,#0x2
   \   0001C7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001CA   E9           MOV     A,R1
   \   0001CB   FE           MOV     R6,A
   1301          
   1302                if ( dstPg != OSAL_NV_PAGE_NULL )
   \   0001CC   EE           MOV     A,R6
   \   0001CD   7003         JNZ     $+5
   \   0001CF   02....       LJMP    ??osal_nv_write_12 & 0xFFFF
   1303                {
   1304                  uint16 tmp = OSAL_NV_DATA_SIZE( hdr.len );
   \   0001D2   7410         MOV     A,#0x10
   \   0001D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D7   E0           MOVX    A,@DPTR
   \   0001D8   2403         ADD     A,#0x3
   \   0001DA   F5..         MOV     ?V0 + 2,A
   \   0001DC   A3           INC     DPTR
   \   0001DD   E0           MOVX    A,@DPTR
   \   0001DE   3400         ADDC    A,#0x0
   \   0001E0   F5..         MOV     ?V0 + 3,A
   \   0001E2   7402         MOV     A,#0x2
   \   0001E4   78..         MOV     R0,#?V0 + 2
   \   0001E6   12....       LCALL   ?US_SHR
   \   0001E9   E5..         MOV     A,?V0 + 2
   \   0001EB   75F004       MOV     B,#0x4
   \   0001EE   A4           MUL     AB
   \   0001EF   C5..         XCH     A,?V0 + 2
   \   0001F1   AAF0         MOV     R2,B
   \   0001F3   75F000       MOV     B,#0x0
   \   0001F6   A4           MUL     AB
   \   0001F7   2A           ADD     A,R2
   \   0001F8   FA           MOV     R2,A
   \   0001F9   75F004       MOV     B,#0x4
   \   0001FC   E5..         MOV     A,?V0 + 3
   \   0001FE   A4           MUL     AB
   \   0001FF   2A           ADD     A,R2
   \   000200   F5..         MOV     ?V0 + 3,A
   \   000202   7402         MOV     A,#0x2
   \   000204   12....       LCALL   ?XSTACK_DISP0_8
   \   000207   E5..         MOV     A,?V0 + 2
   \   000209   F0           MOVX    @DPTR,A
   \   00020A   A3           INC     DPTR
   \   00020B   E5..         MOV     A,?V0 + 3
   \   00020D   F0           MOVX    @DPTR,A
   1305                  uint16 dstOff = pgOff[dstPg-OSAL_NV_PAGE_BEG] - tmp;
   \   00020E   EE           MOV     A,R6
   \   00020F   F8           MOV     R0,A
   \   000210   7900         MOV     R1,#0x0
   \   000212   E8           MOV     A,R0
   \   000213   75F002       MOV     B,#0x2
   \   000216   A4           MUL     AB
   \   000217   C8           XCH     A,R0
   \   000218   AAF0         MOV     R2,B
   \   00021A   75F000       MOV     B,#0x0
   \   00021D   A4           MUL     AB
   \   00021E   2A           ADD     A,R2
   \   00021F   FA           MOV     R2,A
   \   000220   75F002       MOV     B,#0x2
   \   000223   E9           MOV     A,R1
   \   000224   A4           MUL     AB
   \   000225   2A           ADD     A,R2
   \   000226   F9           MOV     R1,A
   \   000227   E8           MOV     A,R0
   \   000228   24..         ADD     A,#((pgOff + 136) & 0xff)
   \   00022A   F582         MOV     DPL,A
   \   00022C   E9           MOV     A,R1
   \   00022D   34..         ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
   \   00022F   F583         MOV     DPH,A
   \   000231   C082         PUSH    DPL
   \   000233   C083         PUSH    DPH
   \   000235   7402         MOV     A,#0x2
   \   000237   12....       LCALL   ?XSTACK_DISP0_8
   \   00023A   E0           MOVX    A,@DPTR
   \   00023B   F8           MOV     R0,A
   \   00023C   A3           INC     DPTR
   \   00023D   E0           MOVX    A,@DPTR
   \   00023E   F9           MOV     R1,A
   \   00023F   D083         POP     DPH
   \   000241   D082         POP     DPL
   \   000243   E0           MOVX    A,@DPTR
   \   000244   C3           CLR     C
   \   000245   98           SUBB    A,R0
   \   000246   F8           MOV     R0,A
   \   000247   A3           INC     DPTR
   \   000248   E0           MOVX    A,@DPTR
   \   000249   99           SUBB    A,R1
   \   00024A   F9           MOV     R1,A
   \   00024B   88..         MOV     ?V0 + 0,R0
   \   00024D   89..         MOV     ?V0 + 1,R1
   1306                  uint8 srcPg = findPg;
   \   00024F   90....       MOV     DPTR,#findPg
   \   000252   E0           MOVX    A,@DPTR
   \   000253   FF           MOV     R7,A
   1307                  srcOff = origOff;
   \   000254   7408         MOV     A,#0x8
   \   000256   12....       LCALL   ?XSTACK_DISP0_8
   \   000259   E0           MOVX    A,@DPTR
   \   00025A   F5..         MOV     ?V0 + 4,A
   \   00025C   A3           INC     DPTR
   \   00025D   E0           MOVX    A,@DPTR
   \   00025E   F5..         MOV     ?V0 + 5,A
   1308          
   1309                  setItem( srcPg, srcOff, eNvXfer );
   \   000260                ; Setup parameters for call to function setItem
   \   000260   7C00         MOV     R4,#0x0
   \   000262   AA..         MOV     R2,?V0 + 4
   \   000264   AB..         MOV     R3,?V0 + 5
   \   000266   EF           MOV     A,R7
   \   000267   F9           MOV     R1,A
   \   000268   12....       LCALL   ??setItem?relay
   1310          
   1311                  xferBuf( srcPg, srcOff, dstPg, dstOff, ndx );
   \   00026B                ; Setup parameters for call to function xferBuf
   \   00026B   85..82       MOV     DPL,?XSP + 0
   \   00026E   85..83       MOV     DPH,?XSP + 1
   \   000271   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000274   78..         MOV     R0,#?V0 + 0
   \   000276   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000279   EE           MOV     A,R6
   \   00027A   FC           MOV     R4,A
   \   00027B   AA..         MOV     R2,?V0 + 4
   \   00027D   AB..         MOV     R3,?V0 + 5
   \   00027F   EF           MOV     A,R7
   \   000280   F9           MOV     R1,A
   \   000281   12....       LCALL   ??xferBuf?relay
   \   000284   7404         MOV     A,#0x4
   \   000286   12....       LCALL   ?DEALLOC_XSTACK8
   1312                  srcOff += ndx;
   \   000289   85..82       MOV     DPL,?XSP + 0
   \   00028C   85..83       MOV     DPH,?XSP + 1
   \   00028F   E0           MOVX    A,@DPTR
   \   000290   25..         ADD     A,?V0 + 4
   \   000292   F5..         MOV     ?V0 + 4,A
   \   000294   A3           INC     DPTR
   \   000295   E0           MOVX    A,@DPTR
   \   000296   35..         ADDC    A,?V0 + 5
   \   000298   F5..         MOV     ?V0 + 5,A
   1313                  dstOff += ndx;
   \   00029A   85..82       MOV     DPL,?XSP + 0
   \   00029D   85..83       MOV     DPH,?XSP + 1
   \   0002A0   E0           MOVX    A,@DPTR
   \   0002A1   25..         ADD     A,?V0 + 0
   \   0002A3   F5..         MOV     ?V0 + 0,A
   \   0002A5   A3           INC     DPTR
   \   0002A6   E0           MOVX    A,@DPTR
   \   0002A7   35..         ADDC    A,?V0 + 1
   \   0002A9   F5..         MOV     ?V0 + 1,A
   1314          
   1315                  writeBuf( dstPg, dstOff, len, buf );
   \   0002AB                ; Setup parameters for call to function writeBuf
   \   0002AB   7427         MOV     A,#0x27
   \   0002AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B0   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0002B3   7427         MOV     A,#0x27
   \   0002B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B8   E0           MOVX    A,@DPTR
   \   0002B9   FC           MOV     R4,A
   \   0002BA   A3           INC     DPTR
   \   0002BB   E0           MOVX    A,@DPTR
   \   0002BC   FD           MOV     R5,A
   \   0002BD   AA..         MOV     R2,?V0 + 0
   \   0002BF   AB..         MOV     R3,?V0 + 1
   \   0002C1   EE           MOV     A,R6
   \   0002C2   F9           MOV     R1,A
   \   0002C3   12....       LCALL   ??writeBuf?relay
   \   0002C6   7402         MOV     A,#0x2
   \   0002C8   12....       LCALL   ?DEALLOC_XSTACK8
   1316                  srcOff += len;
   \   0002CB   7425         MOV     A,#0x25
   \   0002CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D0   E0           MOVX    A,@DPTR
   \   0002D1   25..         ADD     A,?V0 + 4
   \   0002D3   F5..         MOV     ?V0 + 4,A
   \   0002D5   A3           INC     DPTR
   \   0002D6   E0           MOVX    A,@DPTR
   \   0002D7   35..         ADDC    A,?V0 + 5
   \   0002D9   F5..         MOV     ?V0 + 5,A
   1317                  dstOff += len;
   \   0002DB   7425         MOV     A,#0x25
   \   0002DD   12....       LCALL   ?XSTACK_DISP0_8
   \   0002E0   E0           MOVX    A,@DPTR
   \   0002E1   25..         ADD     A,?V0 + 0
   \   0002E3   F5..         MOV     ?V0 + 0,A
   \   0002E5   A3           INC     DPTR
   \   0002E6   E0           MOVX    A,@DPTR
   \   0002E7   35..         ADDC    A,?V0 + 1
   \   0002E9   F5..         MOV     ?V0 + 1,A
   1318          
   1319                  xferBuf( srcPg, srcOff, dstPg, dstOff, (hdr.len-ndx-len) );
   \   0002EB                ; Setup parameters for call to function xferBuf
   \   0002EB   7410         MOV     A,#0x10
   \   0002ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0002F0   C082         PUSH    DPL
   \   0002F2   C083         PUSH    DPH
   \   0002F4   85..82       MOV     DPL,?XSP + 0
   \   0002F7   85..83       MOV     DPH,?XSP + 1
   \   0002FA   E0           MOVX    A,@DPTR
   \   0002FB   F8           MOV     R0,A
   \   0002FC   A3           INC     DPTR
   \   0002FD   E0           MOVX    A,@DPTR
   \   0002FE   F9           MOV     R1,A
   \   0002FF   D083         POP     DPH
   \   000301   D082         POP     DPL
   \   000303   E0           MOVX    A,@DPTR
   \   000304   C3           CLR     C
   \   000305   98           SUBB    A,R0
   \   000306   FA           MOV     R2,A
   \   000307   A3           INC     DPTR
   \   000308   E0           MOVX    A,@DPTR
   \   000309   99           SUBB    A,R1
   \   00030A   FB           MOV     R3,A
   \   00030B   7425         MOV     A,#0x25
   \   00030D   12....       LCALL   ?XSTACK_DISP0_8
   \   000310   E0           MOVX    A,@DPTR
   \   000311   F8           MOV     R0,A
   \   000312   A3           INC     DPTR
   \   000313   E0           MOVX    A,@DPTR
   \   000314   F9           MOV     R1,A
   \   000315   EA           MOV     A,R2
   \   000316   C3           CLR     C
   \   000317   98           SUBB    A,R0
   \   000318   F5..         MOV     ?V0 + 2,A
   \   00031A   EB           MOV     A,R3
   \   00031B   99           SUBB    A,R1
   \   00031C   F5..         MOV     ?V0 + 3,A
   \   00031E   78..         MOV     R0,#?V0 + 2
   \   000320   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000323   78..         MOV     R0,#?V0 + 0
   \   000325   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000328   EE           MOV     A,R6
   \   000329   FC           MOV     R4,A
   \   00032A   AA..         MOV     R2,?V0 + 4
   \   00032C   AB..         MOV     R3,?V0 + 5
   \   00032E   EF           MOV     A,R7
   \   00032F   F9           MOV     R1,A
   \   000330   12....       LCALL   ??xferBuf?relay
   \   000333   7404         MOV     A,#0x4
   \   000335   12....       LCALL   ?DEALLOC_XSTACK8
   1320          
   1321                  // Calculate and write the new checksum.
   1322                  dstOff = pgOff[dstPg-OSAL_NV_PAGE_BEG] - tmp;
   \   000338   EE           MOV     A,R6
   \   000339   F8           MOV     R0,A
   \   00033A   7900         MOV     R1,#0x0
   \   00033C   E8           MOV     A,R0
   \   00033D   75F002       MOV     B,#0x2
   \   000340   A4           MUL     AB
   \   000341   C8           XCH     A,R0
   \   000342   AAF0         MOV     R2,B
   \   000344   75F000       MOV     B,#0x0
   \   000347   A4           MUL     AB
   \   000348   2A           ADD     A,R2
   \   000349   FA           MOV     R2,A
   \   00034A   75F002       MOV     B,#0x2
   \   00034D   E9           MOV     A,R1
   \   00034E   A4           MUL     AB
   \   00034F   2A           ADD     A,R2
   \   000350   F9           MOV     R1,A
   \   000351   E8           MOV     A,R0
   \   000352   24..         ADD     A,#((pgOff + 136) & 0xff)
   \   000354   F582         MOV     DPL,A
   \   000356   E9           MOV     A,R1
   \   000357   34..         ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
   \   000359   F583         MOV     DPH,A
   \   00035B   C082         PUSH    DPL
   \   00035D   C083         PUSH    DPH
   \   00035F   7402         MOV     A,#0x2
   \   000361   12....       LCALL   ?XSTACK_DISP0_8
   \   000364   E0           MOVX    A,@DPTR
   \   000365   F8           MOV     R0,A
   \   000366   A3           INC     DPTR
   \   000367   E0           MOVX    A,@DPTR
   \   000368   F9           MOV     R1,A
   \   000369   D083         POP     DPH
   \   00036B   D082         POP     DPL
   \   00036D   E0           MOVX    A,@DPTR
   \   00036E   C3           CLR     C
   \   00036F   98           SUBB    A,R0
   \   000370   F8           MOV     R0,A
   \   000371   A3           INC     DPTR
   \   000372   E0           MOVX    A,@DPTR
   \   000373   99           SUBB    A,R1
   \   000374   F9           MOV     R1,A
   \   000375   88..         MOV     ?V0 + 0,R0
   \   000377   89..         MOV     ?V0 + 1,R1
   1323                  tmp = calcChkF( dstPg, dstOff, hdr.len );
   \   000379                ; Setup parameters for call to function calcChkF
   \   000379   7410         MOV     A,#0x10
   \   00037B   12....       LCALL   ?XSTACK_DISP0_8
   \   00037E   E0           MOVX    A,@DPTR
   \   00037F   FC           MOV     R4,A
   \   000380   A3           INC     DPTR
   \   000381   E0           MOVX    A,@DPTR
   \   000382   FD           MOV     R5,A
   \   000383   AA..         MOV     R2,?V0 + 0
   \   000385   AB..         MOV     R3,?V0 + 1
   \   000387   EE           MOV     A,R6
   \   000388   F9           MOV     R1,A
   \   000389   12....       LCALL   ??calcChkF?relay
   \   00038C   7402         MOV     A,#0x2
   \   00038E   12....       LCALL   ?XSTACK_DISP0_8
   \   000391   EA           MOV     A,R2
   \   000392   F0           MOVX    @DPTR,A
   \   000393   A3           INC     DPTR
   \   000394   EB           MOV     A,R3
   \   000395   F0           MOVX    @DPTR,A
   1324                  dstOff -= OSAL_NV_HDR_SIZE;
   \   000396   E5..         MOV     A,?V0 + 0
   \   000398   24F8         ADD     A,#-0x8
   \   00039A   F5..         MOV     ?V0 + 0,A
   \   00039C   E5..         MOV     A,?V0 + 1
   \   00039E   34FF         ADDC    A,#-0x1
   \   0003A0   F5..         MOV     ?V0 + 1,A
   1325                  writeWordH( dstPg, (dstOff+OSAL_NV_HDR_CHK), (uint8 *)&tmp );
   \   0003A2                ; Setup parameters for call to function writeWordH
   \   0003A2   7402         MOV     A,#0x2
   \   0003A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A7   AC82         MOV     R4,DPL
   \   0003A9   AD83         MOV     R5,DPH
   \   0003AB   7404         MOV     A,#0x4
   \   0003AD   25..         ADD     A,?V0 + 0
   \   0003AF   FA           MOV     R2,A
   \   0003B0   7400         MOV     A,#0x0
   \   0003B2   35..         ADDC    A,?V0 + 1
   \   0003B4   FB           MOV     R3,A
   \   0003B5   EE           MOV     A,R6
   \   0003B6   F9           MOV     R1,A
   \   0003B7   12....       LCALL   ??writeWordH?relay
   1326                  nvReadHdr( dstPg, dstOff, (uint8 *)(&hdr) );
   \   0003BA                ; Setup parameters for call to function nvReadHdr
   \   0003BA   740E         MOV     A,#0xe
   \   0003BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0003BF   AC82         MOV     R4,DPL
   \   0003C1   AD83         MOV     R5,DPH
   \   0003C3   AA..         MOV     R2,?V0 + 0
   \   0003C5   AB..         MOV     R3,?V0 + 1
   \   0003C7   EE           MOV     A,R6
   \   0003C8   F9           MOV     R1,A
   \   0003C9   12....       LCALL   nvReadHdr & 0xFFFF
   1327          
   1328                  if ( tmp == hdr.chk )
   \   0003CC   7402         MOV     A,#0x2
   \   0003CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0003D1   E0           MOVX    A,@DPTR
   \   0003D2   F8           MOV     R0,A
   \   0003D3   A3           INC     DPTR
   \   0003D4   E0           MOVX    A,@DPTR
   \   0003D5   F9           MOV     R1,A
   \   0003D6   7412         MOV     A,#0x12
   \   0003D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0003DB   E0           MOVX    A,@DPTR
   \   0003DC   68           XRL     A,R0
   \   0003DD   7003         JNZ     ??osal_nv_write_13
   \   0003DF   A3           INC     DPTR
   \   0003E0   E0           MOVX    A,@DPTR
   \   0003E1   69           XRL     A,R1
   \                     ??osal_nv_write_13:
   \   0003E2   7013         JNZ     ??osal_nv_write_14
   1329                  {
   1330                    setItem( srcPg, origOff, eNvZero );
   \   0003E4                ; Setup parameters for call to function setItem
   \   0003E4   7C01         MOV     R4,#0x1
   \   0003E6   7408         MOV     A,#0x8
   \   0003E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0003EB   E0           MOVX    A,@DPTR
   \   0003EC   FA           MOV     R2,A
   \   0003ED   A3           INC     DPTR
   \   0003EE   E0           MOVX    A,@DPTR
   \   0003EF   FB           MOV     R3,A
   \   0003F0   EF           MOV     A,R7
   \   0003F1   F9           MOV     R1,A
   \   0003F2   12....       LCALL   ??setItem?relay
   \   0003F5   8003         SJMP    ??osal_nv_write_15
   1331                  }
   1332                  else
   1333                  {
   1334                    rtrn = NV_OPER_FAILED;
   \                     ??osal_nv_write_14:
   \   0003F7   75..10       MOV     ?V0 + 6,#0x10
   1335                  }
   1336          
   1337                  if ( dstPg == pgRes )
   \                     ??osal_nv_write_15:
   \   0003FA   90....       MOV     DPTR,#pgRes
   \   0003FD   E0           MOVX    A,@DPTR
   \   0003FE   6E           XRL     A,R6
   \   0003FF   700F         JNZ     ??osal_nv_write_4
   1338                  {
   1339                    compactPage( comPg );
   \   000401                ; Setup parameters for call to function compactPage
   \   000401   7404         MOV     A,#0x4
   \   000403   12....       LCALL   ?XSTACK_DISP0_8
   \   000406   E0           MOVX    A,@DPTR
   \   000407   F9           MOV     R1,A
   \   000408   12....       LCALL   ??compactPage?relay
   \   00040B   8003         SJMP    ??osal_nv_write_4
   1340                  }
   1341                }
   1342                else
   1343                {
   1344                  rtrn = NV_OPER_FAILED;
   \                     ??osal_nv_write_12:
   \   00040D   75..10       MOV     ?V0 + 6,#0x10
   1345                }
   1346              }
   1347            }
   1348          
   1349            if ( failF )
   \                     ??osal_nv_write_4:
   \   000410   90....       MOV     DPTR,#failF
   \   000413   E0           MOVX    A,@DPTR
   \   000414   6006         JZ      ??osal_nv_write_16
   1350            {
   1351              (void)initNV();  // See comment at the declaration of failF.
   \   000416                ; Setup parameters for call to function initNV
   \   000416   12....       LCALL   ??initNV?relay
   1352              rtrn = NV_OPER_FAILED;
   \   000419   75..10       MOV     ?V0 + 6,#0x10
   1353            }
   1354          
   1355            return rtrn;
   \                     ??osal_nv_write_16:
   \   00041C   A9..         MOV     R1,?V0 + 6
   \                     ??osal_nv_write_2:
   \   00041E   7416         MOV     A,#0x16
   \   000420   12....       LCALL   ?DEALLOC_XSTACK8
   \   000423   7F07         MOV     R7,#0x7
   \   000425   02....       LJMP    ?BANKED_LEAVE_XDATA
   1356          }
   1357          
   1358          /*********************************************************************
   1359           * @fn      osal_nv_read
   1360           *
   1361           * @brief   Read data from NV. This function can be used to read an entire item from NV or
   1362           *          an element of an item by indexing into the item with an offset.
   1363           *          Read data is copied into *buf.
   1364           *
   1365           * @param   id  - Valid NV item Id.
   1366           * @param   ndx - Index offset into item
   1367           * @param   len - Length of data to read.
   1368           * @param  *buf - Data is read into this buffer.
   1369           *
   1370           * @return  ZSUCCESS if NV data was copied to the parameter 'buf'.
   1371           *          Otherwise, NV_OPER_FAILED for failure.
   1372           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1373          uint8 osal_nv_read( uint16 id, uint16 ndx, uint16 len, void *buf )
   \                     osal_nv_read:
   1374          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
   \   000009   8C..         MOV     ?V0 + 6,R4
   \   00000B   8D..         MOV     ?V0 + 7,R5
   \   00000D   7410         MOV     A,#0x10
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FE           MOV     R6,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FF           MOV     R7,A
   1375            uint16 offset;
   1376          
   1377            if ( id == ZCD_NV_EXTADDR )
   \   000017   7401         MOV     A,#0x1
   \   000019   65..         XRL     A,?V0 + 2
   \   00001B   7004         JNZ     ??osal_nv_read_0
   \   00001D   7400         MOV     A,#0x0
   \   00001F   65..         XRL     A,?V0 + 3
   \                     ??osal_nv_read_0:
   \   000021   700E         JNZ     ??osal_nv_read_1
   1378            {
   1379              offset = OSAL_NV_IEEE_OFFSET;
   \   000023   75..F8       MOV     ?V0 + 0,#-0x8
   \   000026   75..07       MOV     ?V0 + 1,#0x7
   1380              findPg = OSAL_NV_IEEE_PAGE;
   \   000029   743F         MOV     A,#0x3f
   \   00002B   90....       MOV     DPTR,#findPg
   \   00002E   F0           MOVX    @DPTR,A
   \   00002F   8021         SJMP    ??osal_nv_read_2
   1381            }
   1382            else
   1383            {
   1384              offset = findItem( id );
   \                     ??osal_nv_read_1:
   \   000031                ; Setup parameters for call to function findItem
   \   000031   AA..         MOV     R2,?V0 + 2
   \   000033   AB..         MOV     R3,?V0 + 3
   \   000035   12....       LCALL   ??findItem?relay
   \   000038   8A..         MOV     ?V0 + 4,R2
   \   00003A   8B..         MOV     ?V0 + 5,R3
   \   00003C   85....       MOV     ?V0 + 0,?V0 + 4
   \   00003F   85....       MOV     ?V0 + 1,?V0 + 5
   1385              if ( offset == OSAL_NV_ITEM_NULL )
   \   000042   7400         MOV     A,#0x0
   \   000044   65..         XRL     A,?V0 + 0
   \   000046   7004         JNZ     ??osal_nv_read_3
   \   000048   7400         MOV     A,#0x0
   \   00004A   65..         XRL     A,?V0 + 1
   \                     ??osal_nv_read_3:
   \   00004C   7004         JNZ     ??osal_nv_read_2
   1386              {
   1387                return NV_OPER_FAILED;
   \   00004E   7910         MOV     R1,#0x10
   \   000050   802C         SJMP    ??osal_nv_read_4
   1388              }
   1389            }
   1390          
   1391            nvReadBuf(findPg, offset+ndx, buf, len);
   \                     ??osal_nv_read_2:
   \   000052                ; Setup parameters for call to function nvReadBuf
   \   000052   8E..         MOV     ?V0 + 4,R6
   \   000054   8F..         MOV     ?V0 + 5,R7
   \   000056   78..         MOV     R0,#?V0 + 4
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   7414         MOV     A,#0x14
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   E0           MOVX    A,@DPTR
   \   000061   FC           MOV     R4,A
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   FD           MOV     R5,A
   \   000065   E5..         MOV     A,?V0 + 6
   \   000067   25..         ADD     A,?V0 + 0
   \   000069   FA           MOV     R2,A
   \   00006A   E5..         MOV     A,?V0 + 7
   \   00006C   35..         ADDC    A,?V0 + 1
   \   00006E   FB           MOV     R3,A
   \   00006F   90....       MOV     DPTR,#findPg
   \   000072   E0           MOVX    A,@DPTR
   \   000073   F9           MOV     R1,A
   \   000074   12....       LCALL   nvReadBuf & 0xFFFF
   \   000077   7402         MOV     A,#0x2
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   1392          
   1393            return ZSUCCESS;
   \   00007C   7900         MOV     R1,#0x0
   \                     ??osal_nv_read_4:
   \   00007E   7F08         MOV     R7,#0x8
   \   000080   02....       LJMP    ?BANKED_LEAVE_XDATA
   1394          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??initNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    initNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??setPageUse?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    setPageUse

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??initPage?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    initPage

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??erasePage?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    erasePage

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??compactPage?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    compactPage

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??findItem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    findItem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??initItem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    initItem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??setItem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    setItem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??calcChkB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    calcChkB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??calcChkF?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    calcChkF

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??writeWord?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    writeWord

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??writeWordM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    writeWordM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??writeWordH?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    writeWordH

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??writeBuf?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    writeBuf

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??xferBuf?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    xferBuf

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??writeItem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    writeItem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??writeIEEE?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    writeIEEE

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_nv_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_nv_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_nv_item_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_nv_item_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_nv_item_len?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_nv_item_len

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_nv_write?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_nv_write

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_nv_read?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_nv_read
   1395          
   1396          /*********************************************************************
   1397          *********************************************************************/

   Maximum stack usage in bytes:

     Function            ISTACK PSTACK XSTACK
     --------            ------ ------ ------
     calcChkB                0      0     39
     calcChkF                0      0     57
       -> nvReadWord         0      0     40
     compactPage             2      0     65
       -> writeWordH         0      0     48
       -> nvReadHdr          0      0     48
       -> calcChkF           0      0     48
       -> setItem            0      0     48
       -> writeBuf           0      0     52
       -> xferBuf            0      0     56
       -> setItem            0      0     48
       -> erasePage          0      0     48
       -> setPageUse         0      0     48
     erasePage               0      0     47
       -> HalAdcCheckVdd     0      0     34
       -> nvReadHdr          0      0     34
       -> writeWordM         0      0     36
     findItem                0      0     51
       -> initPage           0      0     28
       -> findItem           0      0     28
     initItem                2      0     62
       -> writeItem          0      0     46
       -> compactPage        0      0     40
     initNV                  0      0     67
       -> nvReadHdr          0      0     58
       -> nvReadHdr          0      0     58
       -> setPageUse         0      0     58
       -> initPage           0      0     58
       -> nvReadHdr          0      0     58
       -> writeWordM         0      0     60
       -> writeWordM         0      0     60
       -> setPageUse         0      0     58
       -> compactPage        0      0     58
       -> erasePage          0      0     58
       -> initNV             0      0     58
     initPage                0      0     57
       -> nvReadHdr          0      0     56
       -> calcChkF           0      0     56
       -> findItem           0      0     56
       -> setItem            0      0     56
       -> setItem            0      0     56
     osal_nv_init            0      0      9
       -> initNV             0      0     18
     osal_nv_item_init       0      0     18
       -> findItem           0      0     28
       -> initItem           0      0     32
       -> initNV             0      0     28
     osal_nv_item_len        0      0     20
       -> findItem           0      0     40
       -> nvReadHdr          0      0     40
     osal_nv_read            0      0     22
       -> findItem           0      0     32
       -> nvReadBuf          0      0     36
     osal_nv_write           4      0     45
       -> writeIEEE          0      0     74
       -> findItem           0      0     74
       -> nvReadHdr          0      0     74
       -> nvReadByte         0      0     74
       -> initItem           0      0     78
       -> setItem            0      0     74
       -> xferBuf            0      0     82
       -> writeBuf           0      0     78
       -> xferBuf            0      0     82
       -> calcChkF           0      0     74
       -> writeWordH         0      0     74
       -> nvReadHdr          0      0     74
       -> setItem            0      0     74
       -> compactPage        0      0     74
       -> initNV             0      0     74
     setItem                 0      0     59
       -> nvReadHdr          0      0     44
       -> writeWord          0      0     44
       -> writeWord          0      0     44
     setPageUse              0      0     46
       -> writeWord          0      0     34
     writeBuf                1      0     59
       -> nvReadWord         0      0     38
       -> writeWord          0      0     38
       -> writeWordM         0      0     40
       -> nvReadWord         0      0     38
       -> writeWord          0      0     38
     writeIEEE               0      0     55
       -> nvReadHdr          0      0     34
       -> writeWordM         0      0     36
     writeItem               0      0     52
       -> setPageUse         0      0     54
       -> writeWord          0      0     54
       -> nvReadHdr          0      0     54
       -> calcChkB           0      0     54
       -> writeBuf           0      0     58
       -> calcChkF           0      0     54
       -> writeWordH         0      0     54
       -> nvReadHdr          0      0     54
     writeWord               0      0     41
       -> HalAdcCheckVdd     0      0     28
       -> flashWriteBuf      0      0     28
     writeWordH              1      0     53
       -> writeWord          0      0     32
     writeWordM              0      0     44
       -> HalAdcCheckVdd     0      0     28
       -> flashWriteBuf      0      0     28
     xferBuf                 0      0     63
       -> nvReadWord         0      0     44
       -> nvReadByte         0      0     44
       -> writeWord          0      0     44
       -> nvReadWord         0      0     44
       -> writeWord          0      0     44
       -> nvReadWord         0      0     44
       -> nvReadByte         0      0     44
       -> writeWord          0      0     44


   Segment part sizes:

     Function/Label            Bytes
     --------------            -----
     _A_IEN0                      1
     FWT                          1
     FADDRH                       1
     FCTL                         1
     flashXdataBuf               22
     pgOff                        4
     pgLost                       4
     pgRes                        1
     findPg                       1
     failF                        1
     initNV                     488
     setPageUse                  85
     initPage                   666
     erasePage                  201
     compactPage                550
     findItem                   114
     initItem                   430
     setItem                    239
     calcChkB                   166
     calcChkF                   166
     writeWord                   81
     writeWordM                  87
     writeWordH                 105
     writeBuf                   514
     xferBuf                    458
     writeItem                  529
     writeIEEE                  150
     osal_nv_init                16
     osal_nv_item_init          118
     osal_nv_item_len           109
     osal_nv_write             1064
     osal_nv_read               131
     ??initNV?relay               6
     ??setPageUse?relay           6
     ??initPage?relay             6
     ??erasePage?relay            6
     ??compactPage?relay          6
     ??findItem?relay             6
     ??initItem?relay             6
     ??setItem?relay              6
     ??calcChkB?relay             6
     ??calcChkF?relay             6
     ??writeWord?relay            6
     ??writeWordM?relay           6
     ??writeWordH?relay           6
     ??writeBuf?relay             6
     ??xferBuf?relay              6
     ??writeItem?relay            6
     ??writeIEEE?relay            6
     ??osal_nv_init?relay         6
     ??osal_nv_item_init?relay    6
     ??osal_nv_item_len?relay     6
     ??osal_nv_write?relay        6
     ??osal_nv_read?relay         6

 
 6 467 bytes in segment BANKED_CODE
   132 bytes in segment BANK_RELAYS
     4 bytes in segment SFR_AN
    33 bytes in segment XDATA_Z
 
 6 599 bytes of CODE  memory
     0 bytes of DATA  memory (+ 4 bytes shared)
    33 bytes of XDATA memory

Errors: none
Warnings: none

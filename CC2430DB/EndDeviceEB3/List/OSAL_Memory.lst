###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    18/Mar/2013  18:21:46 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \osal\common\OSAL_Memory.c                         #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\. #
#                          .\..\..\Tools\CC2430DB\f8wEndev.cfg" (-DCPU32MHZ   #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_OPT_FFD=0 -DBLINK_LEDS "-DCONST=const        #
#                          __code" -DGENERIC=__generic) -f "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\Tools #
#                          \CC2430DB\f8wConfig.cfg" (-DSECURE=0               #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\osal\com #
#                          mon\OSAL_Memory.c" -D CC2430EB -D AXD_END3 -D      #
#                          NWK_AUTO_POLL -D REFLECTOR -D xZTOOL_P1 -D         #
#                          xMT_TASK -D xMT_ZDO_FUNC -D xLCD_SUPPORTED=DEBUG   #
#                          -D xPOWER_SAVING -lC "C:\Texas                     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\EndDeviceEB3\L #
#                          ist\" -lA "C:\Texas Instruments\ZStack-1.4.3-1.2.1 #
#                          \Projects\zstack\Samples\cc2430-zstack-adxl345\CC2 #
#                          430DB\EndDeviceEB3\List\" --diag_suppress          #
#                          Pe001,Pa010 --diag_remark pe550 -o "C:\Texas       #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\EndDeviceEB3\O #
#                          bj\" -e --require_prototypes -z2 --no_cse          #
#                          --no_unroll --no_inline --no_code_motion           #
#                          --no_tbaa --debug --core=plain --dptr=16,1         #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\cc2430-zstack-adxl345\CC2430DB\"    #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\. #
#                          .\SOURCE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\cc2430-zstack-adxl345 #
#                          \CC2430DB\..\Drivers\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\ZMAIN #
#                          \TI2430DB\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MT\" -I "C:\Texas                      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\INCLUDE\" -I "C:\Texas             #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\TARGET\CC2430EB\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\OSAL\INCLUDE\" -I "C:\Texas            #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\AF\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\NWK\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SEC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SYS\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\ZDO\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\ZMAC\F8W\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\ZMAC\" -I "C:\Texas                    #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SADDR\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SDATA\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\INCLUDE\" -I "C:\Texas             #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\HIGH_LEVEL\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\LOW_LEVEL\SRF03\SINGLE_CHIP\" -I   #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          4.0 Evaluation version\8051\INC\" -I "C:\Program   #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\CC2430DB\EndDe #
#                          viceEB3\List\OSAL_Memory.lst                       #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\CC2430DB\EndDe #
#                          viceEB3\Obj\OSAL_Memory.r51                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\osal\common\OSAL_Memory.c
      1          /**************************************************************************************************
      2            Filename:       OSAL_Memory.c
      3            Revised:        $Date: 2007-10-28 18:43:04 -0700 (Sun, 28 Oct 2007) $
      4            Revision:       $Revision: 15800 $
      5          
      6            Description:    OSAL Heap Memory management functions.
      7          
      8          
      9            Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "ZComDef.h"
     45          #include "OSAL_Memory.h"
     46          #include "OnBoard.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     47          #include "hal_assert.h"
     48          
     49          #if ( MAXMEMHEAP >= 32768 )
     50            #error MAXMEMHEAP is too big to manage!
     51          #endif
     52          
     53          // Minimum wasted bytes to justify splitting a block before allocation.
     54          #if !defined ( OSALMEM_MIN_BLKSZ )
     55            #define OSALMEM_MIN_BLKSZ    4
     56          #endif
     57          
     58          /* Profiling memory allocations showed that a significant % of very high
     59           * frequency allocations/frees are for block sizes less than or equal to 16.
     60           */
     61          #if !defined ( OSALMEM_SMALL_BLKSZ )
     62            #define OSALMEM_SMALL_BLKSZ  16
     63          #endif
     64          
     65          #if !defined ( OSALMEM_NODEBUG )
     66            #define OSALMEM_NODEBUG      TRUE
     67          #endif
     68          
     69          #if !defined ( OSALMEM_PROFILER )
     70            #define OSALMEM_PROFILER     FALSE
     71          #endif
     72          
     73          #if !defined ( OSALMEM_GUARD )
     74            #define OSALMEM_GUARD  TRUE  // TBD - Hacky workaround til Bugzilla 1252 is fixed!
     75            #define OSALMEM_READY  0xE2
     76          #endif
     77          
     78          #if ( OSALMEM_PROFILER )
     79            #define OSALMEM_INIT   'X'
     80            #define OSALMEM_ALOC   'A'
     81            #define OSALMEM_REIN   'F'
     82          #endif
     83          
     84          /*********************************************************************
     85           * MACROS
     86           */
     87          
     88          /*
     89           *  The MAC_ASSERT macro is for use during debugging.
     90           *  The given expression must evaluate as "true" or else fatal error occurs.
     91           *  At that point, the call stack feature of the debugger can pinpoint where
     92           *  the problem occurred.
     93           *
     94           *  To disable this feature and save code size, the project should define
     95           *  OSALMEM_NODEBUG to TRUE.
     96           */
     97          #if ( OSALMEM_NODEBUG )
     98            #define OSALMEM_ASSERT( expr )
     99            #define OSALMEM_DEBUG( statement )
    100          #else
    101            #define OSALMEM_ASSERT( expr)        HAL_ASSERT( expr )
    102            #define OSALMEM_DEBUG( statement)    st( statement )
    103          #endif
    104          
    105          /*********************************************************************
    106           * TYPEDEFS
    107           */
    108          
    109          typedef uint16  osalMemHdr_t;
    110          
    111          /*********************************************************************
    112           * CONSTANTS
    113           */
    114          
    115          #define OSALMEM_IN_USE  0x8000
    116          
    117          /* This number sets the size of the small-block bucket. Although profiling
    118           * shows max simultaneous alloc of 16x18, timing without profiling overhead
    119           * shows that the best worst case is achieved with the following.
    120           */
    121          #define SMALLBLKHEAP    232
    122          
    123          // To maintain data alignment of the pointer returned, reserve the greater
    124          // space for the memory block header.
    125          #define HDRSZ  ( (sizeof ( halDataAlign_t ) > sizeof( osalMemHdr_t )) ? \
    126                            sizeof ( halDataAlign_t ) : sizeof( osalMemHdr_t ) )
    127          
    128          /*********************************************************************
    129           * GLOBAL VARIABLES
    130           */
    131          
    132          /*********************************************************************
    133           * EXTERNAL VARIABLES
    134           */
    135          
    136          /*********************************************************************
    137           * EXTERNAL FUNCTIONS
    138           */
    139          
    140          /*********************************************************************
    141           * LOCAL VARIABLES
    142           */
    143          
    144          #if ( OSALMEM_GUARD )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    145            static byte ready = 0;
   \                     ready:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    146          #endif
    147          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    148          static osalMemHdr_t *ff1;  // First free block in the small-block bucket.
   \                     ff1:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    149          static osalMemHdr_t *ff2;  // First free block after the small-block bucket.
   \                     ff2:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    150          
    151          #if ( OSALMEM_METRICS )
    152            static uint16 blkMax;  // Max cnt of all blocks ever seen at once.
    153            static uint16 blkCnt;  // Current cnt of all blocks.
    154            static uint16 blkFree; // Current cnt of free blocks.
    155            static uint16 memAlo;  // Current total memory allocated.
    156            static uint16 memMax;  // Max total memory ever allocated at once.
    157          #endif
    158          
    159          #if ( OSALMEM_PROFILER )
    160            #define OSALMEM_PROMAX  8
    161            /* The profiling buckets must differ by at least OSALMEM_MIN_BLKSZ; the
    162             * last bucket must equal the max alloc size. Set the bucket sizes to
    163             * whatever sizes necessary to show how your application is using memory.
    164             */
    165            static uint16 proCnt[OSALMEM_PROMAX] = { 
    166              OSALMEM_SMALL_BLKSZ, 48, 112, 176, 192, 224, 256, 65535 };
    167            static uint16 proCur[OSALMEM_PROMAX] = { 0 };
    168            static uint16 proMax[OSALMEM_PROMAX] = { 0 };
    169            static uint16 proTot[OSALMEM_PROMAX] = { 0 };
    170            static uint16 proSmallBlkMiss;
    171          #endif
    172          
    173          // Memory Allocation Heap.
    174          #if defined( EXTERNAL_RAM )
    175            static byte *theHeap = (byte *)EXT_RAM_BEG;
    176          #else

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    177            static halDataAlign_t _theHeap[ MAXMEMHEAP / sizeof( halDataAlign_t ) ];
   \                     _theHeap:
   \   000000                DS 1664
   \   000680                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    178            static byte *theHeap = (byte *)_theHeap;
   \                     theHeap:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for theHeap>`
   \   000002                REQUIRE __INIT_XDATA_I
    179          #endif
    180          
    181          /*********************************************************************
    182           * LOCAL FUNCTIONS
    183           */
    184          
    185          /*********************************************************************
    186           * @fn      osal_mem_init
    187           *
    188           * @brief   Initialize the heap memory management system.
    189           *
    190           * @param   void
    191           *
    192           * @return  void
    193           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    194          void osal_mem_init( void )
   \                     osal_mem_init:
    195          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    196            osalMemHdr_t *tmp;
    197          
    198          #if ( OSALMEM_PROFILER )
    199            osal_memset( theHeap, OSALMEM_INIT, MAXMEMHEAP );
    200          #endif
    201          
    202            // Setup a NULL block at the end of the heap for fast comparisons with zero.
    203            tmp = (osalMemHdr_t *)theHeap + (MAXMEMHEAP / HDRSZ) - 1;
   \   000005   90....       MOV     DPTR,#theHeap
   \   000008   E0           MOVX    A,@DPTR
   \   000009   247E         ADD     A,#0x7e
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   3406         ADDC    A,#0x6
   \   000010   F9           MOV     R1,A
   \   000011   E8           MOV     A,R0
   \   000012   FE           MOV     R6,A
   \   000013   E9           MOV     A,R1
   \   000014   FF           MOV     R7,A
    204            *tmp = 0;
   \   000015   8E82         MOV     DPL,R6
   \   000017   8F83         MOV     DPH,R7
   \   000019   7400         MOV     A,#0x0
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   7400         MOV     A,#0x0
   \   00001F   F0           MOVX    @DPTR,A
    205          
    206            // Setup a small-block bucket.
    207            tmp = (osalMemHdr_t *)theHeap;
   \   000020   90....       MOV     DPTR,#theHeap
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F8           MOV     R0,A
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F9           MOV     R1,A
   \   000028   E8           MOV     A,R0
   \   000029   FE           MOV     R6,A
   \   00002A   E9           MOV     A,R1
   \   00002B   FF           MOV     R7,A
    208            *tmp = SMALLBLKHEAP;
   \   00002C   8E82         MOV     DPL,R6
   \   00002E   8F83         MOV     DPH,R7
   \   000030   74E8         MOV     A,#-0x18
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   7400         MOV     A,#0x0
   \   000036   F0           MOVX    @DPTR,A
    209          
    210            // Setup the wilderness.
    211            tmp = (osalMemHdr_t *)theHeap + (SMALLBLKHEAP / HDRSZ);
   \   000037   90....       MOV     DPTR,#theHeap
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   24E8         ADD     A,#-0x18
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   3400         ADDC    A,#0x0
   \   000042   F9           MOV     R1,A
   \   000043   E8           MOV     A,R0
   \   000044   FE           MOV     R6,A
   \   000045   E9           MOV     A,R1
   \   000046   FF           MOV     R7,A
    212            *tmp = ((MAXMEMHEAP / HDRSZ) * HDRSZ) - SMALLBLKHEAP - HDRSZ;
   \   000047   8E82         MOV     DPL,R6
   \   000049   8F83         MOV     DPH,R7
   \   00004B   7496         MOV     A,#-0x6a
   \   00004D   F0           MOVX    @DPTR,A
   \   00004E   A3           INC     DPTR
   \   00004F   7405         MOV     A,#0x5
   \   000051   F0           MOVX    @DPTR,A
    213          
    214          #if ( OSALMEM_GUARD )
    215            ready = OSALMEM_READY;
   \   000052   74E2         MOV     A,#-0x1e
   \   000054   90....       MOV     DPTR,#ready
   \   000057   F0           MOVX    @DPTR,A
    216          #endif
    217          
    218            // Setup a NULL block that is never freed so that the small-block bucket
    219            // is never coalesced with the wilderness.
    220            ff1 = tmp;
   \   000058   90....       MOV     DPTR,#ff1
   \   00005B   EE           MOV     A,R6
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   EF           MOV     A,R7
   \   00005F   F0           MOVX    @DPTR,A
    221            ff2 = osal_mem_alloc( 0 );
   \   000060                ; Setup parameters for call to function osal_mem_alloc
   \   000060   7A00         MOV     R2,#0x0
   \   000062   7B00         MOV     R3,#0x0
   \   000064   12....       LCALL   ??osal_mem_alloc?relay
   \   000067   90....       MOV     DPTR,#ff2
   \   00006A   EA           MOV     A,R2
   \   00006B   F0           MOVX    @DPTR,A
   \   00006C   A3           INC     DPTR
   \   00006D   EB           MOV     A,R3
   \   00006E   F0           MOVX    @DPTR,A
    222            ff1 = (osalMemHdr_t *)theHeap;
   \   00006F   90....       MOV     DPTR,#theHeap
   \   000072   E0           MOVX    A,@DPTR
   \   000073   F8           MOV     R0,A
   \   000074   A3           INC     DPTR
   \   000075   E0           MOVX    A,@DPTR
   \   000076   F9           MOV     R1,A
   \   000077   90....       MOV     DPTR,#ff1
   \   00007A   E8           MOV     A,R0
   \   00007B   F0           MOVX    @DPTR,A
   \   00007C   A3           INC     DPTR
   \   00007D   E9           MOV     A,R1
   \   00007E   F0           MOVX    @DPTR,A
    223          
    224          #if ( OSALMEM_METRICS )
    225            /* Start with the small-block bucket and the wilderness - don't count the
    226             * end-of-heap NULL block nor the end-of-small-block NULL block.
    227             */
    228            blkCnt = blkFree = 2;
    229          #endif
    230          }
   \   00007F   7F01         MOV     R7,#0x1
   \   000081   02....       LJMP    ?BANKED_LEAVE_XDATA
    231          
    232          /*********************************************************************
    233           * @fn      osal_mem_kick
    234           *
    235           * @brief   Kick the ff1 pointer out past the long-lived OSAL Task blocks.
    236           *          Invoke this once after all long-lived blocks have been allocated -
    237           *          presently at the end of osal_init_system().
    238           *
    239           * @param   void
    240           *
    241           * @return  void
    242           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    243          void osal_mem_kick( void )
   \                     osal_mem_kick:
    244          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    245            halIntState_t intState;
    246          
    247            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000004   A2AF         MOV     C,0xa8.7
   \   000006   E4           CLR     A
   \   000007   92E0         MOV     0xE0 /* A   */.0,C
   \   000009   FA           MOV     R2,A
   \   00000A   C2AF         CLR     0xa8.7
    248          
    249            /* Logic in osal_mem_free() will ratchet ff1 back down to the first free
    250             * block in the small-block bucket.
    251             */
    252            ff1 = ff2;
   \   00000C   90....       MOV     DPTR,#ff2
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F8           MOV     R0,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F9           MOV     R1,A
   \   000014   90....       MOV     DPTR,#ff1
   \   000017   E8           MOV     A,R0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   E9           MOV     A,R1
   \   00001B   F0           MOVX    @DPTR,A
    253          
    254            HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
   \   00001C   EA           MOV     A,R2
   \   00001D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00001F   92AF         MOV     0xa8.7,C
    255          }
   \   000021   D083         POP     DPH
   \   000023   D082         POP     DPL
   \   000025   02....       LJMP    ?BRET
   \   000028                REQUIRE _A_IEN0
    256          
    257          /*********************************************************************
    258           * @fn      osal_mem_alloc
    259           *
    260           * @brief   Implementation of the allocator functionality.
    261           *
    262           * @param   size - number of bytes to allocate from the heap.
    263           *
    264           * @return  void * - pointer to the heap allocation; NULL if error or failure.
    265           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    266          void *osal_mem_alloc( uint16 size )
   \                     osal_mem_alloc:
    267          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
    268            osalMemHdr_t *prev;
    269            osalMemHdr_t *hdr;
    270            halIntState_t intState;
    271            uint16 tmp;
    272            byte coal = 0;
   \   000009   75..00       MOV     ?V0 + 5,#0x0
    273          
    274          #if ( OSALMEM_GUARD )
    275            // Try to protect against premature use by HAL / OSAL.
    276            if ( ready != OSALMEM_READY )
   \   00000C   90....       MOV     DPTR,#ready
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   64E2         XRL     A,#0xe2
   \   000012   6003         JZ      ??osal_mem_alloc_0
    277            {
    278              osal_mem_init();
   \   000014                ; Setup parameters for call to function osal_mem_init
   \   000014   12....       LCALL   ??osal_mem_init?relay
    279            }
    280          #endif
    281          
    282            OSALMEM_ASSERT( size );
    283          
    284            size += HDRSZ;
   \                     ??osal_mem_alloc_0:
   \   000017   E5..         MOV     A,?V0 + 2
   \   000019   2402         ADD     A,#0x2
   \   00001B   F5..         MOV     ?V0 + 2,A
   \   00001D   E5..         MOV     A,?V0 + 3
   \   00001F   3400         ADDC    A,#0x0
   \   000021   F5..         MOV     ?V0 + 3,A
    285          
    286            // Calculate required bytes to add to 'size' to align to halDataAlign_t.
    287            if ( sizeof( halDataAlign_t ) == 2 )
    288            {
    289              size += (size & 0x01);
    290            }
    291            else if ( sizeof( halDataAlign_t ) != 1 )
    292            {
    293              const byte mod = size % sizeof( halDataAlign_t );
    294          
    295              if ( mod != 0 )
    296              {
    297                size += (sizeof( halDataAlign_t ) - mod);
    298              }
    299            }
    300          
    301            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000023   A2AF         MOV     C,0xa8.7
   \   000025   E4           CLR     A
   \   000026   92E0         MOV     0xE0 /* A   */.0,C
   \   000028   F5..         MOV     ?V0 + 4,A
   \   00002A   C2AF         CLR     0xa8.7
    302          
    303            // Smaller allocations are first attempted in the small-block bucket.
    304            if ( size <= OSALMEM_SMALL_BLKSZ )
   \   00002C   C3           CLR     C
   \   00002D   E5..         MOV     A,?V0 + 2
   \   00002F   9411         SUBB    A,#0x11
   \   000031   E5..         MOV     A,?V0 + 3
   \   000033   9400         SUBB    A,#0x0
   \   000035   500E         JNC     ??osal_mem_alloc_1
    305            {
    306              hdr = ff1;
   \   000037   90....       MOV     DPTR,#ff1
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F8           MOV     R0,A
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F9           MOV     R1,A
   \   00003F   E8           MOV     A,R0
   \   000040   FE           MOV     R6,A
   \   000041   E9           MOV     A,R1
   \   000042   FF           MOV     R7,A
   \   000043   800C         SJMP    ??osal_mem_alloc_2
    307            }
    308            else
    309            {
    310              hdr = ff2;
   \                     ??osal_mem_alloc_1:
   \   000045   90....       MOV     DPTR,#ff2
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F8           MOV     R0,A
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   F9           MOV     R1,A
   \   00004D   E8           MOV     A,R0
   \   00004E   FE           MOV     R6,A
   \   00004F   E9           MOV     A,R1
   \   000050   FF           MOV     R7,A
    311            }
    312            tmp = *hdr;
   \                     ??osal_mem_alloc_2:
   \   000051   8E82         MOV     DPL,R6
   \   000053   8F83         MOV     DPH,R7
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F5..         MOV     ?V0 + 0,A
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   F5..         MOV     ?V0 + 1,A
    313          
    314            do
    315            {
    316              if ( tmp & OSALMEM_IN_USE )
   \                     ??osal_mem_alloc_3:
   \   00005C   7400         MOV     A,#0x0
   \   00005E   55..         ANL     A,?V0 + 0
   \   000060   F8           MOV     R0,A
   \   000061   7480         MOV     A,#-0x80
   \   000063   55..         ANL     A,?V0 + 1
   \   000065   F9           MOV     R1,A
   \   000066   7400         MOV     A,#0x0
   \   000068   68           XRL     A,R0
   \   000069   7003         JNZ     ??osal_mem_alloc_4
   \   00006B   7400         MOV     A,#0x0
   \   00006D   69           XRL     A,R1
   \                     ??osal_mem_alloc_4:
   \   00006E   6011         JZ      ??osal_mem_alloc_5
    317              {
    318                tmp ^= OSALMEM_IN_USE;
   \   000070   7400         MOV     A,#0x0
   \   000072   65..         XRL     A,?V0 + 0
   \   000074   F5..         MOV     ?V0 + 0,A
   \   000076   7480         MOV     A,#-0x80
   \   000078   65..         XRL     A,?V0 + 1
   \   00007A   F5..         MOV     ?V0 + 1,A
    319                coal = 0;
   \   00007C   75..00       MOV     ?V0 + 5,#0x0
   \   00007F   804D         SJMP    ??osal_mem_alloc_6
    320              }
    321              else
    322              {
    323                if ( coal != 0 )
   \                     ??osal_mem_alloc_5:
   \   000081   E5..         MOV     A,?V0 + 5
   \   000083   6037         JZ      ??osal_mem_alloc_7
    324                {
    325          #if ( OSALMEM_METRICS )
    326                  blkCnt--;
    327                  blkFree--;
    328          #endif
    329          
    330                  *prev += *hdr;
   \   000085   8E82         MOV     DPL,R6
   \   000087   8F83         MOV     DPH,R7
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   F8           MOV     R0,A
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   F9           MOV     R1,A
   \   00008E   85..82       MOV     DPL,?V0 + 6
   \   000091   85..83       MOV     DPH,?V0 + 7
   \   000094   E0           MOVX    A,@DPTR
   \   000095   28           ADD     A,R0
   \   000096   F0           MOVX    @DPTR,A
   \   000097   A3           INC     DPTR
   \   000098   E0           MOVX    A,@DPTR
   \   000099   39           ADDC    A,R1
   \   00009A   F0           MOVX    @DPTR,A
    331          
    332                  if ( *prev >= size )
   \   00009B   85..82       MOV     DPL,?V0 + 6
   \   00009E   85..83       MOV     DPH,?V0 + 7
   \   0000A1   C3           CLR     C
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   95..         SUBB    A,?V0 + 2
   \   0000A5   A3           INC     DPTR
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   95..         SUBB    A,?V0 + 3
   \   0000A9   4023         JC      ??osal_mem_alloc_6
    333                  {
    334                    hdr = prev;
   \   0000AB   AE..         MOV     R6,?V0 + 6
   \   0000AD   AF..         MOV     R7,?V0 + 7
    335                    tmp = *hdr;
   \   0000AF   8E82         MOV     DPL,R6
   \   0000B1   8F83         MOV     DPH,R7
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   F5..         MOV     ?V0 + 0,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   F5..         MOV     ?V0 + 1,A
    336                    break;
   \   0000BA   8038         SJMP    ??osal_mem_alloc_8
    337                  }
    338                }
    339                else
    340                {
    341                  if ( tmp >= size )
   \                     ??osal_mem_alloc_7:
   \   0000BC   C3           CLR     C
   \   0000BD   E5..         MOV     A,?V0 + 0
   \   0000BF   95..         SUBB    A,?V0 + 2
   \   0000C1   E5..         MOV     A,?V0 + 1
   \   0000C3   95..         SUBB    A,?V0 + 3
   \   0000C5   502D         JNC     ??osal_mem_alloc_8
    342                  {
    343                    break;
    344                  }
    345          
    346                  coal = 1;
   \   0000C7   75..01       MOV     ?V0 + 5,#0x1
    347                  prev = hdr;
   \   0000CA   8E..         MOV     ?V0 + 6,R6
   \   0000CC   8F..         MOV     ?V0 + 7,R7
    348                }
    349              }
    350          
    351              hdr = (osalMemHdr_t *)((byte *)hdr + tmp);
   \                     ??osal_mem_alloc_6:
   \   0000CE   EE           MOV     A,R6
   \   0000CF   25..         ADD     A,?V0 + 0
   \   0000D1   FE           MOV     R6,A
   \   0000D2   EF           MOV     A,R7
   \   0000D3   35..         ADDC    A,?V0 + 1
   \   0000D5   FF           MOV     R7,A
    352          
    353              tmp = *hdr;
   \   0000D6   8E82         MOV     DPL,R6
   \   0000D8   8F83         MOV     DPH,R7
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   F5..         MOV     ?V0 + 0,A
   \   0000DD   A3           INC     DPTR
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   F5..         MOV     ?V0 + 1,A
    354              if ( tmp == 0 )
   \   0000E1   7400         MOV     A,#0x0
   \   0000E3   65..         XRL     A,?V0 + 0
   \   0000E5   7004         JNZ     ??osal_mem_alloc_9
   \   0000E7   7400         MOV     A,#0x0
   \   0000E9   65..         XRL     A,?V0 + 1
   \                     ??osal_mem_alloc_9:
   \   0000EB   6003         JZ      $+5
   \   0000ED   02....       LJMP    ??osal_mem_alloc_3 & 0xFFFF
    355              {
    356                hdr = NULL;
   \   0000F0   7E00         MOV     R6,#0x0
   \   0000F2   7F00         MOV     R7,#0x0
    357                break;
    358              }
    359          
    360          
    361            } while ( 1 );
    362          
    363            if ( hdr != NULL )
   \                     ??osal_mem_alloc_8:
   \   0000F4   EE           MOV     A,R6
   \   0000F5   6400         XRL     A,#0x0
   \   0000F7   7003         JNZ     ??osal_mem_alloc_10
   \   0000F9   EF           MOV     A,R7
   \   0000FA   6400         XRL     A,#0x0
   \                     ??osal_mem_alloc_10:
   \   0000FC   6059         JZ      ??osal_mem_alloc_11
    364            {
    365              tmp -= size;
   \   0000FE   C3           CLR     C
   \   0000FF   E5..         MOV     A,?V0 + 0
   \   000101   95..         SUBB    A,?V0 + 2
   \   000103   F5..         MOV     ?V0 + 0,A
   \   000105   E5..         MOV     A,?V0 + 1
   \   000107   95..         SUBB    A,?V0 + 3
   \   000109   F5..         MOV     ?V0 + 1,A
    366          
    367              // Determine whether the threshold for splitting is met.
    368              if ( tmp >= OSALMEM_MIN_BLKSZ )
   \   00010B   C3           CLR     C
   \   00010C   E5..         MOV     A,?V0 + 0
   \   00010E   9404         SUBB    A,#0x4
   \   000110   E5..         MOV     A,?V0 + 1
   \   000112   9400         SUBB    A,#0x0
   \   000114   402C         JC      ??osal_mem_alloc_12
    369              {
    370                // Split the block before allocating it.
    371                osalMemHdr_t *next = (osalMemHdr_t *)((byte *)hdr + size);
   \   000116   EE           MOV     A,R6
   \   000117   25..         ADD     A,?V0 + 2
   \   000119   F8           MOV     R0,A
   \   00011A   EF           MOV     A,R7
   \   00011B   35..         ADDC    A,?V0 + 3
   \   00011D   F9           MOV     R1,A
   \   00011E   E8           MOV     A,R0
   \   00011F   FA           MOV     R2,A
   \   000120   E9           MOV     A,R1
   \   000121   FB           MOV     R3,A
    372                *next = tmp;
   \   000122   8A82         MOV     DPL,R2
   \   000124   8B83         MOV     DPH,R3
   \   000126   E5..         MOV     A,?V0 + 0
   \   000128   F0           MOVX    @DPTR,A
   \   000129   A3           INC     DPTR
   \   00012A   E5..         MOV     A,?V0 + 1
   \   00012C   F0           MOVX    @DPTR,A
    373                *hdr = (size | OSALMEM_IN_USE);
   \   00012D   7400         MOV     A,#0x0
   \   00012F   45..         ORL     A,?V0 + 2
   \   000131   F8           MOV     R0,A
   \   000132   7480         MOV     A,#-0x80
   \   000134   45..         ORL     A,?V0 + 3
   \   000136   F9           MOV     R1,A
   \   000137   8E82         MOV     DPL,R6
   \   000139   8F83         MOV     DPH,R7
   \   00013B   E8           MOV     A,R0
   \   00013C   F0           MOVX    @DPTR,A
   \   00013D   A3           INC     DPTR
   \   00013E   E9           MOV     A,R1
   \   00013F   F0           MOVX    @DPTR,A
   \   000140   800D         SJMP    ??osal_mem_alloc_13
    374          
    375          #if ( OSALMEM_METRICS )
    376                blkCnt++;
    377                if ( blkMax < blkCnt )
    378                {
    379                  blkMax = blkCnt;
    380                }
    381                memAlo += size;
    382          #endif
    383              }
    384              else
    385              {
    386          #if ( OSALMEM_METRICS )
    387                memAlo += *hdr;
    388                blkFree--;
    389          #endif
    390          
    391                *hdr |= OSALMEM_IN_USE;
   \                     ??osal_mem_alloc_12:
   \   000142   8E82         MOV     DPL,R6
   \   000144   8F83         MOV     DPH,R7
   \   000146   E0           MOVX    A,@DPTR
   \   000147   4400         ORL     A,#0x0
   \   000149   F0           MOVX    @DPTR,A
   \   00014A   A3           INC     DPTR
   \   00014B   E0           MOVX    A,@DPTR
   \   00014C   4480         ORL     A,#0x80
   \   00014E   F0           MOVX    @DPTR,A
    392              }
    393          
    394          #if ( OSALMEM_METRICS )
    395              if ( memMax < memAlo )
    396              {
    397                memMax = memAlo;
    398              }
    399          #endif
    400          
    401          #if ( OSALMEM_PROFILER )
    402            {
    403              byte idx;
    404              size = *hdr ^ OSALMEM_IN_USE;
    405          
    406              for ( idx = 0; idx < OSALMEM_PROMAX; idx++ )
    407              {
    408                if ( size <= proCnt[idx] )
    409                {
    410                  break;
    411                }
    412              }
    413              proCur[idx]++;
    414              if ( proMax[idx] < proCur[idx] )
    415              {
    416                proMax[idx] = proCur[idx];
    417              }
    418              proTot[idx]++;
    419            }
    420          #endif
    421          
    422              hdr++;
   \                     ??osal_mem_alloc_13:
   \   00014F   EE           MOV     A,R6
   \   000150   2402         ADD     A,#0x2
   \   000152   FE           MOV     R6,A
   \   000153   EF           MOV     A,R7
   \   000154   3400         ADDC    A,#0x0
   \   000156   FF           MOV     R7,A
    423          
    424          #if ( OSALMEM_PROFILER )
    425              osal_memset( (byte *)hdr, OSALMEM_ALOC, (size - HDRSZ) );
    426          
    427              /* A small-block could not be allocated in the small-block bucket.
    428               * When this occurs significantly frequently, increase the size of the
    429               * bucket in order to restore better worst case run times. Set the first
    430               * profiling bucket size in proCnt[] to the small-block bucket size and
    431               * divide proSmallBlkMiss by the corresponding proTot[] size to get % miss.
    432               * Best worst case time on TrasmitApp was achieved at a 0-15% miss rate
    433               * during steady state Tx load, 0% during idle and steady state Rx load.
    434               */
    435              if ( (size <= OSALMEM_SMALL_BLKSZ) && (hdr > ff2) )
    436              {
    437                proSmallBlkMiss++;
    438              }
    439          #endif
    440            }
    441          
    442            HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
   \                     ??osal_mem_alloc_11:
   \   000157   E5..         MOV     A,?V0 + 4
   \   000159   A2E0         MOV     C,0xE0 /* A   */.0
   \   00015B   92AF         MOV     0xa8.7,C
    443          
    444            return (void *)hdr;
   \   00015D   EE           MOV     A,R6
   \   00015E   FA           MOV     R2,A
   \   00015F   EF           MOV     A,R7
   \   000160   FB           MOV     R3,A
   \   000161   7F08         MOV     R7,#0x8
   \   000163   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000166                REQUIRE _A_IEN0
    445          }
    446          
    447          /*********************************************************************
    448           * @fn      osal_mem_free
    449           *
    450           * @brief   Implementation of the de-allocator functionality.
    451           *
    452           * @param   ptr - pointer to the memory to free.
    453           *
    454           * @return  void
    455           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    456          void osal_mem_free( void *ptr )
   \                     osal_mem_free:
    457          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
    458            osalMemHdr_t *currHdr;
    459            halIntState_t intState;
    460          
    461          #if ( OSALMEM_GUARD )
    462            // Try to protect against premature use by HAL / OSAL.
    463            if ( ready != OSALMEM_READY )
   \   000009   90....       MOV     DPTR,#ready
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   64E2         XRL     A,#0xe2
   \   00000F   6003         JZ      ??osal_mem_free_0
    464            {
    465              osal_mem_init();
   \   000011                ; Setup parameters for call to function osal_mem_init
   \   000011   12....       LCALL   ??osal_mem_init?relay
    466            }
    467          #endif
    468          
    469            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \                     ??osal_mem_free_0:
   \   000014   A2AF         MOV     C,0xa8.7
   \   000016   E4           CLR     A
   \   000017   92E0         MOV     0xE0 /* A   */.0,C
   \   000019   F5..         MOV     ?V0 + 2,A
   \   00001B   C2AF         CLR     0xa8.7
    470          
    471            OSALMEM_ASSERT( ptr );
    472          
    473            currHdr = (osalMemHdr_t *)ptr - 1;
   \   00001D   E5..         MOV     A,?V0 + 0
   \   00001F   24FE         ADD     A,#-0x2
   \   000021   F8           MOV     R0,A
   \   000022   E5..         MOV     A,?V0 + 1
   \   000024   34FF         ADDC    A,#-0x1
   \   000026   F9           MOV     R1,A
   \   000027   E8           MOV     A,R0
   \   000028   FE           MOV     R6,A
   \   000029   E9           MOV     A,R1
   \   00002A   FF           MOV     R7,A
    474          
    475            // Has this block already been freed?
    476            OSALMEM_ASSERT( *currHdr & OSALMEM_IN_USE );
    477          
    478            *currHdr &= ~OSALMEM_IN_USE;
   \   00002B   8E82         MOV     DPL,R6
   \   00002D   8F83         MOV     DPH,R7
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   54FF         ANL     A,#0xff
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \   000035   547F         ANL     A,#0x7f
   \   000037   F0           MOVX    @DPTR,A
    479          
    480          #if ( OSALMEM_PROFILER )
    481            {
    482              uint16 size = *currHdr;
    483              byte idx;
    484          
    485              for ( idx = 0; idx < OSALMEM_PROMAX; idx++ )
    486              {
    487                if ( size <= proCnt[idx] )
    488                {
    489                  break;
    490                }
    491              }
    492          
    493              proCur[idx]--;
    494            }
    495          #endif
    496          
    497          #if ( OSALMEM_METRICS )
    498            memAlo -= *currHdr;
    499            blkFree++;
    500          #endif
    501          
    502            if ( ff1 > currHdr )
   \   000038   90....       MOV     DPTR,#ff1
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F8           MOV     R0,A
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F9           MOV     R1,A
   \   000040   C3           CLR     C
   \   000041   EE           MOV     A,R6
   \   000042   98           SUBB    A,R0
   \   000043   EF           MOV     A,R7
   \   000044   99           SUBB    A,R1
   \   000045   5008         JNC     ??osal_mem_free_1
    503            {
    504              ff1 = currHdr;
   \   000047   90....       MOV     DPTR,#ff1
   \   00004A   EE           MOV     A,R6
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   EF           MOV     A,R7
   \   00004E   F0           MOVX    @DPTR,A
    505            }
    506          
    507          #if ( OSALMEM_PROFILER )
    508            osal_memset( (byte *)currHdr+HDRSZ, OSALMEM_REIN, (*currHdr - HDRSZ) );
    509          #endif
    510          
    511            HAL_EXIT_CRITICAL_SECTION( intState );  // Re-enable interrupts.
   \                     ??osal_mem_free_1:
   \   00004F   E5..         MOV     A,?V0 + 2
   \   000051   A2E0         MOV     C,0xE0 /* A   */.0
   \   000053   92AF         MOV     0xa8.7,C
    512          }
   \   000055   7F03         MOV     R7,#0x3
   \   000057   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00005A                REQUIRE _A_IEN0

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for theHeap>`:
   \   000000   ....         DW _theHeap

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_mem_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_mem_kick?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_kick

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_mem_alloc?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_alloc

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_mem_free?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_mem_free
    513          
    514          #if ( OSALMEM_METRICS )
    515          /*********************************************************************
    516           * @fn      osal_heap_block_max
    517           *
    518           * @brief   Return the maximum number of blocks ever allocated at once.
    519           *
    520           * @param   none
    521           *
    522           * @return  Maximum number of blocks ever allocated at once.
    523           */
    524          uint16 osal_heap_block_max( void )
    525          {
    526            return blkMax;
    527          }
    528          
    529          /*********************************************************************
    530           * @fn      osal_heap_block_cnt
    531           *
    532           * @brief   Return the current number of blocks now allocated.
    533           *
    534           * @param   none
    535           *
    536           * @return  Current number of blocks now allocated.
    537           */
    538          uint16 osal_heap_block_cnt( void )
    539          {
    540            return blkCnt;
    541          }
    542          
    543          /*********************************************************************
    544           * @fn      osal_heap_block_free
    545           *
    546           * @brief   Return the current number of free blocks.
    547           *
    548           * @param   none
    549           *
    550           * @return  Current number of free blocks.
    551           */
    552          uint16 osal_heap_block_free( void )
    553          {
    554            return blkFree;
    555          }
    556          
    557          /*********************************************************************
    558           * @fn      osal_heap_mem_used
    559           *
    560           * @brief   Return the current number of bytes allocated.
    561           *
    562           * @param   none
    563           *
    564           * @return  Current number of bytes allocated.
    565           */
    566          uint16 osal_heap_mem_used( void )
    567          {
    568            return memAlo;
    569          }
    570          #endif
    571          
    572          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    573          /*********************************************************************
    574           * @fn      osal_heap_high_water
    575           *
    576           * @brief   Return the highest byte ever allocated in the heap.
    577           *
    578           * @param   none
    579           *
    580           * @return  Highest number of bytes ever used by the stack.
    581           */
    582          uint16 osal_heap_high_water( void )
    583          {
    584          #if ( OSALMEM_METRICS )
    585            return memMax;
    586          #else
    587            return MAXMEMHEAP;
    588          #endif
    589          }
    590          #endif
    591          
    592          /*********************************************************************
    593          *********************************************************************/

   Maximum stack usage in bytes:

     Function            ISTACK PSTACK XSTACK
     --------            ------ ------ ------
     osal_mem_alloc          0      0     25
       -> osal_mem_init      0      0     32
     osal_mem_free           0      0     11
       -> osal_mem_init      0      0     22
     osal_mem_init           0      0     25
       -> osal_mem_alloc     0      0     18
     osal_mem_kick           2      0      0


   Segment part sizes:

     Function/Label             Bytes
     --------------             -----
     _A_IEN0                       1
     ready                         1
     ff1                           2
     ff2                           2
     _theHeap                   1664
     theHeap                       2
     osal_mem_init               132
     osal_mem_kick                40
     osal_mem_alloc              358
     osal_mem_free                90
     ?<Initializer for theHeap>    2
     ??osal_mem_init?relay         6
     ??osal_mem_kick?relay         6
     ??osal_mem_alloc?relay        6
     ??osal_mem_free?relay         6

 
   620 bytes in segment BANKED_CODE
    24 bytes in segment BANK_RELAYS
     1 byte  in segment SFR_AN
     2 bytes in segment XDATA_I
     2 bytes in segment XDATA_ID
 1 669 bytes in segment XDATA_Z
 
   646 bytes of CODE  memory
     0 bytes of DATA  memory (+ 1 byte shared)
 1 671 bytes of XDATA memory

Errors: none
Warnings: none

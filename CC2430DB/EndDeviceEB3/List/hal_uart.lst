###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    18/Mar/2013  18:21:54 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \hal\target\CC2430EB\hal_uart.c                    #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\. #
#                          .\..\..\Tools\CC2430DB\f8wEndev.cfg" (-DCPU32MHZ   #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_OPT_FFD=0 -DBLINK_LEDS "-DCONST=const        #
#                          __code" -DGENERIC=__generic) -f "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\Tools #
#                          \CC2430DB\f8wConfig.cfg" (-DSECURE=0               #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\hal\targ #
#                          et\CC2430EB\hal_uart.c" -D CC2430EB -D AXD_END3    #
#                          -D NWK_AUTO_POLL -D REFLECTOR -D xZTOOL_P1 -D      #
#                          xMT_TASK -D xMT_ZDO_FUNC -D xLCD_SUPPORTED=DEBUG   #
#                          -D xPOWER_SAVING -lC "C:\Texas                     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\EndDeviceEB3\L #
#                          ist\" -lA "C:\Texas Instruments\ZStack-1.4.3-1.2.1 #
#                          \Projects\zstack\Samples\cc2430-zstack-adxl345\CC2 #
#                          430DB\EndDeviceEB3\List\" --diag_suppress          #
#                          Pe001,Pa010 --diag_remark pe550 -o "C:\Texas       #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\EndDeviceEB3\O #
#                          bj\" -e --require_prototypes -z2 --no_cse          #
#                          --no_unroll --no_inline --no_code_motion           #
#                          --no_tbaa --debug --core=plain --dptr=16,1         #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\cc2430-zstack-adxl345\CC2430DB\"    #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\. #
#                          .\SOURCE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\cc2430-zstack-adxl345 #
#                          \CC2430DB\..\Drivers\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\ZMAIN #
#                          \TI2430DB\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MT\" -I "C:\Texas                      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\INCLUDE\" -I "C:\Texas             #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\TARGET\CC2430EB\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\OSAL\INCLUDE\" -I "C:\Texas            #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\AF\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\NWK\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SEC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SYS\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\ZDO\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\ZMAC\F8W\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\ZMAC\" -I "C:\Texas                    #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SADDR\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SDATA\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\INCLUDE\" -I "C:\Texas             #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\HIGH_LEVEL\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\LOW_LEVEL\SRF03\SINGLE_CHIP\" -I   #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          4.0 Evaluation version\8051\INC\" -I "C:\Program   #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\CC2430DB\EndDe #
#                          viceEB3\List\hal_uart.lst                          #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\CC2430DB\EndDe #
#                          viceEB3\Obj\hal_uart.r51                           #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\hal\target\CC2430EB\hal_uart.c
      1          /**************************************************************************************************
      2            Filename:       _hal_uart.c
      3            Revised:        $Date: 2007-11-01 08:44:53 -0700 (Thu, 01 Nov 2007) $
      4            Revision:       $Revision: 15821 $
      5          
      6            Description: This file contains the interface to the H/W UART driver.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "hal_types.h"
     45          #include "hal_assert.h"
     46          #include "hal_board.h"

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
     47          #include "hal_defs.h"
     48          #if defined( HAL_UART_DMA ) && HAL_UART_DMA
     49            #include "hal_dma.h"
     50          #endif
     51          #include "hal_mcu.h"
     52          #include "hal_uart.h"
     53          #include "osal.h"
     54          
     55          /*********************************************************************
     56           * MACROS
     57           */
     58          
     59          #if !defined ( HAL_UART_DEBUG )
     60            #define HAL_UART_DEBUG  FALSE
     61          #endif
     62          
     63          #if !defined ( HAL_UART_CLOSE )
     64            #define HAL_UART_CLOSE  FALSE
     65          #endif
     66          
     67          #if !defined ( HAL_UART_BIG_TX_BUF )
     68            #define HAL_UART_BIG_TX_BUF  FALSE
     69          #endif
     70          
     71          /*
     72           *  The MAC_ASSERT macro is for use during debugging.
     73           *  The given expression must evaluate as "true" or else fatal error occurs.
     74           *  At that point, the call stack feature of the debugger can pinpoint where
     75           *  the problem occurred.
     76           *
     77           *  To disable this feature and save code size, the project should define
     78           *  HAL_UART_DEBUG to FALSE.
     79           */
     80          #if ( HAL_UART_DEBUG )
     81            #define HAL_UART_ASSERT( expr)        HAL_ASSERT( expr )
     82          #else
     83            #define HAL_UART_ASSERT( expr )
     84          #endif
     85          
     86          #define P2DIR_PRIPO               0xC0
     87          #if HAL_UART_0_ENABLE
     88            #define HAL_UART_PRIPO          0x00
     89          #else
     90            #define HAL_UART_PRIPO          0x40
     91          #endif
     92          
     93          #define HAL_UART_0_PERCFG_BIT     0x01  // USART0 on P0, so clear this bit.
     94          #define HAL_UART_0_P0_RX_TX       0x0c  // Peripheral I/O Select for Rx/Tx.
     95          #define HAL_UART_0_P0_RTS         0x10  // Peripheral I/O Select for RTS.
     96          #define HAL_UART_0_P0_CTS         0x20  // Peripheral I/O Select for CTS.
     97          
     98          #define HAL_UART_1_PERCFG_BIT     0x02  // USART1 on P1, so set this bit.
     99          #define HAL_UART_1_P1_RTS         0x10  // Peripheral I/O Select for RTS.
    100          #define HAL_UART_1_P1_CTS         0x20  // Peripheral I/O Select for CTS.
    101          #define HAL_UART_1_P1_RX_TX       0xC0  // Peripheral I/O Select for Rx/Tx.
    102          
    103          #define TX_AVAIL( cfg ) \
    104            ((cfg->txTail == cfg->txHead) ? (cfg->txMax-1) : \
    105            ((cfg->txTail >  cfg->txHead) ? (cfg->txTail - cfg->txHead - 1) : \
    106                               (cfg->txMax - cfg->txHead + cfg->txTail)))
    107          
    108          #define RX0_FLOW_ON  ( P0 &= ~HAL_UART_0_P0_CTS )
    109          #define RX0_FLOW_OFF ( P0 |= HAL_UART_0_P0_CTS )
    110          #define RX1_FLOW_ON  ( P1 &= ~HAL_UART_1_P1_CTS)
    111          #define RX1_FLOW_OFF ( P1 |= HAL_UART_1_P1_CTS )
    112          
    113          #define RX_STOP_FLOW( cfg ) { \
    114            if ( !(cfg->flag & UART_CFG_U1F) ) \
    115            { \
    116              RX0_FLOW_OFF; \
    117            } \
    118            else \
    119            { \
    120              RX1_FLOW_OFF; \
    121            } \
    122            if ( cfg->flag & UART_CFG_DMA ) \
    123            { \
    124              cfg->rxTick = DMA_RX_DLY; \
    125            } \
    126            cfg->flag |= UART_CFG_RXF; \
    127          }
    128          
    129          #define RX_STRT_FLOW( cfg ) { \
    130            if ( !(cfg->flag & UART_CFG_U1F) ) \
    131            { \
    132              RX0_FLOW_ON; \
    133            } \
    134            else \
    135            { \
    136              RX1_FLOW_ON; \
    137            } \
    138            cfg->flag &= ~UART_CFG_RXF; \
    139          }
    140          
    141          #define UART_RX_AVAIL( cfg ) \
    142            ( (cfg->rxHead >= cfg->rxTail) ? (cfg->rxHead - cfg->rxTail) : \
    143                                             (cfg->rxMax - cfg->rxTail + cfg->rxHead +1 ) )
    144          
    145          /* Need to leave enough of the Rx buffer free to handle the incoming bytes
    146           * after asserting flow control, but before the transmitter has obeyed it.
    147           * At the max expected baud rate of 115.2k, 16 bytes will only take ~1.3 msecs,
    148           * but at the min expected baud rate of 38.4k, they could take ~4.2 msecs.
    149           * SAFE_RX_MIN and DMA_RX_DLY must both be consistent according to
    150           * the min & max expected baud rate.
    151           */
    152          #if !defined( SAFE_RX_MIN )
    153            #define SAFE_RX_MIN  48  // bytes - max expected per poll @ 115.2k
    154            // 16 bytes @ 38.4 kBaud -> 4.16 msecs -> 138 32-kHz ticks.
    155            #define DMA_RX_DLY  140
    156            //  2 bytes @ 38.4 kBaud -> 0.52 msecs ->  17 32-kHz ticks.
    157            #define DMA_TX_DLY   20
    158          #endif
    159          
    160          // The timeout tick is at 32-kHz, so multiply msecs by 33.
    161          #define RX_MSECS_TO_TICKS  33
    162          
    163          // The timeout only supports 1 byte.
    164          #if !defined( HAL_UART_RX_IDLE )
    165            #define HAL_UART_RX_IDLE  (6 * RX_MSECS_TO_TICKS)
    166          #endif
    167          
    168          // Only supporting 1 of the 2 USART modules to be driven by DMA at a time.
    169          #if HAL_UART_DMA == 1
    170            #define DMATRIG_RX  HAL_DMA_TRIG_URX0
    171            #define DMATRIG_TX  HAL_DMA_TRIG_UTX0
    172            #define DMA_UDBUF   HAL_DMA_U0DBUF
    173            #define DMA_PAD     U0BAUD
    174          #elif HAL_UART_DMA == 2
    175            #define DMATRIG_RX  HAL_DMA_TRIG_URX1
    176            #define DMATRIG_TX  HAL_DMA_TRIG_UTX1
    177            #define DMA_UDBUF   HAL_DMA_U1DBUF
    178            #define DMA_PAD     U1BAUD
    179          #endif
    180          
    181          #define DMA_RX( cfg ) { \
    182            volatile uint8 ft2430 = U0DBUF; \
    183            \
    184            halDMADesc_t *ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_RX ); \
    185            \
    186            HAL_DMA_SET_DEST( ch, cfg->rxBuf ); \
    187            \
    188            HAL_DMA_SET_LEN( ch, cfg->rxMax ); \
    189            \
    190            HAL_DMA_CLEAR_IRQ( HAL_DMA_CH_RX ); \
    191            \
    192            HAL_DMA_ARM_CH( HAL_DMA_CH_RX ); \
    193          }
    194          
    195          #define DMA_TX( cfg ) { \
    196            halDMADesc_t *ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_TX ); \
    197            \
    198            HAL_DMA_SET_SOURCE( ch, (cfg->txBuf + cfg->txTail) ); \
    199            \
    200            HAL_DMA_SET_LEN( ch, cfg->txCnt ); \
    201            \
    202            HAL_DMA_CLEAR_IRQ( HAL_DMA_CH_TX ); \
    203            \
    204            HAL_DMA_ARM_CH( HAL_DMA_CH_TX ); \
    205            \
    206            HAL_DMA_START_CH( HAL_DMA_CH_TX ); \
    207          }
    208          
    209          /*********************************************************************
    210           * TYPEDEFS
    211           */
    212          
    213          typedef struct
    214          {
    215            uint8 *rxBuf;
    216            uint8 rxHead;
    217            uint8 rxTail;
    218            uint8 rxMax;
    219            uint8 rxCnt;
    220            uint8 rxTick;
    221            uint8 rxHigh;
    222          
    223            uint8 *txBuf;
    224          #if HAL_UART_BIG_TX_BUF
    225            uint16 txHead;
    226            uint16 txTail;
    227            uint16 txMax;
    228            uint16 txCnt;
    229          #else
    230            uint8 txHead;
    231            uint8 txTail;
    232            uint8 txMax;
    233            uint8 txCnt;
    234          #endif
    235            uint8 txTick;
    236          
    237            uint8 flag;
    238          
    239            halUARTCBack_t rxCB;
    240          } uartCfg_t;
    241          
    242          /*********************************************************************
    243           * CONSTANTS
    244           */
    245          
    246          // Used by DMA macros to shift 1 to create a mask for DMA registers.
    247          #define HAL_DMA_CH_TX    3
    248          #define HAL_DMA_CH_RX    4
    249          
    250          #define HAL_DMA_U0DBUF  0xDFC1
    251          #define HAL_DMA_U1DBUF  0xDFF9
    252          
    253          // UxCSR - USART Control and Status Register.
    254          #define CSR_MODE      0x80
    255          #define CSR_RE        0x40
    256          #define CSR_SLAVE     0x20
    257          #define CSR_FE        0x10
    258          #define CSR_ERR       0x08
    259          #define CSR_RX_BYTE   0x04
    260          #define CSR_TX_BYTE   0x02
    261          #define CSR_ACTIVE    0x01
    262          
    263          // UxUCR - USART UART Control Register.
    264          #define UCR_FLUSH     0x80
    265          #define UCR_FLOW      0x40
    266          #define UCR_D9        0x20
    267          #define UCR_BIT9      0x10
    268          #define UCR_PARITY    0x08
    269          #define UCR_SPB       0x04
    270          #define UCR_STOP      0x02
    271          #define UCR_START     0x01
    272          
    273          #define UTX0IE        0x04
    274          #define UTX1IE        0x08
    275          
    276          #define UART_CFG_U1F  0x80  // USART1 flag bit.
    277          #define UART_CFG_DMA  0x40  // Port is using DMA.
    278          #define UART_CFG_FLW  0x20  // Port is using flow control.
    279          #define UART_CFG_SP4  0x10
    280          #define UART_CFG_SP3  0x08
    281          #define UART_CFG_SP2  0x04
    282          #define UART_CFG_RXF  0x02  // Rx flow is disabled.
    283          #define UART_CFG_TXF  0x01  // Tx is in process.
    284          
    285          /*********************************************************************
    286           * GLOBAL VARIABLES
    287           */
    288          
    289          /*********************************************************************
    290           * GLOBAL FUNCTIONS
    291           */
    292          
    293          /*********************************************************************
    294           * LOCAL VARIABLES
    295           */
    296          
    297          #if HAL_UART_0_ENABLE
    298          static uartCfg_t *cfg0;
    299          #endif
    300          #if HAL_UART_1_ENABLE
    301          static uartCfg_t *cfg1;
    302          #endif
    303          
    304          /*********************************************************************
    305           * LOCAL FUNCTIONS
    306           */
    307          
    308          #if HAL_UART_DMA
    309          static void pollDMA( uartCfg_t *cfg );
    310          #endif
    311          #if HAL_UART_ISR
    312          static void pollISR( uartCfg_t *cfg );
    313          #endif
    314          
    315          #if HAL_UART_DMA
    316          /******************************************************************************
    317           * @fn      pollDMA
    318           *
    319           * @brief   Poll a USART module implemented by DMA.
    320           *
    321           * @param   cfg - USART configuration structure.
    322           *
    323           * @return  none
    324           *****************************************************************************/
    325          static void pollDMA( uartCfg_t *cfg )
    326          {
    327            const uint8 cnt = cfg->rxHead;
    328            uint8 *pad = cfg->rxBuf+(cfg->rxHead*2);
    329          
    330            // Pack the received bytes to the front of the queue.
    331            while ( (*pad == DMA_PAD) && (cfg->rxHead < cfg->rxMax) )
    332            {
    333              cfg->rxBuf[cfg->rxHead++] = *(pad+1);
    334              pad += 2;
    335            }
    336          
    337            if ( !(cfg->flag & UART_CFG_RXF) )
    338            {
    339              /* It is necessary to stop Rx flow and wait for H/W-enqueued bytes still
    340               * incoming to stop before resetting the DMA Rx engine. If DMA Rx is
    341               * aborted during incoming data, a byte may be lost inside the engine
    342               * during the 2-step transfer process of read/write.
    343               */
    344              if ( cfg->rxHead >= (cfg->rxMax - SAFE_RX_MIN) )
    345              {
    346                RX_STOP_FLOW( cfg );
    347              }
    348              // If anything received, reset the Rx idle timer.
    349              else if ( cfg->rxHead != cnt )
    350              {
    351                cfg->rxTick = HAL_UART_RX_IDLE;
    352              }
    353            }
    354            else if ( !cfg->rxTick && (cfg->rxHead == cfg->rxTail) )
    355            {
    356              HAL_DMA_ABORT_CH( HAL_DMA_CH_RX );
    357              cfg->rxHead = cfg->rxTail = 0;
    358              osal_memset( cfg->rxBuf, ~DMA_PAD, cfg->rxMax*2 );
    359              DMA_RX( cfg );
    360              RX_STRT_FLOW( cfg );
    361            }
    362          
    363            if ( HAL_DMA_CHECK_IRQ( HAL_DMA_CH_TX ) )
    364            {
    365              HAL_DMA_CLEAR_IRQ( HAL_DMA_CH_TX );
    366              cfg->flag &= ~UART_CFG_TXF;
    367              cfg->txTick = DMA_TX_DLY;
    368          
    369              if ( (cfg->txMax - cfg->txCnt) < cfg->txTail )
    370              {
    371                cfg->txTail = 0;  // DMA can only run to the end of the Tx buffer.
    372              }
    373              else
    374              {
    375                cfg->txTail += cfg->txCnt;
    376              }
    377            }
    378            else if ( !(cfg->flag & UART_CFG_TXF) && !cfg->txTick )
    379            {
    380              if ( cfg->txTail != cfg->txHead )
    381              {
    382                if ( cfg->txTail < cfg->txHead )
    383                {
    384                  cfg->txCnt = cfg->txHead - cfg->txTail;
    385                }
    386                else  // Can only run DMA engine up to max, then restart at zero.
    387                {
    388                  cfg->txCnt = cfg->txMax - cfg->txTail + 1;
    389                }
    390          
    391                cfg->flag |= UART_CFG_TXF;
    392                DMA_TX( cfg );
    393              }
    394            }
    395          }
    396          #endif
    397          
    398          #if HAL_UART_ISR
    399          /******************************************************************************
    400           * @fn      pollISR
    401           *
    402           * @brief   Poll a USART module implemented by ISR.
    403           *
    404           * @param   cfg - USART configuration structure.
    405           *
    406           * @return  none
    407           *****************************************************************************/
    408          static void pollISR( uartCfg_t *cfg )
    409          {
    410            uint8 cnt = UART_RX_AVAIL( cfg );
    411          
    412            if ( !(cfg->flag & UART_CFG_RXF) )
    413            {
    414              // If anything received, reset the Rx idle timer.
    415              if ( cfg->rxCnt != cnt )
    416              {
    417                cfg->rxTick = HAL_UART_RX_IDLE;
    418                cfg->rxCnt = cnt;
    419              }
    420          
    421              /* It is necessary to stop Rx flow in advance of a full Rx buffer because
    422               * bytes can keep coming while sending H/W fifo flushes.
    423               */
    424              if ( cfg->rxCnt >= (cfg->rxMax - SAFE_RX_MIN) )
    425              {
    426                RX_STOP_FLOW( cfg );
    427              }
    428            }
    429          }
    430          #endif
    431          
    432          /******************************************************************************
    433           * @fn      HalUARTInit
    434           *
    435           * @brief   Initialize the UART
    436           *
    437           * @param   none
    438           *
    439           * @return  none
    440           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    441          void HalUARTInit( void )
   \                     HalUARTInit:
    442          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    443          #if HAL_UART_DMA
    444            halDMADesc_t *ch;
    445          #endif
    446          
    447            // Set P2 priority - USART0 over USART1 if both are defined.
    448            P2DIR &= ~P2DIR_PRIPO;
   \   000000   53FF3F       ANL     0xff,#0x3f
   \   000003   E5FF         MOV     A,0xff
    449            P2DIR |= HAL_UART_PRIPO;
   \   000005   43FF40       ORL     0xff,#0x40
    450          
    451          #if HAL_UART_0_ENABLE
    452            // Set UART0 I/O location to P0.
    453            PERCFG &= ~HAL_UART_0_PERCFG_BIT;
    454          
    455            /* Enable Tx and Rx on P0 */
    456            P0SEL |= HAL_UART_0_P0_RX_TX;
    457          
    458            /* Make sure ADC doesnt use this */
    459            ADCCFG &= ~HAL_UART_0_P0_RX_TX;
    460          
    461            /* Mode is UART Mode */
    462            U0CSR = CSR_MODE;
    463          
    464            /* Flush it */
    465            U0UCR = UCR_FLUSH;
    466          #endif
    467          
    468          #if HAL_UART_1_ENABLE
    469            // Set UART1 I/O location to P1.
    470            PERCFG |= HAL_UART_1_PERCFG_BIT;
    471          
    472            /* Enable Tx and Rx on P1 */
    473            P1SEL  |= HAL_UART_1_P1_RX_TX;
    474          
    475            /* Make sure ADC doesnt use this */
    476            ADCCFG &= ~HAL_UART_1_P1_RX_TX;
    477          
    478            /* Mode is UART Mode */
    479            U1CSR = CSR_MODE;
    480          
    481            /* Flush it */
    482            U1UCR = UCR_FLUSH;
    483          #endif
    484          
    485          #if HAL_UART_DMA
    486            // Setup Tx by DMA.
    487            ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_TX );
    488          
    489            // The start address of the destination.
    490            HAL_DMA_SET_DEST( ch, DMA_UDBUF );
    491          
    492            // Using the length field to determine how many bytes to transfer.
    493            HAL_DMA_SET_VLEN( ch, HAL_DMA_VLEN_USE_LEN );
    494          
    495            // One byte is transferred each time.
    496            HAL_DMA_SET_WORD_SIZE( ch, HAL_DMA_WORDSIZE_BYTE );
    497          
    498            // The bytes are transferred 1-by-1 on Tx Complete trigger.
    499            HAL_DMA_SET_TRIG_MODE( ch, HAL_DMA_TMODE_SINGLE );
    500            HAL_DMA_SET_TRIG_SRC( ch, DMATRIG_TX );
    501          
    502            // The source address is decremented by 1 byte after each transfer.
    503            HAL_DMA_SET_SRC_INC( ch, HAL_DMA_SRCINC_1 );
    504          
    505            // The destination address is constant - the Tx Data Buffer.
    506            HAL_DMA_SET_DST_INC( ch, HAL_DMA_DSTINC_0 );
    507          
    508            // The DMA is to be polled and shall not issue an IRQ upon completion.
    509            HAL_DMA_SET_IRQ( ch, HAL_DMA_IRQMASK_DISABLE );
    510          
    511            // Xfer all 8 bits of a byte xfer.
    512            HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS );
    513          
    514            // DMA Tx has shared priority for memory access - every other one.
    515            HAL_DMA_SET_PRIORITY( ch, HAL_DMA_PRI_HIGH );
    516          
    517            // Setup Rx by DMA.
    518            ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_RX );
    519          
    520            // The start address of the source.
    521            HAL_DMA_SET_SOURCE( ch, DMA_UDBUF );
    522          
    523            // Using the length field to determine how many bytes to transfer.
    524            HAL_DMA_SET_VLEN( ch, HAL_DMA_VLEN_USE_LEN );
    525          
    526            /* The trick is to cfg DMA to xfer 2 bytes for every 1 byte of Rx.
    527             * The byte after the Rx Data Buffer is the Baud Cfg Register,
    528             * which always has a known value. So init Rx buffer to inverse of that
    529             * known value. DMA word xfer will flip the bytes, so every valid Rx byte
    530             * in the Rx buffer will be preceded by a DMA_PAD char equal to the
    531             * Baud Cfg Register value.
    532             */
    533            HAL_DMA_SET_WORD_SIZE( ch, HAL_DMA_WORDSIZE_WORD );
    534          
    535            // The bytes are transferred 1-by-1 on Rx Complete trigger.
    536            HAL_DMA_SET_TRIG_MODE( ch, HAL_DMA_TMODE_SINGLE );
    537            HAL_DMA_SET_TRIG_SRC( ch, DMATRIG_RX );
    538          
    539            // The source address is constant - the Rx Data Buffer.
    540            HAL_DMA_SET_SRC_INC( ch, HAL_DMA_SRCINC_0 );
    541          
    542            // The destination address is incremented by 1 word after each transfer.
    543            HAL_DMA_SET_DST_INC( ch, HAL_DMA_DSTINC_1 );
    544          
    545            // The DMA is to be polled and shall not issue an IRQ upon completion.
    546            HAL_DMA_SET_IRQ( ch, HAL_DMA_IRQMASK_DISABLE );
    547          
    548            // Xfer all 8 bits of a byte xfer.
    549            HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS );
    550          
    551            // DMA has highest priority for memory access.
    552            HAL_DMA_SET_PRIORITY( ch, HAL_DMA_PRI_HIGH );
    553          #endif
    554          }
   \   000008   02....       LJMP    ?BRET
   \   00000B                REQUIRE P2DIR
    555          
    556          /******************************************************************************
    557           * @fn      HalUARTOpen
    558           *
    559           * @brief   Open a port according tp the configuration specified by parameter.
    560           *
    561           * @param   port   - UART port
    562           *          config - contains configuration information
    563           *
    564           * @return  Status of the function call
    565           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    566          uint8 HalUARTOpen( uint8 port, halUARTCfg_t *config )
   \                     HalUARTOpen:
    567          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
    568            uartCfg_t **cfgPP = NULL;
   \   000009   75..00       MOV     ?V0 + 2,#0x0
   \   00000C   75..00       MOV     ?V0 + 3,#0x0
    569            uartCfg_t *cfg;
    570          
    571          #if HAL_UART_0_ENABLE
    572            if ( port == HAL_UART_PORT_0 )
    573            {
    574              cfgPP = &cfg0;
    575            }
    576          #endif
    577          
    578          #if HAL_UART_1_ENABLE
    579            if ( port == HAL_UART_PORT_1 )
    580            {
    581              cfgPP = &cfg1;
    582            }
    583          #endif
    584          
    585            HAL_UART_ASSERT( cfgPP );
    586          
    587          #if HAL_UART_CLOSE
    588            // Protect against user re-opening port before closing it.
    589            HalUARTClose( port );
    590          #else
    591            HAL_UART_ASSERT( *cfgPP == NULL );
    592          #endif
    593          
    594            HAL_UART_ASSERT( (config->baudRate == HAL_UART_BR_38400) ||
    595                             (config->baudRate == HAL_UART_BR_115200) );
    596          
    597            /* Whereas runtime heap alloc can be expected to fail - one-shot system
    598             * initialization must succeed, so no check for alloc fail.
    599             */
    600            *cfgPP = (uartCfg_t *)osal_mem_alloc( sizeof( uartCfg_t ) );
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   7A12         MOV     R2,#0x12
   \   000011   7B00         MOV     R3,#0x0
   \   000013   12....       LCALL   ??osal_mem_alloc?relay
   \   000016   85..82       MOV     DPL,?V0 + 2
   \   000019   85..83       MOV     DPH,?V0 + 3
   \   00001C   EA           MOV     A,R2
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   EB           MOV     A,R3
   \   000020   F0           MOVX    @DPTR,A
    601            cfg = *cfgPP;
   \   000021   85..82       MOV     DPL,?V0 + 2
   \   000024   85..83       MOV     DPH,?V0 + 3
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F8           MOV     R0,A
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F9           MOV     R1,A
   \   00002C   E8           MOV     A,R0
   \   00002D   FE           MOV     R6,A
   \   00002E   E9           MOV     A,R1
   \   00002F   FF           MOV     R7,A
    602            HAL_UART_ASSERT( cfg );
    603          
    604            cfg->rxMax = config->rx.maxBufSize;
   \   000030   85..82       MOV     DPL,?V0 + 0
   \   000033   85..83       MOV     DPH,?V0 + 1
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   8E82         MOV     DPL,R6
   \   000043   8F83         MOV     DPH,R7
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   F0           MOVX    @DPTR,A
    605          
    606          #if !HAL_UART_BIG_TX_BUF
    607            HAL_UART_ASSERT( (config->tx.maxBufSize < 256) );
    608          #endif
    609            cfg->txMax = config->tx.maxBufSize;
   \   00004A   E5..         MOV     A,?V0 + 0
   \   00004C   2412         ADD     A,#0x12
   \   00004E   F582         MOV     DPL,A
   \   000050   E5..         MOV     A,?V0 + 1
   \   000052   3400         ADDC    A,#0x0
   \   000054   F583         MOV     DPH,A
   \   000056   E0           MOVX    A,@DPTR
   \   000057   C0E0         PUSH    A
   \   000059   EE           MOV     A,R6
   \   00005A   240C         ADD     A,#0xc
   \   00005C   F582         MOV     DPL,A
   \   00005E   EF           MOV     A,R7
   \   00005F   3400         ADDC    A,#0x0
   \   000061   F583         MOV     DPH,A
   \   000063   D0E0         POP     A
   \   000065   F0           MOVX    @DPTR,A
    610            cfg->txBuf = osal_mem_alloc( cfg->txMax+1 );
   \   000066                ; Setup parameters for call to function osal_mem_alloc
   \   000066   EE           MOV     A,R6
   \   000067   240C         ADD     A,#0xc
   \   000069   F582         MOV     DPL,A
   \   00006B   EF           MOV     A,R7
   \   00006C   3400         ADDC    A,#0x0
   \   00006E   F583         MOV     DPH,A
   \   000070   E0           MOVX    A,@DPTR
   \   000071   F8           MOV     R0,A
   \   000072   7900         MOV     R1,#0x0
   \   000074   7401         MOV     A,#0x1
   \   000076   28           ADD     A,R0
   \   000077   FA           MOV     R2,A
   \   000078   7400         MOV     A,#0x0
   \   00007A   39           ADDC    A,R1
   \   00007B   FB           MOV     R3,A
   \   00007C   12....       LCALL   ??osal_mem_alloc?relay
   \   00007F   8E82         MOV     DPL,R6
   \   000081   8F83         MOV     DPH,R7
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   EA           MOV     A,R2
   \   00008C   F0           MOVX    @DPTR,A
   \   00008D   A3           INC     DPTR
   \   00008E   EB           MOV     A,R3
   \   00008F   F0           MOVX    @DPTR,A
    611          
    612            cfg->rxHead = cfg->rxTail = 0;
   \   000090   7A00         MOV     R2,#0x0
   \   000092   EA           MOV     A,R2
   \   000093   8E82         MOV     DPL,R6
   \   000095   8F83         MOV     DPH,R7
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   F0           MOVX    @DPTR,A
   \   00009B   EA           MOV     A,R2
   \   00009C   8E82         MOV     DPL,R6
   \   00009E   8F83         MOV     DPH,R7
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   F0           MOVX    @DPTR,A
    613            cfg->txHead = cfg->txTail = 0;
   \   0000A3   7A00         MOV     R2,#0x0
   \   0000A5   EA           MOV     A,R2
   \   0000A6   C0E0         PUSH    A
   \   0000A8   EE           MOV     A,R6
   \   0000A9   240B         ADD     A,#0xb
   \   0000AB   F582         MOV     DPL,A
   \   0000AD   EF           MOV     A,R7
   \   0000AE   3400         ADDC    A,#0x0
   \   0000B0   F583         MOV     DPH,A
   \   0000B2   D0E0         POP     A
   \   0000B4   F0           MOVX    @DPTR,A
   \   0000B5   EA           MOV     A,R2
   \   0000B6   8E82         MOV     DPL,R6
   \   0000B8   8F83         MOV     DPH,R7
   \   0000BA   A3           INC     DPTR
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   A3           INC     DPTR
   \   0000BF   A3           INC     DPTR
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   F0           MOVX    @DPTR,A
    614            cfg->rxHigh = config->rx.maxBufSize - config->flowControlThreshold;
   \   0000C5   85..82       MOV     DPL,?V0 + 0
   \   0000C8   85..83       MOV     DPH,?V0 + 1
   \   0000CB   A3           INC     DPTR
   \   0000CC   A3           INC     DPTR
   \   0000CD   A3           INC     DPTR
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   F8           MOV     R0,A
   \   0000D0   85..82       MOV     DPL,?V0 + 0
   \   0000D3   85..83       MOV     DPH,?V0 + 1
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   A3           INC     DPTR
   \   0000DD   A3           INC     DPTR
   \   0000DE   A3           INC     DPTR
   \   0000DF   A3           INC     DPTR
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   C3           CLR     C
   \   0000E2   98           SUBB    A,R0
   \   0000E3   8E82         MOV     DPL,R6
   \   0000E5   8F83         MOV     DPH,R7
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   A3           INC     DPTR
   \   0000EB   A3           INC     DPTR
   \   0000EC   A3           INC     DPTR
   \   0000ED   A3           INC     DPTR
   \   0000EE   F0           MOVX    @DPTR,A
    615            cfg->rxCB = config->callBackFunc;
   \   0000EF   E5..         MOV     A,?V0 + 0
   \   0000F1   241B         ADD     A,#0x1b
   \   0000F3   F582         MOV     DPL,A
   \   0000F5   E5..         MOV     A,?V0 + 1
   \   0000F7   3400         ADDC    A,#0x0
   \   0000F9   F583         MOV     DPH,A
   \   0000FB   E0           MOVX    A,@DPTR
   \   0000FC   F8           MOV     R0,A
   \   0000FD   A3           INC     DPTR
   \   0000FE   E0           MOVX    A,@DPTR
   \   0000FF   F9           MOV     R1,A
   \   000100   EE           MOV     A,R6
   \   000101   2410         ADD     A,#0x10
   \   000103   F582         MOV     DPL,A
   \   000105   EF           MOV     A,R7
   \   000106   3400         ADDC    A,#0x0
   \   000108   F583         MOV     DPH,A
   \   00010A   E8           MOV     A,R0
   \   00010B   F0           MOVX    @DPTR,A
   \   00010C   A3           INC     DPTR
   \   00010D   E9           MOV     A,R1
   \   00010E   F0           MOVX    @DPTR,A
    616          
    617          #if HAL_UART_0_ENABLE
    618            if ( port == HAL_UART_PORT_0 )
    619            {
    620              // Only supporting 38400 or 115200 for code size - other is possible.
    621              U0BAUD = (config->baudRate == HAL_UART_BR_38400) ? 59 : 216;
    622              U0GCR = (config->baudRate == HAL_UART_BR_38400) ? 10 : 11;
    623          
    624              U0CSR |= CSR_RE;
    625          
    626          #if HAL_UART_DMA == 1
    627              cfg->flag = UART_CFG_DMA;
    628              HAL_UART_ASSERT( (config->rx.maxBufSize <= 128) );
    629              HAL_UART_ASSERT( (config->rx.maxBufSize > SAFE_RX_MIN) );
    630              cfg->rxBuf = osal_mem_alloc( cfg->rxMax*2 );
    631              osal_memset( cfg->rxBuf, ~DMA_PAD, cfg->rxMax*2 );
    632              DMA_RX( cfg );
    633          #else
    634              cfg->flag = 0;
    635              HAL_UART_ASSERT( (config->rx.maxBufSize < 256) );
    636              cfg->rxBuf = osal_mem_alloc( cfg->rxMax+1 );
    637              URX0IE = 1;
    638              IEN2 |= UTX0IE;
    639          #endif
    640          
    641              // 8 bits/char; no parity; 1 stop bit; stop bit hi.
    642              if ( config->flowControl )
    643              {
    644                cfg->flag |= UART_CFG_FLW;
    645                U0UCR = UCR_FLOW | UCR_STOP;
    646                // Must rely on H/W for RTS (i.e. Tx stops when receiver negates CTS.)
    647                P0SEL |= HAL_UART_0_P0_RTS;
    648                // Cannot use H/W for CTS as DMA does not clear the Rx bytes properly.
    649                P0DIR |= HAL_UART_0_P0_CTS;
    650                RX0_FLOW_ON;
    651              }
    652              else
    653              {
    654                U0UCR = UCR_STOP;
    655              }
    656              }
    657          #endif
    658          
    659          #if HAL_UART_1_ENABLE
    660            if ( port == HAL_UART_PORT_1 )
    661            {
    662              // Only supporting 38400 or 115200 for code size - other is possible.
    663              U1BAUD = (config->baudRate == HAL_UART_BR_38400) ? 59 : 216;
    664              U1GCR = (config->baudRate == HAL_UART_BR_38400) ? 10 : 11;
    665          
    666              U1CSR |= CSR_RE;
    667          
    668          #if HAL_UART_DMA == 2
    669              cfg->flag = (UART_CFG_U1F | UART_CFG_DMA);
    670              HAL_UART_ASSERT( (config->rx.maxBufSize <= 128) );
    671              HAL_UART_ASSERT( (config->rx.maxBufSize > SAFE_RX_MIN) );
    672              cfg->rxBuf = osal_mem_alloc( cfg->rxMax*2 );
    673              osal_memset( cfg->rxBuf, ~DMA_PAD, cfg->rxMax*2 );
    674              DMA_RX( cfg );
    675          #else
    676              cfg->flag = UART_CFG_U1F;
    677              HAL_UART_ASSERT( (config->rx.maxBufSize < 256) );
    678              cfg->rxBuf = osal_mem_alloc( cfg->rxMax+1 );
    679              URX1IE = 1;
    680              IEN2 |= UTX1IE;
    681          #endif
    682          
    683              // 8 bits/char; no parity; 1 stop bit; stop bit hi.
    684              if ( config->flowControl )
    685              {
    686                cfg->flag |= UART_CFG_FLW;
    687                U1UCR = UCR_FLOW | UCR_STOP;
    688                // Must rely on H/W for RTS (i.e. Tx stops when receiver negates CTS.)
    689                P1SEL |= HAL_UART_1_P1_RTS;
    690                // Cannot use H/W for CTS as DMA does not clear the Rx bytes properly.
    691                P1DIR |= HAL_UART_1_P1_CTS;
    692                RX1_FLOW_ON;
    693              }
    694              else
    695              {
    696                U1UCR = UCR_STOP;
    697              }
    698            }
    699          #endif
    700          
    701            return HAL_UART_SUCCESS;
   \   00010F   7900         MOV     R1,#0x0
   \   000111   7F05         MOV     R7,#0x5
   \   000113   02....       LJMP    ?BANKED_LEAVE_XDATA
    702          }
    703          
    704          /******************************************************************************
    705           * @fn      HalUARTClose
    706           *
    707           * @brief   Close the UART
    708           *
    709           * @param   port - UART port
    710           *
    711           * @return  none
    712           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    713          void HalUARTClose( uint8 port )
   \                     HalUARTClose:
    714          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    715          #if HAL_UART_CLOSE
    716            uartCfg_t *cfg;
    717          
    718          #if HAL_UART_0_ENABLE
    719            if ( port == HAL_UART_PORT_0 )
    720            {
    721              U0CSR &= ~CSR_RE;
    722          #if HAL_UART_DMA == 1
    723              HAL_DMA_ABORT_CH( HAL_DMA_CH_RX );
    724              HAL_DMA_ABORT_CH( HAL_DMA_CH_TX );
    725          #else
    726              URX0IE = 0;
    727          #endif
    728              cfg = cfg0;
    729              cfg0 = NULL;
    730            }
    731          #endif
    732          #if HAL_UART_1_ENABLE
    733            if ( port == HAL_UART_PORT_1 )
    734            {
    735              U1CSR &= ~CSR_RE;
    736          #if HAL_UART_DMA == 2
    737              HAL_DMA_ABORT_CH( HAL_DMA_CH_RX );
    738              HAL_DMA_ABORT_CH( HAL_DMA_CH_TX );
    739          #else
    740              URX1IE = 0;
    741          #endif
    742              cfg = cfg1;
    743              cfg1 = NULL;
    744            }
    745          #endif
    746          
    747            if ( cfg )
    748            {
    749              if ( cfg->rxBuf )
    750              {
    751                osal_mem_free( cfg->rxBuf );
    752              }
    753              if ( cfg->txBuf )
    754              {
    755                osal_mem_free( cfg->txBuf );
    756              }
    757              osal_mem_free( cfg );
    758            }
    759          #endif
    760          }
   \   000000   02....       LJMP    ?BRET
    761          
    762          /******************************************************************************
    763           * @fn      HalUARTPoll
    764           *
    765           * @brief   Poll the UART.
    766           *
    767           * @param   none
    768           *
    769           * @return  none
    770           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    771          void HalUARTPoll( void )
   \                     HalUARTPoll:
    772          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    773          #if ( HAL_UART_0_ENABLE | HAL_UART_1_ENABLE )
    774            static uint8 tickShdw;
    775            uartCfg_t *cfg;
    776            uint8 tick;
    777          
    778          #if HAL_UART_0_ENABLE
    779            if ( cfg0 )
    780            {
    781              cfg = cfg0;
    782            }
    783          #endif
    784          #if HAL_UART_1_ENABLE
    785            if ( cfg1 )
    786            {
    787              cfg = cfg1;
    788            }
    789          #endif
    790          
    791            // Use the LSB of the sleep timer (ST0 must be read first anyway).
    792            tick = ST0 - tickShdw;
    793            tickShdw = ST0;
    794          
    795            do
    796            {
    797              if ( cfg->txTick > tick )
    798              {
    799                cfg->txTick -= tick;
    800              }
    801              else
    802              {
    803                cfg->txTick = 0;
    804              }
    805          
    806              if ( cfg->rxTick > tick )
    807              {
    808                cfg->rxTick -= tick;
    809              }
    810              else
    811              {
    812                cfg->rxTick = 0;
    813              }
    814          
    815          #if HAL_UART_ISR
    816          #if HAL_UART_DMA
    817              if ( cfg->flag & UART_CFG_DMA )
    818              {
    819                pollDMA( cfg );
    820              }
    821              else
    822          #endif
    823                {
    824                pollISR( cfg );
    825                }
    826          #elif HAL_UART_DMA
    827              pollDMA( cfg );
    828          #endif
    829          
    830              /* The following logic makes continuous callbacks on any eligible flag
    831               * until the condition corresponding to the flag is rectified.
    832               * So even if new data is not received, continuous callbacks are made.
    833               */
    834                if ( cfg->rxHead != cfg->rxTail )
    835                {
    836                uint8 evt;
    837          
    838                if ( cfg->rxHead >= (cfg->rxMax - SAFE_RX_MIN) )
    839                {
    840                  evt = HAL_UART_RX_FULL;
    841                }
    842                else if ( cfg->rxHigh && (cfg->rxHead >= cfg->rxHigh) )
    843                {
    844                  evt = HAL_UART_RX_ABOUT_FULL;
    845              }
    846                else if ( cfg->rxTick == 0 )
    847              {
    848                  evt = HAL_UART_RX_TIMEOUT;
    849              }
    850              else
    851              {
    852                  evt = 0;
    853              }
    854          
    855              if ( evt && cfg->rxCB )
    856              {
    857                  cfg->rxCB( ((cfg->flag & UART_CFG_U1F)!=0), evt );
    858              }
    859              }
    860          
    861          #if HAL_UART_0_ENABLE
    862              if ( cfg == cfg0 )
    863              {
    864          #if HAL_UART_1_ENABLE
    865                if ( cfg1 )
    866                {
    867                  cfg = cfg1;
    868                }
    869                else
    870          #endif
    871                  break;
    872              }
    873              else
    874          #endif
    875                break;
    876          
    877            } while ( TRUE );
    878          #else
    879            return;
   \   000000   02....       LJMP    ?BRET
    880          #endif
    881          }
    882          
    883          /**************************************************************************************************
    884           * @fn      Hal_UART_RxBufLen()
    885           *
    886           * @brief   Calculate Rx Buffer length - the number of bytes in the buffer.
    887           *
    888           * @param   port - UART port
    889           *
    890           * @return  length of current Rx Buffer
    891           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    892          uint16 Hal_UART_RxBufLen( uint8 port )
   \                     Hal_UART_RxBufLen:
    893          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    894            uartCfg_t *cfg = NULL;
   \   000004   7C00         MOV     R4,#0x0
   \   000006   7D00         MOV     R5,#0x0
    895          
    896          #if HAL_UART_0_ENABLE
    897            if ( port == HAL_UART_PORT_0 )
    898            {
    899              cfg = cfg0;
    900            }
    901          #endif
    902          #if HAL_UART_1_ENABLE
    903            if ( port == HAL_UART_PORT_1 )
    904            {
    905              cfg = cfg1;
    906            }
    907          #endif
    908          
    909            HAL_UART_ASSERT( cfg );
    910          
    911            return UART_RX_AVAIL( cfg );
   \   000008   8C82         MOV     DPL,R4
   \   00000A   8D83         MOV     DPH,R5
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   C0E0         PUSH    A
   \   000011   8C82         MOV     DPL,R4
   \   000013   8D83         MOV     DPH,R5
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FA           MOV     R2,A
   \   00001A   D0E0         POP     A
   \   00001C   C3           CLR     C
   \   00001D   9A           SUBB    A,R2
   \   00001E   401E         JC      ??Hal_UART_RxBufLen_0
   \   000020   8C82         MOV     DPL,R4
   \   000022   8D83         MOV     DPH,R5
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F8           MOV     R0,A
   \   000028   7900         MOV     R1,#0x0
   \   00002A   8C82         MOV     DPL,R4
   \   00002C   8D83         MOV     DPH,R5
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   FA           MOV     R2,A
   \   000033   7B00         MOV     R3,#0x0
   \   000035   E8           MOV     A,R0
   \   000036   C3           CLR     C
   \   000037   9A           SUBB    A,R2
   \   000038   FA           MOV     R2,A
   \   000039   E9           MOV     A,R1
   \   00003A   9B           SUBB    A,R3
   \   00003B   FB           MOV     R3,A
   \   00003C   8034         SJMP    ??Hal_UART_RxBufLen_1
   \                     ??Hal_UART_RxBufLen_0:
   \   00003E   8C82         MOV     DPL,R4
   \   000040   8D83         MOV     DPH,R5
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F8           MOV     R0,A
   \   000048   7900         MOV     R1,#0x0
   \   00004A   8C82         MOV     DPL,R4
   \   00004C   8D83         MOV     DPH,R5
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   FA           MOV     R2,A
   \   000053   7B00         MOV     R3,#0x0
   \   000055   E8           MOV     A,R0
   \   000056   C3           CLR     C
   \   000057   9A           SUBB    A,R2
   \   000058   F8           MOV     R0,A
   \   000059   E9           MOV     A,R1
   \   00005A   9B           SUBB    A,R3
   \   00005B   F9           MOV     R1,A
   \   00005C   8C82         MOV     DPL,R4
   \   00005E   8D83         MOV     DPH,R5
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \   000063   7B00         MOV     R3,#0x0
   \   000065   28           ADD     A,R0
   \   000066   F8           MOV     R0,A
   \   000067   EB           MOV     A,R3
   \   000068   39           ADDC    A,R1
   \   000069   F9           MOV     R1,A
   \   00006A   7401         MOV     A,#0x1
   \   00006C   28           ADD     A,R0
   \   00006D   FA           MOV     R2,A
   \   00006E   7400         MOV     A,#0x0
   \   000070   39           ADDC    A,R1
   \   000071   FB           MOV     R3,A
   \                     ??Hal_UART_RxBufLen_1:
   \   000072   D083         POP     DPH
   \   000074   D082         POP     DPL
   \   000076   02....       LJMP    ?BRET
    912          }
    913          
    914          /*****************************************************************************
    915           * @fn      HalUARTRead
    916           *
    917           * @brief   Read a buffer from the UART
    918           *
    919           * @param   port - USART module designation
    920           *          buf  - valid data buffer at least 'len' bytes in size
    921           *          len  - max length number of bytes to copy to 'buf'
    922           *
    923           * @return  length of buffer that was read
    924           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    925          uint16 HalUARTRead( uint8 port, uint8 *buf, uint16 len )
   \                     HalUARTRead:
    926          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
    927            uartCfg_t *cfg = NULL;
   \   000009   75..00       MOV     ?V0 + 2,#0x0
   \   00000C   75..00       MOV     ?V0 + 3,#0x0
    928            uint8 cnt = 0;
   \   00000F   75..00       MOV     ?V0 + 4,#0x0
    929          
    930          #if HAL_UART_0_ENABLE
    931            if ( port == HAL_UART_PORT_0 )
    932            {
    933              cfg = cfg0;
    934            }
    935          #endif
    936          #if HAL_UART_1_ENABLE
    937            if ( port == HAL_UART_PORT_1 )
    938            {
    939              cfg = cfg1;
    940            }
    941          #endif
    942          
    943            HAL_UART_ASSERT( cfg );
    944          
    945            while ( (cfg->rxTail != cfg->rxHead) && (cnt < len) )
   \                     ??HalUARTRead_0:
   \   000012   85..82       MOV     DPL,?V0 + 2
   \   000015   85..83       MOV     DPH,?V0 + 3
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   FA           MOV     R2,A
   \   00001D   85..82       MOV     DPL,?V0 + 2
   \   000020   85..83       MOV     DPH,?V0 + 3
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   6A           XRL     A,R2
   \   000027   6074         JZ      ??HalUARTRead_1
   \   000029   85....       MOV     ?V0 + 0,?V0 + 4
   \   00002C   75..00       MOV     ?V0 + 1,#0x0
   \   00002F   C3           CLR     C
   \   000030   E5..         MOV     A,?V0 + 0
   \   000032   9C           SUBB    A,R4
   \   000033   E5..         MOV     A,?V0 + 1
   \   000035   9D           SUBB    A,R5
   \   000036   5065         JNC     ??HalUARTRead_1
    946            {
    947              *buf++ = cfg->rxBuf[cfg->rxTail];
   \   000038   85..82       MOV     DPL,?V0 + 2
   \   00003B   85..83       MOV     DPH,?V0 + 3
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   FA           MOV     R2,A
   \   000043   7B00         MOV     R3,#0x0
   \   000045   85..82       MOV     DPL,?V0 + 2
   \   000048   85..83       MOV     DPH,?V0 + 3
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   2A           ADD     A,R2
   \   00004D   FF           MOV     R7,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   3B           ADDC    A,R3
   \   000051   8F82         MOV     DPL,R7
   \   000053   F583         MOV     DPH,A
   \   000055   E0           MOVX    A,@DPTR
   \   000056   8882         MOV     DPL,R0
   \   000058   8983         MOV     DPH,R1
   \   00005A   F0           MOVX    @DPTR,A
   \   00005B   8882         MOV     DPL,R0
   \   00005D   8983         MOV     DPH,R1
   \   00005F   A3           INC     DPTR
   \   000060   A882         MOV     R0,DPL
   \   000062   A983         MOV     R1,DPH
    948              if ( cfg->rxTail == cfg->rxMax )
   \   000064   85..82       MOV     DPL,?V0 + 2
   \   000067   85..83       MOV     DPH,?V0 + 3
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   FA           MOV     R2,A
   \   00006F   85..82       MOV     DPL,?V0 + 2
   \   000072   85..83       MOV     DPH,?V0 + 3
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   6A           XRL     A,R2
   \   00007B   700E         JNZ     ??HalUARTRead_2
    949              {
    950                cfg->rxTail = 0;
   \   00007D   7400         MOV     A,#0x0
   \   00007F   85..82       MOV     DPL,?V0 + 2
   \   000082   85..83       MOV     DPH,?V0 + 3
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   F0           MOVX    @DPTR,A
   \   000089   800D         SJMP    ??HalUARTRead_3
    951              }
    952              else
    953              {
    954                cfg->rxTail++;
   \                     ??HalUARTRead_2:
   \   00008B   85..82       MOV     DPL,?V0 + 2
   \   00008E   85..83       MOV     DPH,?V0 + 3
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   E0           MOVX    A,@DPTR
   \   000095   2401         ADD     A,#0x1
   \   000097   F0           MOVX    @DPTR,A
    955              }
    956              cnt++;
   \                     ??HalUARTRead_3:
   \   000098   05..         INC     ?V0 + 4
   \   00009A   02....       LJMP    ??HalUARTRead_0 & 0xFFFF
    957            }
    958          
    959          #if HAL_UART_DMA
    960            #if HAL_UART_ISR
    961            if ( cfg->flag & UART_CFG_DMA )
    962            #endif
    963            {
    964              /* If there is no flow control on a DMA-driven UART, the Rx Head & Tail
    965               * pointers must be reset to zero after every read in order to preserve the
    966               * full length of the Rx buffer. This implies that every Read must read all
    967               * of the Rx bytes available, or the pointers will not be reset and the
    968               * next incoming packet may not fit in the Rx buffer space remaining - thus
    969               * the end portion of the incoming packet that does not fit would be lost.
    970               */
    971              if ( !(cfg->flag & UART_CFG_FLW) )
    972              {
    973                // This is a trick to trigger the DMA abort and restart logic in pollDMA.
    974                cfg->flag |= UART_CFG_RXF;
    975              }
    976            }
    977          #endif
    978          
    979          #if HAL_UART_ISR
    980            #if HAL_UART_DMA
    981            if ( !(cfg->flag & UART_CFG_DMA) )
    982            #endif
    983            {
    984              cfg->rxCnt = UART_RX_AVAIL( cfg );
    985          
    986              if ( cfg->flag & UART_CFG_RXF )
    987              {
    988                if ( cfg->rxCnt < (cfg->rxMax - SAFE_RX_MIN) )
    989                {
    990                  RX_STRT_FLOW( cfg );
    991                }
    992              }
    993            }
    994          #endif
    995          
    996            return cnt;
   \                     ??HalUARTRead_1:
   \   00009D   E5..         MOV     A,?V0 + 4
   \   00009F   F5..         MOV     ?V0 + 0,A
   \   0000A1   AA..         MOV     R2,?V0 + 0
   \   0000A3   7B00         MOV     R3,#0x0
   \   0000A5   7F05         MOV     R7,#0x5
   \   0000A7   02....       LJMP    ?BANKED_LEAVE_XDATA
    997          }
    998          
    999          /******************************************************************************
   1000           * @fn      HalUARTWrite
   1001           *
   1002           * @brief   Write a buffer to the UART.
   1003           *
   1004           * @param   port    - UART port
   1005           *          pBuffer - pointer to the buffer that will be written, not freed
   1006           *          length  - length of
   1007           *
   1008           * @return  length of the buffer that was sent
   1009           *****************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1010          uint16 HalUARTWrite( uint8 port, uint8 *buf, uint16 len )
   \                     HalUARTWrite:
   1011          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
   1012            uartCfg_t *cfg = NULL;
   \   000009   7E00         MOV     R6,#0x0
   \   00000B   7F00         MOV     R7,#0x0
   1013            uint8 cnt;
   1014          
   1015          #if HAL_UART_0_ENABLE
   1016            if ( port == HAL_UART_PORT_0 )
   1017            {
   1018              cfg = cfg0;
   1019            }
   1020          #endif
   1021          #if HAL_UART_1_ENABLE
   1022            if ( port == HAL_UART_PORT_1 )
   1023            {
   1024              cfg = cfg1;
   1025            }
   1026          #endif
   1027          
   1028            HAL_UART_ASSERT( cfg );
   1029          
   1030            if ( cfg->txHead == cfg->txTail )
   1031            {
   1032          #if HAL_UART_DMA
   1033              // When pointers are equal, reset to zero to get max len w/out wrapping.
   1034              cfg->txHead = cfg->txTail = 0;
   1035          #endif
   1036          #if HAL_UART_ISR
   1037          #if HAL_UART_DMA
   1038              if ( !(cfg->flag & UART_CFG_DMA) )
   1039          #endif
   1040              {
   1041                cfg->flag &= ~UART_CFG_TXF;
   1042              }
   1043          #endif
   1044            }
   1045          
   1046            // Accept "all-or-none" on write request.
   1047            if ( TX_AVAIL( cfg ) < len )
   \   00000D   EE           MOV     A,R6
   \   00000E   240B         ADD     A,#0xb
   \   000010   F582         MOV     DPL,A
   \   000012   EF           MOV     A,R7
   \   000013   3400         ADDC    A,#0x0
   \   000015   F583         MOV     DPH,A
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FA           MOV     R2,A
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6A           XRL     A,R2
   \   000029   701B         JNZ     ??HalUARTWrite_0
   \   00002B   EE           MOV     A,R6
   \   00002C   240C         ADD     A,#0xc
   \   00002E   F582         MOV     DPL,A
   \   000030   EF           MOV     A,R7
   \   000031   3400         ADDC    A,#0x0
   \   000033   F583         MOV     DPH,A
   \   000035   E0           MOVX    A,@DPTR
   \   000036   FA           MOV     R2,A
   \   000037   7B00         MOV     R3,#0x0
   \   000039   74FF         MOV     A,#-0x1
   \   00003B   2A           ADD     A,R2
   \   00003C   F5..         MOV     ?V0 + 0,A
   \   00003E   74FF         MOV     A,#-0x1
   \   000040   3B           ADDC    A,R3
   \   000041   F5..         MOV     ?V0 + 1,A
   \   000043   02....       LJMP    ??HalUARTWrite_1 & 0xFFFF
   \                     ??HalUARTWrite_0:
   \   000046   8E82         MOV     DPL,R6
   \   000048   8F83         MOV     DPH,R7
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   C0E0         PUSH    A
   \   000057   EE           MOV     A,R6
   \   000058   240B         ADD     A,#0xb
   \   00005A   F582         MOV     DPL,A
   \   00005C   EF           MOV     A,R7
   \   00005D   3400         ADDC    A,#0x0
   \   00005F   F583         MOV     DPH,A
   \   000061   E0           MOVX    A,@DPTR
   \   000062   FA           MOV     R2,A
   \   000063   D0E0         POP     A
   \   000065   C3           CLR     C
   \   000066   9A           SUBB    A,R2
   \   000067   5035         JNC     ??HalUARTWrite_2
   \   000069   EE           MOV     A,R6
   \   00006A   240B         ADD     A,#0xb
   \   00006C   F582         MOV     DPL,A
   \   00006E   EF           MOV     A,R7
   \   00006F   3400         ADDC    A,#0x0
   \   000071   F583         MOV     DPH,A
   \   000073   E0           MOVX    A,@DPTR
   \   000074   FA           MOV     R2,A
   \   000075   7B00         MOV     R3,#0x0
   \   000077   8E82         MOV     DPL,R6
   \   000079   8F83         MOV     DPH,R7
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   A3           INC     DPTR
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   F5..         MOV     ?V0 + 0,A
   \   000088   75..00       MOV     ?V0 + 1,#0x0
   \   00008B   EA           MOV     A,R2
   \   00008C   C3           CLR     C
   \   00008D   95..         SUBB    A,?V0 + 0
   \   00008F   FA           MOV     R2,A
   \   000090   EB           MOV     A,R3
   \   000091   95..         SUBB    A,?V0 + 1
   \   000093   FB           MOV     R3,A
   \   000094   74FF         MOV     A,#-0x1
   \   000096   2A           ADD     A,R2
   \   000097   FA           MOV     R2,A
   \   000098   74FF         MOV     A,#-0x1
   \   00009A   3B           ADDC    A,R3
   \   00009B   FB           MOV     R3,A
   \   00009C   8043         SJMP    ??HalUARTWrite_3
   \                     ??HalUARTWrite_2:
   \   00009E   EE           MOV     A,R6
   \   00009F   240C         ADD     A,#0xc
   \   0000A1   F582         MOV     DPL,A
   \   0000A3   EF           MOV     A,R7
   \   0000A4   3400         ADDC    A,#0x0
   \   0000A6   F583         MOV     DPH,A
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   FA           MOV     R2,A
   \   0000AA   7B00         MOV     R3,#0x0
   \   0000AC   8E82         MOV     DPL,R6
   \   0000AE   8F83         MOV     DPH,R7
   \   0000B0   A3           INC     DPTR
   \   0000B1   A3           INC     DPTR
   \   0000B2   A3           INC     DPTR
   \   0000B3   A3           INC     DPTR
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   F5..         MOV     ?V0 + 0,A
   \   0000BD   75..00       MOV     ?V0 + 1,#0x0
   \   0000C0   EA           MOV     A,R2
   \   0000C1   C3           CLR     C
   \   0000C2   95..         SUBB    A,?V0 + 0
   \   0000C4   FA           MOV     R2,A
   \   0000C5   EB           MOV     A,R3
   \   0000C6   95..         SUBB    A,?V0 + 1
   \   0000C8   FB           MOV     R3,A
   \   0000C9   EE           MOV     A,R6
   \   0000CA   240B         ADD     A,#0xb
   \   0000CC   F582         MOV     DPL,A
   \   0000CE   EF           MOV     A,R7
   \   0000CF   3400         ADDC    A,#0x0
   \   0000D1   F583         MOV     DPH,A
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   F5..         MOV     ?V0 + 0,A
   \   0000D6   75..00       MOV     ?V0 + 1,#0x0
   \   0000D9   E5..         MOV     A,?V0 + 0
   \   0000DB   2A           ADD     A,R2
   \   0000DC   FA           MOV     R2,A
   \   0000DD   E5..         MOV     A,?V0 + 1
   \   0000DF   3B           ADDC    A,R3
   \   0000E0   FB           MOV     R3,A
   \                     ??HalUARTWrite_3:
   \   0000E1   8A..         MOV     ?V0 + 0,R2
   \   0000E3   8B..         MOV     ?V0 + 1,R3
   \                     ??HalUARTWrite_1:
   \   0000E5   C3           CLR     C
   \   0000E6   E5..         MOV     A,?V0 + 0
   \   0000E8   9C           SUBB    A,R4
   \   0000E9   E5..         MOV     A,?V0 + 1
   \   0000EB   9D           SUBB    A,R5
   \   0000EC   5007         JNC     ??HalUARTWrite_4
   1048            {
   1049              return 0;
   \   0000EE   7A00         MOV     R2,#0x0
   \   0000F0   7B00         MOV     R3,#0x0
   \   0000F2   02....       LJMP    ??HalUARTWrite_5 & 0xFFFF
   1050            }
   1051          
   1052            for ( cnt = len; cnt; cnt-- )
   \                     ??HalUARTWrite_4:
   \   0000F5   EC           MOV     A,R4
   \   0000F6   F5..         MOV     ?V0 + 3,A
   \                     ??HalUARTWrite_6:
   \   0000F8   E5..         MOV     A,?V0 + 3
   \   0000FA   7003         JNZ     $+5
   \   0000FC   02....       LJMP    ??HalUARTWrite_7 & 0xFFFF
   1053            {
   1054              cfg->txBuf[ cfg->txHead ] = *buf++;
   \   0000FF   8882         MOV     DPL,R0
   \   000101   8983         MOV     DPH,R1
   \   000103   E0           MOVX    A,@DPTR
   \   000104   C0E0         PUSH    A
   \   000106   8E82         MOV     DPL,R6
   \   000108   8F83         MOV     DPH,R7
   \   00010A   A3           INC     DPTR
   \   00010B   A3           INC     DPTR
   \   00010C   A3           INC     DPTR
   \   00010D   A3           INC     DPTR
   \   00010E   A3           INC     DPTR
   \   00010F   A3           INC     DPTR
   \   000110   A3           INC     DPTR
   \   000111   A3           INC     DPTR
   \   000112   A3           INC     DPTR
   \   000113   A3           INC     DPTR
   \   000114   E0           MOVX    A,@DPTR
   \   000115   FA           MOV     R2,A
   \   000116   7B00         MOV     R3,#0x0
   \   000118   8E82         MOV     DPL,R6
   \   00011A   8F83         MOV     DPH,R7
   \   00011C   A3           INC     DPTR
   \   00011D   A3           INC     DPTR
   \   00011E   A3           INC     DPTR
   \   00011F   A3           INC     DPTR
   \   000120   A3           INC     DPTR
   \   000121   A3           INC     DPTR
   \   000122   A3           INC     DPTR
   \   000123   A3           INC     DPTR
   \   000124   E0           MOVX    A,@DPTR
   \   000125   2A           ADD     A,R2
   \   000126   F5..         MOV     ?V0 + 0,A
   \   000128   A3           INC     DPTR
   \   000129   E0           MOVX    A,@DPTR
   \   00012A   3B           ADDC    A,R3
   \   00012B   85..82       MOV     DPL,?V0 + 0
   \   00012E   F583         MOV     DPH,A
   \   000130   D0E0         POP     A
   \   000132   F0           MOVX    @DPTR,A
   \   000133   8882         MOV     DPL,R0
   \   000135   8983         MOV     DPH,R1
   \   000137   A3           INC     DPTR
   \   000138   A882         MOV     R0,DPL
   \   00013A   A983         MOV     R1,DPH
   1055          
   1056              if ( cfg->txHead == cfg->txMax )
   \   00013C   8E82         MOV     DPL,R6
   \   00013E   8F83         MOV     DPH,R7
   \   000140   A3           INC     DPTR
   \   000141   A3           INC     DPTR
   \   000142   A3           INC     DPTR
   \   000143   A3           INC     DPTR
   \   000144   A3           INC     DPTR
   \   000145   A3           INC     DPTR
   \   000146   A3           INC     DPTR
   \   000147   A3           INC     DPTR
   \   000148   A3           INC     DPTR
   \   000149   A3           INC     DPTR
   \   00014A   E0           MOVX    A,@DPTR
   \   00014B   FA           MOV     R2,A
   \   00014C   EE           MOV     A,R6
   \   00014D   240C         ADD     A,#0xc
   \   00014F   F582         MOV     DPL,A
   \   000151   EF           MOV     A,R7
   \   000152   3400         ADDC    A,#0x0
   \   000154   F583         MOV     DPH,A
   \   000156   E0           MOVX    A,@DPTR
   \   000157   6A           XRL     A,R2
   \   000158   7013         JNZ     ??HalUARTWrite_8
   1057              {
   1058                cfg->txHead = 0;
   \   00015A   7400         MOV     A,#0x0
   \   00015C   8E82         MOV     DPL,R6
   \   00015E   8F83         MOV     DPH,R7
   \   000160   A3           INC     DPTR
   \   000161   A3           INC     DPTR
   \   000162   A3           INC     DPTR
   \   000163   A3           INC     DPTR
   \   000164   A3           INC     DPTR
   \   000165   A3           INC     DPTR
   \   000166   A3           INC     DPTR
   \   000167   A3           INC     DPTR
   \   000168   A3           INC     DPTR
   \   000169   A3           INC     DPTR
   \   00016A   F0           MOVX    @DPTR,A
   \   00016B   8012         SJMP    ??HalUARTWrite_9
   1059              }
   1060              else
   1061              {
   1062                cfg->txHead++;
   \                     ??HalUARTWrite_8:
   \   00016D   8E82         MOV     DPL,R6
   \   00016F   8F83         MOV     DPH,R7
   \   000171   A3           INC     DPTR
   \   000172   A3           INC     DPTR
   \   000173   A3           INC     DPTR
   \   000174   A3           INC     DPTR
   \   000175   A3           INC     DPTR
   \   000176   A3           INC     DPTR
   \   000177   A3           INC     DPTR
   \   000178   A3           INC     DPTR
   \   000179   A3           INC     DPTR
   \   00017A   A3           INC     DPTR
   \   00017B   E0           MOVX    A,@DPTR
   \   00017C   2401         ADD     A,#0x1
   \   00017E   F0           MOVX    @DPTR,A
   1063              }
   1064            }
   \                     ??HalUARTWrite_9:
   \   00017F   15..         DEC     ?V0 + 3
   \   000181   02....       LJMP    ??HalUARTWrite_6 & 0xFFFF
   1065          
   1066          #if HAL_UART_ISR
   1067          #if HAL_UART_DMA
   1068            if ( !(cfg->flag & UART_CFG_DMA) )
   1069          #endif
   1070            {
   1071              if ( !(cfg->flag & UART_CFG_TXF) && len )
   1072              {
   1073                cfg->flag |= UART_CFG_TXF;
   1074                if ( !(cfg->flag & UART_CFG_U1F) )
   1075                {
   1076                  U0DBUF = cfg->txBuf[cfg->txTail];
   1077                }
   1078                else
   1079                {
   1080                  U1DBUF = cfg->txBuf[cfg->txTail];
   1081                }
   1082              }
   1083            }
   1084          #endif
   1085          
   1086            return len;
   \                     ??HalUARTWrite_7:
   \   000184   EC           MOV     A,R4
   \   000185   FA           MOV     R2,A
   \   000186   ED           MOV     A,R5
   \   000187   FB           MOV     R3,A
   \                     ??HalUARTWrite_5:
   \   000188   7F04         MOV     R7,#0x4
   \   00018A   02....       LJMP    ?BANKED_LEAVE_XDATA
   1087          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTOpen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTOpen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTClose?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTClose

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??Hal_UART_RxBufLen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    Hal_UART_RxBufLen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalUARTWrite?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalUARTWrite
   1088          
   1089          #if HAL_UART_ISR
   1090          /***************************************************************************************************
   1091           * @fn      halUart0RxIsr
   1092           *
   1093           * @brief   UART0 Receive Interrupt
   1094           *
   1095           * @param   None
   1096           *
   1097           * @return  None
   1098           ***************************************************************************************************/
   1099          #if HAL_UART_0_ENABLE
   1100          HAL_ISR_FUNCTION( halUart0RxIsr, URX0_VECTOR )
   1101          {
   1102            cfg0->rxBuf[cfg0->rxHead] = U0DBUF;
   1103          
   1104            if ( cfg0->rxHead == cfg0->rxMax )
   1105            {
   1106              cfg0->rxHead = 0;
   1107            }
   1108            else
   1109            {
   1110              cfg0->rxHead++;
   1111            }
   1112          }
   1113          #endif
   1114          
   1115          /***************************************************************************************************
   1116           * @fn      halUart1RxIsr
   1117           *
   1118           * @brief   UART1 Receive Interrupt
   1119           *
   1120           * @param   None
   1121           *
   1122           * @return  None
   1123           ***************************************************************************************************/
   1124          #if HAL_UART_1_ENABLE
   1125          HAL_ISR_FUNCTION( halUart1RxIsr, URX1_VECTOR )
   1126          {
   1127            cfg1->rxBuf[cfg1->rxHead] = U1DBUF;
   1128          
   1129            if ( cfg1->rxHead == cfg1->rxMax )
   1130            {
   1131              cfg1->rxHead = 0;
   1132            }
   1133            else
   1134            {
   1135              cfg1->rxHead++;
   1136            }
   1137          }
   1138          #endif
   1139          
   1140          /***************************************************************************************************
   1141           * @fn      halUart0TxIsr
   1142           *
   1143           * @brief   UART0 Transmit Interrupt
   1144           *
   1145           * @param   None
   1146           *
   1147           * @return  None
   1148           ***************************************************************************************************/
   1149          #if HAL_UART_0_ENABLE
   1150          HAL_ISR_FUNCTION( halUart0TxIsr, UTX0_VECTOR )
   1151          {
   1152            UTX0IF = 0;
   1153          
   1154            if ( cfg0->txTail == cfg0->txMax )
   1155            {
   1156              cfg0->txTail = 0;
   1157            }
   1158            else
   1159            {
   1160              cfg0->txTail++;
   1161            }
   1162          
   1163            if ( cfg0->txTail != cfg0->txHead )
   1164            {
   1165              U0DBUF = cfg0->txBuf[cfg0->txTail];
   1166            }
   1167          }
   1168          #endif
   1169          
   1170          /***************************************************************************************************
   1171           * @fn      halUart1TxIsr
   1172           *
   1173           * @brief   UART1 Transmit Interrupt
   1174           *
   1175           * @param   None
   1176           *
   1177           * @return  None
   1178           ***************************************************************************************************/
   1179          #if HAL_UART_1_ENABLE
   1180          HAL_ISR_FUNCTION( halUart1TxIsr, UTX1_VECTOR )
   1181          {
   1182            UTX1IF = 0;
   1183            U1CSR &= ~CSR_TX_BYTE;  // Rev-D does not require, older does.
   1184          
   1185            if ( cfg1->txTail == cfg1->txMax )
   1186            {
   1187              cfg1->txTail = 0;
   1188            }
   1189            else
   1190            {
   1191              cfg1->txTail++;
   1192            }
   1193          
   1194            if ( cfg1->txTail != cfg1->txHead )
   1195            {
   1196              U1DBUF = cfg1->txBuf[cfg1->txTail];
   1197            }
   1198          }
   1199          #endif
   1200          #endif
   1201          
   1202          /******************************************************************************
   1203          ******************************************************************************/

   Maximum stack usage in bytes:

     Function            ISTACK PSTACK XSTACK
     --------            ------ ------ ------
     HalUARTClose            0      0      0
     HalUARTInit             0      0      0
     HalUARTOpen             1      0     13
       -> osal_mem_alloc     0      0     26
       -> osal_mem_alloc     0      0     26
     HalUARTPoll             0      0      0
     HalUARTRead             1      0     13
     HalUARTWrite            1      0     12
     Hal_UART_RxBufLen       3      0      0


   Segment part sizes:

     Function/Label            Bytes
     --------------            -----
     P2DIR                        1
     HalUARTInit                 11
     HalUARTOpen                278
     HalUARTClose                 3
     HalUARTPoll                  3
     Hal_UART_RxBufLen          121
     HalUARTRead                170
     HalUARTWrite               397
     ??HalUARTInit?relay          6
     ??HalUARTOpen?relay          6
     ??HalUARTClose?relay         6
     ??HalUARTPoll?relay          6
     ??Hal_UART_RxBufLen?relay    6
     ??HalUARTRead?relay          6
     ??HalUARTWrite?relay         6

 
 983 bytes in segment BANKED_CODE
  42 bytes in segment BANK_RELAYS
   1 byte  in segment SFR_AN
 
 1 025 bytes of CODE memory
     0 bytes of DATA memory (+ 1 byte shared)

Errors: none
Warnings: none

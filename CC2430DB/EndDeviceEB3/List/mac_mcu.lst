###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    18/Mar/2013  18:21:56 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \mac\low_level\srf03\single_chip\mac_mcu.c         #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\. #
#                          .\..\..\Tools\CC2430DB\f8wEndev.cfg" (-DCPU32MHZ   #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_OPT_FFD=0 -DBLINK_LEDS "-DCONST=const        #
#                          __code" -DGENERIC=__generic) -f "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\Tools #
#                          \CC2430DB\f8wConfig.cfg" (-DSECURE=0               #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\mac\low_ #
#                          level\srf03\single_chip\mac_mcu.c" -D CC2430EB -D  #
#                          AXD_END3 -D NWK_AUTO_POLL -D REFLECTOR -D          #
#                          xZTOOL_P1 -D xMT_TASK -D xMT_ZDO_FUNC -D           #
#                          xLCD_SUPPORTED=DEBUG -D xPOWER_SAVING -lC          #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\cc2430-zstack-adxl345\CC2430DB\EndD #
#                          eviceEB3\List\" -lA "C:\Texas                      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\EndDeviceEB3\L #
#                          ist\" --diag_suppress Pe001,Pa010 --diag_remark    #
#                          pe550 -o "C:\Texas Instruments\ZStack-1.4.3-1.2.1\ #
#                          Projects\zstack\Samples\cc2430-zstack-adxl345\CC24 #
#                          30DB\EndDeviceEB3\Obj\" -e --require_prototypes    #
#                          -z2 --no_cse --no_unroll --no_inline               #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs 8  #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\" #
#                           -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Proje #
#                          cts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\ #
#                          ..\SOURCE\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\Drivers\"   #
#                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB\. #
#                          .\..\..\ZMAIN\TI2430DB\" -I "C:\Texas              #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MT\" -I "C:\Texas                      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\INCLUDE\" -I "C:\Texas             #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\HAL\TARGET\CC2430EB\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\OSAL\INCLUDE\" -I "C:\Texas            #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\AF\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\NWK\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SEC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\SYS\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\STACK\ZDO\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\ZMAC\F8W\" -I "C:\Texas                #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\ZMAC\" -I "C:\Texas                    #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SADDR\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\SERVICES\SDATA\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\INCLUDE\" -I "C:\Texas             #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\HIGH_LEVEL\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\.. #
#                          \COMPONENTS\MAC\LOW_LEVEL\SRF03\SINGLE_CHIP\" -I   #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          4.0 Evaluation version\8051\INC\" -I "C:\Program   #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\CC2430DB\EndDe #
#                          viceEB3\List\mac_mcu.lst                           #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\cc2430-zstack-adxl345\CC2430DB\EndDe #
#                          viceEB3\Obj\mac_mcu.r51                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\mac\low_level\srf03\single_chip\mac_mcu.c
      1          /**************************************************************************************************
      2            Filename:       mac_mcu.c
      3            Revised:        $Date: 2007-10-29 22:38:47 -0700 (Mon, 29 Oct 2007) $
      4            Revision:       $Revision: 15812 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40             ///////////////////////////////////////////////////////////////////////////////////
     41             //  REV_B_WORKAROUND : Place holder as a reminder to optimize the bank select code
     42             //  once Rev B obsoleted.  Currently the bank select bits share a register with
     43             //  other functionality.  This will be *mirrored* to a new location where it
     44             //  is the only thing in the register.
     45             ///////////////////////////////////////////////////////////////////////////////////
     46          
     47          
     48          /* ------------------------------------------------------------------------------------------------
     49           *                                          Includes
     50           * ------------------------------------------------------------------------------------------------
     51           */
     52          
     53          /* hal */
     54          #include "hal_defs.h"
     55          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x91
   \   unsigned char volatile __sfr RFIM
   \                     RFIM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9b
   \   unsigned char volatile __sfr S1CON
   \                     S1CON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9c
   \   unsigned char volatile __sfr T2PEROF0
   \                     T2PEROF0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr T2PEROF1
   \                     T2PEROF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr T2PEROF2
   \                     T2PEROF2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa1
   \   unsigned char volatile __sfr T2OF0
   \                     T2OF0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa2
   \   unsigned char volatile __sfr T2OF1
   \                     T2OF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa3
   \   unsigned char volatile __sfr T2OF2
   \                     T2OF2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa4
   \   unsigned char volatile __sfr T2CAPLPL
   \                     T2CAPLPL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa5
   \   unsigned char volatile __sfr T2CAPHPH
   \                     T2CAPHPH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa6
   \   unsigned char volatile __sfr T2TLD
   \                     T2TLD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa7
   \   unsigned char volatile __sfr T2THD
   \                     T2THD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa9
   \   unsigned char volatile __sfr IP0
   \                     IP0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb9
   \   unsigned char volatile __sfr IP1
   \                     IP1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbc
   \   unsigned char volatile __sfr RNDL
   \                     RNDL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbd
   \   unsigned char volatile __sfr RNDH
   \                     RNDH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc3
   \   unsigned char volatile __sfr T2CNF
   \                     T2CNF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe9
   \   unsigned char volatile __sfr RFIF
   \                     RFIF:
   \   000000                DS 1
     56          
     57          /* low-level specific */
     58          #include "mac_rx.h"
     59          #include "mac_tx.h"
     60          #include "mac_backoff_timer.h"
     61          #include "mac_csp_tx.h"
     62          #include "mac_rx_onoff.h"
     63          
     64          /* target specific */
     65          #include "mac_mcu.h"
     66          #include "mac_radio_defs.h"
     67          
     68          /* debug */
     69          #include "mac_assert.h"
     70          
     71          
     72          /* ------------------------------------------------------------------------------------------------
     73           *                                           Defines
     74           * ------------------------------------------------------------------------------------------------
     75           */
     76          #define T2CNF_BASE_VALUE    (RUN | SYNC)
     77          
     78          /* for optimized indexing of uint32's */
     79          #if HAL_MCU_LITTLE_ENDIAN()
     80          #define UINT32_NDX0   0
     81          #define UINT32_NDX1   1
     82          #define UINT32_NDX2   2
     83          #define UINT32_NDX3   3
     84          #else
     85          #define UINT32_NDX0   3
     86          #define UINT32_NDX1   2
     87          #define UINT32_NDX2   1
     88          #define UINT32_NDX3   0
     89          #endif
     90          
     91          /* ------------------------------------------------------------------------------------------------
     92           *                                        Local Variables
     93           * ------------------------------------------------------------------------------------------------
     94           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     95          static int8 maxRssi;
   \                     maxRssi:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     96          
     97          /*
     98           *  A shadow variable is required for the lower four bits of T2PEROF2.  These bits have different
     99           *  functionality for read versus write.  This would fine except the upper bits of T2PEROF2 are
    100           *  used to enable and disable interrupts and must be set independently of the lower four bits.
    101           *  Since the original value of the lower four bits is lost (it reads as something else) these
    102           *  bits must be stored in a shadow variable.  This shadow variable is declared here and is
    103           *  used where needed in this module.
    104           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    105          static uint8 shadowPerof2;
   \                     shadowPerof2:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    106          
    107          
    108          /* ------------------------------------------------------------------------------------------------
    109           *                                       Local Prototypes
    110           * ------------------------------------------------------------------------------------------------
    111           */
    112          static void mcuRecordMaxRssiIsr(void);
    113          
    114          
    115          /**************************************************************************************************
    116           * @fn          macMcuInit
    117           *
    118           * @brief       Initialize the MCU.
    119           *
    120           * @param       none
    121           *
    122           * @return      none
    123           **************************************************************************************************
    124           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    125          void macMcuInit(void)
   \                     macMcuInit:
    126          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    127          
    128            MAC_ASSERT(CHVER >= 0x03); /* chip versions before version D are obsolete */
   \   000004   90DF60       MOV     DPTR,#-0x20a0
   \   000007   E0           MOVX    A,@DPTR
   \   000008   C3           CLR     C
   \   000009   9403         SUBB    A,#0x3
   \   00000B   5003         JNC     ??macMcuInit_0
   \   00000D                ; Setup parameters for call to function halAssertHandler
   \   00000D   12....       LCALL   ??halAssertHandler?relay
    129          
    130            /* tuning adjustments for optimal radio performance; details available in datasheet */
    131            RXCTRL0H = 0x32;
   \                     ??macMcuInit_0:
   \   000010   7432         MOV     A,#0x32
   \   000012   90DF0C       MOV     DPTR,#-0x20f4
   \   000015   F0           MOVX    @DPTR,A
    132            RXCTRL0L = 0xF5;
   \   000016   74F5         MOV     A,#-0xb
   \   000018   90DF0D       MOV     DPTR,#-0x20f3
   \   00001B   F0           MOVX    @DPTR,A
    133          
    134            /* enable TX_DONE interrupts for ACK transmits */
    135            IRQSRC = TXACK;
   \   00001C   7401         MOV     A,#0x1
   \   00001E   90DF64       MOV     DPTR,#-0x209c
   \   000021   F0           MOVX    @DPTR,A
    136          
    137            /* disable the CSPT register compare function */
    138            CSPT = 0xFF;
   \   000022   74FF         MOV     A,#-0x1
   \   000024   90DF16       MOV     DPTR,#-0x20ea
   \   000027   F0           MOVX    @DPTR,A
    139          
    140            /* enable general RF interrupts */
    141            IEN2 |= RFIE;
   \   000028   439A01       ORL     0x9a,#0x1
    142          
    143            /* intialize shadow register */
    144            shadowPerof2 = 0;
   \   00002B   7400         MOV     A,#0x0
   \   00002D   90....       MOV     DPTR,#shadowPerof2
   \   000030   F0           MOVX    @DPTR,A
    145          
    146            /* set RF interrupts one notch above lowest priority (four levels available) */
    147            IP0 |=  IP_RFERR_RF_DMA_BV;
   \   000031   43A901       ORL     0xa9,#0x1
    148            IP1 &= ~IP_RFERR_RF_DMA_BV;
   \   000034   53B9FE       ANL     0xb9,#0xfe
    149          
    150            /*-------------------------------------------------------------------------------
    151             *  Initialize MAC timer.
    152             */
    153          
    154            /* set timer rollover */
    155            T2CAPLPL = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() & 0xFF;
   \   000037   75A400       MOV     0xa4,#0x0
    156            T2CAPHPH = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() >> 8;
   \   00003A   75A528       MOV     0xa5,#0x28
    157          
    158            /* start timer */
    159            T2CNF |= RUN;
   \   00003D   43C301       ORL     0xc3,#0x1
    160          
    161            /* enable timer interrupts */
    162            T2IE = 1;
   \   000040   D2BA         SETB    0xb8.2
    163          
    164           /*----------------------------------------------------------------------------------------------
    165            *  Initialize random seed value.
    166            */
    167          
    168            /* turn on radio power */
    169            RFPWR &= ~RREG_RADIO_PD;
   \   000042   90DF17       MOV     DPTR,#-0x20e9
   \   000045   E0           MOVX    A,@DPTR
   \   000046   C2E3         CLR     0xE0 /* A   */.3
   \   000048   F0           MOVX    @DPTR,A
    170            while((RFPWR & ADI_RADIO_PD));
   \                     ??macMcuInit_1:
   \   000049   90DF17       MOV     DPTR,#-0x20e9
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   A2E4         MOV     C,0xE0 /* A   */.4
   \   00004F   40F8         JC      ??macMcuInit_1
    171          
    172            /*
    173             *  Set radio for infinite reception.  Once radio reaches this state,
    174             *  it will stay in receive mode regardless RF activity.
    175             */
    176            MDMCTRL1L = MDMCTRL1L_RESET_VALUE | RX_MODE_INFINITE_RECEPTION;
   \   000051   7402         MOV     A,#0x2
   \   000053   90DF05       MOV     DPTR,#-0x20fb
   \   000056   F0           MOVX    @DPTR,A
    177          
    178            /* turn on the receiver */
    179            macRxOn();
   \   000057                ; Setup parameters for call to function macRxOn
   \   000057   12....       LCALL   ??macRxOn?relay
    180          
    181            /*
    182             *  Wait for radio to reach infinite reception state.  Once it does,
    183             *  The least significant bit of ADTSTH should be pretty random.
    184             */
    185            while (FSMSTATE != FSM_FFCTRL_STATE_RX_INF)
   \                     ??macMcuInit_2:
   \   00005A   90DF39       MOV     DPTR,#-0x20c7
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   641F         XRL     A,#0x1f
   \   000060   603C         JZ      ??macMcuInit_3
    186          
    187            /* put 16 random bits into the seed value */
    188            {
    189              uint16 rndSeed;
    190              uint8  i;
    191          
    192              rndSeed = 0;
   \   000062   7800         MOV     R0,#0x0
   \   000064   7900         MOV     R1,#0x0
    193          
    194              for(i=0; i<16; i++)
   \   000066   7C00         MOV     R4,#0x0
   \                     ??macMcuInit_4:
   \   000068   EC           MOV     A,R4
   \   000069   C3           CLR     C
   \   00006A   9410         SUBB    A,#0x10
   \   00006C   501A         JNC     ??macMcuInit_5
    195              {
    196                /* use most random bit of analog to digital receive conversion to populate the random seed */
    197                rndSeed = (rndSeed << 1) | (ADCTSTH & 0x01);
   \   00006E   E8           MOV     A,R0
   \   00006F   C3           CLR     C
   \   000070   33           RLC     A
   \   000071   F8           MOV     R0,A
   \   000072   E9           MOV     A,R1
   \   000073   33           RLC     A
   \   000074   F9           MOV     R1,A
   \   000075   90DF3A       MOV     DPTR,#-0x20c6
   \   000078   E0           MOVX    A,@DPTR
   \   000079   A2E0         MOV     C,0xE0 /* A   */.0
   \   00007B   E4           CLR     A
   \   00007C   92E0         MOV     0xE0 /* A   */.0,C
   \   00007E   7B00         MOV     R3,#0x0
   \   000080   48           ORL     A,R0
   \   000081   F8           MOV     R0,A
   \   000082   EB           MOV     A,R3
   \   000083   49           ORL     A,R1
   \   000084   F9           MOV     R1,A
    198              }
   \   000085   0C           INC     R4
   \   000086   80E0         SJMP    ??macMcuInit_4
    199          
    200              /*
    201               *  The seed value must not be zero.  If it is, the psuedo random sequence will be always be zero.
    202               *  There is an extremely small chance this seed could randomly be zero (more likely some type of
    203               *  hardware problem would cause this).  The following check makes sure this does not happen.
    204               */
    205              if (rndSeed == 0x0000)
   \                     ??macMcuInit_5:
   \   000088   7400         MOV     A,#0x0
   \   00008A   68           XRL     A,R0
   \   00008B   7003         JNZ     ??macMcuInit_6
   \   00008D   7400         MOV     A,#0x0
   \   00008F   69           XRL     A,R1
   \                     ??macMcuInit_6:
   \   000090   7004         JNZ     ??macMcuInit_7
    206              {
    207                rndSeed = 0xBEEF; /* completely arbitrary "random" value */
   \   000092   78EF         MOV     R0,#-0x11
   \   000094   79BE         MOV     R1,#-0x42
    208              }
    209          
    210              /*
    211               *  Two writes to RNDL will set the random seed.  A write to RNDL copies current contents
    212               *  of RNDL to RNDH before writing new the value to RNDL.
    213               */
    214              RNDL = rndSeed & 0xFF;
   \                     ??macMcuInit_7:
   \   000096   E8           MOV     A,R0
   \   000097   F5BC         MOV     0xbc,A
    215              RNDL = rndSeed >> 8;
   \   000099   E9           MOV     A,R1
   \   00009A   F5BC         MOV     0xbc,A
   \   00009C   80BC         SJMP    ??macMcuInit_2
    216            }
    217          
    218            /* turn off the receiver */
    219            macRxOff();
   \                     ??macMcuInit_3:
   \   00009E                ; Setup parameters for call to function macRxOff
   \   00009E   12....       LCALL   ??macRxOff?relay
    220          
    221            /* take receiver out of infinite reception mode; set back to normal operation */
    222            MDMCTRL1L = MDMCTRL1L_RESET_VALUE | RX_MODE_NORMAL_OPERATION;
   \   0000A1   7400         MOV     A,#0x0
   \   0000A3   90DF05       MOV     DPTR,#-0x20fb
   \   0000A6   F0           MOVX    @DPTR,A
    223          
    224            /* turn radio back off */
    225            RFPWR |= RREG_RADIO_PD;
   \   0000A7   90DF17       MOV     DPTR,#-0x20e9
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   D2E3         SETB    0xE0 /* A   */.3
   \   0000AD   F0           MOVX    @DPTR,A
    226          }
   \   0000AE   D083         POP     DPH
   \   0000B0   D082         POP     DPL
   \   0000B2   02....       LJMP    ?BRET
   \   0000B5                REQUIRE IEN2
   \   0000B5                REQUIRE T2CAPLPL
   \   0000B5                REQUIRE T2CAPHPH
   \   0000B5                REQUIRE IP0
   \   0000B5                REQUIRE _A_IEN1
   \   0000B5                REQUIRE IP1
   \   0000B5                REQUIRE RNDL
   \   0000B5                REQUIRE T2CNF
    227          
    228          
    229          /**************************************************************************************************
    230           * @fn          macMcuRandomByte
    231           *
    232           * @brief       Returns a random byte using a special hardware feature that generates new
    233           *              random values based on the truly random seed set earlier.
    234           *
    235           * @param       none
    236           *
    237           * @return      a random byte
    238           **************************************************************************************************
    239           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    240          uint8 macMcuRandomByte(void)
   \                     macMcuRandomByte:
    241          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    242            /* clock the random generator to get a new random value */
    243            ADCCON1 = (ADCCON1 & ~RCTRL_BITS) | RCTRL_CLOCK_LFSR;
   \   000000   74F3         MOV     A,#-0xd
   \   000002   55B4         ANL     A,0xb4
   \   000004   4404         ORL     A,#0x4
   \   000006   F5B4         MOV     0xb4,A
    244          
    245            /* return new randomized value from hardware */
    246            return(RNDH);
   \   000008   A9BD         MOV     R1,0xbd
   \   00000A   02....       LJMP    ?BRET
   \   00000D                REQUIRE ADCCON1
   \   00000D                REQUIRE RNDH
    247          }
    248          
    249          
    250          /**************************************************************************************************
    251           * @fn          macMcuTimerCount
    252           *
    253           * @brief       Returns the upper eight bits of hardware timer count.  The full 16-bit timer
    254           *              count is not returned because the timer compare feature only compares one byte.
    255           *
    256           * @param       none
    257           *
    258           * @return      upper eight bits of hardware timer count
    259           **************************************************************************************************
    260           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    261          uint8 macMcuTimerCount(void)
   \                     macMcuTimerCount:
    262          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    263            uint8 volatile temp;
    264          
    265            /* reading T2TLD latches T2THD */
    266            temp = T2TLD;
   \   000009   E5A6         MOV     A,0xa6
   \   00000B   85..82       MOV     DPL,?XSP + 0
   \   00000E   85..83       MOV     DPH,?XSP + 1
   \   000011   F0           MOVX    @DPTR,A
    267            return(T2THD);
   \   000012   A9A7         MOV     R1,0xa7
   \   000014   7401         MOV     A,#0x1
   \   000016   12....       LCALL   ?DEALLOC_XSTACK8
   \   000019   D083         POP     DPH
   \   00001B   D082         POP     DPL
   \   00001D   02....       LJMP    ?BRET
   \   000020                REQUIRE T2TLD
   \   000020                REQUIRE T2THD
    268          }
    269          
    270          
    271          /**************************************************************************************************
    272           * @fn          macMcuTimerCapture
    273           *
    274           * @brief       Returns the last timer capture.  This capture should have occurred at the
    275           *              receive time of the last frame (the last time SFD transitioned to active).
    276           *
    277           * @param       none
    278           *
    279           * @return      last capture of hardware timer (full 16-bit value)
    280           **************************************************************************************************
    281           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    282          uint16 macMcuTimerCapture(void)
   \                     macMcuTimerCapture:
    283          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    284            uint16 timerCapture;
    285          
    286            timerCapture = T2CAPLPL;
   \   000004   ACA4         MOV     R4,0xa4
   \   000006   8C82         MOV     DPL,R4
   \   000008   758300       MOV     DPH,#0x0
   \   00000B   AA82         MOV     R2,DPL
   \   00000D   AB83         MOV     R3,DPH
    287            timerCapture |= T2CAPHPH << 8;
   \   00000F   E5A5         MOV     A,0xa5
   \   000011   F8           MOV     R0,A
   \   000012   E4           CLR     A
   \   000013   C8           XCH     A,R0
   \   000014   F9           MOV     R1,A
   \   000015   E8           MOV     A,R0
   \   000016   4A           ORL     A,R2
   \   000017   FA           MOV     R2,A
   \   000018   E9           MOV     A,R1
   \   000019   4B           ORL     A,R3
   \   00001A   FB           MOV     R3,A
    288          
    289            return (timerCapture);
   \   00001B   D083         POP     DPH
   \   00001D   D082         POP     DPL
   \   00001F   02....       LJMP    ?BRET
   \   000022                REQUIRE T2CAPLPL
   \   000022                REQUIRE T2CAPHPH
    290          }
    291          
    292          
    293          /**************************************************************************************************
    294           * @fn          macMcuOverflowCount
    295           *
    296           * @brief       Returns the value of the overflow counter which is a special hardware feature.
    297           *              The overflow count actually is only 20 bits of information.
    298           *
    299           * @param       none
    300           *
    301           * @return      value of overflow counter
    302           **************************************************************************************************
    303           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    304          uint32 macMcuOverflowCount(void)
   \                     macMcuOverflowCount:
    305          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    306            uint32 overflowCount;
    307          
    308            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    309          
    310            /* must read T2OF0 first, this latches T2OF1 and T2OF2 */
    311            ((uint8 *)&overflowCount)[UINT32_NDX0] = T2OF0;
   \   00000A   E5A1         MOV     A,0xa1
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   F0           MOVX    @DPTR,A
    312            ((uint8 *)&overflowCount)[UINT32_NDX1] = T2OF1;
   \   000013   E5A2         MOV     A,0xa2
   \   000015   C0E0         PUSH    A
   \   000017   7401         MOV     A,#0x1
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   D0E0         POP     A
   \   00001E   F0           MOVX    @DPTR,A
    313            ((uint8 *)&overflowCount)[UINT32_NDX2] = T2OF2;
   \   00001F   E5A3         MOV     A,0xa3
   \   000021   C0E0         PUSH    A
   \   000023   7402         MOV     A,#0x2
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   D0E0         POP     A
   \   00002A   F0           MOVX    @DPTR,A
    314            ((uint8 *)&overflowCount)[UINT32_NDX3] = 0;
   \   00002B   7400         MOV     A,#0x0
   \   00002D   C0E0         PUSH    A
   \   00002F   7403         MOV     A,#0x3
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   D0E0         POP     A
   \   000036   F0           MOVX    @DPTR,A
    315          
    316            return (overflowCount);
   \   000037   85..82       MOV     DPL,?XSP + 0
   \   00003A   85..83       MOV     DPH,?XSP + 1
   \   00003D   78..         MOV     R0,#?V0 + 0
   \   00003F   12....       LCALL   ?L_MOV_X
   \   000042   AA..         MOV     R2,?V0 + 0
   \   000044   AB..         MOV     R3,?V0 + 1
   \   000046   AC..         MOV     R4,?V0 + 2
   \   000048   AD..         MOV     R5,?V0 + 3
   \   00004A   7404         MOV     A,#0x4
   \   00004C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004F   7F04         MOV     R7,#0x4
   \   000051   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000054                REQUIRE T2OF0
   \   000054                REQUIRE T2OF1
   \   000054                REQUIRE T2OF2
    317          }
    318          
    319          
    320          /**************************************************************************************************
    321           * @fn          macMcuOverflowCapture
    322           *
    323           * @brief       Returns the last capture of the overflow counter.  A special hardware feature
    324           *              captures the overflow counter when the regular hardware timer is captured.
    325           *
    326           * @param       none
    327           *
    328           * @return      last capture of overflow count
    329           **************************************************************************************************
    330           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    331          uint32 macMcuOverflowCapture(void)
   \                     macMcuOverflowCapture:
    332          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    333            uint32 overflowCapture;
    334          
    335            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    336          
    337            ((uint8 *)&overflowCapture)[UINT32_NDX0] = T2PEROF0;
   \   00000A   E59C         MOV     A,0x9c
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   F0           MOVX    @DPTR,A
    338            ((uint8 *)&overflowCapture)[UINT32_NDX1] = T2PEROF1;
   \   000013   E59D         MOV     A,0x9d
   \   000015   C0E0         PUSH    A
   \   000017   7401         MOV     A,#0x1
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   D0E0         POP     A
   \   00001E   F0           MOVX    @DPTR,A
    339            ((uint8 *)&overflowCapture)[UINT32_NDX2] = T2PEROF2 & PEROF2_BITS;
   \   00001F   740F         MOV     A,#0xf
   \   000021   559E         ANL     A,0x9e
   \   000023   C0E0         PUSH    A
   \   000025   7402         MOV     A,#0x2
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   D0E0         POP     A
   \   00002C   F0           MOVX    @DPTR,A
    340            ((uint8 *)&overflowCapture)[UINT32_NDX3] = 0;
   \   00002D   7400         MOV     A,#0x0
   \   00002F   C0E0         PUSH    A
   \   000031   7403         MOV     A,#0x3
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   D0E0         POP     A
   \   000038   F0           MOVX    @DPTR,A
    341          
    342            return (overflowCapture);
   \   000039   85..82       MOV     DPL,?XSP + 0
   \   00003C   85..83       MOV     DPH,?XSP + 1
   \   00003F   78..         MOV     R0,#?V0 + 0
   \   000041   12....       LCALL   ?L_MOV_X
   \   000044   AA..         MOV     R2,?V0 + 0
   \   000046   AB..         MOV     R3,?V0 + 1
   \   000048   AC..         MOV     R4,?V0 + 2
   \   00004A   AD..         MOV     R5,?V0 + 3
   \   00004C   7404         MOV     A,#0x4
   \   00004E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000051   7F04         MOV     R7,#0x4
   \   000053   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000056                REQUIRE T2PEROF0
   \   000056                REQUIRE T2PEROF1
   \   000056                REQUIRE T2PEROF2
    343          }
    344          
    345          
    346          /**************************************************************************************************
    347           * @fn          macMcuOverflowSetCount
    348           *
    349           * @brief       Sets the value of the hardware overflow counter.
    350           *
    351           * @param       count - new overflow count value
    352           *
    353           * @return      none
    354           **************************************************************************************************
    355           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    356          void macMcuOverflowSetCount(uint32 count)
   \                     macMcuOverflowSetCount:
    357          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   A3           INC     DPTR
   \   000016   EC           MOV     A,R4
   \   000017   F0           MOVX    @DPTR,A
   \   000018   A3           INC     DPTR
   \   000019   ED           MOV     A,R5
   \   00001A   F0           MOVX    @DPTR,A
    358            MAC_ASSERT(!((count >> 16) & ~PEROF2_BITS));   /* illegal count value */
   \   00001B   85..82       MOV     DPL,?XSP + 0
   \   00001E   85..83       MOV     DPH,?XSP + 1
   \   000021   78..         MOV     R0,#?V0 + 0
   \   000023   12....       LCALL   ?L_MOV_X
   \   000026   7410         MOV     A,#0x10
   \   000028   78..         MOV     R0,#?V0 + 0
   \   00002A   12....       LCALL   ?UL_SHR
   \   00002D   74F0         MOV     A,#-0x10
   \   00002F   55..         ANL     A,?V0 + 0
   \   000031   F8           MOV     R0,A
   \   000032   74FF         MOV     A,#-0x1
   \   000034   55..         ANL     A,?V0 + 1
   \   000036   F9           MOV     R1,A
   \   000037   7400         MOV     A,#0x0
   \   000039   68           XRL     A,R0
   \   00003A   7003         JNZ     ??macMcuOverflowSetCount_0
   \   00003C   7400         MOV     A,#0x0
   \   00003E   69           XRL     A,R1
   \                     ??macMcuOverflowSetCount_0:
   \   00003F   6003         JZ      ??macMcuOverflowSetCount_1
   \   000041                ; Setup parameters for call to function halAssertHandler
   \   000041   12....       LCALL   ??halAssertHandler?relay
    359          
    360            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    361          
    362            /* T2OF2 must be written last */
    363            T2OF0 = ((uint8 *)&count)[UINT32_NDX0];
   \                     ??macMcuOverflowSetCount_1:
   \   000044   85..82       MOV     DPL,?XSP + 0
   \   000047   85..83       MOV     DPH,?XSP + 1
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F5A1         MOV     0xa1,A
    364            T2OF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   00004D   7401         MOV     A,#0x1
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F5A2         MOV     0xa2,A
    365            T2OF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   000055   7402         MOV     A,#0x2
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F5A3         MOV     0xa3,A
    366          }
   \   00005D   7404         MOV     A,#0x4
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   7F04         MOV     R7,#0x4
   \   000064   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000067                REQUIRE T2OF0
   \   000067                REQUIRE T2OF1
   \   000067                REQUIRE T2OF2
    367          
    368          
    369          /**************************************************************************************************
    370           * @fn          macMcuOverflowSetCompare
    371           *
    372           * @brief       Set overflow count compare value.  An interrupt is triggered when the overflow
    373           *              count equals this compare value.
    374           *
    375           * @param       count - overflow count compare value
    376           *
    377           * @return      none
    378           **************************************************************************************************
    379           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    380          void macMcuOverflowSetCompare(uint32 count)
   \                     macMcuOverflowSetCompare:
    381          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   A3           INC     DPTR
   \   000016   EC           MOV     A,R4
   \   000017   F0           MOVX    @DPTR,A
   \   000018   A3           INC     DPTR
   \   000019   ED           MOV     A,R5
   \   00001A   F0           MOVX    @DPTR,A
    382            halIntState_t  s;
    383            uint8 imBits;
    384          
    385            MAC_ASSERT(!((count >> 16) & ~PEROF2_BITS));   /* illegal count value */
   \   00001B   85..82       MOV     DPL,?XSP + 0
   \   00001E   85..83       MOV     DPH,?XSP + 1
   \   000021   78..         MOV     R0,#?V0 + 0
   \   000023   12....       LCALL   ?L_MOV_X
   \   000026   7410         MOV     A,#0x10
   \   000028   78..         MOV     R0,#?V0 + 0
   \   00002A   12....       LCALL   ?UL_SHR
   \   00002D   74F0         MOV     A,#-0x10
   \   00002F   55..         ANL     A,?V0 + 0
   \   000031   F8           MOV     R0,A
   \   000032   74FF         MOV     A,#-0x1
   \   000034   55..         ANL     A,?V0 + 1
   \   000036   F9           MOV     R1,A
   \   000037   7400         MOV     A,#0x0
   \   000039   68           XRL     A,R0
   \   00003A   7003         JNZ     ??macMcuOverflowSetCompare_0
   \   00003C   7400         MOV     A,#0x0
   \   00003E   69           XRL     A,R1
   \                     ??macMcuOverflowSetCompare_0:
   \   00003F   6003         JZ      ??macMcuOverflowSetCompare_1
   \   000041                ; Setup parameters for call to function halAssertHandler
   \   000041   12....       LCALL   ??halAssertHandler?relay
    386          
    387            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetCompare_1:
   \   000044   A2AF         MOV     C,0xa8.7
   \   000046   E4           CLR     A
   \   000047   92E0         MOV     0xE0 /* A   */.0,C
   \   000049   FE           MOV     R6,A
   \   00004A   C2AF         CLR     0xa8.7
    388          
    389            /* remember value of interrupt mask bits, allows OFCMPIM bit to be restored later */
    390            imBits = T2PEROF2 & ~PEROF2_BITS;
   \   00004C   74F0         MOV     A,#-0x10
   \   00004E   559E         ANL     A,0x9e
   \   000050   FF           MOV     R7,A
    391          
    392            /*
    393             *  Disable overflow compare interrupts.  (It is OK to write zero to compare part of
    394             *  this register.  Interrupts are disabled and the new value will be written and the
    395             *  interrupt flag cleared before interrupts are re-enabled.)
    396             */
    397            T2PEROF2 = imBits & ~OFCMPIM;
   \   000051   74DF         MOV     A,#-0x21
   \   000053   5F           ANL     A,R7
   \   000054   F59E         MOV     0x9e,A
    398            T2PEROF2 = imBits & ~OFCMPIM;  /* writing twice is chip bug workaround */
   \   000056   74DF         MOV     A,#-0x21
   \   000058   5F           ANL     A,R7
   \   000059   F59E         MOV     0x9e,A
    399          
    400            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    401            T2PEROF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   E0           MOVX    A,@DPTR
   \   000062   F59C         MOV     0x9c,A
    402            T2PEROF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   000064   7401         MOV     A,#0x1
   \   000066   12....       LCALL   ?XSTACK_DISP0_8
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   F59D         MOV     0x9d,A
    403          
    404            /* see declaration of this shadow variable for more information */
    405            shadowPerof2 = ((uint8 *)&count)[UINT32_NDX2];
   \   00006C   7402         MOV     A,#0x2
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   E0           MOVX    A,@DPTR
   \   000072   90....       MOV     DPTR,#shadowPerof2
   \   000075   F0           MOVX    @DPTR,A
    406          
    407            /* write the compare value part of T2PEROF2 without re-enabling overflow compare interrupts */
    408            T2PEROF2 = (imBits & ~OFCMPIM) | shadowPerof2;
   \   000076   90....       MOV     DPTR,#shadowPerof2
   \   000079   74DF         MOV     A,#-0x21
   \   00007B   5F           ANL     A,R7
   \   00007C   FA           MOV     R2,A
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   4A           ORL     A,R2
   \   00007F   F59E         MOV     0x9e,A
    409            T2PEROF2 = (imBits & ~OFCMPIM) | shadowPerof2;  /* writing twice is chip bug workaround */
   \   000081   90....       MOV     DPTR,#shadowPerof2
   \   000084   74DF         MOV     A,#-0x21
   \   000086   5F           ANL     A,R7
   \   000087   FA           MOV     R2,A
   \   000088   E0           MOVX    A,@DPTR
   \   000089   4A           ORL     A,R2
   \   00008A   F59E         MOV     0x9e,A
    410          
    411            /*
    412             *  Now that new compare value is stored, clear the interrupt flag.  This is important just
    413             *  in case a false match was generated as the multi-byte compare value was written.
    414             */
    415            T2CNF = T2CNF_BASE_VALUE | (~OFCMPIF & T2CNF_IF_BITS);
   \   00008C   75C3C3       MOV     0xc3,#-0x3d
    416          
    417            /* re-enable overflow compare interrupts if they were previously enabled */
    418            T2PEROF2 = imBits | shadowPerof2;
   \   00008F   90....       MOV     DPTR,#shadowPerof2
   \   000092   E0           MOVX    A,@DPTR
   \   000093   4F           ORL     A,R7
   \   000094   F59E         MOV     0x9e,A
    419            T2PEROF2 = imBits | shadowPerof2;  /* writing twice is chip bug workaround */
   \   000096   90....       MOV     DPTR,#shadowPerof2
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   4F           ORL     A,R7
   \   00009B   F59E         MOV     0x9e,A
    420          
    421            HAL_EXIT_CRITICAL_SECTION(s);
   \   00009D   EE           MOV     A,R6
   \   00009E   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000A0   92AF         MOV     0xa8.7,C
    422          }
   \   0000A2   7404         MOV     A,#0x4
   \   0000A4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A7   7F04         MOV     R7,#0x4
   \   0000A9   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   0000AC                REQUIRE T2PEROF0
   \   0000AC                REQUIRE T2PEROF1
   \   0000AC                REQUIRE T2PEROF2
   \   0000AC                REQUIRE _A_IEN0
   \   0000AC                REQUIRE T2CNF
    423          
    424          
    425          /**************************************************************************************************
    426           * @fn          macMcuTimer2Isr
    427           *
    428           * @brief       Interrupt service routine for timer2, the MAC timer.
    429           *
    430           * @param       none
    431           *
    432           * @return      none
    433           **************************************************************************************************
    434           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    435          HAL_ISR_FUNCTION( macMcuTimer2Isr, T2_VECTOR )
   \                     macMcuTimer2Isr:
    436          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    437            uint8 t2perof2;
    438          
    439            /* temporary variable used to suppress volatile access order warning */
    440            t2perof2 = T2PEROF2;
   \   000007   E59E         MOV     A,0x9e
   \   000009   FE           MOV     R6,A
    441          
    442            /*------------------------------------------------------------------------------------------------
    443             *  Overflow compare interrupt - triggers when then overflow counter is
    444             *  equal to the overflow compare register.
    445             */
    446            if ((T2CNF & OFCMPIF) & t2perof2)
   \   00000A   E5C3         MOV     A,0xc3
   \   00000C   5E           ANL     A,R6
   \   00000D   5420         ANL     A,#0x20
   \   00000F   6005         JZ      ??macMcuTimer2Isr_0
    447            {
    448              /* call function for dealing with the timer compare interrupt */
    449              macBackoffTimerCompareIsr();
   \   000011                ; Setup parameters for call to function macBackoffTimerCompareIsr
   \   000011   12....       LCALL   ??macBackoffTimerCompareIsr?relay
   \   000014   800D         SJMP    ??macMcuTimer2Isr_1
    450          
    451              /*
    452               *  NOTE : The interrupt flag for overflow compare is not cleared here.  This is done
    453               *         in the code that sets a new overflow compare value.
    454               */
    455            }
    456          
    457            /*------------------------------------------------------------------------------------------------
    458             *  Overflow interrupt - triggers when the hardware timer rolls over.
    459             */
    460            else if ((T2CNF & PERIF) & t2perof2)
   \                     ??macMcuTimer2Isr_0:
   \   000016   E5C3         MOV     A,0xc3
   \   000018   5E           ANL     A,R6
   \   000019   5440         ANL     A,#0x40
   \   00001B   6006         JZ      ??macMcuTimer2Isr_1
    461            {
    462              /* call energy detect interrupt function, this interrupt not used for any other functionality */
    463              mcuRecordMaxRssiIsr();
   \   00001D                ; Setup parameters for call to function mcuRecordMaxRssiIsr
   \   00001D   12....       LCALL   ??mcuRecordMaxRssiIsr?relay
    464          
    465              /* clear the interrupt flag by writing a zero to only that flag, write one to other flags */
    466              T2CNF = T2CNF_BASE_VALUE | (~PERIF & T2CNF_IF_BITS);
   \   000020   75C3A3       MOV     0xc3,#-0x5d
    467            }
    468          }
   \                     ??macMcuTimer2Isr_1:
   \   000023   7F01         MOV     R7,#0x1
   \   000025   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000028                REQUIRE T2PEROF2
   \   000028                REQUIRE T2CNF
    469          
    470          
    471          /**************************************************************************************************
    472           * @fn          macMcuOrT2PEROF2
    473           *
    474           * @brief       This function is used to OR the interrupt mask bits in register T2PERFOF2.
    475           *              Because of the hardware design a shadow register is required to preserve the
    476           *              other bits in this register.  See the declaration of variable shadowPerof2 above
    477           *              for a full description.
    478           *
    479           * @param       orValue - value to OR register with
    480           *
    481           * @return      none
    482           **************************************************************************************************
    483           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    484          void macMcuOrT2PEROF2(uint8 orValue)
   \                     macMcuOrT2PEROF2:
    485          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    486            halIntState_t  s;
    487          
    488            MAC_ASSERT(!(orValue & PEROF2_BITS)); /* only interrupt mask bits should be affected */
   \   000007   740F         MOV     A,#0xf
   \   000009   5E           ANL     A,R6
   \   00000A   6003         JZ      ??macMcuOrT2PEROF2_0
   \   00000C                ; Setup parameters for call to function halAssertHandler
   \   00000C   12....       LCALL   ??halAssertHandler?relay
    489          
    490            /*
    491             *  Perform OR operation only on interrupt mask bits.  The shadow register preserves
    492             *  the value previously written to the other bits in the register.
    493             */
    494            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macMcuOrT2PEROF2_0:
   \   00000F   A2AF         MOV     C,0xa8.7
   \   000011   E4           CLR     A
   \   000012   92E0         MOV     0xE0 /* A   */.0,C
   \   000014   FF           MOV     R7,A
   \   000015   C2AF         CLR     0xa8.7
    495            T2PEROF2 = ((T2PEROF2 & ~PEROF2_BITS) | orValue) | shadowPerof2;
   \   000017   90....       MOV     DPTR,#shadowPerof2
   \   00001A   74F0         MOV     A,#-0x10
   \   00001C   559E         ANL     A,0x9e
   \   00001E   4E           ORL     A,R6
   \   00001F   FA           MOV     R2,A
   \   000020   E0           MOVX    A,@DPTR
   \   000021   4A           ORL     A,R2
   \   000022   F59E         MOV     0x9e,A
    496            T2PEROF2 = ((T2PEROF2 & ~PEROF2_BITS) | orValue) | shadowPerof2;  /* writing twice is chip bug workaround */
   \   000024   90....       MOV     DPTR,#shadowPerof2
   \   000027   74F0         MOV     A,#-0x10
   \   000029   559E         ANL     A,0x9e
   \   00002B   4E           ORL     A,R6
   \   00002C   FA           MOV     R2,A
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   4A           ORL     A,R2
   \   00002F   F59E         MOV     0x9e,A
    497            HAL_EXIT_CRITICAL_SECTION(s);
   \   000031   EF           MOV     A,R7
   \   000032   A2E0         MOV     C,0xE0 /* A   */.0
   \   000034   92AF         MOV     0xa8.7,C
    498          }
   \   000036   7F01         MOV     R7,#0x1
   \   000038   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00003B                REQUIRE T2PEROF2
   \   00003B                REQUIRE _A_IEN0
    499          
    500          
    501          /**************************************************************************************************
    502           * @fn          macMcuAndT2PEROF2
    503           *
    504           * @brief       This function is used to AND the interrupt mask bits in register T2PERFOF2.
    505           *              Because of the hardware design a shadow register is required to preserve the
    506           *              other bits in this register.  See the declaration of variable shadowPerof2 above
    507           *              for a full description.
    508           *
    509           * @param       andValue - value to AND register with
    510           *
    511           * @return      none
    512           **************************************************************************************************
    513           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    514          void macMcuAndT2PEROF2(uint8 andValue)
   \                     macMcuAndT2PEROF2:
    515          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    516            halIntState_t  s;
    517          
    518            MAC_ASSERT((andValue & PEROF2_BITS) == PEROF2_BITS); /* only interrupt mask bits should be affected */
   \   000007   740F         MOV     A,#0xf
   \   000009   5E           ANL     A,R6
   \   00000A   640F         XRL     A,#0xf
   \   00000C   6003         JZ      ??macMcuAndT2PEROF2_0
   \   00000E                ; Setup parameters for call to function halAssertHandler
   \   00000E   12....       LCALL   ??halAssertHandler?relay
    519          
    520            /*
    521             *  Perform AND operation only on interrupt mask bits.  The shadow register preserves
    522             *  the value previously written to the other bits in the register.
    523             */
    524            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macMcuAndT2PEROF2_0:
   \   000011   A2AF         MOV     C,0xa8.7
   \   000013   E4           CLR     A
   \   000014   92E0         MOV     0xE0 /* A   */.0,C
   \   000016   FF           MOV     R7,A
   \   000017   C2AF         CLR     0xa8.7
    525            T2PEROF2 = ((T2PEROF2 & ~PEROF2_BITS) & andValue) | shadowPerof2;
   \   000019   90....       MOV     DPTR,#shadowPerof2
   \   00001C   E59E         MOV     A,0x9e
   \   00001E   5E           ANL     A,R6
   \   00001F   54F0         ANL     A,#0xf0
   \   000021   FA           MOV     R2,A
   \   000022   E0           MOVX    A,@DPTR
   \   000023   4A           ORL     A,R2
   \   000024   F59E         MOV     0x9e,A
    526            T2PEROF2 = ((T2PEROF2 & ~PEROF2_BITS) & andValue) | shadowPerof2;  /* writing twice is chip bug workaround */
   \   000026   90....       MOV     DPTR,#shadowPerof2
   \   000029   E59E         MOV     A,0x9e
   \   00002B   5E           ANL     A,R6
   \   00002C   54F0         ANL     A,#0xf0
   \   00002E   FA           MOV     R2,A
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   4A           ORL     A,R2
   \   000031   F59E         MOV     0x9e,A
    527            HAL_EXIT_CRITICAL_SECTION(s);
   \   000033   EF           MOV     A,R7
   \   000034   A2E0         MOV     C,0xE0 /* A   */.0
   \   000036   92AF         MOV     0xa8.7,C
    528          }
   \   000038   7F01         MOV     R7,#0x1
   \   00003A   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00003D                REQUIRE T2PEROF2
   \   00003D                REQUIRE _A_IEN0
    529          
    530          
    531          /**************************************************************************************************
    532           * @fn          macMcuRfIsr
    533           *
    534           * @brief       Interrupt service routine that handles all RF interrupts.  There are a number
    535           *              of conditions "ganged" onto this one ISR so each condition must be tested for.
    536           *
    537           * @param       none
    538           *
    539           * @return      none
    540           **************************************************************************************************
    541           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    542          HAL_ISR_FUNCTION( macMcuRfIsr, RF_VECTOR )
   \                     macMcuRfIsr:
    543          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    544            uint8 rfim;
    545          
    546            rfim = RFIM;
   \   000007   E591         MOV     A,0x91
   \   000009   FE           MOV     R6,A
    547          
    548            if ((RFIF & IRQ_CSP_INT) & rfim)
   \   00000A   EE           MOV     A,R6
   \   00000B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000D   C0D0         PUSH    PSW
   \   00000F   E5E9         MOV     A,0xe9
   \   000011   A2E0         MOV     C,0xE0 /* A   */.0
   \   000013   92F0         MOV     B.0,C
   \   000015   12....       LCALL   ?POP_BIT_ISP
   \   000018   1581         DEC     SP
   \   00001A   82F0         ANL     C,B.0
   \   00001C   5008         JNC     ??macMcuRfIsr_0
    549            {
    550              /*
    551               *  Important!  Because of how the CSP programs are written, CSP_INT interrupts should
    552               *  be processed before CSP_STOP interrupts.  This becomes an issue when there are
    553               *  long critical sections.
    554               */
    555              /* clear flag */
    556              RFIF = ~IRQ_CSP_INT;
   \   00001E   75E9FE       MOV     0xe9,#-0x2
    557              macCspTxIntIsr();
   \   000021                ; Setup parameters for call to function macCspTxIntIsr
   \   000021   12....       LCALL   ??macCspTxIntIsr?relay
   \   000024   8037         SJMP    ??macMcuRfIsr_1
    558            }
    559            else if ((RFIF & IRQ_CSP_STOP) & rfim)
   \                     ??macMcuRfIsr_0:
   \   000026   E5E9         MOV     A,0xe9
   \   000028   5E           ANL     A,R6
   \   000029   5402         ANL     A,#0x2
   \   00002B   6008         JZ      ??macMcuRfIsr_2
    560            {
    561              /* clear flag */
    562              RFIF = ~IRQ_CSP_STOP;
   \   00002D   75E9FD       MOV     0xe9,#-0x3
    563              macCspTxStopIsr();
   \   000030                ; Setup parameters for call to function macCspTxStopIsr
   \   000030   12....       LCALL   ??macCspTxStopIsr?relay
   \   000033   8028         SJMP    ??macMcuRfIsr_1
    564            }
    565            else if ((RFIF & IRQ_TXDONE) & rfim)
   \                     ??macMcuRfIsr_2:
   \   000035   E5E9         MOV     A,0xe9
   \   000037   5E           ANL     A,R6
   \   000038   5440         ANL     A,#0x40
   \   00003A   600C         JZ      ??macMcuRfIsr_3
    566            {
    567              /* disable interrupt - set up is for "one shot" operation */
    568              HAL_DISABLE_INTERRUPTS();
   \   00003C   C2AF         CLR     0xa8.7
    569              RFIM &= ~IM_TXDONE;
   \   00003E   5391BF       ANL     0x91,#0xbf
    570              HAL_ENABLE_INTERRUPTS();
   \   000041   D2AF         SETB    0xa8.7
    571              macRxAckTxDoneCallback();
   \   000043                ; Setup parameters for call to function macRxAckTxDoneCallback
   \   000043   12....       LCALL   ??macRxAckTxDoneCallback?relay
   \   000046   8015         SJMP    ??macMcuRfIsr_1
    572            }
    573            else if ((RFIF & IRQ_FIFOP) & rfim)
   \                     ??macMcuRfIsr_3:
   \   000048   E5E9         MOV     A,0xe9
   \   00004A   5E           ANL     A,R6
   \   00004B   5420         ANL     A,#0x20
   \   00004D   600E         JZ      ??macMcuRfIsr_1
    574            {
    575              /* continue to execute interrupt handler as long as FIFOP is active */
    576              do
    577              {
    578                macRxThresholdIsr();
   \                     ??macMcuRfIsr_4:
   \   00004F                ; Setup parameters for call to function macRxThresholdIsr
   \   00004F   12....       LCALL   ??macRxThresholdIsr?relay
    579                RFIF = ~IRQ_FIFOP;
   \   000052   75E9DF       MOV     0xe9,#-0x21
    580              } while (RFSTATUS & FIFOP);
   \   000055   90DF62       MOV     DPTR,#-0x209e
   \   000058   E0           MOVX    A,@DPTR
   \   000059   A2E2         MOV     C,0xE0 /* A   */.2
   \   00005B   40F2         JC      ??macMcuRfIsr_4
    581            }
    582          
    583            S1CON = 0x00;
   \                     ??macMcuRfIsr_1:
   \   00005D   759B00       MOV     0x9b,#0x0
    584            RFIF = 0xFF;
   \   000060   75E9FF       MOV     0xe9,#-0x1
    585          }
   \   000063   7F01         MOV     R7,#0x1
   \   000065   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000068                REQUIRE RFIM
   \   000068                REQUIRE S1CON
   \   000068                REQUIRE _A_IEN0
   \   000068                REQUIRE RFIF
    586          
    587          
    588          /**************************************************************************************************
    589           * @fn          macMcuRecordMaxRssiStart
    590           *
    591           * @brief       Starts recording of the maximum received RSSI value.
    592           *
    593           * @param       none
    594           *
    595           * @return      none
    596           **************************************************************************************************
    597           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    598          void macMcuRecordMaxRssiStart(void)
   \                     macMcuRecordMaxRssiStart:
    599          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    600            /* start maximum recorded value at the lowest possible value */
    601            maxRssi = -128;
   \   000004   7480         MOV     A,#-0x80
   \   000006   90....       MOV     DPTR,#maxRssi
   \   000009   F0           MOVX    @DPTR,A
    602          
    603            /* enable timer overflow interrupt */
    604            macMcuOrT2PEROF2(PERIM);
   \   00000A                ; Setup parameters for call to function macMcuOrT2PEROF2
   \   00000A   7940         MOV     R1,#0x40
   \   00000C   12....       LCALL   ??macMcuOrT2PEROF2?relay
    605          }
   \   00000F   D083         POP     DPH
   \   000011   D082         POP     DPL
   \   000013   02....       LJMP    ?BRET
    606          
    607          
    608          /**************************************************************************************************
    609           * @fn          macMcuRecordMaxRssiStop
    610           *
    611           * @brief       Stops recording of the maximum received RSSI.  It returns the maximum value
    612           *              received since starting the recording.
    613           *
    614           * @param       none
    615           *
    616           * @return      maximum received RSSI value
    617           **************************************************************************************************
    618           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    619          int8 macMcuRecordMaxRssiStop(void)
   \                     macMcuRecordMaxRssiStop:
    620          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    621            /* disable timer overflow interrupt */
    622            macMcuAndT2PEROF2(~PERIM);
   \   000004                ; Setup parameters for call to function macMcuAndT2PEROF2
   \   000004   79BF         MOV     R1,#-0x41
   \   000006   12....       LCALL   ??macMcuAndT2PEROF2?relay
    623          
    624            return(maxRssi);
   \   000009   90....       MOV     DPTR,#maxRssi
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   D083         POP     DPH
   \   000010   D082         POP     DPL
   \   000012   02....       LJMP    ?BRET
    625          }
    626          
    627          
    628          /*=================================================================================================
    629           * @fn          macMcuRecordMaxRssiIsr
    630           *
    631           * @brief       Interrupt service routine called during recording of max RSSI value.
    632           *
    633           * @param       none
    634           *
    635           * @return      none
    636           *=================================================================================================
    637           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    638          static void mcuRecordMaxRssiIsr(void)
   \                     mcuRecordMaxRssiIsr:
    639          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    640            int8 rssi;
    641          
    642            /* read latest RSSI value */
    643            rssi = RSSIL;
   \   000004   90DF07       MOV     DPTR,#-0x20f9
   \   000007   E0           MOVX    A,@DPTR
   \   000008   FA           MOV     R2,A
    644          
    645            /* if new RSSI value is greater than the maximum already received, it is the new maximum */
    646            if (rssi > maxRssi)
   \   000009   90....       MOV     DPTR,#maxRssi
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   C3           CLR     C
   \   00000E   9A           SUBB    A,R2
   \   00000F   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000011   65D0         XRL     A,PSW
   \   000013   33           RLC     A
   \   000014   5005         JNC     ??mcuRecordMaxRssiIsr_0
    647            {
    648              maxRssi = rssi;
   \   000016   EA           MOV     A,R2
   \   000017   90....       MOV     DPTR,#maxRssi
   \   00001A   F0           MOVX    @DPTR,A
    649            }
    650          }
   \                     ??mcuRecordMaxRssiIsr_0:
   \   00001B   D083         POP     DPH
   \   00001D   D082         POP     DPL
   \   00001F   02....       LJMP    ?BRET

   \                                 In  segment INTVEC, offset 0x53, root
   \                     `??macMcuTimer2Isr??INTVEC 83`:
   \   000053   02....       LJMP       (macMcuTimer2Isr)

   \                                 In  segment INTVEC, offset 0x83, root
   \                     `??macMcuRfIsr??INTVEC 131`:
   \   000083   02....       LJMP       (macMcuRfIsr)

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuRandomByte?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRandomByte

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuTimerCount?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimerCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuTimerCapture?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimerCapture

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowCount?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowCapture?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowCapture

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowSetCount?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowSetCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowSetCompare?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowSetCompare

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOrT2PEROF2?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOrT2PEROF2

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuAndT2PEROF2?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuAndT2PEROF2

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuRecordMaxRssiStart?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRecordMaxRssiStart

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuRecordMaxRssiStop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRecordMaxRssiStop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mcuRecordMaxRssiIsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mcuRecordMaxRssiIsr
    651          
    652          
    653          
    654          /**************************************************************************************************
    655           *                                  Compile Time Integrity Checks
    656           **************************************************************************************************
    657           */
    658          #if ((IRQ_SFD != IM_SFD) || (IRQ_FIFOP != IM_FIFOP) || (IRQ_TXDONE != IM_TXDONE))
    659          #error "ERROR: Compile time error with RFIF vs RFIM register defines."
    660          #endif
    661          
    662          #if ((OFCMPIF != OFCMPIM) || (PERIF != PERIM) || (CMPIF != CMPIM))
    663          #error "ERROR: Compile time error with T2CNF vs T2PEROF2 register defines."
    664          #endif
    665          
    666          
    667          /**************************************************************************************************
    668          */

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     macMcuAndT2PEROF2                  0      0      9
       -> halAssertHandler              0      0     18
     macMcuInit                         2      0      0
       -> halAssertHandler              4      0      0
       -> macRxOn                       4      0      0
       -> macRxOff                      4      0      0
     macMcuOrT2PEROF2                   0      0      9
       -> halAssertHandler              0      0     18
     macMcuOverflowCapture              1      0     16
     macMcuOverflowCount                1      0     16
     macMcuOverflowSetCompare           0      0     16
       -> halAssertHandler              0      0     32
     macMcuOverflowSetCount             0      0     16
       -> halAssertHandler              0      0     32
     macMcuRandomByte                   0      0      0
     macMcuRecordMaxRssiStart           2      0      0
       -> macMcuOrT2PEROF2              4      0      0
     macMcuRecordMaxRssiStop            2      0      0
       -> macMcuAndT2PEROF2             4      0      0
     macMcuRfIsr                       16      0      0
       -> macCspTxIntIsr               30      0      0
       -> macCspTxStopIsr              30      0      0
       -> macRxAckTxDoneCallback       30      0      0
       -> macRxThresholdIsr            30      0      0
     macMcuTimer2Isr                   15      0      0
       -> macBackoffTimerCompareIsr    30      0      0
       -> mcuRecordMaxRssiIsr          30      0      0
     macMcuTimerCapture                 2      0      0
     macMcuTimerCount                   3      0      1
     mcuRecordMaxRssiIsr                2      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     RFIM                              1
     IEN2                              1
     S1CON                             1
     T2PEROF0                          1
     T2PEROF1                          1
     T2PEROF2                          1
     T2OF0                             1
     T2OF1                             1
     T2OF2                             1
     T2CAPLPL                          1
     T2CAPHPH                          1
     T2TLD                             1
     T2THD                             1
     _A_IEN0                           1
     IP0                               1
     ADCCON1                           1
     _A_IEN1                           1
     IP1                               1
     RNDL                              1
     RNDH                              1
     T2CNF                             1
     RFIF                              1
     maxRssi                           1
     shadowPerof2                      1
     macMcuInit                      181
     macMcuRandomByte                 13
     macMcuTimerCount                 32
     macMcuTimerCapture               34
     macMcuOverflowCount              84
     macMcuOverflowCapture            86
     macMcuOverflowSetCount          103
     macMcuOverflowSetCompare        172
     macMcuTimer2Isr                  40
     macMcuOrT2PEROF2                 59
     macMcuAndT2PEROF2                61
     macMcuRfIsr                     104
     macMcuRecordMaxRssiStart         22
     macMcuRecordMaxRssiStop          21
     mcuRecordMaxRssiIsr              34
     ??macMcuTimer2Isr??INTVEC 83      3
     ??macMcuRfIsr??INTVEC 131         3
     ??macMcuInit?relay                6
     ??macMcuRandomByte?relay          6
     ??macMcuTimerCount?relay          6
     ??macMcuTimerCapture?relay        6
     ??macMcuOverflowCount?relay       6
     ??macMcuOverflowCapture?relay     6
     ??macMcuOverflowSetCount?relay    6
     ??macMcuOverflowSetCompare?relay
                                       6
     ??macMcuOrT2PEROF2?relay          6
     ??macMcuAndT2PEROF2?relay         6
     ??macMcuRecordMaxRssiStart?relay
                                       6
     ??macMcuRecordMaxRssiStop?relay
                                       6
     ??mcuRecordMaxRssiIsr?relay       6

 
 902 bytes in segment BANKED_CODE
  78 bytes in segment BANK_RELAYS
   6 bytes in segment INTVEC
 144 bytes in segment NEAR_CODE
  22 bytes in segment SFR_AN
   2 bytes in segment XDATA_Z
 
 1 124 bytes of CODE  memory (+  6 bytes shared)
     0 bytes of DATA  memory (+ 22 bytes shared)
     2 bytes of XDATA memory

Errors: none
Warnings: none

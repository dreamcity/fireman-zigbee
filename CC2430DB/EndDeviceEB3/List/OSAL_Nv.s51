///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR 8051 C/C++ Compiler V7.30B/W32                   18/Mar/2013  18:21:46 /
// Copyright 2004-2007 IAR Systems. All rights reserved.                      /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data                                              /
//    Dptr setup         =  1,16                                              /
//    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Component /
//                          s\osal\mcu\ccsoc\OSAL_Nv.c                        /
//    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Proje /
//                          cts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB /
//                          \..\..\..\Tools\CC2430DB\f8wEndev.cfg"            /
//                          (-DCPU32MHZ -DFORCE_MAC_NEAR -DROOT=__near_func   /
//                          -DMAC_OPT_FFD=0 -DBLINK_LEDS "-DCONST=const       /
//                          __code" -DGENERIC=__generic) -f "C:\Texas         /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\Too /
//                          ls\CC2430DB\f8wConfig.cfg" (-DSECURE=0            /
//                          -DDEFAULT_CHANLIST=0x00000800                     /
//                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3  /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20          /
//                          -DNWK_MAX_BINDING_ENTRIES=10                      /
//                          -DMAX_BINDING_CLUSTER_IDS=5                       /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   /
//                          0x0A, 0x0C, 0x0D}" -DRFD_RCVC_ALWAYS_ON=FALSE     /
//                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100           /
//                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440  /
//                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Componen /
//                          ts\osal\mcu\ccsoc\OSAL_Nv.c" -D CC2430EB -D       /
//                          AXD_END3 -D NWK_AUTO_POLL -D REFLECTOR -D         /
//                          xZTOOL_P1 -D xMT_TASK -D xMT_ZDO_FUNC -D          /
//                          xLCD_SUPPORTED=DEBUG -D xPOWER_SAVING -lC         /
//                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects /
//                          \zstack\Samples\cc2430-zstack-adxl345\CC2430DB\En /
//                          dDeviceEB3\List\" -lA "C:\Texas                   /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\EndDeviceEB3 /
//                          \List\" --diag_suppress Pe001,Pa010               /
//                          --diag_remark pe550 -o "C:\Texas                  /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\EndDeviceEB3 /
//                          \Obj\" -e --require_prototypes -z2 --no_cse       /
//                          --no_unroll --no_inline --no_code_motion          /
//                          --no_tbaa --debug --core=plain --dptr=16,1        /
//                          --data_model=large --code_model=banked            /
//                          --calling_convention=xdata_reentrant              /
//                          --place_constants=data --nr_virtual_regs 8 -I     /
//                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects /
//                          \zstack\Samples\cc2430-zstack-adxl345\CC2430DB\"  /
//                          -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Proje /
//                          cts\zstack\Samples\cc2430-zstack-adxl345\CC2430DB /
//                          \..\SOURCE\" -I "C:\Texas                         /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\Drivers\" /
//                           -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Proj /
//                          ects\zstack\Samples\cc2430-zstack-adxl345\CC2430D /
//                          B\..\..\..\ZMAIN\TI2430DB\" -I "C:\Texas          /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\MT\" -I "C:\Texas                   /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\HAL\INCLUDE\" -I "C:\Texas          /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\HAL\TARGET\CC2430EB\" -I "C:\Texas  /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas       /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\OSAL\INCLUDE\" -I "C:\Texas         /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\STACK\AF\" -I "C:\Texas             /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\STACK\NWK\" -I "C:\Texas            /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\STACK\SEC\" -I "C:\Texas            /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\STACK\SYS\" -I "C:\Texas            /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\STACK\ZDO\" -I "C:\Texas            /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\ZMAC\F8W\" -I "C:\Texas             /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\ZMAC\" -I "C:\Texas                 /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\SERVICES\SADDR\" -I "C:\Texas       /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\SERVICES\SDATA\" -I "C:\Texas       /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\MAC\INCLUDE\" -I "C:\Texas          /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\MAC\HIGH_LEVEL\" -I "C:\Texas       /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas  /
//                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sa /
//                          mples\cc2430-zstack-adxl345\CC2430DB\..\..\..\..\ /
//                          ..\COMPONENTS\MAC\LOW_LEVEL\SRF03\SINGLE_CHIP\"   /
//                          -I "C:\Program Files\IAR Systems\Embedded         /
//                          Workbench 4.0 Evaluation version\8051\INC\" -I    /
//                          "C:\Program Files\IAR Systems\Embedded Workbench  /
//                          4.0 Evaluation version\8051\INC\CLIB\"            /
//    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ /
//                          zstack\Samples\cc2430-zstack-adxl345\CC2430DB\End /
//                          DeviceEB3\List\OSAL_Nv.s51                        /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME OSAL_Nv

        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ??calcChkB?relay
        EXTERN ??calcChkF?relay
        EXTERN ??compactPage?relay
        EXTERN ??erasePage?relay
        EXTERN ??findItem?relay
        EXTERN ??initItem?relay
        EXTERN ??initNV?relay
        EXTERN ??initPage?relay
        EXTERN ??setItem?relay
        EXTERN ??setPageUse?relay
        EXTERN ??writeBuf?relay
        EXTERN ??writeIEEE?relay
        EXTERN ??writeItem?relay
        EXTERN ??writeWord?relay
        EXTERN ??writeWordH?relay
        EXTERN ??writeWordM?relay
        EXTERN ??xferBuf?relay
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?PUSH_XSTACK8_X_TWO
        EXTERN ?PUSH_XSTACK_I_ONE
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?S_SHL
        EXTERN ?US_DIV_MOD
        EXTERN ?US_SHR
        EXTERN ?V0
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN __INIT_XDATA_Z

        FUNCTION ??calcChkB?relay,0203H
        FUNCTION ??calcChkF?relay,0203H
        FUNCTION ??compactPage?relay,0203H
        FUNCTION ??erasePage?relay,0203H
        FUNCTION ??findItem?relay,0203H
        FUNCTION ??initItem?relay,0203H
        FUNCTION ??initNV?relay,0203H
        FUNCTION ??initPage?relay,0203H
        PUBLIC ??osal_nv_init?relay
        FUNCTION ??osal_nv_init?relay,0203H
        PUBLIC ??osal_nv_item_init?relay
        FUNCTION ??osal_nv_item_init?relay,0203H
        PUBLIC ??osal_nv_item_len?relay
        FUNCTION ??osal_nv_item_len?relay,0203H
        PUBLIC ??osal_nv_read?relay
        FUNCTION ??osal_nv_read?relay,0203H
        PUBLIC ??osal_nv_write?relay
        FUNCTION ??osal_nv_write?relay,0203H
        FUNCTION ??setItem?relay,0203H
        FUNCTION ??setPageUse?relay,0203H
        FUNCTION ??writeBuf?relay,0203H
        FUNCTION ??writeIEEE?relay,0203H
        FUNCTION ??writeItem?relay,0203H
        FUNCTION ??writeWord?relay,0203H
        FUNCTION ??writeWordH?relay,0203H
        FUNCTION ??writeWordM?relay,0203H
        FUNCTION ??xferBuf?relay,0203H
        PUBWEAK FADDRH
        PUBWEAK FCTL
        PUBWEAK FWT
        PUBWEAK _A_IEN0
        FUNCTION calcChkB,0203H
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 12, STACK
        FUNCTION calcChkF,021203H
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 20, STACK
        FUNCTION compactPage,021203H
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 28, STACK
        FUNCTION erasePage,0a1203H
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 18, STACK
        FUNCTION findItem,021203H
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 14, STACK
        PUBLIC flashXdataBuf
        FUNCTION initItem,021203H
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 23, STACK
        FUNCTION initNV,021203H
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 30, STACK
        FUNCTION initPage,021203H
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 28, STACK
        PUBLIC osal_nv_init
        FUNCTION osal_nv_init,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        PUBLIC osal_nv_item_init
        FUNCTION osal_nv_item_init,021203H
        ARGFRAME XSTACK, 2, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC osal_nv_item_len
        FUNCTION osal_nv_item_len,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        PUBLIC osal_nv_read
        FUNCTION osal_nv_read,021203H
        ARGFRAME XSTACK, 4, STACK
        LOCFRAME XSTACK, 18, STACK
        PUBLIC osal_nv_write
        FUNCTION osal_nv_write,021203H
        ARGFRAME XSTACK, 4, STACK
        LOCFRAME ISTACK, 4, STACK
        LOCFRAME XSTACK, 41, STACK
        FUNCTION setItem,021203H
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 22, STACK
        FUNCTION setPageUse,021203H
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 17, STACK
        FUNCTION writeBuf,021203H
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 20, STACK
        FUNCTION writeIEEE,021203H
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 18, STACK
        FUNCTION writeItem,021203H
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 29, STACK
        FUNCTION writeWord,021203H
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 14, STACK
        FUNCTION writeWordH,021203H
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 16, STACK
        FUNCTION writeWordM,021203H
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 14, STACK
        FUNCTION xferBuf,021203H
        ARGFRAME XSTACK, 41, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 22, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP DATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource SP:8, PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
HalAdcCheckVdd      SYMBOL "HalAdcCheckVdd"
??HalAdcCheckVdd?relay SYMBOL "?relay", HalAdcCheckVdd
osal_nv_init        SYMBOL "osal_nv_init"
??osal_nv_init?relay SYMBOL "?relay", osal_nv_init
osal_nv_item_init   SYMBOL "osal_nv_item_init"
??osal_nv_item_init?relay SYMBOL "?relay", osal_nv_item_init
osal_nv_item_len    SYMBOL "osal_nv_item_len"
??osal_nv_item_len?relay SYMBOL "?relay", osal_nv_item_len
osal_nv_read        SYMBOL "osal_nv_read"
??osal_nv_read?relay SYMBOL "?relay", osal_nv_read
osal_nv_write       SYMBOL "osal_nv_write"
??osal_nv_write?relay SYMBOL "?relay", osal_nv_write

        EXTERN nvReadHdr
        FUNCTION nvReadHdr,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN HalAdcCheckVdd
        FUNCTION HalAdcCheckVdd,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN nvReadWord
        FUNCTION nvReadWord,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN flashWriteBuf
        FUNCTION flashWriteBuf,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN nvReadByte
        FUNCTION nvReadByte,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN nvReadBuf
        FUNCTION nvReadBuf,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN ??HalAdcCheckVdd?relay
        FUNCTION ??HalAdcCheckVdd?relay,00H

// C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\osal\mcu\ccsoc\OSAL_Nv.c
//    1 /**************************************************************************************************
//    2   Filename:       OSAL_Nv.c
//    3   Revised:        $Date: 2007-10-28 18:43:04 -0700 (Sun, 28 Oct 2007) $
//    4   Revision:       $Revision: 15800 $
//    5 
//    6   Description:    This module contains the OSAL non-volatile memory functions.
//    7 
//    8 
//    9   Copyright 2007 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /**************************************************************************************************
//   41   Notes:
//   42     - A trick buried deep in initPage() requires that the MSB of the NV Item Id is to
//   43       be reserved for use by this module.
//   44     - Due to .s51 code and code-size saving tricks, the max NV item size is 1024 bytes.
//   45 **************************************************************************************************/
//   46 
//   47 /*********************************************************************
//   48  * INCLUDES
//   49  */
//   50 
//   51 #include "ZComDef.h"
//   52 #include "hal_adc.h"

        ASEGN SFR_AN:DATA:NOROOT,0a8H
// union <unnamed> volatile __sfr _A_IEN0
_A_IEN0:
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0abH
// unsigned char volatile __sfr FWT
FWT:
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0adH
// unsigned char volatile __sfr FADDRH
FADDRH:
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0aeH
// unsigned char volatile __sfr FCTL
FCTL:
        DS 1
//   53 #include "osal.h"
//   54 #include "OSAL_Nv.h"
//   55 #include <ioCC2430.h>
//   56 
//   57 /*********************************************************************
//   58  * CONSTANTS
//   59  */
//   60 
//   61 #define OSAL_NV_ACTIVE          0x00
//   62 #define OSAL_NV_ERASED          0xFF
//   63 #define OSAL_NV_ERASED_ID       0xFFFF
//   64 #define OSAL_NV_ZEROED_ID       0x0000
//   65 // Reserve MSB of Id to signal a search for the "old" source copy (new write interrupted/failed.)
//   66 #define OSAL_NV_SOURCE_ID       0x8000
//   67 
//   68 #define OSAL_NV_PAGE_FREE      (OSAL_NV_PAGE_SIZE - Z_EXTADDR_LEN)
//   69 
//   70 /* The last Flash page will reserve an IEEE addr block at the end of the page where the tools know
//   71  * to program the IEEE.
//   72  */
//   73 #define OSAL_NV_IEEE_OFFSET    (OSAL_NV_PAGE_SIZE - Z_EXTADDR_LEN)
//   74 #define OSAL_NV_IEEE_PAGE       63
//   75 
//   76 // In case pages 0-1 are ever used, define a null page value.
//   77 #define OSAL_NV_PAGE_NULL       0
//   78 
//   79 // In case item Id 0 is ever used, define a null item value.
//   80 #define OSAL_NV_ITEM_NULL       0
//   81 
//   82 #define OSAL_NV_WORD_SIZE       4
//   83 
//   84 #define OSAL_NV_PAGE_HDR_OFFSET 0
//   85 
//   86 /*********************************************************************
//   87  * MACROS
//   88  */
//   89 
//   90 #define  OSAL_NV_CHECK_BUS_VOLTAGE  (HalAdcCheckVdd( HAL_ADC_VDD_LIMIT_4 ))
//   91 
//   92 #define OSAL_NV_DATA_SIZE( LEN )  \ 
//   93    ((((LEN) + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE)
//   94 
//   95 #define OSAL_NV_ITEM_SIZE( LEN )  \ 
//   96   (((((LEN) + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE) + OSAL_NV_HDR_SIZE)
//   97 
//   98 /*********************************************************************
//   99  * TYPEDEFS
//  100  */
//  101 
//  102 typedef struct
//  103 {
//  104   uint16 id;
//  105   uint16 len;   // Enforce Flash-WORD size on len.
//  106   uint16 chk;   // Byte-wise checksum of the 'len' data bytes of the item.
//  107   uint16 stat;  // Item status.
//  108 } osalNvHdr_t;
//  109 // Struct member offsets.
//  110 #define OSAL_NV_HDR_ID    0
//  111 #define OSAL_NV_HDR_LEN   2
//  112 #define OSAL_NV_HDR_CHK   4
//  113 #define OSAL_NV_HDR_STAT  6
//  114 
//  115 #define OSAL_NV_HDR_ITEM  2  // Length of any item of a header struct.
//  116 #define OSAL_NV_HDR_SIZE  8
//  117 #define OSAL_NV_HDR_HALF (OSAL_NV_HDR_SIZE / 2)
//  118 
//  119 typedef struct
//  120 {
//  121   uint16 active;
//  122   uint16 inUse;
//  123   uint16 xfer;
//  124   uint16 spare;
//  125 } osalNvPgHdr_t;
//  126 // Struct member offsets.
//  127 #define OSAL_NV_PG_ACTIVE 0
//  128 #define OSAL_NV_PG_INUSE  2
//  129 #define OSAL_NV_PG_XFER   4
//  130 #define OSAL_NV_PG_SPARE  6
//  131 
//  132 #define OSAL_NV_PAGE_HDR_SIZE  8
//  133 #define OSAL_NV_PAGE_HDR_HALF (OSAL_NV_PAGE_HDR_SIZE / 2)
//  134 
//  135 typedef enum
//  136 {
//  137   eNvXfer,
//  138   eNvZero
//  139 } eNvHdrEnum;
//  140 
//  141 typedef enum
//  142 {
//  143   ePgActive,
//  144   ePgInUse,
//  145   ePgXfer,
//  146   ePgSpare
//  147 } ePgHdrEnum;
//  148 
//  149 /*********************************************************************
//  150  * GLOBAL VARIABLES
//  151  */
//  152 
//  153 /* This can be placed in the non-retention RAM - the assembly routine is copied from Flash to XDATA
//  154  * on every call. If enough retention RAM is available, or if on a mains-powered device, could
//  155  * easily change to copy Flash to XDATA only on initialization.
//  156  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  157 uint8 __xdata flashXdataBuf[22];
flashXdataBuf:
        DS 22
        REQUIRE __INIT_XDATA_Z
//  158 
//  159 /*********************************************************************
//  160  * EXTERNAL FUNCTIONS
//  161  */
//  162 
//  163 /*********************************************************************
//  164  * @fn      nvRead...
//  165  *
//  166  * @brief   Reads a byte, OSAL_NV_WORD_SIZE, or OSAL_NV_HDR_SIZE bytes from NV.
//  167  *
//  168  * @param   pg - Valid NV page.
//  169  * @param   offset - Valid offset into the page.
//  170  * @param   buf - Valid buffer space at least as big as the read request.
//  171  *
//  172  * @return  none
//  173  */
//  174 extern __near_func void nvReadByte( uint8 pg, uint16 offset, uint8 *buf );
//  175 extern __near_func void nvReadWord( uint8 pg, uint16 offset, uint8 *buf );
//  176 extern __near_func void nvReadHdr(uint8 pg, uint16 offset, uint8 *buf);
//  177 
//  178 /*********************************************************************
//  179  * @fn      nvReadBuf
//  180  *
//  181  * @brief   Reads N bytes from NV.
//  182  *
//  183  * @param   pg - Valid NV page.
//  184  * @param   offset - Valid offset into the page.
//  185  * @param   buf - Valid buffer space at least as big as the read request.
//  186  * @param   cnt - Number of bytes to read.
//  187  *
//  188  * @return  none
//  189  */
//  190 extern __near_func void nvReadBuf(uint8 pg, uint16 offset, uint8 *buf, uint16 cnt);
//  191 
//  192 /*********************************************************************
//  193  * @fn      flashWriteBuf
//  194  *
//  195  * @brief   Writes N blocks of 4-bytes to NV.
//  196  *
//  197  * @param   cnt - Number of blocks of 4-bytes to write.
//  198  * @param   buf - Valid buffer space at least as big as the write request.
//  199  * @param   addr - Valid FADDRH/L address: 3-byte addr / 4 = 2-byte addr.
//  200  *
//  201  * @return  none
//  202  */
//  203 extern __near_func void flashWriteBuf(uint8 cnt, uint16 buf, uint16 addr);
//  204 
//  205 extern bool HalAdcCheckVdd(uint8 limit);
//  206 
//  207 /*********************************************************************
//  208  * LOCAL VARIABLES
//  209  */
//  210 
//  211 // Offset into the page of the first available erased space.

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  212 static uint16 pgOff[OSAL_NV_PAGES_USED];
pgOff:
        DS 4
        REQUIRE __INIT_XDATA_Z
//  213 
//  214 // Count of the bytes lost for the zeroed-out items.

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  215 static uint16 pgLost[OSAL_NV_PAGES_USED];
pgLost:
        DS 4
        REQUIRE __INIT_XDATA_Z
//  216 

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  217 static uint8 pgRes;  // Page reserved for item compacting transfer.
pgRes:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  218 
//  219 // Saving ~100 code bytes to move a uint8* parameter/return value from findItem() to a global.

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  220 static uint8 findPg;
findPg:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  221 
//  222 /* Immediately before the voltage critical operations of a page erase or
//  223  * a word write, check bus voltage. If less than min, set global flag & abort.
//  224  * Since this is to be done at the lowest level, many void functions would have to be changed to
//  225  * return a value and code added to check that value before proceeding, resulting in a very
//  226  * expensive code size hit for implementing this properly. Therefore, use this global as follows:
//  227  * at the start of osal_nv_item_init/osal_nv_write, set to FALSE, and at the end, before returning,
//  228  * check the value. Thus, the global is an accumulator of any error that occurred in any of the
//  229  * attempts to modify Flash with a low bus voltage during the complicated sequence of events that
//  230  * may occur on any item init or write. This is much more expedient and code saving than adding
//  231  * return values and checking return values to early out. No matter which method is used, an NV
//  232  * data record may end up mangled due to the low VCC conditions. The strategy is that the headers
//  233  * and checksums will detect and allow recovery from such a condition.
//  234  *
//  235  * One unfortunate side-effect of using the global fail flag vice adding and checking return
//  236  * values, is that when setting an item Id to zero has failed due to the low VCC check,
//  237  * the page lost-bytes counter is still updated. Having an artificially high lost-byte
//  238  * count makes it look like there are more bytes to recover from compacting a page than there may
//  239  * actually be. The easy work-around implemented is it to invoke initNV() from osal_nv_item_init or
//  240  * osal_nv_write anytime that the failF gets set - this will re-walk all of the pages and set the
//  241  * page offset count and page lost bytes count to their actual values.
//  242  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
//  243 static uint8 failF;
failF:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  244 
//  245 /*********************************************************************
//  246  * LOCAL FUNCTIONS
//  247  */
//  248 
//  249 static uint8  initNV( void );
//  250 
//  251 static void   setPageUse( uint8 pg, uint8 inUse );
//  252 static uint16 initPage( uint8 pg, uint16 id, uint8 findDups );
//  253 static void   erasePage( uint8 pg );
//  254 static void   compactPage( uint8 pg );
//  255 
//  256 static uint16 findItem( uint16 id );
//  257 static uint8  initItem( uint8 flag, uint16 id, uint16 len, void *buf );
//  258 static void   setItem( uint8 pg, uint16 offset, eNvHdrEnum stat );
//  259 
//  260 static uint16 calcChkB( uint16 len, uint8 *buf );
//  261 static uint16 calcChkF( byte pg, uint16 offset, uint16 len );
//  262 
//  263 static void   writeWord( uint8 pg, uint16 offset, uint8 *buf );
//  264 static void   writeWordH( uint8 pg, uint16 offset, uint8 *buf );
//  265 static void   writeWordM( uint8 pg, uint16 offset, uint8 *buf, uint8 cnt );
//  266 static void   writeBuf( uint8 pg, uint16 offset, uint16 len, uint8 *buf );
//  267 static void   xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len );
//  268 
//  269 static uint8  writeItem( uint8 pg, uint16 id, uint16 len, void *buf, uint8 flag );
//  270 
//  271 static uint8  writeIEEE( void *buf );
//  272 
//  273 /*********************************************************************
//  274  * @fn      initNV
//  275  *
//  276  * @brief   Initialize the NV flash pages.
//  277  *
//  278  * @param   none
//  279  *
//  280  * @return  TRUE
//  281  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  282 static uint8 initNV( void )
initNV:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function initNV
//  283 {
        FUNCALL initNV, nvReadHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, nvReadHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, setPageUse
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, initPage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, nvReadHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, writeWordM
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, writeWordM
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, setPageUse
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, compactPage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, erasePage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initNV, initNV
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xd
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 13)
        ; Saved register size: 13
        ; Auto size: 16
        MOV     A,#-0x10
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 29)
//  284   osalNvPgHdr_t pgHdr, ieee;
//  285   uint8 oldPg = OSAL_NV_PAGE_NULL;
        MOV     ?V0 + 0,#0x0
//  286   uint8 newPg = OSAL_NV_PAGE_NULL;
        MOV     R7,#0x0
//  287   uint8 findDups = FALSE;
        MOV     ?V0 + 4,#0x0
//  288   uint8 xBad;
//  289   uint8 pg;
//  290 
//  291   nvReadHdr( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee) );
        ; Setup parameters for call to function nvReadHdr
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#-0x8
        MOV     R3,#0x7
        MOV     R1,#0x3f
        LCALL   nvReadHdr & 0xFFFF
//  292   if ( (ieee.active == OSAL_NV_ERASED_ID) &&
//  293        (ieee.inUse == OSAL_NV_ERASED_ID) &&
//  294        (ieee.xfer == OSAL_NV_ERASED_ID) &&
//  295        (ieee.spare == OSAL_NV_ERASED_ID) )
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initNV_0
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initNV_0:
        JNZ     ??initNV_1
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initNV_2
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initNV_2:
        JNZ     ??initNV_1
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initNV_3
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initNV_3:
        JNZ     ??initNV_1
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initNV_4
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initNV_4:
        JNZ     ??initNV_1
//  296   {
//  297     xBad = TRUE;
        MOV     ?V0 + 1,#0x1
        SJMP    ??initNV_5
//  298   }
//  299   else
//  300   {
//  301     xBad = FALSE;
??initNV_1:
        MOV     ?V0 + 1,#0x0
//  302   }
//  303 
//  304   pgRes = OSAL_NV_PAGE_NULL;
??initNV_5:
        MOV     A,#0x0
        MOV     DPTR,#pgRes
        MOVX    @DPTR,A
//  305 
//  306   for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
        MOV     R6,#0x3c
??initNV_6:
        MOV     A,R6
        CLR     C
        SUBB    A,#0x3e
        JC      $+5
        LJMP    ??initNV_7 & 0xFFFF
//  307   {
//  308     nvReadHdr( pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8 *)(&pgHdr) );
        ; Setup parameters for call to function nvReadHdr
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x0
        MOV     R3,#0x0
        MOV     A,R6
        MOV     R1,A
        LCALL   nvReadHdr & 0xFFFF
//  309 
//  310     if ( pgHdr.active == OSAL_NV_ERASED_ID )
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initNV_8
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initNV_8:
        JNZ     ??initNV_9
//  311     {
//  312       if ( pgRes == OSAL_NV_PAGE_NULL )
        MOV     DPTR,#pgRes
        MOVX    A,@DPTR
        JNZ     ??initNV_10
//  313       {
//  314         pgRes = pg;
        MOV     A,R6
        MOV     DPTR,#pgRes
        MOVX    @DPTR,A
        SJMP    ??initNV_11
//  315       }
//  316       else
//  317       {
//  318         setPageUse( pg, TRUE );
??initNV_10:
        ; Setup parameters for call to function setPageUse
        MOV     R2,#0x1
        MOV     A,R6
        MOV     R1,A
        LCALL   ??setPageUse?relay
        SJMP    ??initNV_11
//  319       }
//  320     }
//  321     else  // Page is active.
//  322     {
//  323       // If the page is not yet in use, it is the tgt of items from an xfer.
//  324       if ( pgHdr.inUse == OSAL_NV_ERASED_ID )
??initNV_9:
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initNV_12
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initNV_12:
        JNZ     ??initNV_13
//  325       {
//  326         newPg = pg;
        MOV     A,R6
        MOV     R7,A
        SJMP    ??initNV_11
//  327       }
//  328       // An Xfer from this page was in progress.
//  329       else if ( pgHdr.xfer != OSAL_NV_ERASED_ID )
??initNV_13:
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initNV_14
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initNV_14:
        JZ      ??initNV_11
//  330       {
//  331         oldPg = pg;
        MOV     ?V0 + 0,R6
//  332       }
//  333     }
//  334 
//  335     // Calculate page offset and lost bytes - any "old" item triggers an N^2 re-scan from start.
//  336     if ( initPage( pg, OSAL_NV_ITEM_NULL, findDups ) != OSAL_NV_ITEM_NULL )
??initNV_11:
        ; Setup parameters for call to function initPage
        MOV     R4,?V0 + 4
        MOV     R2,#0x0
        MOV     R3,#0x0
        MOV     A,R6
        MOV     R1,A
        LCALL   ??initPage?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     A,#0x0
        XRL     A,?V0 + 2
        JNZ     ??initNV_15
        MOV     A,#0x0
        XRL     A,?V0 + 3
??initNV_15:
        JZ      ??initNV_16
//  337     {
//  338       findDups = TRUE;
        MOV     ?V0 + 4,#0x1
//  339       pg = OSAL_NV_PAGE_BEG-1;
        MOV     R6,#0x3b
//  340       continue;
        LJMP    ??initNV_17 & 0xFFFF
//  341     }
//  342 
//  343     nvReadHdr( pg, OSAL_NV_IEEE_OFFSET, (uint8 *)(&pgHdr) );
??initNV_16:
        ; Setup parameters for call to function nvReadHdr
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#-0x8
        MOV     R3,#0x7
        MOV     A,R6
        MOV     R1,A
        LCALL   nvReadHdr & 0xFFFF
//  344     if ( xBad )
        MOV     A,?V0 + 1
        JZ      ??initNV_18
//  345     {
//  346       /* TBD - For the cost of more code space, the IEEE could be checksummed & then tested here
//  347        * before installing to the erased IEEE on page 63.
//  348        */
//  349       if ( (pgHdr.active != OSAL_NV_ERASED_ID) ||
//  350            (pgHdr.inUse != OSAL_NV_ERASED_ID) ||
//  351            (pgHdr.xfer != OSAL_NV_ERASED_ID) ||
//  352            (pgHdr.spare != OSAL_NV_ERASED_ID) )
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initNV_19
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initNV_19:
        JNZ     ??initNV_20
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initNV_21
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initNV_21:
        JNZ     ??initNV_20
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initNV_22
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initNV_22:
        JNZ     ??initNV_20
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initNV_23
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initNV_23:
        JZ      ??initNV_17
//  353       {
//  354         writeWordM( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&pgHdr), 2 );
??initNV_20:
        ; Setup parameters for call to function writeWordM
        MOV     ?V0 + 2,#0x2
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 30)
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#-0x8
        MOV     R3,#0x7
        MOV     R1,#0x3f
        LCALL   ??writeWordM?relay
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 29)
//  355         xBad = FALSE;
        MOV     ?V0 + 1,#0x0
        SJMP    ??initNV_17
//  356       }
//  357     }
//  358     else
//  359     {
//  360       writeWordM( pg, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee), 2 );
??initNV_18:
        ; Setup parameters for call to function writeWordM
        MOV     ?V0 + 2,#0x2
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 30)
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#-0x8
        MOV     R3,#0x7
        MOV     A,R6
        MOV     R1,A
        LCALL   ??writeWordM?relay
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 29)
//  361     }
//  362   }  // for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
??initNV_17:
        INC     R6
        LJMP    ??initNV_6 & 0xFFFF
//  363 
//  364   /* First the old page is erased, and then the new page is put into use.
//  365    * So if a transfer was in progress, the new page will always not yet be
//  366    * marked as in use, since that is the last step to ending a transfer.
//  367    */
//  368   if ( newPg != OSAL_NV_PAGE_NULL )
??initNV_7:
        MOV     A,R7
        JZ      ??initNV_24
//  369   {
//  370     /* If there is already a fallow page reserved, keep it and put the newPg in use.
//  371      * An unfinished compaction will finish to the new reserve page and the old page
//  372      * will be erased and reserved.
//  373      */
//  374     if ( pgRes != OSAL_NV_PAGE_NULL )
        MOV     DPTR,#pgRes
        MOVX    A,@DPTR
        JZ      ??initNV_25
//  375     {
//  376       setPageUse( newPg, TRUE );
        ; Setup parameters for call to function setPageUse
        MOV     R2,#0x1
        MOV     A,R7
        MOV     R1,A
        LCALL   ??setPageUse?relay
        SJMP    ??initNV_26
//  377     }
//  378     /* If setting old page to 'xfer' failed or board reset before it was effected, there is no way
//  379      * to know which page was the 'old page' - so just reset all NV pages to start clean.
//  380      */
//  381     else if ( oldPg != OSAL_NV_PAGE_NULL )
??initNV_25:
        MOV     A,?V0 + 0
        JZ      ??initNV_26
//  382     {
//  383       pgRes = newPg;
        MOV     A,R7
        MOV     DPTR,#pgRes
        MOVX    @DPTR,A
//  384     }
//  385 
//  386     /* If a page compaction was interrupted and the page being compacted is not
//  387      * yet erased, then there may be items remaining to xfer before erasing.
//  388      */
//  389     if ( oldPg != OSAL_NV_PAGE_NULL )
??initNV_26:
        MOV     A,?V0 + 0
        JZ      ??initNV_24
//  390     {
//  391       compactPage( oldPg );
        ; Setup parameters for call to function compactPage
        MOV     R1,?V0 + 0
        LCALL   ??compactPage?relay
//  392     }
//  393   }
//  394 
//  395   /* If no page met the criteria to be the reserve page:
//  396    *  - A compactPage() failed or board reset before doing so.
//  397    *  - Perhaps the user changed which Flash pages are dedicated to NV and downloaded the code
//  398    *    without erasing Flash?
//  399    */
//  400   if ( pgRes == OSAL_NV_PAGE_NULL )
??initNV_24:
        MOV     DPTR,#pgRes
        MOVX    A,@DPTR
        JNZ     ??initNV_27
//  401   {
//  402     for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
        MOV     R6,#0x3c
??initNV_28:
        MOV     A,R6
        CLR     C
        SUBB    A,#0x3e
        JNC     ??initNV_29
//  403     {
//  404       erasePage( pg );
        ; Setup parameters for call to function erasePage
        MOV     A,R6
        MOV     R1,A
        LCALL   ??erasePage?relay
//  405     }
        INC     R6
        SJMP    ??initNV_28
//  406     initNV();
??initNV_29:
        ; Setup parameters for call to function initNV
        LCALL   ??initNV?relay
//  407   }
//  408 
//  409   return TRUE;
??initNV_27:
        MOV     R1,#0x1
        MOV     A,#0x10
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 13)
        MOV     R7,#0x5
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock0
//  410 }
//  411 
//  412 /*********************************************************************
//  413  * @fn      setPageUse
//  414  *
//  415  * @brief   Set page header active/inUse state according to 'inUse'.
//  416  *
//  417  * @param   pg - Valid NV page to verify and init.
//  418  * @param   inUse - Boolean TRUE if inUse, FALSE if only active.
//  419  *
//  420  * @return  none
//  421  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  422 static void setPageUse( uint8 pg, uint8 inUse )
setPageUse:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function setPageUse
//  423 {
        FUNCALL setPageUse, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 8
        MOV     A,#-0x8
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 17)
        MOV     A,R1
        MOV     R6,A
        MOV     A,R2
        MOV     R7,A
//  424   osalNvPgHdr_t pgHdr;
//  425 
//  426   pgHdr.active = OSAL_NV_ZEROED_ID;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  427 
//  428   if ( inUse )
        MOV     A,R7
        JZ      ??setPageUse_0
//  429   {
//  430     pgHdr.inUse = OSAL_NV_ZEROED_ID;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??setPageUse_1
//  431   }
//  432   else
//  433   {
//  434     pgHdr.inUse = OSAL_NV_ERASED_ID;
??setPageUse_0:
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#-0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#-0x1
        MOVX    @DPTR,A
//  435   }
//  436 
//  437   writeWord( pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8*)(&pgHdr) );
??setPageUse_1:
        ; Setup parameters for call to function writeWord
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x0
        MOV     R3,#0x0
        MOV     A,R6
        MOV     R1,A
        LCALL   ??writeWord?relay
//  438 }
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock1
//  439 
//  440 /*********************************************************************
//  441  * @fn      initPage
//  442  *
//  443  * @brief   Walk the page items; calculate checksums, lost bytes & page offset.
//  444  *
//  445  * @param   pg - Valid NV page to verify and init.
//  446  * @param   id - Valid NV item Id to use function as a "findItem".
//  447  *               If set to NULL then just perform the page initialization.
//  448  *
//  449  * @return  If 'id' is non-NULL and good checksums are found, return the offset
//  450  *          of the data corresponding to item Id; else OSAL_NV_ITEM_NULL.
//  451  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  452 static uint16 initPage( uint8 pg, uint16 id, uint8 findDups )
initPage:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function initPage
//  453 {
        FUNCALL initPage, nvReadHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initPage, calcChkF
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initPage, findItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initPage, setItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initPage, setItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 12
        MOV     A,#-0xc
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     ?V0 + 0,R1
        MOV     ?V0 + 1,R4
//  454   uint16 offset = OSAL_NV_PAGE_HDR_SIZE;
        MOV     ?V0 + 2,#0x8
        MOV     ?V0 + 3,#0x0
//  455   uint16 sz, lost = 0;
        MOV     R6,#0x0
        MOV     R7,#0x0
//  456   osalNvHdr_t hdr;
//  457 
//  458   do
//  459   {
//  460     nvReadHdr( pg, offset, (uint8 *)(&hdr) );
??initPage_0:
        ; Setup parameters for call to function nvReadHdr
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        MOV     R1,?V0 + 0
        LCALL   nvReadHdr & 0xFFFF
//  461 
//  462     if ( hdr.id == OSAL_NV_ERASED_ID )
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initPage_1
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initPage_1:
        JNZ     $+5
        LJMP    ??initPage_2 & 0xFFFF
//  463     {
//  464       break;
//  465     }
//  466     offset += OSAL_NV_HDR_SIZE;
        MOV     A,?V0 + 2
        ADD     A,#0x8
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
//  467     sz = OSAL_NV_DATA_SIZE( hdr.len );
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x3
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     ?V0 + 5,A
        MOV     A,#0x2
        MOV     R0,#?V0 + 4
        LCALL   ?US_SHR
        MOV     A,?V0 + 4
        MOV     B,#0x4
        MUL     AB
        XCH     A,?V0 + 4
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,?V0 + 5
        MUL     AB
        ADD     A,R2
        MOV     ?V0 + 5,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 5
        MOVX    @DPTR,A
//  468 
//  469     // A bad 'len' write has blown away the rest of the page.
//  470     if ( (offset + sz) > OSAL_NV_PAGE_FREE )
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 3
        MOV     R1,A
        CLR     C
        MOV     A,R0
        SUBB    A,#-0x7
        MOV     A,R1
        SUBB    A,#0x7
        JC      ??initPage_3
//  471     {
//  472       lost += (OSAL_NV_PAGE_FREE - offset + OSAL_NV_HDR_SIZE);
        MOV     A,#0x0
        ADD     A,R6
        MOV     R0,A
        MOV     A,#0x8
        ADDC    A,R7
        MOV     R1,A
        MOV     A,R0
        CLR     C
        SUBB    A,?V0 + 2
        MOV     R6,A
        MOV     A,R1
        SUBB    A,?V0 + 3
        MOV     R7,A
//  473       offset = OSAL_NV_PAGE_FREE;
        MOV     ?V0 + 2,#-0x8
        MOV     ?V0 + 3,#0x7
//  474       break;
        LJMP    ??initPage_2 & 0xFFFF
//  475     }
//  476 
//  477     if ( hdr.id != OSAL_NV_ZEROED_ID )
??initPage_3:
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x0
        JNZ     ??initPage_4
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
??initPage_4:
        JNZ     $+5
        LJMP    ??initPage_5 & 0xFFFF
//  478     {
//  479       /* This trick allows function to do double duty for findItem() without
//  480        * compromising its essential functionality at powerup initialization.
//  481        */
//  482       if ( id != OSAL_NV_ITEM_NULL )
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x0
        JNZ     ??initPage_6
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
??initPage_6:
        JZ      ??initPage_7
//  483       {
//  484         /* This trick allows asking to find the old/transferred item in case
//  485          * of a successful new item write that gets interrupted before the
//  486          * old item can be zeroed out.
//  487          */
//  488         if ( (id & 0x7fff) == hdr.id )
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ANL     A,#0xff
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x7f
        MOV     R1,A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??initPage_8
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??initPage_8:
        JZ      $+5
        LJMP    ??initPage_9 & 0xFFFF
//  489         {
//  490           if ( (((id & OSAL_NV_SOURCE_ID) == 0) && (hdr.stat == OSAL_NV_ERASED_ID)) ||
//  491                (((id & OSAL_NV_SOURCE_ID) != 0) && (hdr.stat != OSAL_NV_ERASED_ID)) )
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ANL     A,#0x0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x80
        MOV     R1,A
        MOV     A,#0x0
        XRL     A,R0
        JNZ     ??initPage_10
        MOV     A,#0x0
        XRL     A,R1
??initPage_10:
        JNZ     ??initPage_11
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initPage_12
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initPage_12:
        JZ      ??initPage_13
??initPage_11:
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ANL     A,#0x0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x80
        MOV     R1,A
        MOV     A,#0x0
        XRL     A,R0
        JNZ     ??initPage_14
        MOV     A,#0x0
        XRL     A,R1
??initPage_14:
        JNZ     $+5
        LJMP    ??initPage_9 & 0xFFFF
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initPage_15
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initPage_15:
        JNZ     $+5
        LJMP    ??initPage_9 & 0xFFFF
//  492           {
//  493             return offset;
??initPage_13:
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LJMP    ??initPage_16 & 0xFFFF
//  494           }
//  495         }
//  496       }
//  497       // When invoked from the osal_nv_init(), verify checksums and find & zero any duplicates.
//  498       else
//  499       {
//  500         if ( hdr.chk == calcChkF( pg, offset, hdr.len ) )
??initPage_7:
        ; Setup parameters for call to function calcChkF
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        MOV     R1,?V0 + 0
        LCALL   ??calcChkF?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R0,?V0 + 4
        MOV     R1,?V0 + 5
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??initPage_17
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??initPage_17:
        JNZ     ??initPage_18
//  501         {
//  502           if ( findDups )
        MOV     A,?V0 + 1
        JZ      ??initPage_19
//  503           {
//  504             if ( hdr.stat == OSAL_NV_ERASED_ID )
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initPage_20
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initPage_20:
        JZ      $+5
        LJMP    ??initPage_9 & 0xFFFF
//  505             {
//  506               /* The trick of setting the MSB of the item Id causes the logic
//  507                * immediately above to return a valid page only if the header 'stat'
//  508                * indicates that it was the older item being transferred.
//  509                */
//  510               uint16 off = findItem( (hdr.id | OSAL_NV_SOURCE_ID) );
        ; Setup parameters for call to function findItem
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ORL     A,#0x0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ORL     A,#0x80
        MOV     R3,A
        LCALL   ??findItem?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 6,?V0 + 4
        MOV     ?V0 + 7,?V0 + 5
//  511   
//  512               if ( off != OSAL_NV_ITEM_NULL )
        MOV     A,#0x0
        XRL     A,?V0 + 6
        JNZ     ??initPage_21
        MOV     A,#0x0
        XRL     A,?V0 + 7
??initPage_21:
        JZ      ??initPage_9
//  513               {
//  514                 setItem( findPg, off, eNvZero );  // Mark old duplicate as invalid.
        ; Setup parameters for call to function setItem
        MOV     R4,#0x1
        MOV     R2,?V0 + 6
        MOV     R3,?V0 + 7
        MOV     DPTR,#findPg
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??setItem?relay
        SJMP    ??initPage_9
//  515               }
//  516             }
//  517           }
//  518           // Any "old" item immediately exits and triggers the N^2 exhaustive initialization.
//  519           else if ( hdr.stat != OSAL_NV_ERASED_ID )
??initPage_19:
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??initPage_22
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??initPage_22:
        JZ      ??initPage_9
//  520           {
//  521             return OSAL_NV_ERASED_ID;
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        LJMP    ??initPage_16 & 0xFFFF
//  522           }
//  523         }
//  524         else
//  525         {
//  526           setItem( pg, offset, eNvZero );  // Mark bad checksum as invalid.
??initPage_18:
        ; Setup parameters for call to function setItem
        MOV     R4,#0x1
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        MOV     R1,?V0 + 0
        LCALL   ??setItem?relay
//  527           lost += (OSAL_NV_HDR_SIZE + sz);
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,#0x8
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     A,R6
        ADD     A,R0
        MOV     R6,A
        MOV     A,R7
        ADDC    A,R1
        MOV     R7,A
        SJMP    ??initPage_9
//  528         }
//  529       }
//  530     }
//  531     else
//  532     {
//  533       lost += (OSAL_NV_HDR_SIZE + sz);
??initPage_5:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,#0x8
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     A,R6
        ADD     A,R0
        MOV     R6,A
        MOV     A,R7
        ADDC    A,R1
        MOV     R7,A
//  534     }
//  535     offset += sz;
??initPage_9:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 2
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 3
        MOV     ?V0 + 3,A
//  536 
//  537   } while ( TRUE );
        LJMP    ??initPage_0 & 0xFFFF
//  538 
//  539   pgOff[pg - OSAL_NV_PAGE_BEG] = offset;
??initPage_2:
        MOV     R0,?V0 + 0
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#((pgOff + 136) & 0xff)
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
        MOV     DPH,A
        MOV     A,?V0 + 2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 3
        MOVX    @DPTR,A
//  540   pgLost[pg - OSAL_NV_PAGE_BEG] = lost;
        MOV     R0,?V0 + 0
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#((pgLost + 136) & 0xff)
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#(((pgLost - 120) >> 8) & 0xff)
        MOV     DPH,A
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
//  541 
//  542   return OSAL_NV_ITEM_NULL;
        MOV     R2,#0x0
        MOV     R3,#0x0
??initPage_16:
        MOV     A,#0xc
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock2
//  543 }
//  544 
//  545 /*********************************************************************
//  546  * @fn      erasePage
//  547  *
//  548  * @brief   Erases a page in Flash.
//  549  *
//  550  * @param   pg - Valid NV page to erase.
//  551  *
//  552  * @return  none
//  553  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  554 static void erasePage( uint8 pg )
erasePage:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function erasePage
//  555 {
        FUNCALL erasePage, HalAdcCheckVdd
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL erasePage, nvReadHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL erasePage, writeWordM
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 8
        MOV     A,#-0x8
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 17)
        MOV     A,R1
        MOV     R6,A
//  556   halIntState_t intState;
//  557   osalNvHdr_t ieee;
//  558 
//  559   if ( !OSAL_NV_CHECK_BUS_VOLTAGE )
        ; Setup parameters for call to function HalAdcCheckVdd
        MOV     R1,#0x4
        LCALL   ??HalAdcCheckVdd?relay
        MOV     A,R1
        JNZ     ??erasePage_0
//  560   {
//  561     failF = TRUE;
        MOV     A,#0x1
        MOV     DPTR,#failF
        MOVX    @DPTR,A
//  562     return;
        LJMP    ??erasePage_1 & 0xFFFF
//  563   }
//  564 
//  565   HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
??erasePage_0:
        MOV     C,0xa8.7
        CLR     A
        MOV     0xE0 /* A   */.0,C
        MOV     R7,A
        CLR     0xa8.7
//  566   FADDRH = (pg) << 1;
        MOV     A,R6
        CLR     C
        RLC     A
        MOV     0xad,A
//  567   FCTL = 0x01;
        MOV     0xae,#0x1
//  568   asm("NOP");
        NOP
//  569   while(FCTL == 0x80);
??erasePage_2:
        MOV     A,#-0x80
        XRL     A,0xae
        JZ      ??erasePage_2
//  570   HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
        MOV     A,R7
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
//  571 
//  572   pgOff[pg - OSAL_NV_PAGE_BEG] = OSAL_NV_PAGE_HDR_SIZE;
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#((pgOff + 136) & 0xff)
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
        MOV     DPH,A
        MOV     A,#0x8
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  573   pgLost[pg - OSAL_NV_PAGE_BEG] = 0;
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#((pgLost + 136) & 0xff)
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#(((pgLost - 120) >> 8) & 0xff)
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  574 
//  575   nvReadHdr( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee) );
        ; Setup parameters for call to function nvReadHdr
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#-0x8
        MOV     R3,#0x7
        MOV     R1,#0x3f
        LCALL   nvReadHdr & 0xFFFF
//  576   writeWordM( pg, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee), 2 );
        ; Setup parameters for call to function writeWordM
        MOV     ?V0 + 0,#0x2
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 18)
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#-0x8
        MOV     R3,#0x7
        MOV     A,R6
        MOV     R1,A
        LCALL   ??writeWordM?relay
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 17)
//  577 }
??erasePage_1:
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock3
        REQUIRE _A_IEN0
        REQUIRE FADDRH
        REQUIRE FCTL
//  578 
//  579 /*********************************************************************
//  580  * @fn      compactPage
//  581  *
//  582  * @brief   Compacts the page specified.
//  583  *
//  584  * @param   srcPg - Valid NV page to erase.
//  585  *
//  586  * @return  none
//  587  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  588 static void compactPage( uint8 srcPg )
compactPage:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function compactPage
//  589 {
        FUNCALL compactPage, writeWordH
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, nvReadHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, calcChkF
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, setItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, writeBuf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, xferBuf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, setItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, erasePage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compactPage, setPageUse
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 10
        MOV     A,#-0xa
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 24)
        MOV     A,R1
        MOV     R6,A
//  590   uint16 dstOff = pgOff[pgRes-OSAL_NV_PAGE_BEG];
        MOV     DPTR,#pgRes
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#((pgOff + 136) & 0xff)
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
//  591   uint16 srcOff = OSAL_NV_ZEROED_ID;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  592   osalNvHdr_t hdr;
//  593 
//  594   // Mark page as being in process of compaction.
//  595   writeWordH( srcPg, OSAL_NV_PG_XFER, (uint8*)(&srcOff) );
        ; Setup parameters for call to function writeWordH
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x4
        MOV     R3,#0x0
        MOV     A,R6
        MOV     R1,A
        LCALL   ??writeWordH?relay
//  596 
//  597   srcOff = OSAL_NV_PAGE_HDR_SIZE;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x8
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  598 
//  599   do
//  600   {
//  601     uint16 sz;
//  602     nvReadHdr( srcPg, srcOff, (uint8 *)(&hdr) );
??compactPage_0:
        ; Setup parameters for call to function nvReadHdr
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R1,A
        LCALL   nvReadHdr & 0xFFFF
//  603 
//  604     if ( hdr.id == OSAL_NV_ERASED_ID )
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??compactPage_1
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??compactPage_1:
        JNZ     $+5
        LJMP    ??compactPage_2 & 0xFFFF
//  605     {
//  606       break;
//  607     }
//  608 
//  609     srcOff += OSAL_NV_HDR_SIZE;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,#0x8
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
//  610 
//  611     if ( (srcOff + hdr.len) > OSAL_NV_PAGE_FREE )
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        PUSH    DPL
        CFI CFA_SP SP+-1
        PUSH    DPH
        CFI CFA_SP SP+-2
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        POP     DPH
        CFI CFA_SP SP+-1
        POP     DPL
        CFI CFA_SP SP+0
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        CLR     C
        MOV     A,R0
        SUBB    A,#-0x7
        MOV     A,R1
        SUBB    A,#0x7
        JC      $+5
        LJMP    ??compactPage_2 & 0xFFFF
//  612     {
//  613       break;
//  614     }
//  615 
//  616     sz = OSAL_NV_DATA_SIZE( hdr.len );
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x3
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     ?V0 + 5,A
        MOV     A,#0x2
        MOV     R0,#?V0 + 4
        LCALL   ?US_SHR
        MOV     A,?V0 + 4
        MOV     B,#0x4
        MUL     AB
        XCH     A,?V0 + 4
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,?V0 + 5
        MUL     AB
        ADD     A,R2
        MOV     ?V0 + 5,A
        MOV     ?V0 + 2,?V0 + 4
        MOV     ?V0 + 3,?V0 + 5
//  617 
//  618     if ( hdr.id != OSAL_NV_ZEROED_ID )
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x0
        JNZ     ??compactPage_3
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
??compactPage_3:
        JNZ     $+5
        LJMP    ??compactPage_4 & 0xFFFF
//  619     {
//  620       if ( hdr.chk == calcChkF( srcPg, srcOff, hdr.len ) )
        ; Setup parameters for call to function calcChkF
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R1,A
        LCALL   ??calcChkF?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R0,?V0 + 4
        MOV     R1,?V0 + 5
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??compactPage_5
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??compactPage_5:
        JNZ     ??compactPage_6
//  621       {
//  622         setItem( srcPg, srcOff, eNvXfer );
        ; Setup parameters for call to function setItem
        MOV     R4,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R1,A
        LCALL   ??setItem?relay
//  623         writeBuf( pgRes, dstOff, OSAL_NV_HDR_SIZE, (byte *)(&hdr) );
        ; Setup parameters for call to function writeBuf
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 4,DPL
        MOV     ?V0 + 5,DPH
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 26)
        MOV     R4,#0x8
        MOV     R5,#0x0
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     DPTR,#pgRes
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??writeBuf?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 24)
//  624         dstOff += OSAL_NV_HDR_SIZE;
        MOV     A,?V0 + 0
        ADD     A,#0x8
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
//  625         xferBuf( srcPg, srcOff, pgRes, dstOff, sz );
        ; Setup parameters for call to function xferBuf
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 26)
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 28)
        MOV     DPTR,#pgRes
        MOVX    A,@DPTR
        MOV     R4,A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R1,A
        LCALL   ??xferBuf?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 24)
//  626         dstOff += sz;
        MOV     A,?V0 + 0
        ADD     A,?V0 + 2
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,?V0 + 3
        MOV     ?V0 + 1,A
//  627       }
//  628 
//  629       setItem( srcPg, srcOff, eNvZero );  // Mark old location as invalid.
??compactPage_6:
        ; Setup parameters for call to function setItem
        MOV     R4,#0x1
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R1,A
        LCALL   ??setItem?relay
//  630     }
//  631 
//  632     srcOff += sz;
??compactPage_4:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 2
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 3
        MOVX    @DPTR,A
//  633 
//  634   } while ( TRUE );
        LJMP    ??compactPage_0 & 0xFFFF
//  635 
//  636   pgOff[pgRes-OSAL_NV_PAGE_BEG] = dstOff;
??compactPage_2:
        MOV     DPTR,#pgRes
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#((pgOff + 136) & 0xff)
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
        MOV     DPH,A
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
//  637 
//  638   /* In order to recover from a page compaction that is interrupted,
//  639    * the logic in osal_nv_init() depends upon the following order:
//  640    * 1. Compacted page is erased.
//  641    * 2. State of the target of compaction is changed ePgActive to ePgInUse.
//  642    */
//  643   erasePage( srcPg );
        ; Setup parameters for call to function erasePage
        MOV     A,R6
        MOV     R1,A
        LCALL   ??erasePage?relay
//  644 
//  645   // Mark the reserve page as being in use.
//  646   setPageUse( pgRes, TRUE );
        ; Setup parameters for call to function setPageUse
        MOV     R2,#0x1
        MOV     DPTR,#pgRes
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??setPageUse?relay
//  647 
//  648   // Set the reserve page to be the newly erased page.
//  649   pgRes = srcPg;
        MOV     A,R6
        MOV     DPTR,#pgRes
        MOVX    @DPTR,A
//  650 }
        MOV     A,#0xa
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock4
//  651 
//  652 /*********************************************************************
//  653  * @fn      findItem
//  654  *
//  655  * @brief   Find an item Id in NV and return the page and offset to its data.
//  656  *
//  657  * @param   id - Valid NV item Id.
//  658  *
//  659  * @return  Offset of data corresponding to item Id, if found;
//  660  *          otherwise OSAL_NV_ITEM_NULL.
//  661  *
//  662  *          The page containing the item, if found;
//  663  *          otherwise no valid assignment made - left equal to item Id.
//  664  *
//  665  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  666 static uint16 findItem( uint16 id )
findItem:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function findItem
//  667 {
        FUNCALL findItem, initPage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL findItem, findItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  668   uint16 off;
//  669   uint8 pg;
//  670 
//  671   for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
        MOV     ?V0 + 0,#0x3c
??findItem_0:
        MOV     A,?V0 + 0
        CLR     C
        SUBB    A,#0x3e
        JNC     ??findItem_1
//  672   {
//  673     if ( (off = initPage( pg, id, FALSE )) != OSAL_NV_ITEM_NULL )
        ; Setup parameters for call to function initPage
        MOV     R4,#0x0
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 0
        LCALL   ??initPage?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R0,?V0 + 4
        MOV     R1,?V0 + 5
        MOV     ?V0 + 2,R0
        MOV     ?V0 + 3,R1
        MOV     A,#0x0
        XRL     A,R0
        JNZ     ??findItem_2
        MOV     A,#0x0
        XRL     A,R1
??findItem_2:
        JZ      ??findItem_3
//  674     {
//  675       findPg = pg;
        MOV     A,?V0 + 0
        MOV     DPTR,#findPg
        MOVX    @DPTR,A
//  676       return off;
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        SJMP    ??findItem_4
//  677     }
//  678   }
??findItem_3:
        INC     ?V0 + 0
        SJMP    ??findItem_0
//  679 
//  680   // Now attempt to find the item as the "old" item of a failed/interrupted NV write.
//  681   if ( (id & OSAL_NV_SOURCE_ID) == 0 )
??findItem_1:
        MOV     A,#0x0
        ANL     A,R6
        MOV     R0,A
        MOV     A,#-0x80
        ANL     A,R7
        MOV     R1,A
        MOV     A,#0x0
        XRL     A,R0
        JNZ     ??findItem_5
        MOV     A,#0x0
        XRL     A,R1
??findItem_5:
        JNZ     ??findItem_6
//  682   {
//  683     return findItem( id | OSAL_NV_SOURCE_ID );
        ; Setup parameters for call to function findItem
        MOV     A,#0x0
        ORL     A,R6
        MOV     R2,A
        MOV     A,#-0x80
        ORL     A,R7
        MOV     R3,A
        LCALL   ??findItem?relay
        SJMP    ??findItem_4
//  684   }
//  685   else
//  686   {
//  687     findPg = OSAL_NV_PAGE_NULL;
??findItem_6:
        MOV     A,#0x0
        MOV     DPTR,#findPg
        MOVX    @DPTR,A
//  688     return OSAL_NV_ITEM_NULL;
        MOV     R2,#0x0
        MOV     R3,#0x0
??findItem_4:
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock5
//  689   }
//  690 }
//  691 
//  692 /*********************************************************************
//  693  * @fn      initItem
//  694  *
//  695  * @brief   An NV item is created and initialized with the data passed to the function, if any.
//  696  *
//  697  * @param   id  - Valid NV item Id.
//  698  * @param   len - Item data length.
//  699  * @param  *buf - Pointer to item initalization data. Set to NULL if none.
//  700  *
//  701  * @return  TRUE if item write and read back checksums ok; FALSE otherwise.
//  702  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  703 static uint8 initItem( uint8 flag, uint16 id, uint16 len, void *buf )
initItem:
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function initItem
//  704 {
        FUNCALL initItem, writeItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 23, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL initItem, compactPage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     ?V0 + 4,R1
        MOV     ?V0 + 6,R4
        MOV     ?V0 + 7,R5
//  705   uint16 sz = OSAL_NV_ITEM_SIZE( len );
        MOV     A,#0x3
        ADD     A,?V0 + 6
        MOV     ?V0 + 2,A
        MOV     A,#0x0
        ADDC    A,?V0 + 7
        MOV     ?V0 + 3,A
        MOV     A,#0x2
        MOV     R0,#?V0 + 2
        LCALL   ?US_SHR
        MOV     A,?V0 + 2
        MOV     B,#0x4
        MUL     AB
        XCH     A,?V0 + 2
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,?V0 + 3
        MUL     AB
        ADD     A,R2
        MOV     ?V0 + 3,A
        MOV     A,#0x8
        ADD     A,?V0 + 2
        MOV     R0,A
        MOV     A,#0x0
        ADDC    A,?V0 + 3
        MOV     R1,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  706   uint8 rtrn = FALSE;
        MOV     R6,#0x0
//  707   uint8 cnt = OSAL_NV_PAGES_USED;
        MOV     ?V0 + 1,#0x2
//  708   uint8 pg = pgRes+1;  // Set to 1 after the reserve page to even wear across all available pages.
        MOV     DPTR,#pgRes
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R7,A
//  709   uint8 idx;
//  710 
//  711   do {
//  712     if (pg >= OSAL_NV_PAGE_BEG+OSAL_NV_PAGES_USED)
??initItem_0:
        MOV     A,R7
        CLR     C
        SUBB    A,#0x3e
        JC      ??initItem_1
//  713     {
//  714       pg = OSAL_NV_PAGE_BEG;
        MOV     R7,#0x3c
//  715     }
//  716     if ( pg != pgRes )
??initItem_1:
        MOV     DPTR,#pgRes
        MOVX    A,@DPTR
        XRL     A,R7
        JZ      ??initItem_2
//  717     {
//  718       idx = pg - OSAL_NV_PAGE_BEG;
        MOV     A,#-0x3c
        ADD     A,R7
        MOV     ?V0 + 0,A
//  719       if ( (pgOff[idx] - pgLost[idx] + sz) <= OSAL_NV_PAGE_FREE )
        MOV     R0,?V0 + 0
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#(pgOff & 0xff)
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#((pgOff >> 8) & 0xff)
        MOV     DPH,A
        PUSH    DPL
        CFI CFA_SP SP+-1
        PUSH    DPH
        CFI CFA_SP SP+-2
        MOV     R0,?V0 + 0
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#(pgLost & 0xff)
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#((pgLost >> 8) & 0xff)
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        POP     DPH
        CFI CFA_SP SP+-1
        POP     DPL
        CFI CFA_SP SP+0
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        MOV     R1,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        CLR     C
        MOV     A,R0
        SUBB    A,#-0x7
        MOV     A,R1
        SUBB    A,#0x7
        JC      ??initItem_3
//  720       {
//  721         break;
//  722       }
//  723     }
//  724     pg++;
??initItem_2:
        INC     R7
//  725   } while (--cnt);
        MOV     A,#-0x1
        ADD     A,?V0 + 1
        MOV     R2,A
        MOV     ?V0 + 1,R2
        MOV     A,R2
        JZ      $+5
        LJMP    ??initItem_0 & 0xFFFF
//  726 
//  727   if (cnt)
??initItem_3:
        MOV     A,?V0 + 1
        JNZ     $+5
        LJMP    ??initItem_4 & 0xFFFF
//  728   {
//  729     // Item fits if an old page is compacted.
//  730     if ( (pgOff[idx] + sz) > OSAL_NV_PAGE_FREE )
        MOV     R0,?V0 + 0
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#(pgOff & 0xff)
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#((pgOff >> 8) & 0xff)
        MOV     DPH,A
        PUSH    DPL
        CFI CFA_SP SP+-1
        PUSH    DPH
        CFI CFA_SP SP+-2
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        POP     DPH
        CFI CFA_SP SP+-1
        POP     DPL
        CFI CFA_SP SP+0
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        CLR     C
        MOV     A,R0
        SUBB    A,#-0x7
        MOV     A,R1
        SUBB    A,#0x7
        JC      ??initItem_5
//  731     {
//  732       pg = pgRes;
        MOV     DPTR,#pgRes
        MOVX    A,@DPTR
        MOV     R7,A
//  733     }
//  734 
//  735     // New item is the first one written to the reserved page, then the old page is compacted.
//  736     rtrn = writeItem( pg, id, len, buf, flag );
??initItem_5:
        ; Setup parameters for call to function writeItem
        MOV     A,?V0 + 4
        MOV     ?V0 + 2,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 21)
        MOV     A,#0x15
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?PUSH_XSTACK8_X_TWO
        CFI CFA_XSP16 add(XSP16, 23)
        MOV     R4,?V0 + 6
        MOV     R5,?V0 + 7
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R7
        MOV     R1,A
        LCALL   ??writeItem?relay
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     A,R1
        MOV     R6,A
//  737 
//  738     if ( pg == pgRes )
        MOV     DPTR,#pgRes
        MOVX    A,@DPTR
        XRL     A,R7
        JNZ     ??initItem_4
//  739     {
//  740       if ( flag )
        MOV     A,?V0 + 4
        JZ      ??initItem_6
//  741       {
//  742         compactPage( OSAL_NV_PAGE_BEG+idx );
        ; Setup parameters for call to function compactPage
        MOV     A,#0x3c
        ADD     A,?V0 + 0
        MOV     R1,A
        LCALL   ??compactPage?relay
        SJMP    ??initItem_4
//  743       }
//  744       else
//  745       {
//  746         *(uint8 *)buf = OSAL_NV_PAGE_BEG+idx;
??initItem_6:
        MOV     A,#0x3c
        ADD     A,?V0 + 0
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  747       }
//  748     }
//  749   }
//  750 
//  751   return rtrn;
??initItem_4:
        MOV     A,R6
        MOV     R1,A
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock6
//  752 }
//  753 
//  754 /*********************************************************************
//  755  * @fn      setItem
//  756  *
//  757  * @brief   Set an item Id or status to mark its state.
//  758  *
//  759  * @param   pg - Valid NV page.
//  760  * @param   offset - Valid offset into the page of the item data - the header
//  761  *                   offset is calculated from this.
//  762  * @param   stat - Valid enum value for the item status.
//  763  *
//  764  * @return  none
//  765  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  766 static void setItem( uint8 pg, uint16 offset, eNvHdrEnum stat )
setItem:
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function setItem
//  767 {
        FUNCALL setItem, nvReadHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL setItem, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL setItem, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 8
        MOV     A,#-0x8
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     A,R1
        MOV     R6,A
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,R4
        MOV     R7,A
//  768   osalNvHdr_t hdr;
//  769 
//  770   offset -= OSAL_NV_HDR_SIZE;
        MOV     A,?V0 + 0
        ADD     A,#-0x8
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#-0x1
        MOV     ?V0 + 1,A
//  771   nvReadHdr( pg, offset, (uint8 *)(&hdr) );
        ; Setup parameters for call to function nvReadHdr
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     A,R6
        MOV     R1,A
        LCALL   nvReadHdr & 0xFFFF
//  772 
//  773   if ( stat == eNvXfer )
        MOV     A,R7
        JNZ     ??setItem_0
//  774   {
//  775     hdr.stat = OSAL_NV_ACTIVE;
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  776     writeWord( pg, offset+OSAL_NV_HDR_CHK, (uint8*)(&(hdr.chk)) );
        ; Setup parameters for call to function writeWord
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x4
        ADD     A,?V0 + 0
        MOV     R2,A
        MOV     A,#0x0
        ADDC    A,?V0 + 1
        MOV     R3,A
        MOV     A,R6
        MOV     R1,A
        LCALL   ??writeWord?relay
        LJMP    ??setItem_1 & 0xFFFF
//  777   }
//  778   else // if ( stat == eNvZero )
//  779   {
//  780     uint16 sz = ((hdr.len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE +
//  781                                                                           OSAL_NV_HDR_SIZE;
??setItem_0:
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x3
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
        MOV     A,#0x2
        MOV     R0,#?V0 + 2
        LCALL   ?US_SHR
        MOV     A,?V0 + 2
        MOV     B,#0x4
        MUL     AB
        XCH     A,?V0 + 2
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,?V0 + 3
        MUL     AB
        ADD     A,R2
        MOV     ?V0 + 3,A
        MOV     A,#0x8
        ADD     A,?V0 + 2
        MOV     R0,A
        MOV     A,#0x0
        ADDC    A,?V0 + 3
        MOV     R1,A
        MOV     ?V0 + 4,R0
        MOV     ?V0 + 5,R1
//  782     hdr.id = 0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  783     writeWord( pg, offset, (uint8 *)(&hdr) );
        ; Setup parameters for call to function writeWord
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     A,R6
        MOV     R1,A
        LCALL   ??writeWord?relay
//  784     pgLost[pg-OSAL_NV_PAGE_BEG] += sz;
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#((pgLost + 136) & 0xff)
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#(((pgLost - 120) >> 8) & 0xff)
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,?V0 + 4
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 5
        MOVX    @DPTR,A
//  785   }
//  786 }
??setItem_1:
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock7
//  787 
//  788 /*********************************************************************
//  789  * @fn      calcChkB
//  790  *
//  791  * @brief   Calculates the data checksum over the 'buf' parameter.
//  792  *
//  793  * @param   pg - A valid NV Flash page.
//  794  * @param   offset - A valid offset into the page.
//  795  * @param   len - Byte count of the data to be checksummed.
//  796  *
//  797  * @return  Calculated checksum of the data bytes.
//  798  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  799 static uint16 calcChkB( uint16 len, uint8 *buf )
calcChkB:
        CFI Block cfiBlock8 Using cfiCommon0
        CFI Function calcChkB
//  800 {
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     DPL,R4
        MOV     DPH,R5
//  801   uint8 fill = len % OSAL_NV_WORD_SIZE;
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     R2,#0x4
        MOV     R3,#0x0
        LCALL   ?US_DIV_MOD
        MOV     A,R2
        MOV     ?V0 + 0,A
//  802   uint16 chk;
//  803 
//  804   if ( !buf )
        MOV     A,DPL
        XRL     A,#0x0
        JNZ     ??calcChkB_0
        MOV     A,DPH
        XRL     A,#0x0
??calcChkB_0:
        JNZ     ??calcChkB_1
//  805   {
//  806     chk = len * OSAL_NV_ERASED;
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     A,R0
        MOV     B,#-0x1
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#-0x1
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
        SJMP    ??calcChkB_2
//  807   }
//  808   else
//  809   {
//  810     chk = 0;
??calcChkB_1:
        MOV     R4,#0x0
        MOV     R5,#0x0
//  811     while ( len-- )
??calcChkB_3:
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     A,#-0x1
        ADD     A,R0
        MOV     R6,A
        MOV     A,#-0x1
        ADDC    A,R1
        MOV     R7,A
        MOV     A,#0x0
        XRL     A,R0
        JNZ     ??calcChkB_4
        MOV     A,#0x0
        XRL     A,R1
??calcChkB_4:
        JZ      ??calcChkB_2
//  812     {
//  813       chk += *buf++;
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R4
        ADD     A,R0
        MOV     R4,A
        MOV     A,R5
        ADDC    A,R1
        MOV     R5,A
        INC     DPTR
        SJMP    ??calcChkB_3
//  814     }
//  815   }
//  816 
//  817   // calcChkF() will calculate over OSAL_NV_WORD_SIZE alignment.
//  818   if ( fill )
??calcChkB_2:
        MOV     A,?V0 + 0
        JZ      ??calcChkB_5
//  819   {
//  820     chk += (OSAL_NV_WORD_SIZE - fill) * OSAL_NV_ERASED;
        MOV     ?V0 + 2,?V0 + 0
        MOV     ?V0 + 3,#0x0
        MOV     A,#0x4
        CLR     C
        SUBB    A,?V0 + 2
        MOV     R0,A
        MOV     A,#0x0
        SUBB    A,?V0 + 3
        MOV     R1,A
        MOV     A,R0
        MOV     B,#-0x1
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#-0x1
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R4
        ADD     A,R0
        MOV     R4,A
        MOV     A,R5
        ADDC    A,R1
        MOV     R5,A
//  821   }
//  822 
//  823   return chk;
??calcChkB_5:
        MOV     A,R4
        MOV     R2,A
        MOV     A,R5
        MOV     R3,A
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock8
//  824 }
//  825 
//  826 /*********************************************************************
//  827  * @fn      calcChkF
//  828  *
//  829  * @brief   Calculates the data checksum by reading the data bytes from NV.
//  830  *
//  831  * @param   pg - A valid NV Flash page.
//  832  * @param   offset - A valid offset into the page.
//  833  * @param   len - Byte count of the data to be checksummed.
//  834  *
//  835  * @return  Calculated checksum of the data bytes.
//  836  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  837 static uint16 calcChkF( byte pg, uint16 offset, uint16 len )
calcChkF:
        CFI Block cfiBlock9 Using cfiCommon0
        CFI Function calcChkF
//  838 {
        FUNCALL calcChkF, nvReadWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     ?V0 + 1,R1
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
//  839   uint16 chk = 0;
        MOV     ?V0 + 6,#0x0
        MOV     ?V0 + 7,#0x0
//  840 
//  841   len = (len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE;
        MOV     A,#0x3
        ADD     A,R6
        MOV     ?V0 + 2,A
        MOV     A,#0x0
        ADDC    A,R7
        MOV     ?V0 + 3,A
        MOV     A,#0x2
        MOV     R0,#?V0 + 2
        LCALL   ?US_SHR
        MOV     R6,?V0 + 2
        MOV     R7,?V0 + 3
//  842 
//  843   while ( len-- )
??calcChkF_0:
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     A,#-0x1
        ADD     A,R0
        MOV     R6,A
        MOV     A,#-0x1
        ADDC    A,R1
        MOV     R7,A
        MOV     A,#0x0
        XRL     A,R0
        JNZ     ??calcChkF_1
        MOV     A,#0x0
        XRL     A,R1
??calcChkF_1:
        JZ      ??calcChkF_2
//  844   {
//  845     uint8 cnt, tmp[OSAL_NV_WORD_SIZE];
//  846 
//  847     nvReadWord( pg, offset, tmp );
        ; Setup parameters for call to function nvReadWord
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        MOV     R1,?V0 + 1
        LCALL   nvReadWord & 0xFFFF
//  848     offset += OSAL_NV_WORD_SIZE;
        MOV     A,?V0 + 4
        ADD     A,#0x4
        MOV     ?V0 + 4,A
        MOV     A,?V0 + 5
        ADDC    A,#0x0
        MOV     ?V0 + 5,A
//  849 
//  850     for ( cnt = 0; cnt < OSAL_NV_WORD_SIZE; cnt++ )
        MOV     ?V0 + 0,#0x0
??calcChkF_3:
        MOV     A,?V0 + 0
        CLR     C
        SUBB    A,#0x4
        JNC     ??calcChkF_0
//  851     {
//  852       chk += tmp[cnt];
        MOV     ?V0 + 2,?V0 + 0
        MOV     ?V0 + 3,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,?V0 + 2
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,?V0 + 3
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,?V0 + 6
        ADD     A,R0
        MOV     ?V0 + 6,A
        MOV     A,?V0 + 7
        ADDC    A,R1
        MOV     ?V0 + 7,A
//  853     }
        INC     ?V0 + 0
        SJMP    ??calcChkF_3
//  854   }
//  855 
//  856   return chk;
??calcChkF_2:
        MOV     R2,?V0 + 6
        MOV     R3,?V0 + 7
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock9
//  857 }
//  858 
//  859 /*********************************************************************
//  860  * @fn      writeWord
//  861  *
//  862  * @brief   Writes a Flash-WORD to NV.
//  863  *
//  864  * @param   pg - A valid NV Flash page.
//  865  * @param   offset - A valid offset into the page.
//  866  * @param   buf - Pointer to source buffer.
//  867  *
//  868  * @return  none
//  869  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  870 static void writeWord( uint8 pg, uint16 offset, uint8 *buf )
writeWord:
        CFI Block cfiBlock10 Using cfiCommon0
        CFI Function writeWord
//  871 {
        FUNCALL writeWord, HalAdcCheckVdd
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeWord, flashWriteBuf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV     ?V0 + 0,R1
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
//  872     offset = (offset >> 2) + ((uint16)pg << 9);
        MOV     A,#0x2
        MOV     R0,#?V0 + 2
        LCALL   ?US_SHR
        MOV     ?V0 + 4,?V0 + 0
        MOV     ?V0 + 5,#0x0
        MOV     A,#0x9
        MOV     R0,#?V0 + 4
        LCALL   ?S_SHL
        MOV     A,?V0 + 4
        ADD     A,?V0 + 2
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 5
        ADDC    A,?V0 + 3
        MOV     ?V0 + 3,A
//  873 
//  874     if ( OSAL_NV_CHECK_BUS_VOLTAGE )
        ; Setup parameters for call to function HalAdcCheckVdd
        MOV     R1,#0x4
        LCALL   ??HalAdcCheckVdd?relay
        MOV     A,R1
        JZ      ??writeWord_0
//  875     {
//  876     flashWriteBuf(1, (uint16)buf, offset);
        ; Setup parameters for call to function flashWriteBuf
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,#0x1
        LCALL   flashWriteBuf & 0xFFFF
        SJMP    ??writeWord_1
//  877     }
//  878     else
//  879     {
//  880       failF = TRUE;
??writeWord_0:
        MOV     A,#0x1
        MOV     DPTR,#failF
        MOVX    @DPTR,A
//  881     }
//  882 }
??writeWord_1:
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock10
//  883 
//  884 /*********************************************************************
//  885  * @fn      writeWordM
//  886  *
//  887  * @brief   Writes multiple Flash-WORDs to NV.
//  888  *
//  889  * @param   pg - A valid NV Flash page.
//  890  * @param   offset - A valid offset into the page.
//  891  * @param   buf - Pointer to source buffer.
//  892  * @param   cnt - Number of 4-byte blocks to write.
//  893  *
//  894  * @return  none
//  895  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  896 static void writeWordM( uint8 pg, uint16 offset, uint8 *buf, uint8 cnt )
writeWordM:
        CFI Block cfiBlock11 Using cfiCommon0
        CFI Function writeWordM
//  897 {
        FUNCALL writeWordM, HalAdcCheckVdd
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeWordM, flashWriteBuf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 4,R4
        MOV     ?V0 + 5,R5
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R7,A
//  898   offset = (offset >> 2) + ((uint16)pg << 9);
        MOV     A,#0x2
        MOV     R0,#?V0 + 0
        LCALL   ?US_SHR
        MOV     ?V0 + 2,R6
        MOV     ?V0 + 3,#0x0
        MOV     A,#0x9
        MOV     R0,#?V0 + 2
        LCALL   ?S_SHL
        MOV     A,?V0 + 2
        ADD     A,?V0 + 0
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 3
        ADDC    A,?V0 + 1
        MOV     ?V0 + 1,A
//  899 
//  900   if ( OSAL_NV_CHECK_BUS_VOLTAGE )
        ; Setup parameters for call to function HalAdcCheckVdd
        MOV     R1,#0x4
        LCALL   ??HalAdcCheckVdd?relay
        MOV     A,R1
        JZ      ??writeWordM_0
//  901   {
//  902     flashWriteBuf(cnt, (uint16)buf, offset);
        ; Setup parameters for call to function flashWriteBuf
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        MOV     A,R7
        MOV     R1,A
        LCALL   flashWriteBuf & 0xFFFF
        SJMP    ??writeWordM_1
//  903   }
//  904   else
//  905   {
//  906     failF = TRUE;
??writeWordM_0:
        MOV     A,#0x1
        MOV     DPTR,#failF
        MOVX    @DPTR,A
//  907   }
//  908 }
??writeWordM_1:
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock11
//  909 
//  910 /*********************************************************************
//  911  * @fn      writeWordH
//  912  *
//  913  * @brief   Writes the 1st half of a Flash-WORD to NV (filling 2nd half with 0xffff).
//  914  *
//  915  * @param   pg - A valid NV Flash page.
//  916  * @param   offset - A valid offset into the page.
//  917  * @param   buf - Pointer to source buffer.
//  918  *
//  919  * @return  none
//  920  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  921 static void writeWordH( uint8 pg, uint16 offset, uint8 *buf )
writeWordH:
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function writeWordH
//  922 {
        FUNCALL writeWordH, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     ?V0 + 0,R1
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
//  923   uint8 tmp[4];
//  924 
//  925   tmp[0] = buf[0];
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
//  926   tmp[1] = buf[1];
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOVX    A,@DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  927   tmp[2] = OSAL_NV_ERASED;
        MOV     A,#-0x1
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  928   tmp[3] = OSAL_NV_ERASED;
        MOV     A,#-0x1
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  929 
//  930   writeWord( pg, offset, tmp );
        ; Setup parameters for call to function writeWord
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 0
        LCALL   ??writeWord?relay
//  931 }
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock12
//  932 
//  933 /*********************************************************************
//  934  * @fn      writeBuf
//  935  *
//  936  * @brief   Writes a data buffer to NV.
//  937  *
//  938  * @param   dstPg - A valid NV Flash page.
//  939  * @param   offset - A valid offset into the page.
//  940  * @param   len  - Byte count of the data to write.
//  941  * @param   buf  - The data to write.
//  942  *
//  943  * @return  TRUE if data buf checksum matches read back checksum, else FALSE.
//  944  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  945 static void writeBuf( uint8 dstPg, uint16 dstOff, uint16 len, uint8 *buf )
writeBuf:
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function writeBuf
//  946 {
        FUNCALL writeBuf, nvReadWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 19, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 19, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeBuf, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 19, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 19, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeBuf, writeWordM
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeBuf, nvReadWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 19, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 19, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeBuf, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 19, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 19, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xf
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 15)
        ; Saved register size: 15
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 19)
        MOV     ?V0 + 2,R1
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
//  947   uint8 rem = dstOff % OSAL_NV_WORD_SIZE;
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     R2,#0x4
        MOV     R3,#0x0
        LCALL   ?US_DIV_MOD
        MOV     A,R2
        MOV     ?V0 + 3,A
//  948   uint8 tmp[OSAL_NV_WORD_SIZE];
//  949 
//  950   if ( rem )
        MOV     A,?V0 + 3
        JNZ     $+5
        LJMP    ??writeBuf_0 & 0xFFFF
//  951   {
//  952     dstOff = (dstOff / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE;
        MOV     ?V0 + 4,R6
        MOV     ?V0 + 5,R7
        MOV     A,#0x2
        MOV     R0,#?V0 + 4
        LCALL   ?US_SHR
        MOV     R6,?V0 + 4
        MOV     A,R6
        MOV     B,#0x4
        MUL     AB
        XCH     A,R6
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,?V0 + 5
        MUL     AB
        ADD     A,R2
        MOV     R7,A
//  953     nvReadWord( dstPg, dstOff, tmp );
        ; Setup parameters for call to function nvReadWord
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 2
        LCALL   nvReadWord & 0xFFFF
//  954 
//  955     while ( (rem < OSAL_NV_WORD_SIZE) && len )
??writeBuf_1:
        MOV     A,?V0 + 3
        CLR     C
        SUBB    A,#0x4
        JNC     ??writeBuf_2
        MOV     A,#0x0
        XRL     A,?V0 + 0
        JNZ     ??writeBuf_3
        MOV     A,#0x0
        XRL     A,?V0 + 1
??writeBuf_3:
        JZ      ??writeBuf_2
//  956     {
//  957       tmp[rem++] = *buf++;
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     ?V0 + 4,?V0 + 3
        MOV     ?V0 + 5,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,?V0 + 4
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,?V0 + 5
        MOV     DPH,A
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        INC     ?V0 + 3
//  958       len--;
        MOV     A,?V0 + 0
        ADD     A,#-0x1
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#-0x1
        MOV     ?V0 + 1,A
        SJMP    ??writeBuf_1
//  959     }
//  960 
//  961     writeWord( dstPg, dstOff, tmp );
??writeBuf_2:
        ; Setup parameters for call to function writeWord
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 2
        LCALL   ??writeWord?relay
//  962     dstOff += OSAL_NV_WORD_SIZE;
        MOV     A,R6
        ADD     A,#0x4
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
//  963   }
//  964 
//  965   rem = len % OSAL_NV_WORD_SIZE;
??writeBuf_0:
        MOV     R0,?V0 + 0
        MOV     R1,?V0 + 1
        MOV     R2,#0x4
        MOV     R3,#0x0
        LCALL   ?US_DIV_MOD
        MOV     A,R2
        MOV     ?V0 + 3,A
//  966   len /= OSAL_NV_WORD_SIZE;
        MOV     ?V0 + 4,?V0 + 0
        MOV     ?V0 + 5,?V0 + 1
        MOV     A,#0x2
        MOV     R0,#?V0 + 4
        LCALL   ?US_SHR
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
//  967 
//  968   if ( len )
        MOV     A,#0x0
        XRL     A,?V0 + 0
        JNZ     ??writeBuf_4
        MOV     A,#0x0
        XRL     A,?V0 + 1
??writeBuf_4:
        JZ      ??writeBuf_5
//  969   {
//  970     writeWordM( dstPg, dstOff, buf, (uint8)len );
        ; Setup parameters for call to function writeWordM
        MOV     A,?V0 + 0
        MOV     ?V0 + 4,A
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 2
        LCALL   ??writeWordM?relay
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 19)
//  971     dstOff += OSAL_NV_WORD_SIZE * len;
        MOV     R0,?V0 + 0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,?V0 + 1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R6
        ADD     A,R0
        MOV     R6,A
        MOV     A,R7
        ADDC    A,R1
        MOV     R7,A
//  972     buf += OSAL_NV_WORD_SIZE * len;
        MOV     R0,?V0 + 0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,?V0 + 1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  973   }
//  974 
//  975   if ( rem )
??writeBuf_5:
        MOV     A,?V0 + 3
        JZ      ??writeBuf_6
//  976   {
//  977     uint8 idx = 0;
        MOV     ?V0 + 6,#0x0
//  978     nvReadWord( dstPg, dstOff, tmp );
        ; Setup parameters for call to function nvReadWord
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 2
        LCALL   nvReadWord & 0xFFFF
//  979     while ( rem-- )
??writeBuf_7:
        MOV     R2,?V0 + 3
        MOV     A,#-0x1
        ADD     A,R2
        MOV     ?V0 + 3,A
        MOV     A,R2
        JZ      ??writeBuf_8
//  980     {
//  981       tmp[idx++] = *buf++;
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     ?V0 + 4,?V0 + 6
        MOV     ?V0 + 5,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,?V0 + 4
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,?V0 + 5
        MOV     DPH,A
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        INC     ?V0 + 6
        SJMP    ??writeBuf_7
//  982     }
//  983     writeWord( dstPg, dstOff, tmp );
??writeBuf_8:
        ; Setup parameters for call to function writeWord
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 2
        LCALL   ??writeWord?relay
//  984   }
//  985 }
??writeBuf_6:
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 15)
        MOV     R7,#0x7
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock13
//  986 
//  987 /*********************************************************************
//  988  * @fn      xferBuf
//  989  *
//  990  * @brief   Xfers an NV buffer from one location to another, enforcing OSAL_NV_WORD_SIZE writes.
//  991  *
//  992  * @return  none
//  993  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  994 static void xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len )
xferBuf:
        CFI Block cfiBlock14 Using cfiCommon0
        CFI Function xferBuf
//  995 {
        FUNCALL xferBuf, nvReadWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL xferBuf, nvReadByte
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL xferBuf, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL xferBuf, nvReadWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL xferBuf, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL xferBuf, nvReadWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL xferBuf, nvReadByte
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL xferBuf, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 6
        MOV     A,#-0x6
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     ?V0 + 7,R1
        MOV     ?V0 + 3,R4
        MOV     A,#0x16
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
        MOV     A,#0x18
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
//  996   uint8 rem = dstOff % OSAL_NV_WORD_SIZE;
        MOV     R0,?V0 + 0
        MOV     R1,?V0 + 1
        MOV     R2,#0x4
        MOV     R3,#0x0
        LCALL   ?US_DIV_MOD
        MOV     A,R2
        MOV     ?V0 + 2,A
//  997   uint8 tmp[OSAL_NV_WORD_SIZE];
//  998 
//  999   if ( rem )
        MOV     A,?V0 + 2
        JNZ     $+5
        LJMP    ??xferBuf_0 & 0xFFFF
// 1000   {
// 1001     dstOff -= rem;
        MOV     ?V0 + 4,?V0 + 2
        MOV     ?V0 + 5,#0x0
        CLR     C
        MOV     A,?V0 + 0
        SUBB    A,?V0 + 4
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        SUBB    A,?V0 + 5
        MOV     ?V0 + 1,A
// 1002     nvReadWord( dstPg, dstOff, tmp );
        ; Setup parameters for call to function nvReadWord
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     R1,?V0 + 3
        LCALL   nvReadWord & 0xFFFF
// 1003 
// 1004     while ( (rem < OSAL_NV_WORD_SIZE) && len )
??xferBuf_1:
        MOV     A,?V0 + 2
        CLR     C
        SUBB    A,#0x4
        JNC     ??xferBuf_2
        MOV     A,#0x0
        XRL     A,R6
        JNZ     ??xferBuf_3
        MOV     A,#0x0
        XRL     A,R7
??xferBuf_3:
        JZ      ??xferBuf_2
// 1005     {
// 1006       nvReadByte( srcPg, srcOff, tmp+rem );
        ; Setup parameters for call to function nvReadByte
        MOV     ?V0 + 4,?V0 + 2
        MOV     ?V0 + 5,#0x0
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,DPL
        ADD     A,?V0 + 4
        MOV     R4,A
        MOV     A,DPH
        ADDC    A,?V0 + 5
        MOV     R5,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     R1,?V0 + 7
        LCALL   nvReadByte & 0xFFFF
// 1007       srcOff++;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
// 1008       rem++;
        INC     ?V0 + 2
// 1009       len--;
        MOV     A,R6
        ADD     A,#-0x1
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#-0x1
        MOV     R7,A
        SJMP    ??xferBuf_1
// 1010     }
// 1011 
// 1012     writeWord( dstPg, dstOff, tmp );
??xferBuf_2:
        ; Setup parameters for call to function writeWord
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     R1,?V0 + 3
        LCALL   ??writeWord?relay
// 1013     dstOff += OSAL_NV_WORD_SIZE;
        MOV     A,?V0 + 0
        ADD     A,#0x4
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
// 1014   }
// 1015 
// 1016   rem = len % OSAL_NV_WORD_SIZE;
??xferBuf_0:
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     R2,#0x4
        MOV     R3,#0x0
        LCALL   ?US_DIV_MOD
        MOV     A,R2
        MOV     ?V0 + 2,A
// 1017   len /= OSAL_NV_WORD_SIZE;
        MOV     ?V0 + 4,R6
        MOV     ?V0 + 5,R7
        MOV     A,#0x2
        MOV     R0,#?V0 + 4
        LCALL   ?US_SHR
        MOV     R6,?V0 + 4
        MOV     R7,?V0 + 5
// 1018 
// 1019   while ( len-- )
??xferBuf_4:
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     A,#-0x1
        ADD     A,R0
        MOV     R6,A
        MOV     A,#-0x1
        ADDC    A,R1
        MOV     R7,A
        MOV     A,#0x0
        XRL     A,R0
        JNZ     ??xferBuf_5
        MOV     A,#0x0
        XRL     A,R1
??xferBuf_5:
        JZ      ??xferBuf_6
// 1020   {
// 1021     nvReadWord( srcPg, srcOff, tmp );
        ; Setup parameters for call to function nvReadWord
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     R1,?V0 + 7
        LCALL   nvReadWord & 0xFFFF
// 1022     srcOff += OSAL_NV_WORD_SIZE;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,#0x4
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
// 1023     writeWord( dstPg, dstOff, tmp );
        ; Setup parameters for call to function writeWord
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     R1,?V0 + 3
        LCALL   ??writeWord?relay
// 1024     dstOff += OSAL_NV_WORD_SIZE;
        MOV     A,?V0 + 0
        ADD     A,#0x4
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
        SJMP    ??xferBuf_4
// 1025   }
// 1026 
// 1027   if ( rem )
??xferBuf_6:
        MOV     A,?V0 + 2
        JZ      ??xferBuf_7
// 1028   {
// 1029     uint8 idx = 0;
        MOV     ?V0 + 6,#0x0
// 1030     nvReadWord( dstPg, dstOff, tmp );
        ; Setup parameters for call to function nvReadWord
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     R1,?V0 + 3
        LCALL   nvReadWord & 0xFFFF
// 1031     while ( rem-- )
??xferBuf_8:
        MOV     R2,?V0 + 2
        MOV     A,#-0x1
        ADD     A,R2
        MOV     ?V0 + 2,A
        MOV     A,R2
        JZ      ??xferBuf_9
// 1032     {
// 1033       nvReadByte( srcPg, srcOff, tmp+idx );
        ; Setup parameters for call to function nvReadByte
        MOV     ?V0 + 4,?V0 + 6
        MOV     ?V0 + 5,#0x0
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,DPL
        ADD     A,?V0 + 4
        MOV     R4,A
        MOV     A,DPH
        ADDC    A,?V0 + 5
        MOV     R5,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     R1,?V0 + 7
        LCALL   nvReadByte & 0xFFFF
// 1034       srcOff++;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
// 1035       idx++;
        INC     ?V0 + 6
        SJMP    ??xferBuf_8
// 1036     }
// 1037     writeWord( dstPg, dstOff, tmp );
??xferBuf_9:
        ; Setup parameters for call to function writeWord
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     R1,?V0 + 3
        LCALL   ??writeWord?relay
// 1038   }
// 1039 }
??xferBuf_7:
        MOV     A,#0x6
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock14
// 1040 
// 1041 /*********************************************************************
// 1042  * @fn      writeItem
// 1043  *
// 1044  * @brief   Writes an item header/data combo to the specified NV page.
// 1045  *
// 1046  * @param   pg - Valid NV Flash page.
// 1047  * @param   id - Valid NV item Id.
// 1048  * @param   len  - Byte count of the data to write.
// 1049  * @param   buf  - The data to write. If NULL, no data/checksum write.
// 1050  * @param   flag - TRUE if the checksum should be written, FALSE otherwise.
// 1051  *
// 1052  * @return  TRUE if header/data to write matches header/data read back, else FALSE.
// 1053  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1054 static uint8 writeItem( uint8 pg, uint16 id, uint16 len, void *buf, uint8 flag )
writeItem:
        CFI Block cfiBlock15 Using cfiCommon0
        CFI Function writeItem
// 1055 {
        FUNCALL writeItem, setPageUse
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeItem, writeWord
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeItem, nvReadHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeItem, calcChkB
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeItem, writeBuf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeItem, calcChkF
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeItem, writeWordH
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeItem, nvReadHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xf
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 15)
        ; Saved register size: 15
        ; Auto size: 12
        MOV     A,#-0xc
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 27)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     A,R1
        MOV     R6,A
        MOV     ?V0 + 4,R4
        MOV     ?V0 + 5,R5
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
// 1056   uint16 offset = pgOff[pg-OSAL_NV_PAGE_BEG];
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#((pgOff + 136) & 0xff)
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
// 1057   uint8 rtrn = FALSE;
        MOV     R7,#0x0
// 1058   osalNvHdr_t hdr;
// 1059 
// 1060   if ( pg == pgRes )
        MOV     DPTR,#pgRes
        MOVX    A,@DPTR
        XRL     A,R6
        JNZ     ??writeItem_0
// 1061   {
// 1062     /* Mark reserve page as being active, in process of receiving items.
// 1063      * Invoking function must effect a page compaction.
// 1064      */
// 1065     setPageUse( pg, FALSE );
        ; Setup parameters for call to function setPageUse
        MOV     R2,#0x0
        MOV     A,R6
        MOV     R1,A
        LCALL   ??setPageUse?relay
// 1066   }
// 1067 
// 1068   hdr.id = id;
??writeItem_0:
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1069   hdr.len = len;
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 5
        MOVX    @DPTR,A
// 1070 
// 1071   writeWord( pg, offset, (uint8 *)&hdr );
        ; Setup parameters for call to function writeWord
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     A,R6
        MOV     R1,A
        LCALL   ??writeWord?relay
// 1072   nvReadHdr( pg, offset, (uint8 *)(&hdr) );
        ; Setup parameters for call to function nvReadHdr
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     A,R6
        MOV     R1,A
        LCALL   nvReadHdr & 0xFFFF
// 1073 
// 1074   if ( (hdr.id == id) && (hdr.len == len) )
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??writeItem_1
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??writeItem_1:
        JZ      $+5
        LJMP    ??writeItem_2 & 0xFFFF
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,?V0 + 4
        JNZ     ??writeItem_3
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,?V0 + 5
??writeItem_3:
        JZ      $+5
        LJMP    ??writeItem_2 & 0xFFFF
// 1075   {
// 1076     if ( flag )
        MOV     A,?V0 + 6
        JNZ     $+5
        LJMP    ??writeItem_4 & 0xFFFF
// 1077     {
// 1078       uint16 chk = calcChkB( len, buf );
        ; Setup parameters for call to function calcChkB
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        LCALL   ??calcChkB?relay
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1079   
// 1080       offset += OSAL_NV_HDR_SIZE;
        MOV     A,?V0 + 0
        ADD     A,#0x8
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
// 1081       if ( buf != NULL )
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x0
        JNZ     ??writeItem_5
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
??writeItem_5:
        JZ      ??writeItem_6
// 1082       {
// 1083         writeBuf( pg, offset, len, buf );
        ; Setup parameters for call to function writeBuf
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?PUSH_XSTACK8_X_TWO
        CFI CFA_XSP16 add(XSP16, 29)
        MOV     R4,?V0 + 4
        MOV     R5,?V0 + 5
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     A,R6
        MOV     R1,A
        LCALL   ??writeBuf?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 27)
// 1084       }
// 1085   
// 1086       if ( chk == calcChkF( pg, offset, len ) )
??writeItem_6:
        ; Setup parameters for call to function calcChkF
        MOV     R4,?V0 + 4
        MOV     R5,?V0 + 5
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     A,R6
        MOV     R1,A
        LCALL   ??calcChkF?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R0,?V0 + 2
        MOV     R1,?V0 + 3
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??writeItem_7
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??writeItem_7:
        JNZ     ??writeItem_2
// 1087       {
// 1088         writeWordH( pg, (offset-OSAL_NV_WORD_SIZE), (uint8 *)&chk );
        ; Setup parameters for call to function writeWordH
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#-0x4
        ADD     A,?V0 + 0
        MOV     R2,A
        MOV     A,#-0x1
        ADDC    A,?V0 + 1
        MOV     R3,A
        MOV     A,R6
        MOV     R1,A
        LCALL   ??writeWordH?relay
// 1089         nvReadHdr( pg, (offset-OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
        ; Setup parameters for call to function nvReadHdr
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#-0x8
        ADD     A,?V0 + 0
        MOV     R2,A
        MOV     A,#-0x1
        ADDC    A,?V0 + 1
        MOV     R3,A
        MOV     A,R6
        MOV     R1,A
        LCALL   nvReadHdr & 0xFFFF
// 1090   
// 1091         if ( chk == hdr.chk )
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??writeItem_8
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??writeItem_8:
        JNZ     ??writeItem_2
// 1092         {
// 1093           rtrn = pg;
        MOV     A,R6
        MOV     R7,A
        SJMP    ??writeItem_2
// 1094         }
// 1095       }
// 1096     }
// 1097     else
// 1098     {
// 1099       rtrn = pg;
??writeItem_4:
        MOV     A,R6
        MOV     R7,A
// 1100     }
// 1101   }
// 1102 
// 1103   len = OSAL_NV_ITEM_SIZE( hdr.len );
??writeItem_2:
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x3
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
        MOV     A,#0x2
        MOV     R0,#?V0 + 2
        LCALL   ?US_SHR
        MOV     A,?V0 + 2
        MOV     B,#0x4
        MUL     AB
        XCH     A,?V0 + 2
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,?V0 + 3
        MUL     AB
        ADD     A,R2
        MOV     ?V0 + 3,A
        MOV     A,#0x8
        ADD     A,?V0 + 2
        MOV     R0,A
        MOV     A,#0x0
        ADDC    A,?V0 + 3
        MOV     R1,A
        MOV     ?V0 + 4,R0
        MOV     ?V0 + 5,R1
// 1104   pgOff[pg-OSAL_NV_PAGE_BEG] += len;
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#((pgOff + 136) & 0xff)
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,?V0 + 4
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 5
        MOVX    @DPTR,A
// 1105 
// 1106   return rtrn;
        MOV     A,R7
        MOV     R1,A
        MOV     A,#0xc
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 15)
        MOV     R7,#0x7
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock15
// 1107 }
// 1108 
// 1109 /*********************************************************************
// 1110  * @fn      writeIEEE
// 1111  *
// 1112  * @brief   Writes special location / protocol for the IEEE. The global 'failF' should have been
// 1113  *          cleared before invoking.
// 1114  *
// 1115  * @param   buf  - The data to write.
// 1116  *
// 1117  * @return  TRUE if header/data to write matches header/data read back, else FALSE.
// 1118  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1119 static uint8 writeIEEE( void *buf )
writeIEEE:
        CFI Block cfiBlock16 Using cfiCommon0
        CFI Function writeIEEE
// 1120 {
        FUNCALL writeIEEE, nvReadHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL writeIEEE, writeWordM
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 8
        MOV     A,#-0x8
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 17)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1121   osalNvHdr_t hdr;
// 1122   nvReadHdr( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&hdr) );
        ; Setup parameters for call to function nvReadHdr
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#-0x8
        MOV     R3,#0x7
        MOV     R1,#0x3f
        LCALL   nvReadHdr & 0xFFFF
// 1123 
// 1124   if ( (hdr.id == OSAL_NV_ERASED_ID) && (hdr.len == OSAL_NV_ERASED_ID) &&
// 1125        (hdr.chk == OSAL_NV_ERASED_ID) && (hdr.stat == OSAL_NV_ERASED_ID) )
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??writeIEEE_0
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??writeIEEE_0:
        JNZ     ??writeIEEE_1
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??writeIEEE_2
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??writeIEEE_2:
        JNZ     ??writeIEEE_1
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??writeIEEE_3
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??writeIEEE_3:
        JNZ     ??writeIEEE_1
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??writeIEEE_4
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0xff
??writeIEEE_4:
        JNZ     ??writeIEEE_1
// 1126   {
// 1127     writeWordM( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, buf, 2 );
        ; Setup parameters for call to function writeWordM
        MOV     ?V0 + 0,#0x2
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 18)
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,#-0x8
        MOV     R3,#0x7
        MOV     R1,#0x3f
        LCALL   ??writeWordM?relay
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 17)
// 1128     return ((failF) ? NV_OPER_FAILED : ZSUCCESS);
        MOV     DPTR,#failF
        MOVX    A,@DPTR
        JZ      ??writeIEEE_5
        MOV     R1,#0x10
        SJMP    ??writeIEEE_6
??writeIEEE_5:
        MOV     R1,#0x0
        SJMP    ??writeIEEE_6
// 1129   }
// 1130   else
// 1131   {
// 1132     return NV_OPER_FAILED;
??writeIEEE_1:
        MOV     R1,#0x10
??writeIEEE_6:
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 9)
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock16
// 1133   }
// 1134 }
// 1135 
// 1136 /*********************************************************************
// 1137  * @fn      osal_nv_init
// 1138  *
// 1139  * @brief   Initialize NV service.
// 1140  *
// 1141  * @param   p - Not used.
// 1142  *
// 1143  * @return  none
// 1144  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1145 void osal_nv_init( void *p )
osal_nv_init:
        CFI Block cfiBlock17 Using cfiCommon0
        CFI Function osal_nv_init
// 1146 {
        FUNCALL osal_nv_init, initNV
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
// 1147   (void)p;  // Suppress Lint warning.
// 1148 
// 1149   // Set Flash write timing based on CPU speed.
// 1150 #ifdef CPU16MHZ
// 1151   FWT = 0x15;
// 1152 #else
// 1153   FWT = 0x2A;
        MOV     0xab,#0x2a
// 1154 #endif
// 1155 
// 1156   (void)initNV();  // Always returns TRUE after pages have been erased.
        ; Setup parameters for call to function initNV
        LCALL   ??initNV?relay
// 1157 }
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock17
        REQUIRE FWT
// 1158 
// 1159 /*********************************************************************
// 1160  * @fn      osal_nv_item_init
// 1161  *
// 1162  * @brief   If the NV item does not already exist, it is created and
// 1163  *          initialized with the data passed to the function, if any.
// 1164  *          This function must be called before calling osal_nv_read() or
// 1165  *          osal_nv_write().
// 1166  *
// 1167  * @param   id  - Valid NV item Id.
// 1168  * @param   len - Item length.
// 1169  * @param  *buf - Pointer to item initalization data. Set to NULL if none.
// 1170  *
// 1171  * @return  NV_ITEM_UNINIT - Id did not exist and was created successfully.
// 1172  *          ZSUCCESS       - Id already existed, no action taken.
// 1173  *          NV_OPER_FAILED - Failure to find or create Id.
// 1174  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1175 uint8 osal_nv_item_init( uint16 id, uint16 len, void *buf )
osal_nv_item_init:
        CFI Block cfiBlock18 Using cfiCommon0
        CFI Function osal_nv_item_init
// 1176 {
        FUNCALL osal_nv_item_init, findItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_item_init, initItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_item_init, initNV
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 3,A
// 1177   /* Global fail flag for fail due to low bus voltage has less impact on code
// 1178    * size than passing back a return value all the way from the lowest level.
// 1179    */
// 1180   failF = FALSE;
        MOV     A,#0x0
        MOV     DPTR,#failF
        MOVX    @DPTR,A
// 1181 
// 1182   // ZCD_NV_EXTADDR is maintained without an osalNvHdr_t, so it is always already initialized.
// 1183   if ( (id == ZCD_NV_EXTADDR) || (findItem( id ) != OSAL_NV_ITEM_NULL) )
        MOV     A,#0x1
        XRL     A,R6
        JNZ     ??osal_nv_item_init_0
        MOV     A,#0x0
        XRL     A,R7
??osal_nv_item_init_0:
        JZ      ??osal_nv_item_init_1
        ; Setup parameters for call to function findItem
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??findItem?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     A,#0x0
        XRL     A,?V0 + 4
        JNZ     ??osal_nv_item_init_2
        MOV     A,#0x0
        XRL     A,?V0 + 5
??osal_nv_item_init_2:
        JZ      ??osal_nv_item_init_3
// 1184   {
// 1185     return ZSUCCESS;
??osal_nv_item_init_1:
        MOV     R1,#0x0
        SJMP    ??osal_nv_item_init_4
// 1186   }
// 1187   else if ( initItem( TRUE, id, len, buf ) )
??osal_nv_item_init_3:
        ; Setup parameters for call to function initItem
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,#0x1
        LCALL   ??initItem?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     A,R1
        JZ      ??osal_nv_item_init_5
// 1188   {
// 1189     if ( failF )
        MOV     DPTR,#failF
        MOVX    A,@DPTR
        JZ      ??osal_nv_item_init_6
// 1190     {
// 1191       (void)initNV();  // See comment at the declaration of failF.
        ; Setup parameters for call to function initNV
        LCALL   ??initNV?relay
// 1192       return NV_OPER_FAILED;
        MOV     R1,#0x10
        SJMP    ??osal_nv_item_init_4
// 1193     }
// 1194     else
// 1195     {
// 1196       return NV_ITEM_UNINIT;
??osal_nv_item_init_6:
        MOV     R1,#0xf
        SJMP    ??osal_nv_item_init_4
// 1197     }
// 1198   }
// 1199   else
// 1200   {
// 1201     return NV_OPER_FAILED;
??osal_nv_item_init_5:
        MOV     R1,#0x10
??osal_nv_item_init_4:
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock18
// 1202   }
// 1203 }
// 1204 
// 1205 /*********************************************************************
// 1206  * @fn      osal_nv_item_len
// 1207  *
// 1208  * @brief   Get the data length of the item stored in NV memory.
// 1209  *
// 1210  * @param   id  - Valid NV item Id.
// 1211  *
// 1212  * @return  Item length, if found; zero otherwise.
// 1213  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1214 uint16 osal_nv_item_len( uint16 id )
osal_nv_item_len:
        CFI Block cfiBlock19 Using cfiCommon0
        CFI Function osal_nv_item_len
// 1215 {
        FUNCALL osal_nv_item_len, findItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_item_len, nvReadHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 8
        MOV     A,#-0x8
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
// 1216   if ( id == ZCD_NV_EXTADDR )
        MOV     A,#0x1
        XRL     A,?V0 + 0
        JNZ     ??osal_nv_item_len_0
        MOV     A,#0x0
        XRL     A,?V0 + 1
??osal_nv_item_len_0:
        JNZ     ??osal_nv_item_len_1
// 1217   {
// 1218     return Z_EXTADDR_LEN;
        MOV     R2,#0x8
        MOV     R3,#0x0
        SJMP    ??osal_nv_item_len_2
// 1219   }
// 1220   else
// 1221   {
// 1222     uint16 offset = findItem( id );
??osal_nv_item_len_1:
        ; Setup parameters for call to function findItem
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??findItem?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R6,?V0 + 2
        MOV     R7,?V0 + 3
// 1223 
// 1224     if ( offset == OSAL_NV_ITEM_NULL )
        MOV     A,#0x0
        XRL     A,R6
        JNZ     ??osal_nv_item_len_3
        MOV     A,#0x0
        XRL     A,R7
??osal_nv_item_len_3:
        JNZ     ??osal_nv_item_len_4
// 1225     {
// 1226       return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??osal_nv_item_len_2
// 1227     }
// 1228     else
// 1229     {
// 1230       osalNvHdr_t hdr;
// 1231       nvReadHdr( findPg, (offset - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
??osal_nv_item_len_4:
        ; Setup parameters for call to function nvReadHdr
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#-0x8
        ADD     A,R6
        MOV     R2,A
        MOV     A,#-0x1
        ADDC    A,R7
        MOV     R3,A
        MOV     DPTR,#findPg
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   nvReadHdr & 0xFFFF
// 1232       return hdr.len;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
??osal_nv_item_len_2:
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock19
// 1233     }
// 1234   }
// 1235 }
// 1236 
// 1237 /*********************************************************************
// 1238  * @fn      osal_nv_write
// 1239  *
// 1240  * @brief   Write a data item to NV. Function can write an entire item to NV or
// 1241  *          an element of an item by indexing into the item with an offset.
// 1242  *
// 1243  * @param   id  - Valid NV item Id.
// 1244  * @param   ndx - Index offset into item
// 1245  * @param   len - Length of data to write.
// 1246  * @param  *buf - Data to write.
// 1247  *
// 1248  * @return  ZSUCCESS if successful, NV_ITEM_UNINIT if item did not
// 1249  *          exist in NV and offset is non-zero, NV_OPER_FAILED if failure.
// 1250  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1251 uint8 osal_nv_write( uint16 id, uint16 ndx, uint16 len, void *buf )
osal_nv_write:
        CFI Block cfiBlock20 Using cfiCommon0
        CFI Function osal_nv_write
// 1252 {
        FUNCALL osal_nv_write, writeIEEE
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, findItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, nvReadHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, nvReadByte
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, initItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, setItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, xferBuf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 41, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 41, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, writeBuf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, xferBuf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 41, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 41, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, calcChkF
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, writeWordH
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, nvReadHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, setItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, compactPage
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_write, initNV
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xf
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 15)
        ; Saved register size: 15
        ; Auto size: 22
        MOV     A,#-0x16
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 37)
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
// 1253   uint8 rtrn = ZSUCCESS;
        MOV     ?V0 + 6,#0x0
// 1254 
// 1255   /* Global fail flag for fail due to low bus voltage has less impact on code
// 1256    * size than passing back a return value all the way from the lowest level.
// 1257    */
// 1258   failF = FALSE;
        MOV     A,#0x0
        MOV     DPTR,#failF
        MOVX    @DPTR,A
// 1259 
// 1260   if ( id == ZCD_NV_EXTADDR )
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??osal_nv_write_0
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
??osal_nv_write_0:
        JNZ     ??osal_nv_write_1
// 1261   {
// 1262     return writeIEEE( buf );
        ; Setup parameters for call to function writeIEEE
        MOV     A,#0x27
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??writeIEEE?relay
        LJMP    ??osal_nv_write_2 & 0xFFFF
// 1263   }
// 1264 
// 1265   if ( len != 0 )
??osal_nv_write_1:
        MOV     A,#0x25
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x0
        JNZ     ??osal_nv_write_3
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
??osal_nv_write_3:
        JNZ     $+5
        LJMP    ??osal_nv_write_4 & 0xFFFF
// 1266   {
// 1267     osalNvHdr_t hdr;
// 1268     uint16 origOff, srcOff;
// 1269     uint16 cnt;
// 1270     uint8 *ptr;
// 1271 
// 1272     origOff = srcOff = findItem( id );
        ; Setup parameters for call to function findItem
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??findItem?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R0,?V0 + 0
        MOV     R1,?V0 + 1
        MOV     ?V0 + 4,R0
        MOV     ?V0 + 5,R1
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1273     if ( srcOff == OSAL_NV_ITEM_NULL )
        MOV     A,#0x0
        XRL     A,?V0 + 4
        JNZ     ??osal_nv_write_5
        MOV     A,#0x0
        XRL     A,?V0 + 5
??osal_nv_write_5:
        JNZ     ??osal_nv_write_6
// 1274     {
// 1275       return NV_ITEM_UNINIT;
        MOV     R1,#0xf
        LJMP    ??osal_nv_write_2 & 0xFFFF
// 1276     }
// 1277 
// 1278     nvReadHdr( findPg, (srcOff - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
??osal_nv_write_6:
        ; Setup parameters for call to function nvReadHdr
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#-0x8
        ADD     A,?V0 + 4
        MOV     R2,A
        MOV     A,#-0x1
        ADDC    A,?V0 + 5
        MOV     R3,A
        MOV     DPTR,#findPg
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   nvReadHdr & 0xFFFF
// 1279     if ( hdr.len < (ndx + len) )
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        PUSH    DPL
        CFI CFA_SP SP+-1
        PUSH    DPH
        CFI CFA_SP SP+-2
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        PUSH    DPL
        CFI CFA_SP SP+-3
        PUSH    DPH
        CFI CFA_SP SP+-4
        MOV     A,#0x25
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        POP     DPH
        CFI CFA_SP SP+-3
        POP     DPL
        CFI CFA_SP SP+-2
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        POP     DPH
        CFI CFA_SP SP+-1
        POP     DPL
        CFI CFA_SP SP+0
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R0
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        JNC     ??osal_nv_write_7
// 1280     {
// 1281       return NV_OPER_FAILED;
        MOV     R1,#0x10
        LJMP    ??osal_nv_write_2 & 0xFFFF
// 1282     }
// 1283 
// 1284     srcOff += ndx;
??osal_nv_write_7:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 4
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 5
        MOV     ?V0 + 5,A
// 1285     ptr = buf;
        MOV     A,#0x27
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1286     cnt = len;
        MOV     A,#0x25
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1287     while ( cnt )
??osal_nv_write_8:
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x0
        JNZ     ??osal_nv_write_9
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
??osal_nv_write_9:
        JZ      ??osal_nv_write_10
// 1288     {
// 1289       uint8 tmp;
// 1290       nvReadByte( findPg, srcOff++, &tmp );
        ; Setup parameters for call to function nvReadByte
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        MOV     DPTR,#findPg
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   nvReadByte & 0xFFFF
        MOV     A,?V0 + 4
        ADD     A,#0x1
        MOV     ?V0 + 4,A
        MOV     A,?V0 + 5
        ADDC    A,#0x0
        MOV     ?V0 + 5,A
// 1291       if ( tmp != *ptr++ )
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        XRL     A,R2
        JNZ     ??osal_nv_write_10
// 1292       {
// 1293         break;
// 1294       }
// 1295       cnt--;
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#-0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#-0x1
        MOVX    @DPTR,A
        SJMP    ??osal_nv_write_8
// 1296     }
// 1297 
// 1298     if ( cnt != 0 )  // If the buffer to write is different in one or more bytes.
??osal_nv_write_10:
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x0
        JNZ     ??osal_nv_write_11
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
??osal_nv_write_11:
        JNZ     $+5
        LJMP    ??osal_nv_write_4 & 0xFFFF
// 1299     {
// 1300       uint8 comPg, dstPg = initItem( FALSE, id, hdr.len, &comPg );
        ; Setup parameters for call to function initItem
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 39)
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     R1,#0x0
        LCALL   ??initItem?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 37)
        MOV     A,R1
        MOV     R6,A
// 1301 
// 1302       if ( dstPg != OSAL_NV_PAGE_NULL )
        MOV     A,R6
        JNZ     $+5
        LJMP    ??osal_nv_write_12 & 0xFFFF
// 1303       {
// 1304         uint16 tmp = OSAL_NV_DATA_SIZE( hdr.len );
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x3
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
        MOV     A,#0x2
        MOV     R0,#?V0 + 2
        LCALL   ?US_SHR
        MOV     A,?V0 + 2
        MOV     B,#0x4
        MUL     AB
        XCH     A,?V0 + 2
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,?V0 + 3
        MUL     AB
        ADD     A,R2
        MOV     ?V0 + 3,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 3
        MOVX    @DPTR,A
// 1305         uint16 dstOff = pgOff[dstPg-OSAL_NV_PAGE_BEG] - tmp;
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#((pgOff + 136) & 0xff)
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
        MOV     DPH,A
        PUSH    DPL
        CFI CFA_SP SP+-1
        PUSH    DPH
        CFI CFA_SP SP+-2
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        POP     DPH
        CFI CFA_SP SP+-1
        POP     DPL
        CFI CFA_SP SP+0
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        MOV     R1,A
        MOV     ?V0 + 0,R0
        MOV     ?V0 + 1,R1
// 1306         uint8 srcPg = findPg;
        MOV     DPTR,#findPg
        MOVX    A,@DPTR
        MOV     R7,A
// 1307         srcOff = origOff;
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
// 1308 
// 1309         setItem( srcPg, srcOff, eNvXfer );
        ; Setup parameters for call to function setItem
        MOV     R4,#0x0
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        MOV     A,R7
        MOV     R1,A
        LCALL   ??setItem?relay
// 1310 
// 1311         xferBuf( srcPg, srcOff, dstPg, dstOff, ndx );
        ; Setup parameters for call to function xferBuf
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        LCALL   ?PUSH_XSTACK8_X_TWO
        CFI CFA_XSP16 add(XSP16, 39)
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 41)
        MOV     A,R6
        MOV     R4,A
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        MOV     A,R7
        MOV     R1,A
        LCALL   ??xferBuf?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 37)
// 1312         srcOff += ndx;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 4
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 5
        MOV     ?V0 + 5,A
// 1313         dstOff += ndx;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 0
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 1
        MOV     ?V0 + 1,A
// 1314 
// 1315         writeBuf( dstPg, dstOff, len, buf );
        ; Setup parameters for call to function writeBuf
        MOV     A,#0x27
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?PUSH_XSTACK8_X_TWO
        CFI CFA_XSP16 add(XSP16, 39)
        MOV     A,#0x27
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     A,R6
        MOV     R1,A
        LCALL   ??writeBuf?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 37)
// 1316         srcOff += len;
        MOV     A,#0x25
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,?V0 + 4
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 5
        MOV     ?V0 + 5,A
// 1317         dstOff += len;
        MOV     A,#0x25
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,?V0 + 0
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 1
        MOV     ?V0 + 1,A
// 1318 
// 1319         xferBuf( srcPg, srcOff, dstPg, dstOff, (hdr.len-ndx-len) );
        ; Setup parameters for call to function xferBuf
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        PUSH    DPL
        CFI CFA_SP SP+-1
        PUSH    DPH
        CFI CFA_SP SP+-2
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        POP     DPH
        CFI CFA_SP SP+-1
        POP     DPL
        CFI CFA_SP SP+0
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        MOV     R3,A
        MOV     A,#0x25
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R2
        CLR     C
        SUBB    A,R0
        MOV     ?V0 + 2,A
        MOV     A,R3
        SUBB    A,R1
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 39)
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 41)
        MOV     A,R6
        MOV     R4,A
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        MOV     A,R7
        MOV     R1,A
        LCALL   ??xferBuf?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 37)
// 1320 
// 1321         // Calculate and write the new checksum.
// 1322         dstOff = pgOff[dstPg-OSAL_NV_PAGE_BEG] - tmp;
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#((pgOff + 136) & 0xff)
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#(((pgOff - 120) >> 8) & 0xff)
        MOV     DPH,A
        PUSH    DPL
        CFI CFA_SP SP+-1
        PUSH    DPH
        CFI CFA_SP SP+-2
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        POP     DPH
        CFI CFA_SP SP+-1
        POP     DPL
        CFI CFA_SP SP+0
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        MOV     R1,A
        MOV     ?V0 + 0,R0
        MOV     ?V0 + 1,R1
// 1323         tmp = calcChkF( dstPg, dstOff, hdr.len );
        ; Setup parameters for call to function calcChkF
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     A,R6
        MOV     R1,A
        LCALL   ??calcChkF?relay
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1324         dstOff -= OSAL_NV_HDR_SIZE;
        MOV     A,?V0 + 0
        ADD     A,#-0x8
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#-0x1
        MOV     ?V0 + 1,A
// 1325         writeWordH( dstPg, (dstOff+OSAL_NV_HDR_CHK), (uint8 *)&tmp );
        ; Setup parameters for call to function writeWordH
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x4
        ADD     A,?V0 + 0
        MOV     R2,A
        MOV     A,#0x0
        ADDC    A,?V0 + 1
        MOV     R3,A
        MOV     A,R6
        MOV     R1,A
        LCALL   ??writeWordH?relay
// 1326         nvReadHdr( dstPg, dstOff, (uint8 *)(&hdr) );
        ; Setup parameters for call to function nvReadHdr
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     A,R6
        MOV     R1,A
        LCALL   nvReadHdr & 0xFFFF
// 1327 
// 1328         if ( tmp == hdr.chk )
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??osal_nv_write_13
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??osal_nv_write_13:
        JNZ     ??osal_nv_write_14
// 1329         {
// 1330           setItem( srcPg, origOff, eNvZero );
        ; Setup parameters for call to function setItem
        MOV     R4,#0x1
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R7
        MOV     R1,A
        LCALL   ??setItem?relay
        SJMP    ??osal_nv_write_15
// 1331         }
// 1332         else
// 1333         {
// 1334           rtrn = NV_OPER_FAILED;
??osal_nv_write_14:
        MOV     ?V0 + 6,#0x10
// 1335         }
// 1336 
// 1337         if ( dstPg == pgRes )
??osal_nv_write_15:
        MOV     DPTR,#pgRes
        MOVX    A,@DPTR
        XRL     A,R6
        JNZ     ??osal_nv_write_4
// 1338         {
// 1339           compactPage( comPg );
        ; Setup parameters for call to function compactPage
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??compactPage?relay
        SJMP    ??osal_nv_write_4
// 1340         }
// 1341       }
// 1342       else
// 1343       {
// 1344         rtrn = NV_OPER_FAILED;
??osal_nv_write_12:
        MOV     ?V0 + 6,#0x10
// 1345       }
// 1346     }
// 1347   }
// 1348 
// 1349   if ( failF )
??osal_nv_write_4:
        MOV     DPTR,#failF
        MOVX    A,@DPTR
        JZ      ??osal_nv_write_16
// 1350   {
// 1351     (void)initNV();  // See comment at the declaration of failF.
        ; Setup parameters for call to function initNV
        LCALL   ??initNV?relay
// 1352     rtrn = NV_OPER_FAILED;
        MOV     ?V0 + 6,#0x10
// 1353   }
// 1354 
// 1355   return rtrn;
??osal_nv_write_16:
        MOV     R1,?V0 + 6
??osal_nv_write_2:
        MOV     A,#0x16
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 15)
        MOV     R7,#0x7
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock20
// 1356 }
// 1357 
// 1358 /*********************************************************************
// 1359  * @fn      osal_nv_read
// 1360  *
// 1361  * @brief   Read data from NV. This function can be used to read an entire item from NV or
// 1362  *          an element of an item by indexing into the item with an offset.
// 1363  *          Read data is copied into *buf.
// 1364  *
// 1365  * @param   id  - Valid NV item Id.
// 1366  * @param   ndx - Index offset into item
// 1367  * @param   len - Length of data to read.
// 1368  * @param  *buf - Data is read into this buffer.
// 1369  *
// 1370  * @return  ZSUCCESS if NV data was copied to the parameter 'buf'.
// 1371  *          Otherwise, NV_OPER_FAILED for failure.
// 1372  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1373 uint8 osal_nv_read( uint16 id, uint16 ndx, uint16 len, void *buf )
osal_nv_read:
        CFI Block cfiBlock21 Using cfiCommon0
        CFI Function osal_nv_read
// 1374 {
        FUNCALL osal_nv_read, findItem
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL osal_nv_read, nvReadBuf
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 0
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     ?V0 + 6,R4
        MOV     ?V0 + 7,R5
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 1375   uint16 offset;
// 1376 
// 1377   if ( id == ZCD_NV_EXTADDR )
        MOV     A,#0x1
        XRL     A,?V0 + 2
        JNZ     ??osal_nv_read_0
        MOV     A,#0x0
        XRL     A,?V0 + 3
??osal_nv_read_0:
        JNZ     ??osal_nv_read_1
// 1378   {
// 1379     offset = OSAL_NV_IEEE_OFFSET;
        MOV     ?V0 + 0,#-0x8
        MOV     ?V0 + 1,#0x7
// 1380     findPg = OSAL_NV_IEEE_PAGE;
        MOV     A,#0x3f
        MOV     DPTR,#findPg
        MOVX    @DPTR,A
        SJMP    ??osal_nv_read_2
// 1381   }
// 1382   else
// 1383   {
// 1384     offset = findItem( id );
??osal_nv_read_1:
        ; Setup parameters for call to function findItem
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LCALL   ??findItem?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
// 1385     if ( offset == OSAL_NV_ITEM_NULL )
        MOV     A,#0x0
        XRL     A,?V0 + 0
        JNZ     ??osal_nv_read_3
        MOV     A,#0x0
        XRL     A,?V0 + 1
??osal_nv_read_3:
        JNZ     ??osal_nv_read_2
// 1386     {
// 1387       return NV_OPER_FAILED;
        MOV     R1,#0x10
        SJMP    ??osal_nv_read_4
// 1388     }
// 1389   }
// 1390 
// 1391   nvReadBuf(findPg, offset+ndx, buf, len);
??osal_nv_read_2:
        ; Setup parameters for call to function nvReadBuf
        MOV     ?V0 + 4,R6
        MOV     ?V0 + 5,R7
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 18)
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,?V0 + 6
        ADD     A,?V0 + 0
        MOV     R2,A
        MOV     A,?V0 + 7
        ADDC    A,?V0 + 1
        MOV     R3,A
        MOV     DPTR,#findPg
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   nvReadBuf & 0xFFFF
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
// 1392 
// 1393   return ZSUCCESS;
        MOV     R1,#0x0
??osal_nv_read_4:
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock21
// 1394 }

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??initNV?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    initNV

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??setPageUse?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    setPageUse

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??initPage?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    initPage

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??erasePage?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    erasePage

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??compactPage?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    compactPage

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??findItem?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    findItem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??initItem?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    initItem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??setItem?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    setItem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??calcChkB?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    calcChkB

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??calcChkF?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    calcChkF

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??writeWord?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    writeWord

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??writeWordM?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    writeWordM

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??writeWordH?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    writeWordH

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??writeBuf?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    writeBuf

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??xferBuf?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    xferBuf

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??writeItem?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    writeItem

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??writeIEEE?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    writeIEEE

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??osal_nv_init?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    osal_nv_init

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??osal_nv_item_init?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    osal_nv_item_init

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??osal_nv_item_len?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    osal_nv_item_len

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??osal_nv_write?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    osal_nv_write

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??osal_nv_read?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    osal_nv_read

        END
// 1395 
// 1396 /*********************************************************************
// 1397 *********************************************************************/
// 
// 6 467 bytes in segment BANKED_CODE
//   132 bytes in segment BANK_RELAYS
//     4 bytes in segment SFR_AN
//    33 bytes in segment XDATA_Z
// 
// 6 599 bytes of CODE  memory
//     0 bytes of DATA  memory (+ 4 bytes shared)
//    33 bytes of XDATA memory
//
//Errors: none
//Warnings: none

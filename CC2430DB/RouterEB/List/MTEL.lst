###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    03/Jan/2013  17:10:54 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \mt\MTEL.c                                         #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\..\..\..\Tools\C #
#                          C2430DB\f8wRouter.cfg" (-DCPU32MHZ                 #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE -DRTR_NWK         #
#                          -DBLINK_LEDS "-DCONST=const __code"                #
#                          -DGENERIC=__generic) -f "C:\Texas                  #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wCo #
#                          nfig.cfg" (-DSECURE=0 -DDEFAULT_CHANLIST=0x0000080 #
#                          0 -DZDAPP_CONFIG_PAN_ID=0xFFFF                     #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\mt\MTEL. #
#                          c" -D CC2430EB -D AXD_ROUTER -D REFLECTOR -D       #
#                          ZTOOL_P1 -D MT_TASK -D xMT_ZDO_FUNC -D             #
#                          xLCD_SUPPORTED=DEBUG -lC "C:\Texas                 #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\RouterEB\List\" -lA           #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\RouterEB\List\"     #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550    #
#                          -o "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\RouterEB\Obj\"   #
#                          -e --require_prototypes -z9 --no_code_motion       #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\SOURCE\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\Drivers\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\ZMAIN\TI2430DB\" -I  #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MT\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\HAL #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\TARGET\CC2430EB\" -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\OSA #
#                          L\INCLUDE\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\AF\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2. #
#                          1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\.. #
#                          \..\..\COMPONENTS\STACK\NWK\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\SEC\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\STACK\SYS\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\ZDO\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\ZMAC\F8W\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\ZMA #
#                          C\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Pr #
#                          ojects\zstack\Samples\AXDApp\CC2430DB\..\..\..\..\ #
#                          ..\COMPONENTS\SERVICES\SADDR\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\SER #
#                          VICES\SDATA\" -I "C:\Texas                         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\HIGH_LEVEL\" -I           #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \LOW_LEVEL\SRF03\SINGLE_CHIP\" -I "C:\Program      #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\" -I "C:\Program       #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\RouterEB\List\MTEL.l #
#                          st                                                 #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\RouterEB\Obj\MTEL.r5 #
#                          1                                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\mt\MTEL.c
      1          /**************************************************************************************************
      2            Filename:       MTEL.c
      3            Revised:        $Date: 2007-12-07 14:27:57 -0800 (Fri, 07 Dec 2007) $
      4            Revision:       $Revision: 16045 $
      5          
      6            Description:    MonitorTest Event Loop functions. Everything in the MonitorTest Task.
      7          
      8          
      9            Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          #if defined( MT_TASK )
     41          
     42          /*********************************************************************
     43           * INCLUDES
     44           */
     45          #include "ZComDef.h"
     46          #include "OnBoard.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc9
   \   unsigned char volatile __sfr WDCTL
   \                     WDCTL:
   \   000000                DS 1

   \                                 In  segment XDATA_AN, at 0xe000
   \   mboxMsg_t __xdata mboxMsg
   \                     mboxMsg:
   \   000000                DS 8
     47          #include "OSAL.h"
     48          #include "OSAL_Memory.h"
     49          #include "OSAL_Nv.h"
     50          #include "MTEL.h"
     51          #include "DebugTrace.h"
     52          #include "ZMAC.h"
     53          
     54          #if !defined ( NONWK )
     55            #include "NLMEDE.h"
     56            #include "nwk_bufs.h"
     57            #include "ZDObject.h"
     58            #include "ssp.h"
     59            #include "nwk_util.h"
     60          #endif
     61          
     62          #if defined( MT_MAC_FUNC ) || defined( MT_MAC_CB_FUNC )
     63            #include "MT_MAC.h"
     64          #endif
     65          #if defined( MT_NWK_FUNC ) || defined( MT_NWK_CB_FUNC )
     66            #include "MT_NWK.h"
     67            #include "nwk.h"
     68            #include "nwk_bufs.h"
     69          #endif
     70          #if defined( MT_AF_FUNC ) || defined( MT_AF_CB_FUNC )
     71            #include "MT_AF.h"
     72          #endif
     73          #if defined( MT_USER_TEST_FUNC )
     74            #include "AF.h"
     75          #endif
     76          #if defined( MT_ZDO_FUNC )
     77            #include "MT_ZDO.h"
     78          #endif
     79          #if defined (MT_SAPI_FUNC)
     80          	#include "MT_SAPI.h"
     81          #endif
     82          #if defined( APP_TP )
     83           #include "TestProfile.h"
     84          #endif
     85          #if defined( APP_TP2 )
     86           #include "TestProfile2.h"
     87          #endif
     88          
     89          #if defined(APP_TGEN)
     90            #include "TrafficGenApp.h"
     91          #endif
     92          #if defined(APP_DEBUG)
     93          	#include "DebugApp.h"
     94          #endif
     95          #if defined (NWK_TEST)
     96          	#include "HWTTApp.h"
     97          #endif
     98          
     99          /* HAL */
    100          #include "hal_uart.h"
    101          #include "hal_led.h"
    102          #include "hal_key.h"
    103          #include "hal_mailbox.h"
    104          #include "SPIMgr.h"
    105          
    106          /*********************************************************************
    107           * MACROS
    108           */
    109          #define MTEL_DEBUG_INFO( nParams, p1, p2, p3 ) DEBUG_INFO( COMPID_MTEL, nParams, p1, p2, p3 )
    110          
    111          #if defined( EXTERNAL_RAM )
    112            #define IS_MEM_VALID( Addr )  \
    113                  /* Check for valid internal RAM address. */\
    114              ( ( (((Addr) >= MCU_RAM_BEG) && ((Addr) <= MCU_RAM_END)) ||  \
    115                  /* Check for valid external RAM address. */\
    116                  (((Addr) >= EXT_RAM_BEG) && ((Addr) <= EXT_RAM_END)) ) ? TRUE : FALSE )
    117          #else
    118            #define IS_MEM_VALID( Addr )  \
    119                  /* Check for valid internal RAM address. */\
    120              ( ( ((Addr) >= MCU_RAM_BEG) && ((Addr) <= MCU_RAM_END) ) ? TRUE : FALSE )
    121          #endif
    122          
    123          /*********************************************************************
    124           * CONSTANTS
    125           */
    126          
    127          #ifdef ZPORT
    128          const char *MTVersionString[] = {"1.00 (F8W1.4.3-ZP)", "1.10 (F8W1.4.3-ZP)"};
    129          #else

   \                                 In  segment XDATA_I, align 1, keep-with-next
    130          const char *MTVersionString[] = {"1.00 (F8W1.4.3)", "1.10 (F8W1.4.3)"};
   \                     MTVersionString:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for MTVersionString>`
   \   000004                REQUIRE __INIT_XDATA_I
    131          #endif
    132          
    133          /*********************************************************************
    134           * TYPEDEFS
    135           */
    136          
    137          /*********************************************************************
    138           * GLOBAL VARIABLES
    139           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    140          byte MT_TaskID;
   \                     MT_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    141          byte debugThreshold;
   \                     debugThreshold:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    142          byte debugCompId;
   \                     debugCompId:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    143          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    144          UINT16 save_cmd;
   \                     save_cmd:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    145          
    146          //DEBUG

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    147          uint32 longvar;
   \                     longvar:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    148          uint16 *temp_glob_ptr1;
   \                     temp_glob_ptr1:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    149          uint16 *temp_glob_ptr2;
   \                     temp_glob_ptr2:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    150          
    151          /*********************************************************************
    152           * EXTERNAL VARIABLES
    153           */
    154          
    155          /*********************************************************************
    156           * EXTERNAL FUNCTIONS
    157           */
    158          extern unsigned int mac_sim_eventLoop( void );
    159          
    160          #ifdef MACSIM
    161            // Used to pass Zignet message
    162            extern void MACSIM_TranslateMsg( byte *buf, byte bLen );
    163          #endif
    164          
    165          /*********************************************************************
    166           * LOCAL VARIABLES
    167           */
    168          
    169          /*********************************************************************
    170           * LOCAL FUNCTIONS
    171           */
    172          void MT_MsgQueueInit( void );
    173          void MT_ProcessCommand( mtOSALSerialData_t *msg );
    174          void MT_ProcessSerialCommand( byte *msg );
    175          byte MT_RAMRead( UINT16 addr, byte *pData );
    176          byte MT_RAMWrite( UINT16 addr , byte val );
    177          void MT_ProcessDebugMsg( mtDebugMsg_t *pData );
    178          void MT_ProcessDebugStr( mtDebugStr_t *pData );
    179          byte MT_SetDebugThreshold( byte comp_id, byte threshold );
    180          void MT_SendErrorNotification( byte err );
    181          void MT_ResetMsgQueue( void );
    182          byte MT_QueueMsg( byte *msg , byte len );
    183          void MT_ProcessQueue( void );
    184          void MT_SendSPIRespMsg( byte ret, uint16 cmd_id, byte msgLen, byte respLen);
    185          void MT_Reset(byte typID);
    186          byte MT_ProcessSetNV( byte *pData );
    187          void MT_ProcessGetNV( byte *pData );
    188          void MT_ProcessGetNvInfo( void );
    189          void MT_ProcessGetDeviceInfo( void );
    190          byte MTProcessAppMsg( byte *pData, byte len );
    191          void MTProcessAppRspMsg( byte *pData, byte len );
    192          
    193          #if (defined HAL_LED) && (HAL_LED == TRUE)
    194          byte MTProcessLedControl( byte *pData );
    195          #endif
    196          
    197          #if defined ( MT_USER_TEST_FUNC )
    198          void MT_ProcessAppUserCmd( byte *pData );
    199          #endif
    200          
    201          /*********************************************************************
    202           * @fn      MT_TaskInit
    203           *
    204           * @brief
    205           *
    206           *   MonitorTest Task Initialization.  This function is put into the
    207           *   task table.
    208           *
    209           * @param   byte task_id - task ID of the MT Task
    210           *
    211           * @return  void
    212           *
    213           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    214          void MT_TaskInit( byte task_id )
   \                     MT_TaskInit:
    215          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    216            MT_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#MT_TaskID
   \   000008   F0           MOVX    @DPTR,A
    217          
    218            debugThreshold = 0;
   \   000009   E4           CLR     A
   \   00000A   90....       MOV     DPTR,#debugThreshold
   \   00000D   F0           MOVX    @DPTR,A
    219            debugCompId = 0;
   \   00000E   90....       MOV     DPTR,#debugCompId
   \   000011   F0           MOVX    @DPTR,A
    220          
    221            // Initialize the Serial port
    222            SPIMgr_Init();
   \   000012                ; Setup parameters for call to function SPIMgr_Init
   \   000012   12....       LCALL   ??SPIMgr_Init?relay
    223          
    224          } /* MT_TaskInit() */
   \   000015   02....       LJMP    ?Subroutine23 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    225          
    226          #ifdef ZTOOL_PORT
    227          /*********************************************************************
    228           * @fn      MT_IndReset()
    229           *
    230           * @brief   Sends a ZTOOL "reset response" message.
    231           *
    232           * @param   None
    233           *
    234           * @return  None
    235           *
    236           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    237          void MT_IndReset( void )
   \                     MT_IndReset:
    238          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    239          
    240            byte rsp = 0;  // Reset type==0 indicates Z-Stack reset
   \   00000A   E4           CLR     A
   \   00000B   12....       LCALL   ?Subroutine3 & 0xFFFF
    241          
    242            // Send out Reset Response message
    243            MT_BuildAndSendZToolResponse( (SPI_0DATA_MSG_LEN + sizeof( rsp )),
    244                                          (SPI_RESPONSE_BIT | SPI_CMD_SYS_RESET),
    245                                          sizeof( rsp ), &rsp );
   \                     ??CrossCallReturnLabel_8:
   \   00000E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000011   7C01         MOV     R4,#0x1
   \   000013   7A05         MOV     R2,#0x5
   \   000015   02....       LJMP    ?Subroutine24 & 0xFFFF
    246          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000003   12....       LCALL   ?DEALLOC_XSTACK8
   \   000006   7401         MOV     A,#0x1
   \                     ??Subroutine24_0:
   \   000008   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??Subroutine24_1:
   \   00000B   7F02         MOV     R7,#0x2
   \   00000D   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7B10         MOV     R3,#0x10
   \   000002   7906         MOV     R1,#0x6
   \                     ??Subroutine2_0:
   \   000004   12....       LCALL   ??MT_BuildAndSendZToolResponse?relay
   \   000007   7402         MOV     A,#0x2
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   F0           MOVX    @DPTR,A
   \   000007                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000007                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000007   8582..       MOV     ?V0 + 0,DPL
   \   00000A   8583..       MOV     ?V0 + 1,DPH
   \   00000D   78..         MOV     R0,#?V0 + 0
   \   00000F   22           RET
    247          #endif
    248          
    249          /*********************************************************************
    250           * @fn      MT_ProcessEvent
    251           *
    252           * @brief
    253           *
    254           *   MonitorTest Task Event Processor.  This task is put into the
    255           *   task table.
    256           *
    257           * @param   byte task_id - task ID of the MT Task
    258           * @param   UINT16 events - event(s) for the MT Task
    259           *
    260           * @return  void
    261           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    262          UINT16 MT_ProcessEvent( byte task_id, UINT16 events )
   \                     MT_ProcessEvent:
    263          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    264            uint8 *msg_ptr;
    265          
    266            // Could be multiple events, so switch won't work
    267          
    268            if ( events & SYS_EVENT_MSG )
   \   000009   7480         MOV     A,#-0x80
   \   00000B   5F           ANL     A,R7
   \   00000C   F9           MOV     R1,A
   \   00000D   E4           CLR     A
   \   00000E   7001         JNZ     ??MT_ProcessEvent_0
   \   000010   E9           MOV     A,R1
   \                     ??MT_ProcessEvent_0:
   \   000011   7015         JNZ     ??MT_ProcessEvent_1
    269            {
    270              while ( (msg_ptr = osal_msg_receive( MT_TaskID )) )
    271              {
    272                MT_ProcessCommand( (mtOSALSerialData_t *)msg_ptr );
    273              }
    274          
    275              // Return unproccessed events
    276              return (events ^ SYS_EVENT_MSG);
    277            }
    278          
    279          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    280            if ( events & MT_ZTOOL_SERIAL_RCV_BUFFER_FULL )
   \   000013   EE           MOV     A,R6
   \   000014   5404         ANL     A,#0x4
   \   000016   6025         JZ      ??MT_ProcessEvent_2
    281            {
    282              // Do sometype of error processing
    283              MT_SendErrorNotification(RECEIVE_BUFFER_FULL);
   \   000018                ; Setup parameters for call to function MT_SendErrorNotification
   \   000018   7902         MOV     R1,#0x2
   \   00001A   12....       LCALL   ??MT_SendErrorNotification?relay
    284          
    285              // Return unproccessed events
    286              return (events ^ MT_ZTOOL_SERIAL_RCV_BUFFER_FULL);
   \   00001D   7404         MOV     A,#0x4
   \   00001F   6E           XRL     A,R6
   \   000020   FA           MOV     R2,A
   \   000021   EF           MOV     A,R7
   \                     ??MT_ProcessEvent_3:
   \   000022   FB           MOV     R3,A
   \   000023   801C         SJMP    ??MT_ProcessEvent_4
    287            }
   \                     ??MT_ProcessEvent_5:
   \   000025                ; Setup parameters for call to function MT_ProcessCommand
   \   000025   12....       LCALL   ??MT_ProcessCommand?relay
   \                     ??MT_ProcessEvent_1:
   \   000028                ; Setup parameters for call to function osal_msg_receive
   \   000028   90....       MOV     DPTR,#MT_TaskID
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F9           MOV     R1,A
   \   00002D   12....       LCALL   ??osal_msg_receive?relay
   \   000030   EA           MOV     A,R2
   \   000031   7001         JNZ     ??MT_ProcessEvent_6
   \   000033   EB           MOV     A,R3
   \                     ??MT_ProcessEvent_6:
   \   000034   70EF         JNZ     ??MT_ProcessEvent_5
   \   000036   EE           MOV     A,R6
   \   000037   FA           MOV     R2,A
   \   000038   7480         MOV     A,#-0x80
   \   00003A   6F           XRL     A,R7
   \   00003B   80E5         SJMP    ??MT_ProcessEvent_3
    288          #endif
    289          
    290            // Discard or make more handlers
    291            return 0;
   \                     ??MT_ProcessEvent_2:
   \   00003D   7A00         MOV     R2,#0x0
   \   00003F   7B00         MOV     R3,#0x0
   \                     ??MT_ProcessEvent_4:
   \   000041   02....       LJMP    ??Subroutine24_1 & 0xFFFF
    292          
    293          } /* MT_ProcessEvent() */
    294          
    295          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    296          /*********************************************************************
    297           * @fn      MT_BuildSPIMsg
    298           *
    299           * @brief
    300           *
    301           *   Format an SPI message.
    302           *
    303           * @param   UINT16 cmd - command id
    304           * @param   byte *msg - pointer to message buffer
    305           * @param   byte dataLen - length of data field
    306           * @param   byte *pData - pointer to data field
    307           *
    308           * @return  void
    309           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    310          void MT_BuildSPIMsg( UINT16 cmd, byte *msg, byte dataLen, byte *pData )
   \                     MT_BuildSPIMsg:
    311          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   \   000009   89..         MOV     ?V0 + 3,R1
   \   00000B   740E         MOV     A,#0xe
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F5..         MOV     ?V0 + 0,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 1,A
    312            byte *msgPtr;
    313          
    314            *msg++ = SOP_VALUE;
   \   000017   7402         MOV     A,#0x2
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   AE82         MOV     R6,DPL
   \   000021   AF83         MOV     R7,DPH
    315          
    316            msgPtr = msg;
   \   000023   8E..         MOV     ?V0 + 4,R6
   \   000025   8F..         MOV     ?V0 + 5,R7
    317          
    318            *msg++ = (byte)(HI_UINT16( cmd ));
   \   000027   EB           MOV     A,R3
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
    319            *msg++ = (byte)(LO_UINT16( cmd ));
   \   00002A   EA           MOV     A,R2
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
    320          
    321            if ( pData )
   \   00002D   E5..         MOV     A,?V0 + 0
   \   00002F   7002         JNZ     ??MT_BuildSPIMsg_0
   \   000031   E5..         MOV     A,?V0 + 1
   \                     ??MT_BuildSPIMsg_0:
   \   000033   602A         JZ      ??MT_BuildSPIMsg_1
    322            {
    323              *msg++ = dataLen;
   \   000035   E9           MOV     A,R1
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   0E           INC     R6
   \   000039   0E           INC     R6
   \   00003A   0E           INC     R6
   \   00003B   AF83         MOV     R7,DPH
    324          
    325              msg = osal_memcpy( msg, pData, dataLen );
   \   00003D                ; Setup parameters for call to function osal_memcpy
   \   00003D   75..00       MOV     ?V0 + 2,#0x0
   \   000040   78..         MOV     R0,#?V0 + 0
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000045   E9           MOV     A,R1
   \   000046   FC           MOV     R4,A
   \   000047   7D00         MOV     R5,#0x0
   \   000049   EE           MOV     A,R6
   \   00004A   FA           MOV     R2,A
   \   00004B   EF           MOV     A,R7
   \   00004C   FB           MOV     R3,A
   \   00004D   12....       LCALL   ??osal_memcpy?relay
   \   000050   7403         MOV     A,#0x3
   \   000052   12....       LCALL   ?DEALLOC_XSTACK8
   \   000055   8A..         MOV     ?V0 + 0,R2
   \   000057   8B..         MOV     ?V0 + 1,R3
   \   000059   AE..         MOV     R6,?V0 + 0
   \   00005B   AF..         MOV     R7,?V0 + 1
   \   00005D   8008         SJMP    ??MT_BuildSPIMsg_2
    326            }
    327            else
    328              *msg++ = 0;
   \                     ??MT_BuildSPIMsg_1:
   \   00005F   E4           CLR     A
   \   000060   F0           MOVX    @DPTR,A
   \   000061   A3           INC     DPTR
   \   000062   0E           INC     R6
   \   000063   0E           INC     R6
   \   000064   0E           INC     R6
   \   000065   AF83         MOV     R7,DPH
    329          
    330            *msg = SPIMgr_CalcFCS( msgPtr, (byte)(3 + dataLen) );
   \                     ??MT_BuildSPIMsg_2:
   \   000067                ; Setup parameters for call to function SPIMgr_CalcFCS
   \   000067   7403         MOV     A,#0x3
   \   000069   25..         ADD     A,?V0 + 3
   \   00006B   F9           MOV     R1,A
   \   00006C   AA..         MOV     R2,?V0 + 4
   \   00006E   AB..         MOV     R3,?V0 + 5
   \   000070   12....       LCALL   ??SPIMgr_CalcFCS?relay
   \   000073   E9           MOV     A,R1
   \   000074   8E82         MOV     DPL,R6
   \   000076   8F83         MOV     DPH,R7
   \   000078   F0           MOVX    @DPTR,A
    331          }
   \   000079   02....       LJMP    ??Subroutine25_1 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   7401         MOV     A,#0x1
   \                     ??Subroutine25_0:
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??Subroutine25_1:
   \   000005   7F06         MOV     R7,#0x6
   \   000007   02....       LJMP    ?BANKED_LEAVE_XDATA
    332          #endif
    333          
    334          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    335          /*********************************************************************
    336           * @fn      MT_BuildAndSendZToolResponse
    337           *
    338           * @brief
    339           *
    340           *   Build and send a ZTOOL msg
    341           *
    342           * @param   byte err
    343           *
    344           * @return  void
    345           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    346          void MT_BuildAndSendZToolResponse( byte msgLen, uint16 cmd,
   \                     MT_BuildAndSendZToolResponse:
    347                                             byte dataLen, byte *pData )
    348          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   8A..         MOV     ?V0 + 6,R2
   \   000009   8B..         MOV     ?V0 + 7,R3
   \   00000B   8C..         MOV     ?V0 + 3,R4
   \   00000D   7410         MOV     A,#0x10
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F5..         MOV     ?V0 + 1,A
    349            byte *msg_ptr;
    350          
    351            // Get a message buffer to build response message
    352            msg_ptr = osal_mem_alloc( msgLen );
   \   000019                ; Setup parameters for call to function osal_mem_alloc
   \   000019   E9           MOV     A,R1
   \   00001A   FA           MOV     R2,A
   \   00001B   7B00         MOV     R3,#0x0
   \   00001D   12....       LCALL   ??osal_mem_alloc?relay
   \   000020   8A..         MOV     ?V0 + 4,R2
   \   000022   8B..         MOV     ?V0 + 5,R3
   \   000024   AE..         MOV     R6,?V0 + 4
   \   000026   AF..         MOV     R7,?V0 + 5
    353            if ( msg_ptr )
   \   000028   EE           MOV     A,R6
   \   000029   7001         JNZ     ??MT_BuildAndSendZToolResponse_0
   \   00002B   EF           MOV     A,R7
   \                     ??MT_BuildAndSendZToolResponse_0:
   \   00002C   601A         JZ      ??CrossCallReturnLabel_44
    354            {
    355          #ifdef SPI_MGR_DEFAULT_PORT
    356              MT_BuildSPIMsg( cmd, msg_ptr, dataLen, pData );
   \   00002E                ; Setup parameters for call to function MT_BuildSPIMsg
   \   00002E   78..         MOV     R0,#?V0 + 0
   \   000030   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000033   A9..         MOV     R1,?V0 + 3
   \   000035   EE           MOV     A,R6
   \   000036   FC           MOV     R4,A
   \   000037   EF           MOV     A,R7
   \   000038   FD           MOV     R5,A
   \   000039   AA..         MOV     R2,?V0 + 6
   \   00003B   AB..         MOV     R3,?V0 + 7
   \   00003D   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000040   12....       LCALL   ?DEALLOC_XSTACK8
    357              HalUARTWrite ( SPI_MGR_DEFAULT_PORT, msg_ptr, msgLen );
   \   000043                ; Setup parameters for call to function HalUARTWrite
   \   000043   AC..         MOV     R4,?V0 + 2
   \   000045   12....       LCALL   ?Subroutine13 & 0xFFFF
    358          #endif
    359              osal_mem_free( msg_ptr );
    360            }
    361          }
   \                     ??CrossCallReturnLabel_44:
   \   000048   80..         SJMP    ??Subroutine26_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??Subroutine26_0:
   \   000003   7F08         MOV     R7,#0x8
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   7D00         MOV     R5,#0x0
   \                     ??Subroutine13_0:
   \   000002   EE           MOV     A,R6
   \   000003   FA           MOV     R2,A
   \   000004   EF           MOV     A,R7
   \   000005   FB           MOV     R3,A
   \   000006   7900         MOV     R1,#0x0
   \   000008   12....       LCALL   ??HalUARTWrite?relay
   \   00000B                ; Setup parameters for call to function osal_mem_free
   \   00000B                ; Setup parameters for call to function osal_mem_free
   \   00000B                ; Setup parameters for call to function osal_mem_free
   \   00000B   EE           MOV     A,R6
   \   00000C   FA           MOV     R2,A
   \   00000D   EF           MOV     A,R7
   \   00000E   FB           MOV     R3,A
   \   00000F   12....       LCALL   ??osal_mem_free?relay
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ??MT_BuildSPIMsg?relay
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET
    362          #endif
    363          
    364          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    365          /*********************************************************************
    366           * @fn      MT_BuildAndSendZToolCB
    367           *
    368           * @brief
    369           *
    370           *   Build and send a ZTOOL Callback msg
    371           *
    372           * @param   len - length of data portion of the message
    373           *
    374           * @return  void
    375           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    376          void MT_BuildAndSendZToolCB( uint16 callbackID, byte len, byte *pData )
   \                     MT_BuildAndSendZToolCB:
    377          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   89..         MOV     ?V0 + 0,R1
   \   00000B   8C..         MOV     ?V0 + 6,R4
   \   00000D   8D..         MOV     ?V0 + 7,R5
    378            byte msgLen;
    379            mtOSALSerialData_t *msgPtr;
    380            byte *msg;
    381          
    382            msgLen = sizeof ( mtOSALSerialData_t ) + SPI_0DATA_MSG_LEN + len;
    383          
    384            msgPtr = (mtOSALSerialData_t *)osal_msg_allocate( msgLen );
   \   00000F                ; Setup parameters for call to function osal_msg_allocate
   \   00000F   7409         MOV     A,#0x9
   \   000011   12....       LCALL   ?Subroutine14 & 0xFFFF
    385            if ( msgPtr )
   \                     ??CrossCallReturnLabel_87:
   \   000014   7001         JNZ     ??MT_BuildAndSendZToolCB_0
   \   000016   EB           MOV     A,R3
   \                     ??MT_BuildAndSendZToolCB_0:
   \   000017   6062         JZ      ??MT_BuildAndSendZToolCB_1
    386            {
    387              msgPtr->hdr.event = CB_FUNC;
   \   000019   7404         MOV     A,#0x4
   \   00001B   8A82         MOV     DPL,R2
   \   00001D   8B83         MOV     DPH,R3
   \   00001F   F0           MOVX    @DPTR,A
    388              msgPtr->msg = (uint8 *)(msgPtr+1);
   \   000020   EA           MOV     A,R2
   \   000021   2402         ADD     A,#0x2
   \   000023   F8           MOV     R0,A
   \   000024   EB           MOV     A,R3
   \   000025   3400         ADDC    A,#0x0
   \   000027   F9           MOV     R1,A
   \   000028   EA           MOV     A,R2
   \   000029   2404         ADD     A,#0x4
   \   00002B   FA           MOV     R2,A
   \   00002C   EB           MOV     A,R3
   \   00002D   3400         ADDC    A,#0x0
   \   00002F   FB           MOV     R3,A
   \   000030   8882         MOV     DPL,R0
   \   000032   8983         MOV     DPH,R1
   \   000034   EA           MOV     A,R2
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   EB           MOV     A,R3
   \   000038   F0           MOVX    @DPTR,A
    389              msg = msgPtr->msg;
   \   000039   8882         MOV     DPL,R0
   \   00003B   8983         MOV     DPH,R1
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FA           MOV     R2,A
    390          
    391              //First byte is used as the event type for MT
    392              *msg++ = SOP_VALUE;
   \   00003F   7402         MOV     A,#0x2
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
    393              *msg++ = HI_UINT16( callbackID );
   \   000047   EF           MOV     A,R7
   \   000048   F0           MOVX    @DPTR,A
   \   000049   A3           INC     DPTR
    394              *msg++ = LO_UINT16( callbackID );
   \   00004A   EE           MOV     A,R6
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
    395              *msg++ = len;
   \   00004D   E5..         MOV     A,?V0 + 0
   \   00004F   F0           MOVX    @DPTR,A
   \   000050   A3           INC     DPTR
   \   000051   AA82         MOV     R2,DPL
   \   000053   AB83         MOV     R3,DPH
    396          
    397              //Fill up the data bytes
    398              osal_memcpy( msg, pData, len );
   \   000055                ; Setup parameters for call to function osal_memcpy
   \   000055   85....       MOV     ?V0 + 4,?V0 + 6
   \   000058   85....       MOV     ?V0 + 5,?V0 + 7
   \   00005B   75..00       MOV     ?V0 + 6,#0x0
   \   00005E   78..         MOV     R0,#?V0 + 4
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000063   AC..         MOV     R4,?V0 + 0
   \   000065   7D00         MOV     R5,#0x0
   \   000067   12....       LCALL   ??osal_memcpy?relay
   \   00006A   7403         MOV     A,#0x3
   \   00006C   12....       LCALL   ?DEALLOC_XSTACK8
    399          
    400              osal_msg_send( MT_TaskID, (uint8 *)msgPtr );
   \   00006F                ; Setup parameters for call to function osal_msg_send
   \   00006F   AA..         MOV     R2,?V0 + 2
   \   000071   AB..         MOV     R3,?V0 + 3
   \   000073   90....       MOV     DPTR,#MT_TaskID
   \   000076   E0           MOVX    A,@DPTR
   \   000077   F9           MOV     R1,A
   \   000078   12....       LCALL   ??osal_msg_send?relay
    401            }
    402          }
   \                     ??MT_BuildAndSendZToolCB_1:
   \   00007B   02....       LJMP    ??Subroutine26_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   25..         ADD     A,?V0 + 0
   \   000002   FA           MOV     R2,A
   \   000003   7B00         MOV     R3,#0x0
   \   000005   12....       LCALL   ??osal_msg_allocate?relay
   \   000008                REQUIRE ?Subroutine28
   \   000008                ; // Fall through to label ?Subroutine28

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   8A..         MOV     ?V0 + 2,R2
   \   000002   8B..         MOV     ?V0 + 3,R3
   \   000004   EA           MOV     A,R2
   \   000005   22           RET
    403          #endif
    404          
    405          /*********************************************************************
    406           * @fn      MT_ProcessCommand
    407           *
    408           * @brief
    409           *
    410           *   Process Event Messages.
    411           *
    412           * @param   byte *msg - pointer to event message
    413           *
    414           * @return
    415           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    416          void MT_ProcessCommand( mtOSALSerialData_t *msg )
   \                     MT_ProcessCommand:
    417          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
    418            byte deallocate;
    419          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    420            byte *msg_ptr;
    421            byte len;
    422          
    423            // A little setup for AF, CB_FUNC and MT_SYS_APP_RSP_MSG
    424            msg_ptr = msg->msg;
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FE           MOV     R6,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FF           MOV     R7,A
    425          #endif // ZTOOL
    426          
    427            deallocate = true;
    428          
    429            // Use the first byte of the message as the command ID
    430            switch ( msg->hdr.event )
   \   000014   8A82         MOV     DPL,R2
   \   000016   8B83         MOV     DPH,R3
   \   000018   E0           MOVX    A,@DPTR
   \   000019   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for MT_ProcessCommand>_0`:
   \   00001C   00           DB        0
   \   00001D   05           DB        5
   \   00001E   01           DB        1
   \   00001F   ....         DW        ??MT_ProcessCommand_0
   \   000021   02           DB        2
   \   000022   ....         DW        ??MT_ProcessCommand_1
   \   000024   04           DB        4
   \   000025   ....         DW        ??MT_ProcessCommand_2
   \   000027   06           DB        6
   \   000028   ....         DW        ??MT_ProcessCommand_3
   \   00002A   24           DB        36
   \   00002B   ....         DW        ??MT_ProcessCommand_4
   \   00002D   ....         DW        ??MT_ProcessCommand_5
    431            {
    432          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    433              case CMD_SERIAL_MSG:
    434                MT_ProcessSerialCommand( msg->msg );
   \                     ??MT_ProcessCommand_0:
   \   00002F                ; Setup parameters for call to function MT_ProcessSerialCommand
   \   00002F   8A82         MOV     DPL,R2
   \   000031   8B83         MOV     DPH,R3
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   12....       LCALL   ??Subroutine8_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000038   12....       LCALL   ??MT_ProcessSerialCommand?relay
   \   00003B   8063         SJMP    ??MT_ProcessCommand_5
    435                break;
    436          
    437              case CMD_DEBUG_MSG:
    438                MT_ProcessDebugMsg( (mtDebugMsg_t *)msg );
   \                     ??MT_ProcessCommand_1:
   \   00003D                ; Setup parameters for call to function MT_ProcessDebugMsg
   \   00003D   12....       LCALL   ??MT_ProcessDebugMsg?relay
   \   000040   805E         SJMP    ??MT_ProcessCommand_5
    439                break;
    440          
    441              case CMD_DEBUG_STR:
    442                MT_ProcessDebugStr( (mtDebugStr_t *)msg );
   \                     ??MT_ProcessCommand_3:
   \   000042                ; Setup parameters for call to function MT_ProcessDebugStr
   \   000042   12....       LCALL   ??MT_ProcessDebugStr?relay
   \   000045   8059         SJMP    ??MT_ProcessCommand_5
    443                break;
    444          
    445              case CB_FUNC:
    446                /*
    447                  Build SPI message here instead of redundantly calling MT_BuildSPIMsg
    448                  because we have copied data already in the allocated message
    449                */
    450          
    451                /* msg_ptr is the beginning of the intended SPI message */
    452                len = SPI_0DATA_MSG_LEN + msg_ptr[DATALEN_FIELD];
   \                     ??MT_ProcessCommand_2:
   \   000047   8E82         MOV     DPL,R6
   \   000049   8F83         MOV     DPH,R7
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   2405         ADD     A,#0x5
   \   000051   F5..         MOV     ?V0 + 2,A
    453          
    454                /*
    455                  FCS goes to the last byte in the message and is calculated over all
    456                  the bytes except FCS and SOP
    457                */
    458                msg_ptr[len-1] = SPIMgr_CalcFCS( msg_ptr + 1 , (byte)(len-2) );
   \   000053                ; Setup parameters for call to function SPIMgr_CalcFCS
   \   000053   74FE         MOV     A,#-0x2
   \   000055   25..         ADD     A,?V0 + 2
   \   000057   F9           MOV     R1,A
   \   000058   8E82         MOV     DPL,R6
   \   00005A   8F83         MOV     DPH,R7
   \   00005C   A3           INC     DPTR
   \   00005D   AA82         MOV     R2,DPL
   \   00005F   AB83         MOV     R3,DPH
   \   000061   12....       LCALL   ??SPIMgr_CalcFCS?relay
   \   000064   E9           MOV     A,R1
   \   000065   C0E0         PUSH    A
   \   000067   85....       MOV     ?V0 + 4,?V0 + 2
   \   00006A   EE           MOV     A,R6
   \   00006B   25..         ADD     A,?V0 + 4
   \   00006D   F8           MOV     R0,A
   \   00006E   EF           MOV     A,R7
   \   00006F   3400         ADDC    A,#0x0
   \   000071   F9           MOV     R1,A
   \   000072   74FF         MOV     A,#-0x1
   \   000074   28           ADD     A,R0
   \   000075   F582         MOV     DPL,A
   \   000077   74FF         MOV     A,#-0x1
   \   000079   39           ADDC    A,R1
   \   00007A   F583         MOV     DPH,A
   \   00007C   D0E0         POP     A
   \   00007E   F0           MOVX    @DPTR,A
    459          
    460          #ifdef SPI_MGR_DEFAULT_PORT
    461                HalUARTWrite ( SPI_MGR_DEFAULT_PORT, msg_ptr, len );
   \   00007F                ; Setup parameters for call to function HalUARTWrite
   \   00007F   AC..         MOV     R4,?V0 + 2
   \   000081   7D00         MOV     R5,#0x0
   \   000083   EE           MOV     A,R6
   \   000084   FA           MOV     R2,A
   \   000085   EF           MOV     A,R7
   \   000086   FB           MOV     R3,A
   \   000087   7900         MOV     R1,#0x0
   \   000089   12....       LCALL   ??HalUARTWrite?relay
   \   00008C   8012         SJMP    ??MT_ProcessCommand_5
    462          #endif
    463                break;
    464          
    465          #if !defined ( NONWK )
    466              case MT_SYS_APP_RSP_MSG:
    467                len = SPI_0DATA_MSG_LEN + msg_ptr[DATALEN_FIELD];
    468                MTProcessAppRspMsg( msg_ptr, len );
   \                     ??MT_ProcessCommand_4:
   \   00008E                ; Setup parameters for call to function MTProcessAppRspMsg
   \   00008E   8E82         MOV     DPL,R6
   \   000090   8F83         MOV     DPH,R7
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   A3           INC     DPTR
   \   000095   E0           MOVX    A,@DPTR
   \   000096   2405         ADD     A,#0x5
   \   000098   F9           MOV     R1,A
   \   000099   EE           MOV     A,R6
   \   00009A   FA           MOV     R2,A
   \   00009B   EF           MOV     A,R7
   \   00009C   FB           MOV     R3,A
   \   00009D   12....       LCALL   ??MTProcessAppRspMsg?relay
    469                break;
    470          #endif  // NONWK
    471          #endif  // ZTOOL
    472          
    473              default:
    474                break;
    475            }
    476          
    477            if ( deallocate )
    478            {
    479              osal_msg_deallocate( (uint8 *)msg );
   \                     ??MT_ProcessCommand_5:
   \   0000A0                ; Setup parameters for call to function osal_msg_deallocate
   \   0000A0   AA..         MOV     R2,?V0 + 0
   \   0000A2   AB..         MOV     R3,?V0 + 1
   \   0000A4   12....       LCALL   ??osal_msg_deallocate?relay
    480            }
    481          }
   \   0000A7   02....       LJMP    ??Subroutine25_1 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \                     ??Subroutine8_0:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FA           MOV     R2,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FB           MOV     R3,A
   \   00000B   22           RET
    482          
    483          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    484          /*********************************************************************
    485           * @fn      MT_ProcessDebugMsg
    486           *
    487           * @brief
    488           *
    489           *   Build and send a debug message.
    490           *
    491           * @param   byte *data - pointer to the data portion of the debug message
    492           *
    493           * @return  void
    494           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    495          void MT_ProcessDebugMsg( mtDebugMsg_t *msg )
   \                     MT_ProcessDebugMsg:
    496          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    497            byte *msg_ptr;
    498            byte dataLen;
    499            uint8 buf[11];
    500            uint8 *pBuf;
    501          
    502            // Calculate the data length based
    503            dataLen = 5 + (msg->numParams * sizeof ( uint16 ));
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   C3           CLR     C
   \   000018   33           RLC     A
   \   000019   2405         ADD     A,#0x5
   \   00001B   F5..         MOV     ?V0 + 0,A
    504          
    505            // Get a message buffer to build the debug message
    506            msg_ptr = osal_msg_allocate( (byte)(SPI_0DATA_MSG_LEN + dataLen + 1) );
   \   00001D                ; Setup parameters for call to function osal_msg_allocate
   \   00001D   7406         MOV     A,#0x6
   \   00001F   12....       LCALL   ?Subroutine14 & 0xFFFF
    507            if ( msg_ptr )
   \                     ??CrossCallReturnLabel_88:
   \   000022   7001         JNZ     ??MT_ProcessDebugMsg_0
   \   000024   EB           MOV     A,R3
   \                     ??MT_ProcessDebugMsg_0:
   \   000025   7003         JNZ     $+5
   \   000027   02....       LJMP    ??MT_ProcessDebugMsg_1 & 0xFFFF
    508            {
    509              // Build the message
    510              pBuf = buf;
    511              *pBuf++ = msg->compID;
   \   00002A   8E82         MOV     DPL,R6
   \   00002C   8F83         MOV     DPH,R7
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   85..82       MOV     DPL,?XSP + 0
   \   000034   85..83       MOV     DPH,?XSP + 1
   \   000037   12....       LCALL   ?Subroutine4 & 0xFFFF
    512              *pBuf++ = msg->severity;
   \                     ??CrossCallReturnLabel_10:
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   C0E0         PUSH    A
   \   00003D   7401         MOV     A,#0x1
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   D0E0         POP     A
   \   000044   F0           MOVX    @DPTR,A
    513              *pBuf++ = msg->numParams;
   \   000045   EE           MOV     A,R6
   \   000046   2404         ADD     A,#0x4
   \   000048   F8           MOV     R0,A
   \   000049   EF           MOV     A,R7
   \   00004A   3400         ADDC    A,#0x0
   \   00004C   F9           MOV     R1,A
   \   00004D   E8           MOV     A,R0
   \   00004E   FA           MOV     R2,A
   \   00004F   E9           MOV     A,R1
   \   000050   FB           MOV     R3,A
   \   000051   8A82         MOV     DPL,R2
   \   000053   8B83         MOV     DPH,R3
   \   000055   E0           MOVX    A,@DPTR
   \   000056   C0E0         PUSH    A
   \   000058   7402         MOV     A,#0x2
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   D0E0         POP     A
   \   00005F   F0           MOVX    @DPTR,A
   \   000060   7403         MOV     A,#0x3
   \   000062   12....       LCALL   ?XSTACK_DISP0_8
   \   000065   A882         MOV     R0,DPL
   \   000067   A983         MOV     R1,DPH
    514          
    515              if ( msg->numParams >= 1 )
   \   000069   8A82         MOV     DPL,R2
   \   00006B   8B83         MOV     DPH,R3
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   6030         JZ      ??MT_ProcessDebugMsg_2
    516              {
    517                *pBuf++ = HI_UINT16( msg->param1 );
   \   000070   EE           MOV     A,R6
   \   000071   2405         ADD     A,#0x5
   \   000073   F8           MOV     R0,A
   \   000074   EF           MOV     A,R7
   \   000075   3400         ADDC    A,#0x0
   \   000077   F9           MOV     R1,A
   \   000078   8882         MOV     DPL,R0
   \   00007A   8983         MOV     DPH,R1
   \   00007C   A3           INC     DPTR
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   C0E0         PUSH    A
   \   000080   7403         MOV     A,#0x3
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   D0E0         POP     A
   \   000087   F0           MOVX    @DPTR,A
    518                *pBuf++ = LO_UINT16( msg->param1 );
   \   000088   8882         MOV     DPL,R0
   \   00008A   8983         MOV     DPH,R1
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   C0E0         PUSH    A
   \   00008F   7404         MOV     A,#0x4
   \   000091   12....       LCALL   ?XSTACK_DISP0_8
   \   000094   D0E0         POP     A
   \   000096   F0           MOVX    @DPTR,A
   \   000097   7405         MOV     A,#0x5
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   A882         MOV     R0,DPL
   \   00009E   A983         MOV     R1,DPH
    519              }
    520          
    521              if ( msg->numParams >= 2 )
   \                     ??MT_ProcessDebugMsg_2:
   \   0000A0   8E82         MOV     DPL,R6
   \   0000A2   8F83         MOV     DPH,R7
   \   0000A4   A3           INC     DPTR
   \   0000A5   A3           INC     DPTR
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   C3           CLR     C
   \   0000AA   9402         SUBB    A,#0x2
   \   0000AC   4009         JC      ??CrossCallReturnLabel_6
    522              {
    523                *pBuf++ = HI_UINT16( msg->param2 );
   \   0000AE   EE           MOV     A,R6
   \   0000AF   2407         ADD     A,#0x7
   \   0000B1   0A           INC     R2
   \   0000B2   0A           INC     R2
   \   0000B3   0A           INC     R2
   \   0000B4   12....       LCALL   ?Subroutine1 & 0xFFFF
    524                *pBuf++ = LO_UINT16( msg->param2 );
    525              }
    526          
    527              if ( msg->numParams == 3 )
   \                     ??CrossCallReturnLabel_6:
   \   0000B7   8E82         MOV     DPL,R6
   \   0000B9   8F83         MOV     DPH,R7
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   A3           INC     DPTR
   \   0000BF   E0           MOVX    A,@DPTR
   \   0000C0   6403         XRL     A,#0x3
   \   0000C2   7007         JNZ     ??CrossCallReturnLabel_7
    528              {
    529                *pBuf++ = HI_UINT16( msg->param3 );
   \   0000C4   EE           MOV     A,R6
   \   0000C5   2409         ADD     A,#0x9
   \   0000C7   FA           MOV     R2,A
   \   0000C8   12....       LCALL   ?Subroutine1 & 0xFFFF
    530                *pBuf++ = LO_UINT16( msg->param3 );
    531              }
    532          
    533              *pBuf++ = HI_UINT16( msg->timestamp );
   \                     ??CrossCallReturnLabel_7:
   \   0000CB   EE           MOV     A,R6
   \   0000CC   240B         ADD     A,#0xb
   \   0000CE   FA           MOV     R2,A
   \   0000CF   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   0000D2   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   0000D5   A3           INC     DPTR
   \   0000D6   A882         MOV     R0,DPL
   \   0000D8   A983         MOV     R1,DPH
    534              *pBuf++ = LO_UINT16( msg->timestamp );
   \   0000DA   8A82         MOV     DPL,R2
   \   0000DC   8B83         MOV     DPH,R3
   \   0000DE   12....       LCALL   ?Subroutine11 & 0xFFFF
    535          
    536          #ifdef SPI_MGR_DEFAULT_PORT
    537              MT_BuildSPIMsg( SPI_CMD_DEBUG_MSG, &msg_ptr[1], dataLen, buf );
   \                     ??CrossCallReturnLabel_37:
   \   0000E1   85..82       MOV     DPL,?V0 + 2
   \   0000E4   85..83       MOV     DPH,?V0 + 3
   \   0000E7   A3           INC     DPTR
   \   0000E8   AE82         MOV     R6,DPL
   \   0000EA   AF83         MOV     R7,DPH
   \   0000EC                ; Setup parameters for call to function MT_BuildSPIMsg
   \   0000EC   85..82       MOV     DPL,?XSP + 0
   \   0000EF   85..83       MOV     DPH,?XSP + 1
   \   0000F2   8582..       MOV     ?V0 + 4,DPL
   \   0000F5   8583..       MOV     ?V0 + 5,DPH
   \   0000F8   78..         MOV     R0,#?V0 + 4
   \   0000FA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FD   A9..         MOV     R1,?V0 + 0
   \   0000FF   EE           MOV     A,R6
   \   000100   FC           MOV     R4,A
   \   000101   EF           MOV     A,R7
   \   000102   FD           MOV     R5,A
   \   000103   7A03         MOV     R2,#0x3
   \   000105   7B40         MOV     R3,#0x40
   \   000107   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00010A   12....       LCALL   ?DEALLOC_XSTACK8
    538              HalUARTWrite ( SPI_MGR_DEFAULT_PORT, &msg_ptr[1], SPI_0DATA_MSG_LEN + dataLen );
   \   00010D                ; Setup parameters for call to function HalUARTWrite
   \   00010D   7405         MOV     A,#0x5
   \   00010F   25..         ADD     A,?V0 + 0
   \   000111   FC           MOV     R4,A
   \   000112   E4           CLR     A
   \   000113   3400         ADDC    A,#0x0
   \   000115   FD           MOV     R5,A
   \   000116   EE           MOV     A,R6
   \   000117   FA           MOV     R2,A
   \   000118   EF           MOV     A,R7
   \   000119   FB           MOV     R3,A
   \   00011A   7900         MOV     R1,#0x0
   \   00011C   12....       LCALL   ??HalUARTWrite?relay
    539          #endif
    540              osal_msg_deallocate( msg_ptr );
   \   00011F                ; Setup parameters for call to function osal_msg_deallocate
   \   00011F   AA..         MOV     R2,?V0 + 2
   \   000121   AB..         MOV     R3,?V0 + 3
   \   000123   12....       LCALL   ??osal_msg_deallocate?relay
    541            }
    542          }
   \                     ??MT_ProcessDebugMsg_1:
   \   000126   740B         MOV     A,#0xb
   \   000128   80..         SJMP    ??Subroutine25_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000003   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000006   A3           INC     DPTR
   \   000007   A882         MOV     R0,DPL
   \   000009   A983         MOV     R1,DPH
   \   00000B   8A82         MOV     DPL,R2
   \   00000D   8B83         MOV     DPH,R3
   \   00000F   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000012   A3           INC     DPTR
   \   000013   08           INC     R0
   \   000014   A983         MOV     R1,DPH
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   EF           MOV     A,R7
   \   000001   3400         ADDC    A,#0x0
   \   000003   FB           MOV     R3,A
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   F0           MOVX    @DPTR,A
   \   000006   22           RET
    543          #endif // ZTOOL
    544          
    545          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    546          /*********************************************************************
    547           * @fn      MT_ProcessDebugStr
    548           *
    549           * @brief
    550           *
    551           *   Build and send a debug string.
    552           *
    553           * @param   byte *dstr - pointer to the data portion of the debug message
    554           *
    555           * @return  void
    556           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    557          void MT_ProcessDebugStr( mtDebugStr_t *dstr )
   \                     MT_ProcessDebugStr:
    558          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
    559            byte *msg_ptr;
    560          
    561            // Get a message buffer to build the debug message
    562            msg_ptr = osal_mem_alloc( (byte)(SPI_0DATA_MSG_LEN + dstr->sln) );
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   2405         ADD     A,#0x5
   \   000012   12....       LCALL   ?Subroutine15 & 0xFFFF
    563            if ( msg_ptr )
   \                     ??CrossCallReturnLabel_47:
   \   000015   7001         JNZ     ??MT_ProcessDebugStr_0
   \   000017   EF           MOV     A,R7
   \                     ??MT_ProcessDebugStr_0:
   \   000018   6041         JZ      ??CrossCallReturnLabel_46
    564            {
    565          #ifdef SPI_MGR_DEFAULT_PORT
    566              MT_BuildSPIMsg( SPI_RESPONSE_BIT | SPI_SYS_STRING_MSG, msg_ptr, dstr->sln, dstr->pString );
   \   00001A   E5..         MOV     A,?V0 + 0
   \   00001C   2402         ADD     A,#0x2
   \   00001E   F5..         MOV     ?V0 + 2,A
   \   000020   E5..         MOV     A,?V0 + 1
   \   000022   3400         ADDC    A,#0x0
   \   000024   F5..         MOV     ?V0 + 3,A
   \   000026                ; Setup parameters for call to function MT_BuildSPIMsg
   \   000026   85..82       MOV     DPL,?V0 + 0
   \   000029   85..83       MOV     DPH,?V0 + 1
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000032   85..82       MOV     DPL,?V0 + 2
   \   000035   85..83       MOV     DPH,?V0 + 3
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F9           MOV     R1,A
   \   00003A   EE           MOV     A,R6
   \   00003B   FC           MOV     R4,A
   \   00003C   EF           MOV     A,R7
   \   00003D   FD           MOV     R5,A
   \   00003E   7A15         MOV     R2,#0x15
   \   000040   7B10         MOV     R3,#0x10
   \   000042   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
    567              HalUARTWrite ( SPI_MGR_DEFAULT_PORT, msg_ptr, SPI_0DATA_MSG_LEN + dstr->sln );
   \   000048                ; Setup parameters for call to function HalUARTWrite
   \   000048   85..82       MOV     DPL,?V0 + 2
   \   00004B   85..83       MOV     DPH,?V0 + 3
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F8           MOV     R0,A
   \   000050   7405         MOV     A,#0x5
   \   000052   28           ADD     A,R0
   \   000053   FC           MOV     R4,A
   \   000054   E4           CLR     A
   \   000055   3400         ADDC    A,#0x0
   \   000057   FD           MOV     R5,A
   \   000058   12....       LCALL   ??Subroutine13_0 & 0xFFFF
    568          #endif
    569              osal_mem_free( msg_ptr );
    570            }
    571          }
   \                     ??CrossCallReturnLabel_46:
   \   00005B                REQUIRE ?Subroutine29
   \   00005B                ; // Fall through to label ?Subroutine29

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   FA           MOV     R2,A
   \   000001   7B00         MOV     R3,#0x0
   \   000003   12....       LCALL   ??osal_mem_alloc?relay
   \   000006   8A..         MOV     ?V0 + 2,R2
   \   000008   8B..         MOV     ?V0 + 3,R3
   \   00000A   AE..         MOV     R6,?V0 + 2
   \   00000C   AF..         MOV     R7,?V0 + 3
   \   00000E   EE           MOV     A,R6
   \   00000F   22           RET
    572          #endif // ZTOOL
    573          
    574          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    575          /*********************************************************************
    576           * @fn      MT_ProcessSetNV
    577           *
    578           * @brief
    579           *
    580           *   The Set NV serial message.
    581           *
    582           * @param   byte *msg - pointer to the data
    583           *
    584           * @return  ZSuccess if successful
    585           *
    586           * @MT SPI_CMD_SYS_SET_NV
    587           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    588          byte MT_ProcessSetNV( byte *pData )
   \                     MT_ProcessSetNV:
    589          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    590            uint16  attrib;
    591            uint16  attlen;
    592          
    593            attrib = (uint16) *pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FE           MOV     R6,A
    594            pData += 2;   // skip additional byte containing len field
    595            attlen = osal_nv_item_len( attrib );
    596          
    597            return osal_nv_write( attrib, 0, attlen, pData );
   \   00000B                ; Setup parameters for call to function osal_nv_write
   \   00000B   EA           MOV     A,R2
   \   00000C   2402         ADD     A,#0x2
   \   00000E   F5..         MOV     ?V0 + 0,A
   \   000010   EB           MOV     A,R3
   \   000011   3400         ADDC    A,#0x0
   \   000013   F5..         MOV     ?V0 + 1,A
   \   000015   78..         MOV     R0,#?V0 + 0
   \   000017   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001A                ; Setup parameters for call to function osal_nv_item_len
   \   00001A   EE           MOV     A,R6
   \   00001B   FA           MOV     R2,A
   \   00001C   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   00001F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000022   7C00         MOV     R4,#0x0
   \   000024   7D00         MOV     R5,#0x0
   \   000026   EE           MOV     A,R6
   \   000027   FA           MOV     R2,A
   \   000028   7B00         MOV     R3,#0x0
   \   00002A   12....       LCALL   ??osal_nv_write?relay
   \   00002D   7404         MOV     A,#0x4
   \   00002F   80..         SJMP    ??Subroutine24_0
    598          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   12....       LCALL   ??osal_nv_item_len?relay
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   78..         MOV     R0,#?V0 + 0
   \   00000B   22           RET
    599          #endif
    600          
    601          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    602          /*********************************************************************
    603           * @fn      MT_ProcessGetNV
    604           *
    605           * @brief
    606           *
    607           *   The Get NV serial message.
    608           *
    609           * @param   byte *msg - pointer to the data
    610           *
    611           * @return  void
    612           *
    613           * @MT SPI_CMD_SYS_GET_NV
    614           *
    615           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    616          void MT_ProcessGetNV( byte *pData )
   \                     MT_ProcessGetNV:
    617          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
    618            uint16  attrib;
    619            uint16 attlen;
    620            uint16 buflen;
    621            uint8 *buf;
    622          
    623            attrib = (uint16)*pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F5..         MOV     ?V0 + 0,A
    624            attlen = osal_nv_item_len( attrib );
   \   00000C                ; Setup parameters for call to function osal_nv_item_len
   \   00000C   FA           MOV     R2,A
   \   00000D   7B00         MOV     R3,#0x0
   \   00000F   12....       LCALL   ??osal_nv_item_len?relay
   \   000012   8A..         MOV     ?V0 + 2,R2
   \   000014   8B..         MOV     ?V0 + 3,R3
    625          
    626            buflen = attlen + 3;
   \   000016   7403         MOV     A,#0x3
   \   000018   25..         ADD     A,?V0 + 2
   \   00001A   FE           MOV     R6,A
   \   00001B   E4           CLR     A
   \   00001C   35..         ADDC    A,?V0 + 3
   \   00001E   FF           MOV     R7,A
    627            buf = osal_mem_alloc( buflen );
   \   00001F                ; Setup parameters for call to function osal_mem_alloc
   \   00001F   0A           INC     R2
   \   000020   0A           INC     R2
   \   000021   0A           INC     R2
   \   000022   FB           MOV     R3,A
   \   000023   12....       LCALL   ??osal_mem_alloc?relay
   \   000026   8A..         MOV     ?V0 + 6,R2
   \   000028   8B..         MOV     ?V0 + 7,R3
    628            if ( buf != NULL )
   \   00002A   EA           MOV     A,R2
   \   00002B   7001         JNZ     ??MT_ProcessGetNV_0
   \   00002D   EB           MOV     A,R3
   \                     ??MT_ProcessGetNV_0:
   \   00002E   605D         JZ      ??MT_ProcessGetNV_1
    629            {
    630              osal_memset( buf, 0, buflen );
   \   000030                ; Setup parameters for call to function osal_memset
   \   000030   EE           MOV     A,R6
   \   000031   FC           MOV     R4,A
   \   000032   EF           MOV     A,R7
   \   000033   FD           MOV     R5,A
   \   000034   7900         MOV     R1,#0x0
   \   000036   12....       LCALL   ??osal_memset?relay
    631          
    632              buf[0] = osal_nv_read( attrib, 0, attlen, &buf[3] );
   \   000039                ; Setup parameters for call to function osal_nv_read
   \   000039   E5..         MOV     A,?V0 + 6
   \   00003B   2403         ADD     A,#0x3
   \   00003D   F5..         MOV     ?V0 + 4,A
   \   00003F   E5..         MOV     A,?V0 + 7
   \   000041   3400         ADDC    A,#0x0
   \   000043   F5..         MOV     ?V0 + 5,A
   \   000045   78..         MOV     R0,#?V0 + 4
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   78..         MOV     R0,#?V0 + 2
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004F   7C00         MOV     R4,#0x0
   \   000051   7D00         MOV     R5,#0x0
   \   000053   AA..         MOV     R2,?V0 + 0
   \   000055   12....       LCALL   ??Subroutine18_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000058   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005B   E9           MOV     A,R1
   \   00005C   85..82       MOV     DPL,?V0 + 6
   \   00005F   85..83       MOV     DPH,?V0 + 7
   \   000062   F0           MOVX    @DPTR,A
    633              buf[1] = (uint8)attrib;
   \   000063   A3           INC     DPTR
   \   000064   E5..         MOV     A,?V0 + 0
   \   000066   F0           MOVX    @DPTR,A
    634              buf[2] = attlen;
   \   000067   85..82       MOV     DPL,?V0 + 6
   \   00006A   85..83       MOV     DPH,?V0 + 7
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   E5..         MOV     A,?V0 + 2
   \   000071   F0           MOVX    @DPTR,A
    635          
    636              MT_BuildAndSendZToolResponse( (SPI_0DATA_MSG_LEN + buflen),
    637                                            (SPI_RESPONSE_BIT | SPI_CMD_SYS_GET_NV),
    638                                            buflen, buf );
   \   000072                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000072   78..         MOV     R0,#?V0 + 6
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000077   EE           MOV     A,R6
   \   000078   FC           MOV     R4,A
   \   000079   7A13         MOV     R2,#0x13
   \   00007B   7B10         MOV     R3,#0x10
   \   00007D   2405         ADD     A,#0x5
   \   00007F   F9           MOV     R1,A
   \   000080   12....       LCALL   ??Subroutine2_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000083   12....       LCALL   ?DEALLOC_XSTACK8
    639              osal_mem_free( buf );
   \   000086                ; Setup parameters for call to function osal_mem_free
   \   000086   AA..         MOV     R2,?V0 + 6
   \   000088   AB..         MOV     R3,?V0 + 7
   \   00008A   12....       LCALL   ??osal_mem_free?relay
    640            }
    641          }
   \                     ??MT_ProcessGetNV_1:
   \   00008D   02....       LJMP    ??Subroutine26_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7A01         MOV     R2,#0x1
   \                     ??Subroutine18_0:
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_nv_read?relay
   \   00000B   7404         MOV     A,#0x4
   \   00000D   22           RET
    642          #endif
    643          
    644          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    645          #if !defined ( NONWK )
    646          /***************************************************************************************************
    647           * @fn      MT_ProcessGetNvInfo
    648           *
    649           * @brief
    650           *
    651           *   The Get NV Info serial message.
    652           *
    653           * @param   byte *msg - pointer to the data
    654           *
    655           * @return  void
    656           *
    657           * @MT SPI_CMD_SYS_GET_NV_INFO
    658           *
    659           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    660          void MT_ProcessGetNvInfo( void )
   \                     MT_ProcessGetNvInfo:
    661          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    662            uint8 len;
    663            uint8 stat;
    664            uint8 *buf;
    665            uint8 *pBuf;
    666            uint16 tmp16;
    667            uint32 tmp32;
    668          
    669            // Get required length of buffer
    670            // Status + ExtAddr + ChanList + PanID  + SecLevel + PreCfgKey
    671            len = 1 + Z_EXTADDR_LEN + 4 + 2 + 1 + SEC_KEY_LEN;
    672          
    673            buf = osal_mem_alloc( len );
   \   00000A                ; Setup parameters for call to function osal_mem_alloc
   \   00000A   7A20         MOV     R2,#0x20
   \   00000C   12....       LCALL   ?Subroutine17 & 0xFFFF
    674            if ( buf )
   \                     ??CrossCallReturnLabel_85:
   \   00000F   7001         JNZ     ??MT_ProcessGetNvInfo_0
   \   000011   EB           MOV     A,R3
   \                     ??MT_ProcessGetNvInfo_0:
   \   000012   7003         JNZ     $+5
   \   000014   02....       LJMP    ??MT_ProcessGetNvInfo_1 & 0xFFFF
    675            {
    676              // Assume NV not available
    677              osal_memset( buf, 0xFF, len );
   \   000017                ; Setup parameters for call to function osal_memset
   \   000017   7C20         MOV     R4,#0x20
   \   000019   7D00         MOV     R5,#0x0
   \   00001B   79FF         MOV     R1,#-0x1
   \   00001D   12....       LCALL   ??osal_memset?relay
    678          
    679              // Skip over status
    680              pBuf = buf + 1;
   \   000020   85..82       MOV     DPL,?V0 + 2
   \   000023   85..83       MOV     DPH,?V0 + 3
   \   000026   A3           INC     DPTR
   \   000027   8582..       MOV     ?V0 + 0,DPL
   \   00002A   8583..       MOV     ?V0 + 1,DPH
    681          
    682              // Start with 64-bit extended address
    683              stat = osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
   \   00002D                ; Setup parameters for call to function osal_nv_read
   \   00002D   78..         MOV     R0,#?V0 + 0
   \   00002F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000032   75..08       MOV     ?V0 + 4,#0x8
   \   000035   75..00       MOV     ?V0 + 5,#0x0
   \   000038   78..         MOV     R0,#?V0 + 4
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000040   12....       LCALL   ?DEALLOC_XSTACK8
   \   000043   E9           MOV     A,R1
   \   000044   FE           MOV     R6,A
    684              if ( stat ) stat = 0x01;
   \   000045   6002         JZ      ??MT_ProcessGetNvInfo_2
   \   000047   7E01         MOV     R6,#0x1
    685              MT_ReverseBytes( pBuf, Z_EXTADDR_LEN );
   \                     ??MT_ProcessGetNvInfo_2:
   \   000049                ; Setup parameters for call to function MT_ReverseBytes
   \   000049   12....       LCALL   ?Subroutine19 & 0xFFFF
    686              pBuf += Z_EXTADDR_LEN;
    687          
    688              // Scan channel list (bit mask)
    689              if (  osal_nv_read( ZCD_NV_CHANLIST, 0, sizeof( tmp32 ), &tmp32 ) )
   \                     ??CrossCallReturnLabel_60:
   \   00004C                ; Setup parameters for call to function osal_nv_read
   \   00004C   7402         MOV     A,#0x2
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   8582..       MOV     ?V0 + 4,DPL
   \   000054   8583..       MOV     ?V0 + 5,DPH
   \   000057   78..         MOV     R0,#?V0 + 4
   \   000059   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005C   75..04       MOV     ?V0 + 4,#0x4
   \   00005F   75..00       MOV     ?V0 + 5,#0x0
   \   000062   78..         MOV     R0,#?V0 + 4
   \   000064   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000067   7C00         MOV     R4,#0x0
   \   000069   7D00         MOV     R5,#0x0
   \   00006B   7A84         MOV     R2,#-0x7c
   \   00006D   12....       LCALL   ??Subroutine18_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000070   12....       LCALL   ?DEALLOC_XSTACK8
   \   000073   E9           MOV     A,R1
   \   000074   6006         JZ      ??MT_ProcessGetNvInfo_3
    690                stat |= 0x02;
   \   000076   EE           MOV     A,R6
   \   000077   D2E1         SETB    0xE0 /* A   */.1
   \   000079   FE           MOV     R6,A
   \   00007A   8060         SJMP    ??MT_ProcessGetNvInfo_4
    691              else
    692              {
    693                pBuf[0] = BREAK_UINT32( tmp32, 3 );
   \                     ??MT_ProcessGetNvInfo_3:
   \   00007C   7402         MOV     A,#0x2
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   78..         MOV     R0,#?V0 + 4
   \   000083   12....       LCALL   ?L_MOV_X
   \   000086   7418         MOV     A,#0x18
   \   000088   78..         MOV     R0,#?V0 + 4
   \   00008A   12....       LCALL   ?UL_SHR
   \   00008D   85..82       MOV     DPL,?V0 + 0
   \   000090   85..83       MOV     DPH,?V0 + 1
   \   000093   E5..         MOV     A,?V0 + 4
   \   000095   F0           MOVX    @DPTR,A
    694                pBuf[1] = BREAK_UINT32( tmp32, 2 );
   \   000096   7402         MOV     A,#0x2
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   78..         MOV     R0,#?V0 + 4
   \   00009D   12....       LCALL   ?L_MOV_X
   \   0000A0   7410         MOV     A,#0x10
   \   0000A2   78..         MOV     R0,#?V0 + 4
   \   0000A4   12....       LCALL   ?UL_SHR
   \   0000A7   85..82       MOV     DPL,?V0 + 0
   \   0000AA   85..83       MOV     DPH,?V0 + 1
   \   0000AD   A3           INC     DPTR
   \   0000AE   E5..         MOV     A,?V0 + 4
   \   0000B0   F0           MOVX    @DPTR,A
    695                pBuf[2] = BREAK_UINT32( tmp32, 1 );
   \   0000B1   7402         MOV     A,#0x2
   \   0000B3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B6   78..         MOV     R0,#?V0 + 4
   \   0000B8   12....       LCALL   ?L_MOV_X
   \   0000BB   E5..         MOV     A,?V0 + 5
   \   0000BD   85..82       MOV     DPL,?V0 + 0
   \   0000C0   85..83       MOV     DPH,?V0 + 1
   \   0000C3   A3           INC     DPTR
   \   0000C4   A3           INC     DPTR
   \   0000C5   F0           MOVX    @DPTR,A
    696                pBuf[3] = BREAK_UINT32( tmp32, 0 );
   \   0000C6   7402         MOV     A,#0x2
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   78..         MOV     R0,#?V0 + 4
   \   0000CD   12....       LCALL   ?L_MOV_X
   \   0000D0   85..82       MOV     DPL,?V0 + 0
   \   0000D3   85..83       MOV     DPH,?V0 + 1
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   E5..         MOV     A,?V0 + 4
   \   0000DB   F0           MOVX    @DPTR,A
    697              }
    698              pBuf += sizeof( tmp32 );
   \                     ??MT_ProcessGetNvInfo_4:
   \   0000DC   E5..         MOV     A,?V0 + 0
   \   0000DE   2404         ADD     A,#0x4
   \   0000E0   F5..         MOV     ?V0 + 0,A
   \   0000E2   E5..         MOV     A,?V0 + 1
   \   0000E4   3400         ADDC    A,#0x0
   \   0000E6   F5..         MOV     ?V0 + 1,A
    699          
    700              // ZigBee PanID
    701              if ( osal_nv_read( ZCD_NV_PANID, 0, sizeof( tmp16 ), &tmp16 ) )
   \   0000E8                ; Setup parameters for call to function osal_nv_read
   \   0000E8   85..82       MOV     DPL,?XSP + 0
   \   0000EB   85..83       MOV     DPH,?XSP + 1
   \   0000EE   8582..       MOV     ?V0 + 4,DPL
   \   0000F1   8583..       MOV     ?V0 + 5,DPH
   \   0000F4   78..         MOV     R0,#?V0 + 4
   \   0000F6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F9   75..02       MOV     ?V0 + 4,#0x2
   \   0000FC   75..00       MOV     ?V0 + 5,#0x0
   \   0000FF   78..         MOV     R0,#?V0 + 4
   \   000101   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000104   7C00         MOV     R4,#0x0
   \   000106   7D00         MOV     R5,#0x0
   \   000108   7A83         MOV     R2,#-0x7d
   \   00010A   12....       LCALL   ??Subroutine18_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   00010D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000110   E9           MOV     A,R1
   \   000111   6006         JZ      ??MT_ProcessGetNvInfo_5
    702                stat |= 0x04;
   \   000113   EE           MOV     A,R6
   \   000114   D2E2         SETB    0xE0 /* A   */.2
   \   000116   FE           MOV     R6,A
   \   000117   8019         SJMP    ??MT_ProcessGetNvInfo_6
    703              else
    704              {
    705                pBuf[0] = HI_UINT16( tmp16 );
   \                     ??MT_ProcessGetNvInfo_5:
   \   000119   85..82       MOV     DPL,?XSP + 0
   \   00011C   85..83       MOV     DPH,?XSP + 1
   \   00011F   A3           INC     DPTR
   \   000120   E0           MOVX    A,@DPTR
   \   000121   85..82       MOV     DPL,?V0 + 0
   \   000124   85..83       MOV     DPH,?V0 + 1
   \   000127   12....       LCALL   ?Subroutine5 & 0xFFFF
    706                pBuf[1] = LO_UINT16( tmp16 );
   \                     ??CrossCallReturnLabel_12:
   \   00012A   85..82       MOV     DPL,?V0 + 0
   \   00012D   85..83       MOV     DPH,?V0 + 1
   \   000130   A3           INC     DPTR
   \   000131   F0           MOVX    @DPTR,A
    707              }
    708              pBuf += sizeof( tmp16 );
    709          
    710              // Security level
    711              if ( osal_nv_read( ZCD_NV_SECURITY_LEVEL, 0, sizeof( uint8 ), pBuf++ ) )
   \                     ??MT_ProcessGetNvInfo_6:
   \   000132   E5..         MOV     A,?V0 + 0
   \   000134   2402         ADD     A,#0x2
   \   000136   F5..         MOV     ?V0 + 4,A
   \   000138   E5..         MOV     A,?V0 + 1
   \   00013A   3400         ADDC    A,#0x0
   \   00013C   F5..         MOV     ?V0 + 5,A
   \   00013E   85..82       MOV     DPL,?V0 + 4
   \   000141   F583         MOV     DPH,A
   \   000143   A3           INC     DPTR
   \   000144   8582..       MOV     ?V0 + 0,DPL
   \   000147   8583..       MOV     ?V0 + 1,DPH
   \   00014A                ; Setup parameters for call to function osal_nv_read
   \   00014A   78..         MOV     R0,#?V0 + 4
   \   00014C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014F   75..01       MOV     ?V0 + 4,#0x1
   \   000152   75..00       MOV     ?V0 + 5,#0x0
   \   000155   78..         MOV     R0,#?V0 + 4
   \   000157   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015A   7C00         MOV     R4,#0x0
   \   00015C   7D00         MOV     R5,#0x0
   \   00015E   7A61         MOV     R2,#0x61
   \   000160   12....       LCALL   ??Subroutine18_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000163   12....       LCALL   ?DEALLOC_XSTACK8
   \   000166   E9           MOV     A,R1
   \   000167   6004         JZ      ??MT_ProcessGetNvInfo_7
    712                stat |= 0x08;
   \   000169   EE           MOV     A,R6
   \   00016A   D2E3         SETB    0xE0 /* A   */.3
   \   00016C   FE           MOV     R6,A
    713          
    714              // Pre-configured security key
    715              if ( osal_nv_read( ZCD_NV_PRECFGKEY, 0, SEC_KEY_LEN, pBuf ) )
   \                     ??MT_ProcessGetNvInfo_7:
   \   00016D                ; Setup parameters for call to function osal_nv_read
   \   00016D   78..         MOV     R0,#?V0 + 0
   \   00016F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000172   75..10       MOV     ?V0 + 0,#0x10
   \   000175   75..00       MOV     ?V0 + 1,#0x0
   \   000178   78..         MOV     R0,#?V0 + 0
   \   00017A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00017D   7C00         MOV     R4,#0x0
   \   00017F   7D00         MOV     R5,#0x0
   \   000181   7A62         MOV     R2,#0x62
   \   000183   12....       LCALL   ??Subroutine18_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000186   12....       LCALL   ?DEALLOC_XSTACK8
   \   000189   E9           MOV     A,R1
   \   00018A   6004         JZ      ??MT_ProcessGetNvInfo_8
    716                stat |= 0x10;
   \   00018C   EE           MOV     A,R6
   \   00018D   D2E4         SETB    0xE0 /* A   */.4
   \   00018F   FE           MOV     R6,A
    717          
    718              // Status bit mask - bit=1 indicates failure
    719              *buf = stat;
   \                     ??MT_ProcessGetNvInfo_8:
   \   000190   EE           MOV     A,R6
   \   000191   85..82       MOV     DPL,?V0 + 2
   \   000194   85..83       MOV     DPH,?V0 + 3
   \   000197   F0           MOVX    @DPTR,A
    720          
    721              MT_BuildAndSendZToolResponse( (SPI_0DATA_MSG_LEN + len),
    722                                            (SPI_RESPONSE_BIT | SPI_CMD_SYS_GET_NV_INFO),
    723                                            len, buf );
   \   000198                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000198   78..         MOV     R0,#?V0 + 2
   \   00019A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00019D   7C20         MOV     R4,#0x20
   \   00019F   7A1F         MOV     R2,#0x1f
   \   0001A1   7B10         MOV     R3,#0x10
   \   0001A3   7925         MOV     R1,#0x25
   \   0001A5   12....       LCALL   ??Subroutine2_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   0001A8   12....       LCALL   ?DEALLOC_XSTACK8
    724          
    725              osal_mem_free( buf );
   \   0001AB                ; Setup parameters for call to function osal_mem_free
   \   0001AB   AA..         MOV     R2,?V0 + 2
   \   0001AD   AB..         MOV     R3,?V0 + 3
   \   0001AF   12....       LCALL   ??osal_mem_free?relay
    726            }
    727          }
   \                     ??MT_ProcessGetNvInfo_1:
   \   0001B2   7406         MOV     A,#0x6
   \   0001B4   02....       LJMP    ?Subroutine26 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   7908         MOV     R1,#0x8
   \   000002   AA..         MOV     R2,?V0 + 0
   \   000004   AB..         MOV     R3,?V0 + 1
   \   000006   12....       LCALL   ??MT_ReverseBytes?relay
   \   000009   E5..         MOV     A,?V0 + 0
   \   00000B   2408         ADD     A,#0x8
   \   00000D   F5..         MOV     ?V0 + 0,A
   \   00000F   E5..         MOV     A,?V0 + 1
   \   000011   3400         ADDC    A,#0x0
   \   000013   F5..         MOV     ?V0 + 1,A
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   12....       LCALL   ??osal_mem_alloc?relay
   \   000005   02....       LJMP    ?Subroutine28 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   E0           MOVX    A,@DPTR
   \   000008   22           RET
    728          #endif  // NONWK
    729          #endif  // ZTOOL
    730          
    731          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    732          #define DEVICE_INFO_RESPONSE_LEN 46
    733          #define TYPE_COORDINATOR         1
    734          #define TYPE_ROUTER              2
    735          #define TYPE_ENDDEVICE           4
    736          /***************************************************************************************************
    737           * @fn      MT_ProcessGetDeviceInfo
    738           *
    739           * @brief
    740           *
    741           *   The Get Device Info serial message.
    742           *
    743           * @param   byte *msg - pointer to the data
    744           *
    745           * @return  void
    746           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    747          void MT_ProcessGetDeviceInfo( void )
   \                     MT_ProcessGetDeviceInfo:
    748          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    749            byte *buf;
    750            byte *pBuf;
    751            uint8 deviceType = 0;
    752            uint16 shortAddr;
    753            uint16 *assocList;
    754            byte assocCnt;
    755            uint16 *puint16;
    756            byte x;
    757          
    758            buf = osal_mem_alloc( DEVICE_INFO_RESPONSE_LEN );
   \   00000A                ; Setup parameters for call to function osal_mem_alloc
   \   00000A   7A2E         MOV     R2,#0x2e
   \   00000C   12....       LCALL   ?Subroutine17 & 0xFFFF
    759            if ( buf )
   \                     ??CrossCallReturnLabel_86:
   \   00000F   7001         JNZ     ??MT_ProcessGetDeviceInfo_0
   \   000011   EB           MOV     A,R3
   \                     ??MT_ProcessGetDeviceInfo_0:
   \   000012   7003         JNZ     $+5
   \   000014   02....       LJMP    ??MT_ProcessGetDeviceInfo_1 & 0xFFFF
    760            {
    761              pBuf = buf;
    762          
    763              *pBuf++ = ZSUCCESS;
   \   000017   E4           CLR     A
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   12....       LCALL   ??Subroutine0_0 & 0xFFFF
    764          
    765              osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
   \                     ??CrossCallReturnLabel_0:
   \   00001F                ; Setup parameters for call to function osal_nv_read
   \   00001F   78..         MOV     R0,#?V0 + 0
   \   000021   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000024   75..08       MOV     ?V0 + 4,#0x8
   \   000027   75..00       MOV     ?V0 + 5,#0x0
   \   00002A   78..         MOV     R0,#?V0 + 4
   \   00002C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002F   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000032   12....       LCALL   ?DEALLOC_XSTACK8
    766              // Outgoing extended address needs to be reversed
    767              MT_ReverseBytes( pBuf, Z_EXTADDR_LEN );
   \   000035                ; Setup parameters for call to function MT_ReverseBytes
   \   000035   12....       LCALL   ?Subroutine19 & 0xFFFF
    768              pBuf += Z_EXTADDR_LEN;
    769          
    770          #if !defined( NONWK )
    771              shortAddr = NLME_GetShortAddr();
   \                     ??CrossCallReturnLabel_61:
   \   000038                ; Setup parameters for call to function NLME_GetShortAddr
   \   000038   12....       LCALL   ??NLME_GetShortAddr?relay
    772          #else
    773              shortAddr = 0;
    774          #endif
    775          
    776              *pBuf++ = HI_UINT16( shortAddr );
   \   00003B   85..82       MOV     DPL,?V0 + 0
   \   00003E   85..83       MOV     DPH,?V0 + 1
   \   000041   EB           MOV     A,R3
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
    777              *pBuf++ = LO_UINT16( shortAddr );
   \   000044   EA           MOV     A,R2
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
    778          
    779              // Return device type
    780          #if !defined( NONWK )
    781          #if defined (ZDO_COORDINATOR)
    782              deviceType |= (uint8) TYPE_COORDINATOR;
    783            #if defined (SOFT_START)
    784              deviceType |= (uint8) TYPE_ROUTER;
    785            #endif
    786          #endif
    787          #if defined (RTR_NWK) && !defined (ZDO_COORDINATOR)
    788              deviceType |= (uint8) TYPE_ROUTER;
    789          #elif !defined (RTR_NWK)
    790              deviceType |= (uint8) TYPE_ENDDEVICE;
    791          #endif
    792          #endif
    793              *pBuf++ = (byte) deviceType;
   \   000047   7402         MOV     A,#0x2
   \   000049   12....       LCALL   ??Subroutine0_0 & 0xFFFF
    794          
    795              //Return device state
    796          #if !defined( NONWK )
    797              *pBuf++ = (byte)devState;
   \                     ??CrossCallReturnLabel_1:
   \   00004C   90....       MOV     DPTR,#devState
   \   00004F   12....       LCALL   ?Subroutine0 & 0xFFFF
    798          #else
    799              *pBuf++ = (byte)0;
    800          #endif
    801          
    802          #if defined(RTR_NWK) && !defined( NONWK )
    803              assocList = AssocMakeList( &assocCnt );
   \                     ??CrossCallReturnLabel_2:
   \   000052                ; Setup parameters for call to function AssocMakeList
   \   000052   85..82       MOV     DPL,?XSP + 0
   \   000055   85..83       MOV     DPH,?XSP + 1
   \   000058   AA82         MOV     R2,DPL
   \   00005A   AB83         MOV     R3,DPH
   \   00005C   12....       LCALL   ??AssocMakeList?relay
   \   00005F   8A..         MOV     ?V0 + 4,R2
   \   000061   8B..         MOV     ?V0 + 5,R3
   \   000063   AE..         MOV     R6,?V0 + 4
   \   000065   AF..         MOV     R7,?V0 + 5
    804          #else
    805              assocCnt = 0;
    806              assocList = NULL;
    807          #endif
    808          
    809              *pBuf++ = assocCnt;
   \   000067   85..82       MOV     DPL,?XSP + 0
   \   00006A   85..83       MOV     DPH,?XSP + 1
   \   00006D   12....       LCALL   ?Subroutine0 & 0xFFFF
    810          
    811              // upto 16 devices
    812              osal_memset( pBuf, 0, (16 * sizeof(uint16)) );
   \                     ??CrossCallReturnLabel_3:
   \   000070                ; Setup parameters for call to function osal_memset
   \   000070   7C20         MOV     R4,#0x20
   \   000072   7D00         MOV     R5,#0x0
   \   000074   7900         MOV     R1,#0x0
   \   000076   AA..         MOV     R2,?V0 + 0
   \   000078   AB..         MOV     R3,?V0 + 1
   \   00007A   12....       LCALL   ??osal_memset?relay
    813              puint16 = assocList;
   \   00007D   EE           MOV     A,R6
   \   00007E   F8           MOV     R0,A
   \   00007F   EF           MOV     A,R7
   \   000080   F9           MOV     R1,A
    814              for ( x = 0; x < assocCnt; x++ )
   \   000081   7C00         MOV     R4,#0x0
   \   000083   8019         SJMP    ??MT_ProcessGetDeviceInfo_2
    815              {
    816                *pBuf++ = HI_UINT16( *puint16 );
   \                     ??MT_ProcessGetDeviceInfo_3:
   \   000085   8882         MOV     DPL,R0
   \   000087   8983         MOV     DPH,R1
   \   000089   A3           INC     DPTR
   \   00008A   12....       LCALL   ?Subroutine0 & 0xFFFF
    817                *pBuf++ = LO_UINT16( *puint16 );
   \                     ??CrossCallReturnLabel_4:
   \   00008D   8882         MOV     DPL,R0
   \   00008F   8983         MOV     DPH,R1
   \   000091   12....       LCALL   ?Subroutine0 & 0xFFFF
    818                puint16++;
   \                     ??CrossCallReturnLabel_5:
   \   000094   E8           MOV     A,R0
   \   000095   2402         ADD     A,#0x2
   \   000097   08           INC     R0
   \   000098   08           INC     R0
   \   000099   E9           MOV     A,R1
   \   00009A   3400         ADDC    A,#0x0
   \   00009C   F9           MOV     R1,A
    819              }
   \   00009D   0C           INC     R4
   \                     ??MT_ProcessGetDeviceInfo_2:
   \   00009E   85..82       MOV     DPL,?XSP + 0
   \   0000A1   85..83       MOV     DPH,?XSP + 1
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   FA           MOV     R2,A
   \   0000A6   EC           MOV     A,R4
   \   0000A7   C3           CLR     C
   \   0000A8   9A           SUBB    A,R2
   \   0000A9   40DA         JC      ??MT_ProcessGetDeviceInfo_3
    820          
    821              if ( assocList )
   \   0000AB   EE           MOV     A,R6
   \   0000AC   7001         JNZ     ??MT_ProcessGetDeviceInfo_4
   \   0000AE   EF           MOV     A,R7
   \                     ??MT_ProcessGetDeviceInfo_4:
   \   0000AF   6007         JZ      ??MT_ProcessGetDeviceInfo_5
    822                osal_mem_free( assocList );
   \   0000B1                ; Setup parameters for call to function osal_mem_free
   \   0000B1   EE           MOV     A,R6
   \   0000B2   FA           MOV     R2,A
   \   0000B3   EF           MOV     A,R7
   \   0000B4   FB           MOV     R3,A
   \   0000B5   12....       LCALL   ??osal_mem_free?relay
    823          
    824              MT_BuildAndSendZToolResponse( (SPI_0DATA_MSG_LEN + DEVICE_INFO_RESPONSE_LEN),
    825                                            (SPI_RESPONSE_BIT | SPI_CMD_SYS_GET_DEVICE_INFO),
    826                                            DEVICE_INFO_RESPONSE_LEN, buf );
   \                     ??MT_ProcessGetDeviceInfo_5:
   \   0000B8                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   0000B8   78..         MOV     R0,#?V0 + 2
   \   0000BA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BD   7C2E         MOV     R4,#0x2e
   \   0000BF   7A14         MOV     R2,#0x14
   \   0000C1   7B10         MOV     R3,#0x10
   \   0000C3   7933         MOV     R1,#0x33
   \   0000C5   12....       LCALL   ??Subroutine2_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   0000C8   12....       LCALL   ?DEALLOC_XSTACK8
    827          
    828              osal_mem_free( buf );
   \   0000CB                ; Setup parameters for call to function osal_mem_free
   \   0000CB   AA..         MOV     R2,?V0 + 2
   \   0000CD   AB..         MOV     R3,?V0 + 3
   \   0000CF   12....       LCALL   ??osal_mem_free?relay
    829            }
    830          }
   \                     ??MT_ProcessGetDeviceInfo_1:
   \   0000D2   02....       LJMP    ?Subroutine25 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0 + 0
   \   000004   85..83       MOV     DPH,?V0 + 1
   \                     ??Subroutine0_0:
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   8582..       MOV     ?V0 + 0,DPL
   \   00000C   8583..       MOV     ?V0 + 1,DPH
   \   00000F   22           RET
    831          #endif
    832          
    833          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    834          /***************************************************************************************************
    835           * @fn      MT_ProcessSerialCommand
    836           *
    837           * @brief
    838           *
    839           *   Process Serial Message.
    840           *
    841           * @param   byte *msg - pointer to event message
    842           *
    843           * @return  void
    844           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    845          void MT_ProcessSerialCommand( byte *msg )
   \                     MT_ProcessSerialCommand:
    846          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 19
   \   000005   74ED         MOV     A,#-0x13
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    847            UINT16 cmd;
    848            UINT16 callbackID;
    849            byte len;
    850            byte ret;
    851            byte *pData;
    852            uint16 tmp16;
    853            uint32 tmp32;
    854            byte extAddr[Z_EXTADDR_LEN];
    855            byte *retValue;
    856            byte x = 0;
   \   00000A   7900         MOV     R1,#0x0
    857          #if !defined ( NONWK )
    858            uint16 attLen;
    859          #endif // NONWK
    860          
    861            // dig out header info
    862            cmd = BUILD_UINT16( msg[1], msg[0] );
   \   00000C   8A82         MOV     DPL,R2
   \   00000E   8B83         MOV     DPH,R3
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   FE           MOV     R6,A
   \   000013   8A82         MOV     DPL,R2
   \   000015   8B83         MOV     DPH,R3
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FF           MOV     R7,A
    863            save_cmd = cmd;
   \   000019   90....       MOV     DPTR,#save_cmd
   \   00001C   EE           MOV     A,R6
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   EF           MOV     A,R7
   \   000020   F0           MOVX    @DPTR,A
    864            len = msg[2];
    865            pData = &msg[3];
   \   000021   EA           MOV     A,R2
   \   000022   2403         ADD     A,#0x3
   \   000024   FC           MOV     R4,A
   \   000025   EB           MOV     A,R3
   \   000026   3400         ADDC    A,#0x0
   \   000028   FD           MOV     R5,A
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   EC           MOV     A,R4
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   ED           MOV     A,R5
   \   000033   F0           MOVX    @DPTR,A
    866          
    867              // Setup for return;
    868              len = 0;
   \   000034   7C00         MOV     R4,#0x0
    869              retValue = &ret;
   \   000036   7402         MOV     A,#0x2
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   8582..       MOV     ?V0 + 0,DPL
   \   00003E   8583..       MOV     ?V0 + 1,DPH
   \   000041   7403         MOV     A,#0x3
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   E5..         MOV     A,?V0 + 0
   \   000048   F0           MOVX    @DPTR,A
   \   000049   A3           INC     DPTR
   \   00004A   E5..         MOV     A,?V0 + 1
   \   00004C   F0           MOVX    @DPTR,A
    870          
    871              //Process the contents of the message
    872              switch ( cmd )
   \   00004D   8E..         MOV     ?V0 + 0,R6
   \   00004F   8F..         MOV     ?V0 + 1,R7
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?US_SWITCH_DENSE
   \                     `?<Jumptable for MT_ProcessSerialCommand>_0`:
   \   000056   0100         DW        1
   \   000058   1E           DB        30
   \   000059   ....         DW        ??MT_ProcessSerialCommand_0
   \   00005B   ....         DW        ??MT_ProcessSerialCommand_1
   \   00005D   ....         DW        ??MT_ProcessSerialCommand_2
   \   00005F   ....         DW        ??MT_ProcessSerialCommand_3
   \   000061   ....         DW        ??MT_ProcessSerialCommand_0
   \   000063   ....         DW        ??MT_ProcessSerialCommand_4
   \   000065   ....         DW        ??MT_ProcessSerialCommand_5
   \   000067   ....         DW        ??MT_ProcessSerialCommand_6
   \   000069   ....         DW        ??MT_ProcessSerialCommand_7
   \   00006B   ....         DW        ??MT_ProcessSerialCommand_0
   \   00006D   ....         DW        ??MT_ProcessSerialCommand_0
   \   00006F   ....         DW        ??MT_ProcessSerialCommand_0
   \   000071   ....         DW        ??MT_ProcessSerialCommand_0
   \   000073   ....         DW        ??MT_ProcessSerialCommand_0
   \   000075   ....         DW        ??MT_ProcessSerialCommand_0
   \   000077   ....         DW        ??MT_ProcessSerialCommand_0
   \   000079   ....         DW        ??MT_ProcessSerialCommand_8
   \   00007B   ....         DW        ??MT_ProcessSerialCommand_9
   \   00007D   ....         DW        ??MT_ProcessSerialCommand_10
   \   00007F   ....         DW        ??MT_ProcessSerialCommand_11
   \   000081   ....         DW        ??MT_ProcessSerialCommand_12
   \   000083   ....         DW        ??MT_ProcessSerialCommand_0
   \   000085   ....         DW        ??MT_ProcessSerialCommand_13
   \   000087   ....         DW        ??MT_ProcessSerialCommand_14
   \   000089   ....         DW        ??MT_ProcessSerialCommand_15
   \   00008B   ....         DW        ??MT_ProcessSerialCommand_16
   \   00008D   ....         DW        ??MT_ProcessSerialCommand_17
   \   00008F   ....         DW        ??MT_ProcessSerialCommand_18
   \   000091   ....         DW        ??MT_ProcessSerialCommand_19
   \   000093   ....         DW        ??MT_ProcessSerialCommand_20
   \   000095   ....         DW        ??MT_ProcessSerialCommand_21
   \   000097   ....         DW        ??MT_ProcessSerialCommand_22
    873              {
    874          #ifdef MACSIM
    875                case SPI_CMD_ZIGNET_DATA:
    876                  MACSIM_TranslateMsg( pData, len );
    877                  break;
    878          #endif
    879          
    880                case SPI_CMD_SYS_RAM_READ:
    881                  extAddr[0] = MT_RAMRead( (UINT16)BUILD_UINT16( pData[1], pData[0] ), &extAddr[1] );
   \                     ??MT_ProcessSerialCommand_1:
   \   000099                ; Setup parameters for call to function MT_RAMRead
   \   000099   740C         MOV     A,#0xc
   \   00009B   12....       LCALL   ?XSTACK_DISP0_8
   \   00009E   AC82         MOV     R4,DPL
   \   0000A0   AD83         MOV     R5,DPH
   \   0000A2   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   0000A5   FB           MOV     R3,A
   \   0000A6   12....       LCALL   ??MT_RAMRead?relay
   \   0000A9   740B         MOV     A,#0xb
   \   0000AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AE   E9           MOV     A,R1
   \   0000AF   F0           MOVX    @DPTR,A
    882                  len = MT_RAM_READ_RESP_LEN;
   \   0000B0   7C02         MOV     R4,#0x2
    883                  retValue = extAddr;
   \                     ??MT_ProcessSerialCommand_23:
   \   0000B2   A882         MOV     R0,DPL
   \   0000B4   A983         MOV     R1,DPH
   \   0000B6   7403         MOV     A,#0x3
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   E8           MOV     A,R0
   \   0000BC   F0           MOVX    @DPTR,A
   \   0000BD   A3           INC     DPTR
   \   0000BE   E9           MOV     A,R1
   \                     ??MT_ProcessSerialCommand_24:
   \   0000BF   F0           MOVX    @DPTR,A
   \   0000C0   02....       LJMP    ??MT_ProcessSerialCommand_25 & 0xFFFF
    884                  break;
    885          
    886                case SPI_CMD_SYS_RAM_WRITE:
    887                  ret = MT_RAMWrite( (UINT16)BUILD_UINT16( pData[1], pData[0] ), pData[2] );
   \                     ??MT_ProcessSerialCommand_2:
   \   0000C3                ; Setup parameters for call to function MT_RAMWrite
   \   0000C3   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   F9           MOV     R1,A
   \   0000C8   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0000CB   FC           MOV     R4,A
   \   0000CC   85..82       MOV     DPL,?XSP + 0
   \   0000CF   85..83       MOV     DPH,?XSP + 1
   \   0000D2   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   0000D5   FB           MOV     R3,A
   \   0000D6   EC           MOV     A,R4
   \   0000D7   FA           MOV     R2,A
   \   0000D8   12....       LCALL   ??MT_RAMWrite?relay
   \                     ??MT_ProcessSerialCommand_26:
   \   0000DB   7402         MOV     A,#0x2
   \   0000DD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E0   E9           MOV     A,R1
   \   0000E1   02....       LJMP    ??MT_ProcessSerialCommand_27 & 0xFFFF
    888                  len = MT_RAM_WRITE_RESP_LEN;
    889                  break;
    890          
    891                case SPI_CMD_SYS_SET_DEBUG_THRESHOLD:
    892                  ret = MT_SetDebugThreshold( pData[0], pData[1] );
   \                     ??MT_ProcessSerialCommand_3:
   \   0000E4   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   0000E7   FA           MOV     R2,A
   \   0000E8   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   0000EB   90....       MOV     DPTR,#debugThreshold
   \   0000EE   F0           MOVX    @DPTR,A
   \   0000EF   EA           MOV     A,R2
   \   0000F0   90....       MOV     DPTR,#debugCompId
   \   0000F3   F0           MOVX    @DPTR,A
    893                  len = 1;
    894                  break;
    895          
    896                case SPI_CMD_TRACE_SUB:
    897                  break;
    898          
    899                case SPI_CMD_SYS_RESET:
    900                  MT_Reset( pData[0] );
    901                  break;
    902          
    903                case SPI_CMD_SYS_CALLBACK_SUB_CMD:
    904                  // a callback value of 0xFFFF turns on all available callbacks
    905                  callbackID = BUILD_UINT16( pData[1] , pData[0] );
    906                  if ( callbackID == 0xFFFF )
    907                  {
    908                    // What is the action
    909                    if ( pData[2] )
    910                    {
    911                      // Turn on
    912          #if defined( MT_MAC_CB_FUNC )
    913                      _macCallbackSub = 0xFFFF;
    914          #endif
    915          #if defined( MT_NWK_CB_FUNC )
    916                      _nwkCallbackSub = 0xFFFF;
    917          #endif
    918          
    919          #if defined( MT_ZDO_FUNC )
    920                      _zdoCallbackSub = 0xFFFFFFFF;
    921          #endif
    922          #if defined( MT_AF_CB_FUNC )
    923                      _afCallbackSub = 0xFFFF;
    924          #endif
    925          #if defined( MT_SAPI_CB_FUNC )
    926                      _sapiCallbackSub = 0xFFFF;
    927          #endif
    928                    }
    929                    else
    930                    {
    931                      // Turn off
    932          #if defined( MT_MAC_CB_FUNC )
    933                      _macCallbackSub = 0x0000;
    934          #endif
    935          #if defined( MT_NWK_CB_FUNC )
    936                      _nwkCallbackSub = 0x0000;
    937          #endif
    938          
    939          #if defined( MT_ZDO_FUNC )
    940                      _zdoCallbackSub = 0x00000000;
    941          #endif
    942          #if defined( MT_AF_CB_FUNC )
    943                      _afCallbackSub = 0x0000;
    944          #endif
    945          #if defined( MT_SAPI_CB_FUNC )
    946                      _sapiCallbackSub = 0x0000;
    947          #endif
    948                    }
    949                  }
    950                  else
    951                  {
    952                    //First check which layer callbacks are desired and then set the preference
    953          
    954          #if defined( MT_MAC_CB_FUNC )
    955                    //If it is a MAC callback, set the corresponding callback subscription bit
    956                    if (( callbackID & 0xFFF0 ) == SPI_MAC_CB_TYPE )
    957                    {
    958                      //Based on the action field, either enable or disable subscription
    959                      if ( pData[2] )
    960                        _macCallbackSub |=  ( 1 << ( pData[1] & 0x0F ) );
    961                      else
    962                        _macCallbackSub &= ~( 1 << ( pData[1] & 0x0F ) );
    963                    }
    964          #endif
    965          
    966          #if defined( MT_NWK_CB_FUNC )
    967                    //If it is a NWK callback, set the corresponding callback subscription bit
    968                    if (( callbackID & 0xFFF0 ) == SPI_NWK_CB_TYPE )
    969                    {
    970          
    971                      //Based on the action field, either enable or disable subscription
    972                      if ( pData[2] )
    973                        _nwkCallbackSub |=  ( 1 << ( pData[1] & 0x0F ) ) ;
    974                      else
    975                        _nwkCallbackSub &= ~( 1 << ( pData[1] & 0x0F ) );
    976                    }
    977          #endif
    978          
    979          #if defined( MT_ZDO_FUNC )
    980                    //If it is a APS callback, set the corresponding callback subscription bit
    981                    if ( ((callbackID & 0xFFF0) == SPI_ZDO_CB_TYPE) ||
    982                         ((callbackID & 0xFFF0) == SPI_ZDO_CB2_TYPE) )
    983                    {
    984                      //Based on the action field, either enable or disable subscription
    985                      if ( pData[2] )
    986                        _zdoCallbackSub |=  ( 1L << ( pData[1] & 0x1F ) );
    987                      else
    988                        _zdoCallbackSub &= ~( 1L << ( pData[1] & 0x1F ) );
    989                    }
    990          #endif
    991          
    992          #if defined( MT_AF_CB_FUNC )
    993                    // Set the corresponding callback subscription bit for an AF callback.
    994                    if (( callbackID & 0xFFF0 ) == SPI_AF_CB_TYPE )
    995                    {
    996                      // Based on the action field, either enable or disable subscription.
    997                      if ( pData[2] )
    998                        _afCallbackSub |=  ( 1 << ( pData[1] & 0x0F ) );
    999                      else
   1000                        _afCallbackSub &= ~( 1 << ( pData[1] & 0x0F ) );
   1001                    }
   1002          #endif
   1003          #if defined( MT_SAPI_CB_FUNC )
   1004                    // Set the corresponding callback subscription bit for an SAPI callback.
   1005                    if (( callbackID & 0xFFF0 ) == SPI_SAPI_CB_TYPE )
   1006                    {
   1007                      // Based on the action field, either enable or disable subscription.
   1008                      if ( pData[2] )
   1009                        _sapiCallbackSub |=  ( 1 << ( pData[1] & 0x0F ) );
   1010                      else
   1011                        _sapiCallbackSub &= ~( 1 << ( pData[1] & 0x0F ) );
   1012                    }
   1013          #endif
   1014                  }
   1015                  len = 1;
   1016                  ret = ZSUCCESS;
   1017                  break;
   1018          
   1019                case SPI_CMD_SYS_PING:
   1020                  // Get a message buffer to build response message
   1021                  // The Ping response now has capabilities included
   1022          
   1023                  // Build Capabilities
   1024                  tmp16 = MT_CAP_MAC | MT_CAP_NWK | MT_CAP_AF |
   1025                          MT_CAP_ZDO | MT_CAP_USER_TEST | MT_CAP_SAPI_FUNC;
   1026          
   1027                  // Convert to high byte first into temp buffer
   1028                  extAddr[0] = HI_UINT16( tmp16 );
   1029                  extAddr[1] = LO_UINT16( tmp16 );
   1030                  len = sizeof ( tmp16 );
   1031                  retValue = extAddr;
   1032                  break;
   1033          
   1034                case SPI_CMD_SYS_VERSION:
   1035                  {
   1036          #if !defined ( NONWK )
   1037                    uint8 i = NLME_GetProtocolVersion() - 1;
   1038          #else
   1039                    uint8 i = 1;   // just say '1.1' -- irrelevant if stack isn't there anyway
   1040          #endif
   1041          
   1042                    // Get a message buffer to build response message
   1043                    len      = (byte)(osal_strlen( (char *)MTVersionString[i] ));
   1044                    retValue = (byte *)MTVersionString[i];
   1045                  }
   1046                    break;
   1047          
   1048                case SPI_CMD_SYS_SET_EXTADDR:
   1049                  // Incoming extended address is reversed
   1050                  MT_ReverseBytes( pData, Z_EXTADDR_LEN );
   1051          
   1052                  if ( ZMacSetReq( ZMacExtAddr, pData ) == ZMacSuccess )
   1053                    ret = osal_nv_write( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pData );
   1054                  else
   1055                    ret = 1;
   1056                  len = 1;
   1057                  break;
   1058          
   1059                case SPI_CMD_SYS_GET_EXTADDR:
   1060                  ZMacGetReq( ZMacExtAddr, extAddr );
   1061          
   1062                  // Outgoing extended address needs to be reversed
   1063                  MT_ReverseBytes( extAddr, Z_EXTADDR_LEN );
   1064          
   1065                  len = Z_EXTADDR_LEN;
   1066                  retValue = extAddr;
   1067                  break;
   1068          
   1069          #if !defined ( NONWK )
   1070                case SPI_CMD_SYS_SET_PANID:
   1071                  tmp16 = BUILD_UINT16( pData[1], pData[0] );
   1072                  attLen = osal_nv_item_len( ZCD_NV_PANID );
   1073                  ret = osal_nv_write( ZCD_NV_PANID, 0, attLen, &tmp16 );
   1074                  len = 1;
   1075                  break;
   1076          
   1077                case SPI_CMD_SYS_SET_CHANNELS:
   1078                  tmp32 = BUILD_UINT32( pData[3], pData[2], pData[1], pData[0] );
   1079                  attLen = osal_nv_item_len( ZCD_NV_CHANLIST );
   1080                  ret = osal_nv_write( ZCD_NV_CHANLIST, 0, attLen, &tmp32 );
   1081                  len = 1;
   1082                  break;
   1083          
   1084                case SPI_CMD_SYS_SET_SECLEVEL:
   1085                  attLen = osal_nv_item_len( ZCD_NV_SECURITY_LEVEL );
   1086                  ret = osal_nv_write( ZCD_NV_SECURITY_LEVEL, 0, attLen, pData );
   1087                  len = 1;
   1088                  break;
   1089          
   1090                case SPI_CMD_SYS_SET_PRECFGKEY:
   1091                  attLen = osal_nv_item_len( ZCD_NV_PRECFGKEY );
   1092                  ret = osal_nv_write( ZCD_NV_PRECFGKEY, 0, attLen, pData );
   1093                  len = 1;
   1094                  break;
   1095          
   1096                case SPI_CMD_SYS_GET_NV_INFO:
   1097                  MT_ProcessGetNvInfo();
   1098                  break;
   1099          #endif // NONWK
   1100          
   1101                case SPI_CMD_SYS_GET_DEVICE_INFO:
   1102                  MT_ProcessGetDeviceInfo();
   1103                  break;
   1104          
   1105                case SPI_CMD_SYS_SET_NV:
   1106                  ret = MT_ProcessSetNV( pData );
   1107                  len = 1;
   1108                  break;
   1109          
   1110                case SPI_CMD_SYS_GET_NV:
   1111                  MT_ProcessGetNV( pData );
   1112                  break;
   1113          
   1114                case SPI_CMD_SYS_TIME_ALIVE:
   1115                  // Time since last reset (seconds)
   1116                  tmp32 = osal_GetSystemClock() / 1000;
   1117                  // Convert to high byte first into temp buffer
   1118                  extAddr[0] = BREAK_UINT32( tmp32, 3 );
   1119                  extAddr[1] = BREAK_UINT32( tmp32, 2 );
   1120                  extAddr[2] = BREAK_UINT32( tmp32, 1 );
   1121                  extAddr[3] = BREAK_UINT32( tmp32, 0 );
   1122                  len = sizeof ( tmp32 );
   1123                  retValue = extAddr;
   1124                  break;
   1125          
   1126                case SPI_CMD_SYS_KEY_EVENT:
   1127                  // Translate between SPI values to device values
   1128                  if ( pData[1] & 0x01 )
   1129                    x |= HAL_KEY_SW_1;
   1130                  if ( pData[1] & 0x02 )
   1131                    x |= HAL_KEY_SW_2;
   1132                  if ( pData[1] & 0x04 )
   1133                    x |= HAL_KEY_SW_3;
   1134                  if ( pData[1] & 0x08 )
   1135                    x |= HAL_KEY_SW_4;
   1136          #if defined ( HAL_KEY_SW_5 )
   1137                  if ( pData[1] & 0x10 )
   1138                    x |= HAL_KEY_SW_5;
   1139          #endif
   1140          #if defined ( HAL_KEY_SW_6 )
   1141                  if ( pData[1] & 0x20 )
   1142                    x |= HAL_KEY_SW_6;
   1143          #endif
   1144          #if defined ( HAL_KEY_SW_7 )
   1145                  if ( pData[1] & 0x40 )
   1146                    x |= HAL_KEY_SW_7;
   1147          #endif
   1148          #if defined ( HAL_KEY_SW_8 )
   1149                  if ( pData[1] & 0x80 )
   1150                    x |= HAL_KEY_SW_8;
   1151          #endif
   1152                  ret = OnBoard_SendKeys( x, pData[0]  );
   1153                  len = 1;
   1154                  break;
   1155          
   1156                case SPI_CMD_SYS_HEARTBEAT:
   1157                  ret = ZSUCCESS;
   \                     ??MT_ProcessSerialCommand_14:
   \   0000F4   7402         MOV     A,#0x2
   \   0000F6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F9   E4           CLR     A
   \   0000FA   02....       LJMP    ??MT_ProcessSerialCommand_27 & 0xFFFF
   \                     ??MT_ProcessSerialCommand_4:
   \   0000FD                ; Setup parameters for call to function MT_Reset
   \   0000FD   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000100   F9           MOV     R1,A
   \   000101   12....       LCALL   ??MT_Reset?relay
   \   000104   807B         SJMP    ??MT_ProcessSerialCommand_28
   \                     ??MT_ProcessSerialCommand_5:
   \   000106   0C           INC     R4
   \   000107   7402         MOV     A,#0x2
   \   000109   12....       LCALL   ?XSTACK_DISP0_8
   \   00010C   E4           CLR     A
   \   00010D   80B0         SJMP    ??MT_ProcessSerialCommand_24
   \                     ??MT_ProcessSerialCommand_6:
   \   00010F   7409         MOV     A,#0x9
   \   000111   12....       LCALL   ?XSTACK_DISP0_8
   \   000114   E4           CLR     A
   \   000115   F0           MOVX    @DPTR,A
   \   000116   A3           INC     DPTR
   \   000117   F0           MOVX    @DPTR,A
   \   000118   740B         MOV     A,#0xb
   \   00011A   12....       LCALL   ?XSTACK_DISP0_8
   \   00011D   E4           CLR     A
   \   00011E   F0           MOVX    @DPTR,A
   \   00011F   740C         MOV     A,#0xc
   \   000121   12....       LCALL   ?XSTACK_DISP0_8
   \   000124   E4           CLR     A
   \   000125   F0           MOVX    @DPTR,A
   \   000126   0C           INC     R4
   \   000127   0C           INC     R4
   \                     ??MT_ProcessSerialCommand_29:
   \   000128   740B         MOV     A,#0xb
   \   00012A   12....       LCALL   ?XSTACK_DISP0_8
   \   00012D   8083         SJMP    ??MT_ProcessSerialCommand_23
   \                     ??MT_ProcessSerialCommand_7:
   \   00012F                ; Setup parameters for call to function NLME_GetProtocolVersion
   \   00012F   12....       LCALL   ??NLME_GetProtocolVersion?relay
   \   000132   E9           MOV     A,R1
   \   000133   14           DEC     A
   \   000134   C3           CLR     C
   \   000135   33           RLC     A
   \   000136   F8           MOV     R0,A
   \   000137   E4           CLR     A
   \   000138   33           RLC     A
   \   000139   F9           MOV     R1,A
   \   00013A   E8           MOV     A,R0
   \   00013B   24..         ADD     A,#(MTVersionString & 0xff)
   \   00013D   F5..         MOV     ?V0 + 0,A
   \   00013F   E9           MOV     A,R1
   \   000140   34..         ADDC    A,#((MTVersionString >> 8) & 0xff)
   \   000142   F5..         MOV     ?V0 + 1,A
   \   000144                ; Setup parameters for call to function osal_strlen
   \   000144   85..82       MOV     DPL,?V0 + 0
   \   000147   F583         MOV     DPH,A
   \   000149   12....       LCALL   ??Subroutine8_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   00014C   12....       LCALL   ??osal_strlen?relay
   \   00014F   EA           MOV     A,R2
   \   000150   FC           MOV     R4,A
   \   000151   85..82       MOV     DPL,?V0 + 0
   \   000154   85..83       MOV     DPH,?V0 + 1
   \   000157   E0           MOVX    A,@DPTR
   \   000158   F8           MOV     R0,A
   \   000159   A3           INC     DPTR
   \   00015A   E0           MOVX    A,@DPTR
   \   00015B   F9           MOV     R1,A
   \   00015C   7403         MOV     A,#0x3
   \   00015E   12....       LCALL   ?XSTACK_DISP0_8
   \   000161   E8           MOV     A,R0
   \   000162   F0           MOVX    @DPTR,A
   \   000163   A3           INC     DPTR
   \   000164   E9           MOV     A,R1
   \   000165   F0           MOVX    @DPTR,A
   1158                  len = 1;
   1159                  break;
   1160          
   1161          #if !defined ( NONWK )
   1162                case SPI_CMD_SYS_APP_MSG:
   1163                  ret = MTProcessAppMsg( pData, msg[2] );
   1164                  len = 0;
   1165                  break;
   1166          #endif // NONWK
   1167          
   1168                case SPI_CMD_SYS_LED_CONTROL:
   1169          #if (defined HAL_LED) && (HAL_LED == TRUE)
   1170                  ret = MTProcessLedControl( pData );
   1171                  len = 1;
   1172          #endif
   1173                  break;
   1174          
   1175          #ifdef MT_MAC_FUNC
   1176                case SPI_CMD_MAC_INIT:
   1177                case SPI_CMD_MAC_ASSOCIATE_REQ:
   1178                case SPI_CMD_MAC_ASSOCIATE_RSP:
   1179                case SPI_CMD_MAC_DISASSOCIATE_REQ:
   1180                case SPI_CMD_MAC_DATA_REQ:
   1181                case SPI_CMD_MAC_GET_REQ:
   1182                case SPI_CMD_MAC_SET_REQ:
   1183                case SPI_CMD_MAC_START_REQ:
   1184                case SPI_CMD_MAC_SCAN_REQ:
   1185                case SPI_CMD_MAC_RESET_REQ:
   1186                case SPI_CMD_MAC_GTS_REQ:
   1187                case SPI_CMD_MAC_ORPHAN_RSP:
   1188                case SPI_CMD_MAC_RX_ENABLE_REQ:
   1189                case SPI_CMD_MAC_SYNC_REQ:
   1190                case SPI_CMD_MAC_POLL_REQ:
   1191                case SPI_CMD_MAC_PURGE_REQ:
   1192                  MT_MacCommandProcessing( cmd , len , pData );
   1193                  break;
   1194          #endif
   1195          
   1196          #ifdef MT_NWK_FUNC
   1197                case SPI_CMD_NWK_INIT:
   1198                case SPI_CMD_NLDE_DATA_REQ:
   1199                case SPI_CMD_NLME_INIT_COORD_REQ:
   1200                case SPI_CMD_NLME_PERMIT_JOINING_REQ:
   1201                case SPI_CMD_NLME_JOIN_REQ:
   1202                case SPI_CMD_NLME_LEAVE_REQ:
   1203                case SPI_CMD_NLME_RESET_REQ:
   1204                case SPI_CMD_NLME_RX_STATE_REQ:
   1205                case SPI_CMD_NLME_GET_REQ:
   1206                case SPI_CMD_NLME_SET_REQ:
   1207                case SPI_CMD_NLME_NWK_DISC_REQ:
   1208                case SPI_CMD_NLME_ROUTE_DISC_REQ:
   1209                case SPI_CMD_NLME_DIRECT_JOIN_REQ:
   1210                case SPI_CMD_NLME_ORPHAN_JOIN_REQ:
   1211                case SPI_CMD_NLME_START_ROUTER_REQ:
   1212                  MT_NwkCommandProcessing( cmd , len , pData );
   1213                  break;
   1214          #endif
   1215          
   1216          #ifdef MT_ZDO_FUNC
   1217                case SPI_CMD_ZDO_AUTO_ENDDEVICEBIND_REQ:
   1218                case SPI_CMD_ZDO_AUTO_FIND_DESTINATION_REQ:
   1219                case SPI_CMD_ZDO_NWK_ADDR_REQ:
   1220                case SPI_CMD_ZDO_IEEE_ADDR_REQ:
   1221                case SPI_CMD_ZDO_NODE_DESC_REQ:
   1222                case SPI_CMD_ZDO_POWER_DESC_REQ:
   1223                case SPI_CMD_ZDO_SIMPLE_DESC_REQ:
   1224                case SPI_CMD_ZDO_ACTIVE_EPINT_REQ:
   1225                case SPI_CMD_ZDO_MATCH_DESC_REQ:
   1226                case SPI_CMD_ZDO_COMPLEX_DESC_REQ:
   1227                case SPI_CMD_ZDO_USER_DESC_REQ:
   1228                case SPI_CMD_ZDO_END_DEV_BIND_REQ:
   1229                case SPI_CMD_ZDO_BIND_REQ:
   1230                case SPI_CMD_ZDO_UNBIND_REQ:
   1231                case SPI_CMD_ZDO_MGMT_NWKDISC_REQ:
   1232                case SPI_CMD_ZDO_MGMT_LQI_REQ:
   1233                case SPI_CMD_ZDO_MGMT_RTG_REQ:
   1234                case SPI_CMD_ZDO_MGMT_BIND_REQ:
   1235                case SPI_CMD_ZDO_MGMT_DIRECT_JOIN_REQ:
   1236                case SPI_CMD_ZDO_USER_DESC_SET:
   1237                case SPI_CMD_ZDO_END_DEV_ANNCE:
   1238                case SPI_CMD_ZDO_MGMT_LEAVE_REQ:
   1239                case SPI_CMD_ZDO_MGMT_PERMIT_JOIN_REQ:
   1240                case SPI_CMD_ZDO_SERVERDISC_REQ:
   1241                case SPI_CMD_ZDO_NETWORK_START_REQ:
   1242                  MT_ZdoCommandProcessing( cmd , len , pData );
   1243                  break;
   1244          #endif
   1245          
   1246          #if defined ( MT_AF_FUNC )
   1247                case SPI_CMD_AF_INIT:
   1248                case SPI_CMD_AF_REGISTER:
   1249                case SPI_CMD_AF_SENDMSG:
   1250                  MT_afCommandProcessing( cmd , len , pData );
   1251                  break;
   1252          #endif
   1253          
   1254          #if defined ( MT_SAPI_FUNC )
   1255                case SPI_CMD_SAPI_SYS_RESET:
   1256                case SPI_CMD_SAPI_START_REQ:
   1257                case SPI_CMD_SAPI_BIND_DEVICE:
   1258                case SPI_CMD_SAPI_ALLOW_BIND:
   1259                case SPI_CMD_SAPI_SEND_DATA:
   1260                case SPI_CMD_SAPI_READ_CFG:
   1261                case SPI_CMD_SAPI_WRITE_CFG:
   1262                case SPI_CMD_SAPI_GET_DEV_INFO:
   1263                case SPI_CMD_SAPI_FIND_DEV:
   1264                case SPI_CMD_SAPI_PMT_JOIN:
   1265                  ret = MT_sapiCommandProcessing( cmd , len , pData );
   1266                  if ( ret == 0xff )
   1267                    len = 0;
   1268                  else
   1269                    len = 1;
   1270                  break;
   1271          #endif
   1272          
   1273          #if defined ( MT_USER_TEST_FUNC )
   1274                case SPI_CMD_USER_TEST:
   1275                  MT_ProcessAppUserCmd( pData );
   1276                  break;
   1277          #endif
   1278          
   1279                default:
   1280                  break;
   1281              }
   1282          
   1283              if ( len )
   \                     ??MT_ProcessSerialCommand_0:
   \   000166   EC           MOV     A,R4
   \   000167   6018         JZ      ??MT_ProcessSerialCommand_28
   1284              {
   1285                MT_BuildAndSendZToolResponse( (SPI_0DATA_MSG_LEN + len),
   1286                                              (SPI_RESPONSE_BIT | cmd),
   1287                                              len, retValue );
   \                     ??MT_ProcessSerialCommand_25:
   \   000169                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000169   7403         MOV     A,#0x3
   \   00016B   12....       LCALL   ?XSTACK_DISP0_8
   \   00016E   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000171   EE           MOV     A,R6
   \   000172   FA           MOV     R2,A
   \   000173   7410         MOV     A,#0x10
   \   000175   4F           ORL     A,R7
   \   000176   FB           MOV     R3,A
   \   000177   7405         MOV     A,#0x5
   \   000179   2C           ADD     A,R4
   \   00017A   F9           MOV     R1,A
   \   00017B   12....       LCALL   ??Subroutine2_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   00017E   12....       LCALL   ?DEALLOC_XSTACK8
   1288              }
   1289            }
   \                     ??MT_ProcessSerialCommand_28:
   \   000181   7413         MOV     A,#0x13
   \   000183   02....       LJMP    ?Subroutine26 & 0xFFFF
   \                     ??MT_ProcessSerialCommand_8:
   \   000186                ; Setup parameters for call to function MT_ReverseBytes
   \   000186   7908         MOV     R1,#0x8
   \   000188   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   00018B   12....       LCALL   ??MT_ReverseBytes?relay
   \   00018E                ; Setup parameters for call to function ZMacSetReq
   \   00018E   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000191   79E2         MOV     R1,#-0x1e
   \   000193   12....       LCALL   ZMacSetReq & 0xFFFF
   \   000196   E9           MOV     A,R1
   \   000197   7027         JNZ     ??MT_ProcessSerialCommand_30
   \   000199                ; Setup parameters for call to function osal_nv_write
   \   000199   85..82       MOV     DPL,?XSP + 0
   \   00019C   85..83       MOV     DPH,?XSP + 1
   \   00019F   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001A2   75..08       MOV     ?V0 + 0,#0x8
   \   0001A5   75..00       MOV     ?V0 + 1,#0x0
   \   0001A8   78..         MOV     R0,#?V0 + 0
   \   0001AA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001AD   7C00         MOV     R4,#0x0
   \   0001AF   7D00         MOV     R5,#0x0
   \   0001B1   7A01         MOV     R2,#0x1
   \                     ??MT_ProcessSerialCommand_31:
   \   0001B3   7B00         MOV     R3,#0x0
   \   0001B5   12....       LCALL   ??osal_nv_write?relay
   \   0001B8   7404         MOV     A,#0x4
   \   0001BA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001BD   02....       LJMP    ??MT_ProcessSerialCommand_26 & 0xFFFF
   \                     ??MT_ProcessSerialCommand_30:
   \   0001C0   7402         MOV     A,#0x2
   \   0001C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C5   7401         MOV     A,#0x1
   \                     ??MT_ProcessSerialCommand_27:
   \   0001C7   F0           MOVX    @DPTR,A
   \   0001C8   7C01         MOV     R4,#0x1
   \   0001CA   809D         SJMP    ??MT_ProcessSerialCommand_25
   \                     ??MT_ProcessSerialCommand_9:
   \   0001CC                ; Setup parameters for call to function ZMacGetReq
   \   0001CC   740B         MOV     A,#0xb
   \   0001CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D1   AA82         MOV     R2,DPL
   \   0001D3   AB83         MOV     R3,DPH
   \   0001D5   79E2         MOV     R1,#-0x1e
   \   0001D7   12....       LCALL   ZMacGetReq & 0xFFFF
   \   0001DA                ; Setup parameters for call to function MT_ReverseBytes
   \   0001DA   7908         MOV     R1,#0x8
   \   0001DC   AA82         MOV     R2,DPL
   \   0001DE   AB83         MOV     R3,DPH
   \   0001E0   12....       LCALL   ??MT_ReverseBytes?relay
   \   0001E3   7C08         MOV     R4,#0x8
   \   0001E5   02....       LJMP    ??MT_ProcessSerialCommand_29 & 0xFFFF
   \                     ??MT_ProcessSerialCommand_18:
   \   0001E8   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   0001EB   F9           MOV     R1,A
   \   0001EC   EA           MOV     A,R2
   \   0001ED   F8           MOV     R0,A
   \   0001EE   7409         MOV     A,#0x9
   \   0001F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F3   E8           MOV     A,R0
   \   0001F4   F0           MOVX    @DPTR,A
   \   0001F5   A3           INC     DPTR
   \   0001F6   E9           MOV     A,R1
   \   0001F7   F0           MOVX    @DPTR,A
   \   0001F8                ; Setup parameters for call to function osal_nv_write
   \   0001F8   7409         MOV     A,#0x9
   \   0001FA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FD   8582..       MOV     ?V0 + 0,DPL
   \   000200   8583..       MOV     ?V0 + 1,DPH
   \   000203   78..         MOV     R0,#?V0 + 0
   \   000205   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000208                ; Setup parameters for call to function osal_nv_item_len
   \   000208   7A83         MOV     R2,#-0x7d
   \   00020A   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   00020D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000210   7C00         MOV     R4,#0x0
   \   000212   7D00         MOV     R5,#0x0
   \   000214   7A83         MOV     R2,#-0x7d
   \   000216   809B         SJMP    ??MT_ProcessSerialCommand_31
   \                     ??MT_ProcessSerialCommand_19:
   \   000218   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   00021B   A3           INC     DPTR
   \   00021C   E0           MOVX    A,@DPTR
   \   00021D   F5..         MOV     ?V0 + 0,A
   \   00021F   89..         MOV     ?V0 + 1,R1
   \   000221   89..         MOV     ?V0 + 2,R1
   \   000223   89..         MOV     ?V0 + 3,R1
   \   000225   85..82       MOV     DPL,?XSP + 0
   \   000228   85..83       MOV     DPH,?XSP + 1
   \   00022B   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   00022E   A3           INC     DPTR
   \   00022F   E0           MOVX    A,@DPTR
   \   000230   F5..         MOV     ?V0 + 4,A
   \   000232   89..         MOV     ?V0 + 5,R1
   \   000234   89..         MOV     ?V0 + 6,R1
   \   000236   89..         MOV     ?V0 + 7,R1
   \   000238   7408         MOV     A,#0x8
   \   00023A   78..         MOV     R0,#?V0 + 4
   \   00023C   12....       LCALL   ?L_SHL
   \   00023F   78..         MOV     R0,#?V0 + 0
   \   000241   79..         MOV     R1,#?V0 + 4
   \   000243   12....       LCALL   ?L_ADD
   \   000246   85..82       MOV     DPL,?XSP + 0
   \   000249   85..83       MOV     DPH,?XSP + 1
   \   00024C   E0           MOVX    A,@DPTR
   \   00024D   F8           MOV     R0,A
   \   00024E   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000251   F5..         MOV     ?V0 + 4,A
   \   000253   8C..         MOV     ?V0 + 5,R4
   \   000255   7410         MOV     A,#0x10
   \   000257   78..         MOV     R0,#?V0 + 4
   \   000259   12....       LCALL   ?L_SHL
   \   00025C   78..         MOV     R0,#?V0 + 0
   \   00025E   79..         MOV     R1,#?V0 + 4
   \   000260   12....       LCALL   ?L_ADD
   \   000263   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000266   F5..         MOV     ?V0 + 4,A
   \   000268   8C..         MOV     ?V0 + 6,R4
   \   00026A   7418         MOV     A,#0x18
   \   00026C   78..         MOV     R0,#?V0 + 4
   \   00026E   12....       LCALL   ?L_SHL
   \   000271   78..         MOV     R0,#?V0 + 0
   \   000273   79..         MOV     R1,#?V0 + 4
   \   000275   12....       LCALL   ?L_ADD
   \   000278   7405         MOV     A,#0x5
   \   00027A   12....       LCALL   ?XSTACK_DISP0_8
   \   00027D   78..         MOV     R0,#?V0 + 0
   \   00027F   12....       LCALL   ?L_MOV_TO_X
   \   000282                ; Setup parameters for call to function osal_nv_write
   \   000282   7405         MOV     A,#0x5
   \   000284   12....       LCALL   ?XSTACK_DISP0_8
   \   000287   8582..       MOV     ?V0 + 0,DPL
   \   00028A   8583..       MOV     ?V0 + 1,DPH
   \   00028D   78..         MOV     R0,#?V0 + 0
   \   00028F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000292                ; Setup parameters for call to function osal_nv_item_len
   \   000292   7A84         MOV     R2,#-0x7c
   \   000294   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000297   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00029A   7C00         MOV     R4,#0x0
   \   00029C   7D00         MOV     R5,#0x0
   \   00029E   7A84         MOV     R2,#-0x7c
   \                     ??MT_ProcessSerialCommand_32:
   \   0002A0   02....       LJMP    ??MT_ProcessSerialCommand_31 & 0xFFFF
   \                     ??MT_ProcessSerialCommand_20:
   \   0002A3                ; Setup parameters for call to function osal_nv_write
   \   0002A3   85..82       MOV     DPL,?XSP + 0
   \   0002A6   85..83       MOV     DPH,?XSP + 1
   \   0002A9   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0002AC                ; Setup parameters for call to function osal_nv_item_len
   \   0002AC   7A61         MOV     R2,#0x61
   \   0002AE   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   0002B1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002B4   7C00         MOV     R4,#0x0
   \   0002B6   7D00         MOV     R5,#0x0
   \   0002B8   7A61         MOV     R2,#0x61
   \   0002BA   02....       LJMP    ??MT_ProcessSerialCommand_31 & 0xFFFF
   \                     ??MT_ProcessSerialCommand_21:
   \   0002BD                ; Setup parameters for call to function osal_nv_write
   \   0002BD   85..82       MOV     DPL,?XSP + 0
   \   0002C0   85..83       MOV     DPH,?XSP + 1
   \   0002C3   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0002C6                ; Setup parameters for call to function osal_nv_item_len
   \   0002C6   7A62         MOV     R2,#0x62
   \   0002C8   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   0002CB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002CE   7C00         MOV     R4,#0x0
   \   0002D0   7D00         MOV     R5,#0x0
   \   0002D2   7A62         MOV     R2,#0x62
   \   0002D4   80CA         SJMP    ??MT_ProcessSerialCommand_32
   \                     ??MT_ProcessSerialCommand_22:
   \   0002D6                ; Setup parameters for call to function MT_ProcessGetNvInfo
   \   0002D6   12....       LCALL   ??MT_ProcessGetNvInfo?relay
   \   0002D9   02....       LJMP    ??MT_ProcessSerialCommand_28 & 0xFFFF
   \                     ??MT_ProcessSerialCommand_12:
   \   0002DC                ; Setup parameters for call to function MT_ProcessGetDeviceInfo
   \   0002DC   12....       LCALL   ??MT_ProcessGetDeviceInfo?relay
   \   0002DF   02....       LJMP    ??MT_ProcessSerialCommand_28 & 0xFFFF
   \                     ??MT_ProcessSerialCommand_10:
   \   0002E2                ; Setup parameters for call to function MT_ProcessSetNV
   \   0002E2   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   0002E5   12....       LCALL   ??MT_ProcessSetNV?relay
   \   0002E8   02....       LJMP    ??MT_ProcessSerialCommand_26 & 0xFFFF
   \                     ??MT_ProcessSerialCommand_11:
   \   0002EB                ; Setup parameters for call to function MT_ProcessGetNV
   \   0002EB   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   0002EE   12....       LCALL   ??MT_ProcessGetNV?relay
   \   0002F1   02....       LJMP    ??MT_ProcessSerialCommand_28 & 0xFFFF
   \                     ??MT_ProcessSerialCommand_17:
   \   0002F4                ; Setup parameters for call to function osal_GetSystemClock
   \   0002F4   12....       LCALL   ??osal_GetSystemClock?relay
   \   0002F7   8A..         MOV     ?V0 + 4,R2
   \   0002F9   8B..         MOV     ?V0 + 5,R3
   \   0002FB   8C..         MOV     ?V0 + 6,R4
   \   0002FD   8D..         MOV     ?V0 + 7,R5
   \   0002FF   90....       MOV     DPTR,#__Constant_3e8
   \   000302   78..         MOV     R0,#?V0 + 0
   \   000304   12....       LCALL   ?L_MOV_X
   \   000307   78..         MOV     R0,#?V0 + 4
   \   000309   79..         MOV     R1,#?V0 + 0
   \   00030B   12....       LCALL   ?UL_DIV_MOD
   \   00030E   7405         MOV     A,#0x5
   \   000310   12....       LCALL   ?XSTACK_DISP0_8
   \   000313   78..         MOV     R0,#?V0 + 4
   \   000315   12....       LCALL   ?L_MOV_TO_X
   \   000318   7405         MOV     A,#0x5
   \   00031A   12....       LCALL   ?XSTACK_DISP0_8
   \   00031D   78..         MOV     R0,#?V0 + 0
   \   00031F   12....       LCALL   ?L_MOV_X
   \   000322   7418         MOV     A,#0x18
   \   000324   78..         MOV     R0,#?V0 + 0
   \   000326   12....       LCALL   ?UL_SHR
   \   000329   740B         MOV     A,#0xb
   \   00032B   12....       LCALL   ?XSTACK_DISP0_8
   \   00032E   E5..         MOV     A,?V0 + 0
   \   000330   F0           MOVX    @DPTR,A
   \   000331   7405         MOV     A,#0x5
   \   000333   12....       LCALL   ?XSTACK_DISP0_8
   \   000336   78..         MOV     R0,#?V0 + 0
   \   000338   12....       LCALL   ?L_MOV_X
   \   00033B   7410         MOV     A,#0x10
   \   00033D   78..         MOV     R0,#?V0 + 0
   \   00033F   12....       LCALL   ?UL_SHR
   \   000342   740C         MOV     A,#0xc
   \   000344   12....       LCALL   ?XSTACK_DISP0_8
   \   000347   E5..         MOV     A,?V0 + 0
   \   000349   F0           MOVX    @DPTR,A
   \   00034A   7405         MOV     A,#0x5
   \   00034C   12....       LCALL   ?XSTACK_DISP0_8
   \   00034F   78..         MOV     R0,#?V0 + 0
   \   000351   12....       LCALL   ?L_MOV_X
   \   000354   E5..         MOV     A,?V0 + 1
   \   000356   F5..         MOV     ?V0 + 0,A
   \   000358   740D         MOV     A,#0xd
   \   00035A   12....       LCALL   ?XSTACK_DISP0_8
   \   00035D   E5..         MOV     A,?V0 + 0
   \   00035F   F0           MOVX    @DPTR,A
   \   000360   7405         MOV     A,#0x5
   \   000362   12....       LCALL   ?XSTACK_DISP0_8
   \   000365   78..         MOV     R0,#?V0 + 0
   \   000367   12....       LCALL   ?L_MOV_X
   \   00036A   740E         MOV     A,#0xe
   \   00036C   12....       LCALL   ?XSTACK_DISP0_8
   \   00036F   E5..         MOV     A,?V0 + 0
   \   000371   F0           MOVX    @DPTR,A
   \   000372   7C04         MOV     R4,#0x4
   \   000374   02....       LJMP    ??MT_ProcessSerialCommand_29 & 0xFFFF
   \                     ??MT_ProcessSerialCommand_13:
   \   000377   85..82       MOV     DPL,?XSP + 0
   \   00037A   85..83       MOV     DPH,?XSP + 1
   \   00037D   E0           MOVX    A,@DPTR
   \   00037E   F8           MOV     R0,A
   \   00037F   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000382   A2E0         MOV     C,0xE0 /* A   */.0
   \   000384   5001         JNC     ??MT_ProcessSerialCommand_33
   \   000386   09           INC     R1
   \                     ??MT_ProcessSerialCommand_33:
   \   000387   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   00038A   A2E1         MOV     C,0xE0 /* A   */.1
   \   00038C   5004         JNC     ??MT_ProcessSerialCommand_34
   \   00038E   E9           MOV     A,R1
   \   00038F   D2E1         SETB    0xE0 /* A   */.1
   \   000391   F9           MOV     R1,A
   \                     ??MT_ProcessSerialCommand_34:
   \   000392   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000395   A2E2         MOV     C,0xE0 /* A   */.2
   \   000397   5004         JNC     ??MT_ProcessSerialCommand_35
   \   000399   E9           MOV     A,R1
   \   00039A   D2E4         SETB    0xE0 /* A   */.4
   \   00039C   F9           MOV     R1,A
   \                     ??MT_ProcessSerialCommand_35:
   \   00039D   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   0003A0   A2E3         MOV     C,0xE0 /* A   */.3
   \   0003A2   5004         JNC     ??MT_ProcessSerialCommand_36
   \   0003A4   E9           MOV     A,R1
   \   0003A5   D2E3         SETB    0xE0 /* A   */.3
   \   0003A7   F9           MOV     R1,A
   \                     ??MT_ProcessSerialCommand_36:
   \   0003A8   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   0003AB   A2E4         MOV     C,0xE0 /* A   */.4
   \   0003AD   5004         JNC     ??MT_ProcessSerialCommand_37
   \   0003AF   E9           MOV     A,R1
   \   0003B0   D2E2         SETB    0xE0 /* A   */.2
   \   0003B2   F9           MOV     R1,A
   \                     ??MT_ProcessSerialCommand_37:
   \   0003B3   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   0003B6   A2E5         MOV     C,0xE0 /* A   */.5
   \   0003B8   5004         JNC     ??MT_ProcessSerialCommand_38
   \   0003BA   E9           MOV     A,R1
   \   0003BB   D2E5         SETB    0xE0 /* A   */.5
   \   0003BD   F9           MOV     R1,A
   \                     ??MT_ProcessSerialCommand_38:
   \   0003BE   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   0003C1   A2E6         MOV     C,0xE0 /* A   */.6
   \   0003C3   5004         JNC     ??MT_ProcessSerialCommand_39
   \   0003C5   E9           MOV     A,R1
   \   0003C6   D2E6         SETB    0xE0 /* A   */.6
   \   0003C8   F9           MOV     R1,A
   \                     ??MT_ProcessSerialCommand_39:
   \   0003C9                ; Setup parameters for call to function OnBoard_SendKeys
   \   0003C9   85..82       MOV     DPL,?XSP + 0
   \   0003CC   85..83       MOV     DPH,?XSP + 1
   \   0003CF   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   0003D2   FA           MOV     R2,A
   \   0003D3   12....       LCALL   ??OnBoard_SendKeys?relay
   \   0003D6   02....       LJMP    ??MT_ProcessSerialCommand_26 & 0xFFFF
   \                     ??MT_ProcessSerialCommand_15:
   \   0003D9                ; Setup parameters for call to function MTProcessAppMsg
   \   0003D9   8A82         MOV     DPL,R2
   \   0003DB   8B83         MOV     DPH,R3
   \   0003DD   A3           INC     DPTR
   \   0003DE   A3           INC     DPTR
   \   0003DF   E0           MOVX    A,@DPTR
   \   0003E0   F9           MOV     R1,A
   \   0003E1   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   0003E4   12....       LCALL   ??MTProcessAppMsg?relay
   \   0003E7   02....       LJMP    ??MT_ProcessSerialCommand_28 & 0xFFFF
   \                     ??MT_ProcessSerialCommand_16:
   \   0003EA                ; Setup parameters for call to function MTProcessLedControl
   \   0003EA   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   0003ED   12....       LCALL   ??MTProcessLedControl?relay
   \   0003F0   02....       LJMP    ??MT_ProcessSerialCommand_26 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F8           MOV     R0,A
   \                     ??Subroutine20_0:
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F583         MOV     DPH,A
   \   00000C   8882         MOV     DPL,R0
   \   00000E   A3           INC     DPTR
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FA           MOV     R2,A
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B                REQUIRE ?Subroutine27
   \   00000B                ; // Fall through to label ?Subroutine27

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   F583         MOV     DPH,A
   \   000004   8882         MOV     DPL,R0
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E0           MOVX    A,@DPTR
   \                     ??Subroutine9_0:
   \   000007   F8           MOV     R0,A
   \   000008   02....       LJMP    ?Subroutine27 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \                     ??Subroutine7_0:
   \   000006   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   22           RET
   1290          #endif // ZTOOL
   1291          
   1292          #if (defined HAL_LED) && (HAL_LED == TRUE)
   1293          /***************************************************************************************************
   1294           * @fn      MTProcessLedControl
   1295           *
   1296           * @brief
   1297           *
   1298           *   Process the LED Control Message
   1299           *
   1300           * @param   data - input serial buffer
   1301           *
   1302           * @return  status
   1303           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1304          byte MTProcessLedControl( byte *pData )
   \                     MTProcessLedControl:
   1305          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1306            byte iLed;
   1307            byte Led;
   1308            byte iMode;
   1309            byte Mode;
   1310          
   1311            iLed = *pData++;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FC           MOV     R4,A
   \   00000A   A3           INC     DPTR
   1312            iMode = *pData;
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   FA           MOV     R2,A
   1313          
   1314            if ( iLed == 1 )
   \   00000D   7401         MOV     A,#0x1
   \   00000F   6C           XRL     A,R4
   \   000010   7004         JNZ     ??MTProcessLedControl_0
   1315              Led = HAL_LED_1;
   \   000012   7901         MOV     R1,#0x1
   \   000014   8026         SJMP    ??MTProcessLedControl_1
   1316            else if ( iLed == 2 )
   \                     ??MTProcessLedControl_0:
   \   000016   7402         MOV     A,#0x2
   \   000018   6C           XRL     A,R4
   \   000019   7004         JNZ     ??MTProcessLedControl_2
   1317              Led = HAL_LED_2;
   \   00001B   7902         MOV     R1,#0x2
   \   00001D   801D         SJMP    ??MTProcessLedControl_1
   1318            else if ( iLed == 3 )
   \                     ??MTProcessLedControl_2:
   \   00001F   7403         MOV     A,#0x3
   \   000021   6C           XRL     A,R4
   \   000022   7004         JNZ     ??MTProcessLedControl_3
   1319              Led = HAL_LED_3;
   \   000024   7904         MOV     R1,#0x4
   \   000026   8014         SJMP    ??MTProcessLedControl_1
   1320            else if ( iLed == 4 )
   \                     ??MTProcessLedControl_3:
   \   000028   7404         MOV     A,#0x4
   \   00002A   6C           XRL     A,R4
   \   00002B   7004         JNZ     ??MTProcessLedControl_4
   1321              Led = HAL_LED_4;
   \   00002D   7908         MOV     R1,#0x8
   \   00002F   800B         SJMP    ??MTProcessLedControl_1
   1322            else if ( iLed == 0xFF )
   \                     ??MTProcessLedControl_4:
   \   000031   74FF         MOV     A,#-0x1
   \   000033   6C           XRL     A,R4
   \   000034   7004         JNZ     ??MTProcessLedControl_5
   1323              Led = HAL_LED_ALL;
   \   000036   790F         MOV     R1,#0xf
   \   000038   8002         SJMP    ??MTProcessLedControl_1
   1324            else
   1325              Led = 0;
   \                     ??MTProcessLedControl_5:
   \   00003A   7900         MOV     R1,#0x0
   1326          
   1327            if ( iMode == 0 )
   \                     ??MTProcessLedControl_1:
   \   00003C   EA           MOV     A,R2
   \   00003D   7004         JNZ     ??MTProcessLedControl_6
   1328              Mode = HAL_LED_MODE_OFF;
   \   00003F   7A00         MOV     R2,#0x0
   \   000041   8022         SJMP    ??MTProcessLedControl_7
   1329            else if ( iMode == 1 )
   \                     ??MTProcessLedControl_6:
   \   000043   7401         MOV     A,#0x1
   \   000045   6A           XRL     A,R2
   \   000046   7004         JNZ     ??MTProcessLedControl_8
   1330              Mode = HAL_LED_MODE_ON;
   \   000048   7A01         MOV     R2,#0x1
   \   00004A   8019         SJMP    ??MTProcessLedControl_7
   1331            else if ( iMode == 2 )
   \                     ??MTProcessLedControl_8:
   \   00004C   7402         MOV     A,#0x2
   \   00004E   6A           XRL     A,R2
   \   00004F   7004         JNZ     ??MTProcessLedControl_9
   1332              Mode = HAL_LED_MODE_BLINK;
   \   000051   7A02         MOV     R2,#0x2
   \   000053   8010         SJMP    ??MTProcessLedControl_7
   1333            else if ( iMode == 3 )
   \                     ??MTProcessLedControl_9:
   \   000055   7403         MOV     A,#0x3
   \   000057   6A           XRL     A,R2
   \   000058   7004         JNZ     ??MTProcessLedControl_10
   1334              Mode = HAL_LED_MODE_FLASH;
   \   00005A   7A04         MOV     R2,#0x4
   \   00005C   8007         SJMP    ??MTProcessLedControl_7
   1335            else if ( iMode == 4 )
   \                     ??MTProcessLedControl_10:
   \   00005E   7404         MOV     A,#0x4
   \   000060   6A           XRL     A,R2
   \   000061   700C         JNZ     ??MTProcessLedControl_11
   1336              Mode = HAL_LED_MODE_TOGGLE;
   \   000063   7A08         MOV     R2,#0x8
   1337            else
   1338              Led = 0;
   1339          
   1340            if ( Led != 0 )
   \                     ??MTProcessLedControl_7:
   \   000065   E9           MOV     A,R1
   \   000066   6007         JZ      ??MTProcessLedControl_11
   1341            {
   1342              HalLedSet (Led, Mode );
   \   000068                ; Setup parameters for call to function HalLedSet
   \   000068   12....       LCALL   ??HalLedSet?relay
   1343              return ( ZSuccess );
   \   00006B   7900         MOV     R1,#0x0
   \   00006D   8002         SJMP    ??MTProcessLedControl_12
   1344            }
   1345            else
   1346              return ( ZFailure );
   \                     ??MTProcessLedControl_11:
   \   00006F   7901         MOV     R1,#0x1
   \                     ??MTProcessLedControl_12:
   \   000071   02....       LJMP    ?Subroutine23 & 0xFFFF
   1347          }
   1348          #endif // HAL_LED
   1349          
   1350          #if !defined ( NONWK )
   1351          /*********************************************************************
   1352           * @fn      MTProcessAppMsg
   1353           *
   1354           * @brief
   1355           *
   1356           *   Process the User App Message
   1357           *
   1358           * @param   data - input serial buffer
   1359           * @param   len - data length
   1360           *
   1361           * @return  status
   1362           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1363          byte MTProcessAppMsg( byte *pData, byte len )
   \                     MTProcessAppMsg:
   1364          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 3,R1
   1365            byte ret = ZFailure;
   \   00000C   75..01       MOV     ?V0 + 2,#0x1
   1366            byte endpoint;
   1367            endPointDesc_t *epDesc;
   1368            mtSysAppMsg_t *msg;
   1369          
   1370            // Get the endpoint and skip past it.
   1371            endpoint = *pData++;
   \   00000F   8A82         MOV     DPL,R2
   \   000011   8B83         MOV     DPH,R3
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F5..         MOV     ?V0 + 4,A
   \   000016   A3           INC     DPTR
   \   000017   8582..       MOV     ?V0 + 6,DPL
   \   00001A   8583..       MOV     ?V0 + 7,DPH
   1372            len--;
   \   00001D   15..         DEC     ?V0 + 3
   1373          
   1374            // Look up the endpoint
   1375            epDesc = afFindEndPointDesc( endpoint );
   \   00001F                ; Setup parameters for call to function afFindEndPointDesc
   \   00001F   F9           MOV     R1,A
   \   000020   12....       LCALL   ??afFindEndPointDesc?relay
   \   000023   85..82       MOV     DPL,?XSP + 0
   \   000026   85..83       MOV     DPH,?XSP + 1
   \   000029   EA           MOV     A,R2
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   EB           MOV     A,R3
   \   00002D   12....       LCALL   ?Subroutine5 & 0xFFFF
   1376          
   1377            if ( epDesc )
   \                     ??CrossCallReturnLabel_13:
   \   000030   7002         JNZ     ??MTProcessAppMsg_0
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \                     ??MTProcessAppMsg_0:
   \   000034   607E         JZ      ??MTProcessAppMsg_1
   1378            {
   1379              // Build and send the message to the APP
   1380              msg = (mtSysAppMsg_t *)osal_msg_allocate( sizeof( mtSysAppMsg_t ) + len );
   \   000036                ; Setup parameters for call to function osal_msg_allocate
   \   000036   85....       MOV     ?V0 + 0,?V0 + 3
   \   000039   7406         MOV     A,#0x6
   \   00003B   25..         ADD     A,?V0 + 0
   \   00003D   FA           MOV     R2,A
   \   00003E   E4           CLR     A
   \   00003F   3400         ADDC    A,#0x0
   \   000041   FB           MOV     R3,A
   \   000042   12....       LCALL   ??osal_msg_allocate?relay
   \   000045   8A..         MOV     ?V0 + 0,R2
   \   000047   8B..         MOV     ?V0 + 1,R3
   \   000049   AE..         MOV     R6,?V0 + 0
   \   00004B   AF..         MOV     R7,?V0 + 1
   1381              if ( msg )
   \   00004D   EE           MOV     A,R6
   \   00004E   7001         JNZ     ??MTProcessAppMsg_2
   \   000050   EF           MOV     A,R7
   \                     ??MTProcessAppMsg_2:
   \   000051   6061         JZ      ??MTProcessAppMsg_1
   1382              {
   1383                msg->hdr.event = MT_SYS_APP_MSG;
   \   000053   7423         MOV     A,#0x23
   \   000055   8E82         MOV     DPL,R6
   \   000057   8F83         MOV     DPH,R7
   \   000059   F0           MOVX    @DPTR,A
   1384                msg->endpoint = endpoint;
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   E5..         MOV     A,?V0 + 4
   \   00005E   12....       LCALL   ?Subroutine4 & 0xFFFF
   1385                msg->appDataLen = len;
   \                     ??CrossCallReturnLabel_11:
   \   000061   E5..         MOV     A,?V0 + 3
   \   000063   F0           MOVX    @DPTR,A
   1386                msg->appData = (uint8*)(msg+1);
   \   000064   EE           MOV     A,R6
   \   000065   2404         ADD     A,#0x4
   \   000067   FA           MOV     R2,A
   \   000068   EF           MOV     A,R7
   \   000069   3400         ADDC    A,#0x0
   \   00006B   FB           MOV     R3,A
   \   00006C   EE           MOV     A,R6
   \   00006D   2406         ADD     A,#0x6
   \   00006F   F8           MOV     R0,A
   \   000070   EF           MOV     A,R7
   \   000071   3400         ADDC    A,#0x0
   \   000073   F9           MOV     R1,A
   \   000074   8A82         MOV     DPL,R2
   \   000076   8B83         MOV     DPH,R3
   \   000078   E8           MOV     A,R0
   \   000079   F0           MOVX    @DPTR,A
   \   00007A   A3           INC     DPTR
   \   00007B   E9           MOV     A,R1
   \   00007C   F0           MOVX    @DPTR,A
   1387          
   1388                osal_memcpy( msg->appData, pData, len );
   \   00007D                ; Setup parameters for call to function osal_memcpy
   \   00007D   85....       MOV     ?V0 + 0,?V0 + 6
   \   000080   85....       MOV     ?V0 + 1,?V0 + 7
   \   000083   75..00       MOV     ?V0 + 2,#0x0
   \   000086   78..         MOV     R0,#?V0 + 0
   \   000088   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00008B   AC..         MOV     R4,?V0 + 3
   \   00008D   7D00         MOV     R5,#0x0
   \   00008F   8A82         MOV     DPL,R2
   \   000091   8B83         MOV     DPH,R3
   \   000093   12....       LCALL   ??Subroutine8_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000096   12....       LCALL   ??osal_memcpy?relay
   \   000099   7403         MOV     A,#0x3
   \   00009B   12....       LCALL   ?DEALLOC_XSTACK8
   1389          
   1390                osal_msg_send( *(epDesc->task_id), (uint8 *)msg );
   \   00009E                ; Setup parameters for call to function osal_msg_send
   \   00009E   EE           MOV     A,R6
   \   00009F   FA           MOV     R2,A
   \   0000A0   EF           MOV     A,R7
   \   0000A1   FB           MOV     R3,A
   \   0000A2   85..82       MOV     DPL,?XSP + 0
   \   0000A5   85..83       MOV     DPH,?XSP + 1
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   F8           MOV     R0,A
   \   0000AA   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   0000AD   12....       LCALL   ??Subroutine9_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   0000B0   F9           MOV     R1,A
   \   0000B1   12....       LCALL   ??osal_msg_send?relay
   1391          
   1392                ret = ZSuccess;
   1393              }
   1394            }
   1395          
   1396            return ret;
   \                     ??MTProcessAppMsg_1:
   \   0000B4   A9..         MOV     R1,?V0 + 2
   \   0000B6   7402         MOV     A,#0x2
   \   0000B8   02....       LJMP    ?Subroutine26 & 0xFFFF
   1397          }
   1398          #endif // NONWK
   1399          
   1400          #if defined ( ZTOOL_PORT )
   1401          /*********************************************************************
   1402           * @fn      MTProcessAppRspMsg
   1403           *
   1404           * @brief
   1405           *
   1406           *   Process the User App Response Message
   1407           *
   1408           * @param   data - output serial buffer.  The first byte must be the
   1409           *          endpoint that send this message.
   1410           * @param   len - data length
   1411           *
   1412           * @return  none
   1413           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1414          void MTProcessAppRspMsg( byte *pData, byte len )
   \                     MTProcessAppRspMsg:
   1415          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1416            // Send out Reset Response message
   1417            MT_BuildAndSendZToolResponse( (SPI_0DATA_MSG_LEN + len),
   1418                                          (SPI_RESPONSE_BIT | SPI_CMD_SYS_APP_MSG),
   1419                                          len, pData );
   \   000005                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   78..         MOV     R0,#?V0 + 0
   \   00000B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00000E   E9           MOV     A,R1
   \   00000F   FC           MOV     R4,A
   \   000010   7A18         MOV     R2,#0x18
   \   000012   7B10         MOV     R3,#0x10
   \   000014   7405         MOV     A,#0x5
   \   000016   29           ADD     A,R1
   \   000017   F9           MOV     R1,A
   \   000018   12....       LCALL   ??Subroutine2_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   00001B   02....       LJMP    ??Subroutine24_0 & 0xFFFF
   1420          }
   1421          #endif // ZTOOL_PORT
   1422          
   1423          
   1424          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
   1425          #if defined ( MT_USER_TEST_FUNC )
   1426          /*********************************************************************
   1427           * @fn      MT_ProcessAppUserCmd
   1428           *
   1429           * @brief
   1430           *
   1431           *   Temp function for testing
   1432           *
   1433           * @param   data - received message
   1434           *
   1435           * @return  void
   1436           */
   1437          void MT_ProcessAppUserCmd( byte *pData) 						
   1438          {
   1439            uint16 app_cmd;
   1440            byte srcEp;
   1441            uint16 param1;
   1442            uint16 param2;
   1443            byte len;
   1444            uint16 ret;
   1445          
   1446            ret = INVALID_TASK;     //should be changed later
   1447          
   1448            srcEp = *pData++;
   1449          
   1450            app_cmd = BUILD_UINT16( pData[1] , pData[0] );
   1451            pData = pData + sizeof( uint16 );
   1452          
   1453            param1 = BUILD_UINT16( pData[1] , pData[0] );
   1454            pData = pData + sizeof( uint16 );
   1455          
   1456            param2 = BUILD_UINT16( pData[1] , pData[0] );
   1457          
   1458            len = SPI_RESP_MSG_LEN_DEFAULT;
   1459          
   1460          
   1461            switch ( app_cmd )
   1462            {
   1463          
   1464          #if defined (APP_TGEN)
   1465              case TGEN_START:
   1466                TrafficGenApp_SendCmdMSG( param1, param2, TRAFFICGENAPP_CMD_START );
   1467                ret = ZSUCCESS;
   1468                break;
   1469          
   1470              case TGEN_STOP:
   1471                TrafficGenApp_SendCmdMSG( param1, param2, TRAFFICGENAPP_CMD_STOP );
   1472                ret = ZSUCCESS;
   1473                break;
   1474          
   1475              case TGEN_COUNT:
   1476                ret = TrafficGenApp_CountPkt( param1, param2 );
   1477                return;		// so that spi_resp is not sent...
   1478                //ret = ZSUCCESS;
   1479                break;				
   1480          #endif
   1481          
   1482          #if defined (NWK_TEST)
   1483              case HW_TEST:
   1484                HwApp_Start( HI_UINT16(param1), LO_UINT16(param1), HI_UINT16(param2),
   1485                              1000, LO_UINT16(param2), 3, 0 );
   1486                break;
   1487          
   1488              case HW_DISPLAY_RESULT:
   1489                HwApp_TestInfo();
   1490                break;
   1491          
   1492              case HW_SEND_STATUS:
   1493                HwApp_SendStats();
   1494                break;
   1495          #endif
   1496          
   1497          #if defined( APP_TP ) || defined ( APP_TP2 )
   1498            #if defined( APP_TP )
   1499              case TP_SEND_NODATA:
   1500                ret = TestProfileApp_SendNoData( srcEp, (byte)param1 );
   1501                break;
   1502            #endif // APP_TP
   1503          			
   1504              case TP_SEND_BUFFERTEST:
   1505                ret = TestProfileApp_SendBufferReq( srcEp, (byte)param1 );
   1506                break;
   1507          			
   1508            #if defined( APP_TP )
   1509              case TP_SEND_UINT8:
   1510                ret = TestProfileApp_SendUint8( srcEp, (byte)param1 );
   1511                break;
   1512          
   1513              case TP_SEND_INT8:
   1514                ret = TestProfileApp_SendInt8( srcEp, (byte)param1 );
   1515                break;
   1516          
   1517              case TP_SEND_UINT16:
   1518                ret = TestProfileApp_SendUint16( srcEp, (byte)param1 );
   1519                break;
   1520          
   1521              case TP_SEND_INT16:
   1522                ret = TestProfileApp_SendInt16( srcEp, (byte)param1 );
   1523                break;
   1524          
   1525              case TP_SEND_SEMIPREC:
   1526                ret = TestProfileApp_SendSemiPrec( srcEp, (byte)param1 );
   1527                break;
   1528          
   1529              case TP_SEND_FREEFORM:
   1530                ret = TestProfileApp_SendFreeFormReq( srcEp, (byte)param1 );
   1531                break;
   1532          			
   1533            #else // APP_TP
   1534              case TP_SEND_FREEFORM:
   1535                ret = TestProfileApp_SendFreeFormReq(srcEp, (byte)param1, (byte)param2);
   1536                break;
   1537            #endif
   1538          			
   1539            #if defined( APP_TP )
   1540              case TP_SEND_ABS_TIME:
   1541                ret = TestProfileApp_SendAbsTime( srcEp, (byte)param1 );
   1542                break;
   1543          
   1544              case TP_SEND_REL_TIME:
   1545                ret = TestProfileApp_SendRelativeTime( srcEp, (byte)param1 );
   1546                break;
   1547          
   1548              case TP_SEND_CHAR_STRING:
   1549                ret = TestProfileApp_SendCharString( srcEp, (byte)param1 );
   1550                break;
   1551          
   1552              case TP_SEND_OCTET_STRING:
   1553                ret = TestProfileApp_SendOctetString( srcEp, (byte)param1 );
   1554                break;		
   1555            #endif // APP_TP
   1556          				
   1557              case TP_SET_DSTADDRESS:			
   1558                ret = TestProfileApp_SetDestAddress(HI_UINT16(param1), LO_UINT16(param1), param2);
   1559                break;	
   1560          
   1561            #if defined( APP_TP2 )
   1562              case TP_SEND_BUFFER_GROUP:
   1563                ret = TestProfileApp_SendBufferGroup( srcEp, (byte)param1 );
   1564                break;
   1565            #endif // APP_TP
   1566          
   1567              case TP_SEND_BUFFER:
   1568                ret = TestProfileApp_SendBuffer( srcEp, (byte)param1 );
   1569                break;
   1570          				
   1571            #if defined( APP_TP )
   1572              case TP_SEND_MULT_KVP_8BIT:
   1573                TestProfileApp_SendMultiKVP_8bit( srcEp, (byte)param1 );
   1574                ret = ZSuccess;
   1575                break;
   1576          
   1577              case TP_SEND_MULT_KVP_16BIT:
   1578                TestProfileApp_SendMultiKVP_16bit( srcEp, (byte)param1 );
   1579                ret = ZSuccess;
   1580                break;
   1581          
   1582              case TP_SEND_MULT_KVP_TIME:
   1583                TestProfileApp_SendMultiKVP_Time( srcEp, (byte)param1 );
   1584                ret = ZSuccess;
   1585                break;
   1586          
   1587              case TP_SEND_MULT_KVP_STRING:
   1588                TestProfileApp_SendMultiKVP_String( srcEp, (byte)param1 );
   1589                ret = ZSuccess;
   1590                break;
   1591          
   1592              case TP_SEND_MULTI_KVP_STR_TIME:
   1593                ret = ZSuccess;
   1594                TestProfileApp_SendMultiKVP_String_Time( srcEp, (byte)param1 );
   1595                break;
   1596            #endif // APP_TP
   1597          				
   1598              case TP_SEND_COUNTED_PKTS:
   1599                TestProfileApp_SendCountedPktsReq(HI_UINT16(param1), LO_UINT16(param1), param2);
   1600                ret = ZSuccess;
   1601                break;
   1602          
   1603              case TP_SEND_RESET_COUNTER:
   1604                TestProfileApp_CountedPakts_ResetCounterReq( (byte)param1 );
   1605                ret = ZSuccess;
   1606                break;
   1607          
   1608              case TP_SEND_GET_COUNTER:
   1609                TestProfileApp_CountedPakts_GetCounterReq( srcEp, (byte)param1 );
   1610                ret = ZSuccess;
   1611                break;
   1612          				
   1613              case TP_SET_PERMIT_JOIN:
   1614            #if defined ( RTR_NWK )
   1615                NLME_PermitJoiningRequest( (byte)param1 );
   1616                ret = ZSuccess;
   1617            #else
   1618                ret = ZFailure;
   1619            #endif
   1620                break;
   1621          
   1622            #if defined ( APP_TP2 )
   1623              case TP_ADD_GROUP:
   1624                ret = TestProfileApp_SetGroup( srcEp, param1 );
   1625                break;
   1626          
   1627              case TP_REMOVE_GROUP:
   1628                ret = TestProfileApp_RemoveGroup( srcEp, param1 );
   1629                break;
   1630          
   1631              case TP_SEND_UPDATE_KEY:
   1632                ret = TestProfileApp_UpdateKey( srcEp, (uint8)param1, param2 );
   1633                break;
   1634          
   1635              case TP_SEND_SWITCH_KEY:
   1636                ret = TestProfileApp_SwitchKey(  srcEp, (uint8)param1, param2 );
   1637                break;
   1638          			
   1639              case TP_SEND_BUFFERTEST_GROUP:
   1640                ret = TestProfileApp_SendBufferGroupReq( srcEp, (byte)param1 );
   1641                break;
   1642          
   1643              case TP_SEND_ROUTE_DISC_REQ:
   1644                ret = TestProfileApp_SendRouteDiscReq( srcEp, param1,
   1645                                            HI_UINT16( param2 ), LO_UINT16( param2 ) );
   1646                break;
   1647          
   1648              case TP_SEND_ROUTE_DISCOVERY:
   1649          #if defined ( RTR_NWK )
   1650                ret = TestProfileApp_SendRouteDiscovery( param1,
   1651                                            HI_UINT16( param2 ), LO_UINT16( param2 ) );
   1652          #endif
   1653                break;
   1654          
   1655            #endif // APP_TP2
   1656          
   1657          #endif  // APP_TP || APP_TP2
   1658          
   1659          #if defined ( OSAL_TOTAL_MEM )
   1660              case OSAL_MEM_STACK_HIGH_WATER:
   1661              case OSAL_MEM_HEAP_HIGH_WATER:
   1662                if ( app_cmd == OSAL_MEM_STACK_HIGH_WATER)
   1663                  param1 = osal_stack_used();
   1664                else
   1665                  param1 = osal_heap_high_water();
   1666                pData[0] = HI_UINT16( param1 );
   1667                pData[1] = LO_UINT16( param1 );
   1668          
   1669                // The pData for this response will only send one byte,
   1670                // so we are going to call it twice.
   1671                //        MT_BuildAndSendZToolResponse( (SPI_0DATA_MSG_LEN + sizeof( uint16 )),
   1672                //                                    (SPI_CMD_USER_TEST | SPI_RESPONSE_BIT),
   1673                //                                    sizeof( uint16 ), pData );
   1674                MT_SendSPIRespMsg( pData[0], SPI_CMD_USER_TEST, SPI_RESP_MSG_LEN_DEFAULT, 1);
   1675                MT_SendSPIRespMsg( pData[1], SPI_CMD_USER_TEST, SPI_RESP_MSG_LEN_DEFAULT, 1);
   1676                return;
   1677          #endif
   1678          
   1679          #if defined ( APP_DEBUG )
   1680              case DEBUG_GET:
   1681                DebugApp_SendQuery( param1 );
   1682                ret = ZSUCCESS;
   1683                break;
   1684          #endif
   1685          
   1686          #if defined ( APP_TP2 )
   1687              case TP_SEND_BCAST_RSP:
   1688                ret = TestProfileApp_SendBcastRsp( srcEp, (byte)param1 );
   1689                break;
   1690          #endif
   1691          			
   1692              default:
   1693                break;
   1694            }
   1695          
   1696            MT_SendSPIRespMsg( ( byte )ret, SPI_CMD_USER_TEST, len, 1);
   1697          
   1698          }
   1699          #endif // MT_USER_TEST_FUNC
   1700          #endif // ZTOOL
   1701          
   1702          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
   1703          /***************************************************************************************************
   1704           * @fn      MT_RAMRead
   1705           *
   1706           * @brief
   1707           *
   1708           *   Process Serial Message.
   1709           *
   1710           * @param   UINT16 addr - address to read from
   1711           * @param   pData - pointer to buffer to put read data
   1712           *
   1713           * @return  ZSuccess or ZFailure
   1714           *
   1715           * @MT SPI_CMD_SYS_RAM_READ
   1716           *
   1717           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1718          byte MT_RAMRead( UINT16 addr, byte *pData  )
   \                     MT_RAMRead:
   1719          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1720            byte *pAddr;
   1721          
   1722            if ( IS_MEM_VALID( addr ) )
   \   000004   C3           CLR     C
   \   000005   EB           MOV     A,R3
   \   000006   94E0         SUBB    A,#-0x20
   \   000008   400E         JC      ??MT_RAMRead_0
   1723            {
   1724              pAddr = (byte *)addr;
   1725              *pData = *pAddr;
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   8C82         MOV     DPL,R4
   \   000011   8D83         MOV     DPH,R5
   \   000013   F0           MOVX    @DPTR,A
   1726              return ( (byte)ZSuccess );
   \   000014   7900         MOV     R1,#0x0
   \   000016   8008         SJMP    ??MT_RAMRead_1
   1727            }
   1728            else
   1729            {
   1730              *pData = 0;
   \                     ??MT_RAMRead_0:
   \   000018   E4           CLR     A
   \   000019   8C82         MOV     DPL,R4
   \   00001B   8D83         MOV     DPH,R5
   \   00001D   F0           MOVX    @DPTR,A
   1731              return ( (byte)ZFailure );
   \   00001E   7901         MOV     R1,#0x1
   \                     ??MT_RAMRead_1:
   \   000020                REQUIRE ?Subroutine23
   \   000020                ; // Fall through to label ?Subroutine23
   1732            }
   1733          }
   1734          #endif
   1735          
   1736          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
   1737          /***************************************************************************************************
   1738           * @fn      MT_RAMWrite
   1739           *
   1740           * @brief
   1741           *
   1742           *   Process Serial Message.
   1743           *
   1744           * @param   UINT16 addr - address to write at
   1745           * @param   byte val  - values to fill in the above address and the next
   1746           *
   1747           * @return  ZSuccess or ZFailure
   1748           *
   1749           * @MT SPI_CMD_SYS_RAM_WRITE
   1750           *
   1751           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1752          byte MT_RAMWrite( UINT16 addr, byte val )
   \                     MT_RAMWrite:
   1753          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1754            if ( IS_MEM_VALID( addr ) )
   \   000004   C3           CLR     C
   \   000005   EB           MOV     A,R3
   \   000006   94E0         SUBB    A,#-0x20
   \   000008   400A         JC      ??MT_RAMWrite_0
   1755            {
   1756              *((byte*)(addr)) = val;
   \   00000A   E9           MOV     A,R1
   \   00000B   8A82         MOV     DPL,R2
   \   00000D   8B83         MOV     DPH,R3
   \   00000F   F0           MOVX    @DPTR,A
   1757              return ( (byte)ZSuccess );
   \   000010   7900         MOV     R1,#0x0
   \   000012   8002         SJMP    ??MT_RAMWrite_1
   1758            }
   1759            else
   1760              return ( (byte)ZFailure );
   \                     ??MT_RAMWrite_0:
   \   000014   7901         MOV     R1,#0x1
   \                     ??MT_RAMWrite_1:
   \   000016   80..         SJMP    ?Subroutine23
   1761          }
   1762          #endif
   1763          
   1764          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
   1765          /***************************************************************************************************
   1766           * @fn      MT_SetDebugThreshold
   1767           *
   1768           * @brief
   1769           *
   1770           *   Set Debug Threshold for software components.
   1771           *
   1772           * @param   comp_id   - software component ID.
   1773           * @param   threshold - threshold value for reporting debug messages.
   1774           *
   1775           * @return  ZSuccess
   1776           *
   1777           * @MT SPI_CMD_SYS_SET_DEBUG_THRESHOLD
   1778           *
   1779           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1780          byte MT_SetDebugThreshold( byte compID, byte threshold )
   \                     MT_SetDebugThreshold:
   1781          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1782            // *** RKJ - for now if we get any threshold message, set it on
   1783            debugThreshold = threshold;
   \   000004   EA           MOV     A,R2
   \   000005   90....       MOV     DPTR,#debugThreshold
   \   000008   F0           MOVX    @DPTR,A
   1784            debugCompId = compID;
   \   000009   E9           MOV     A,R1
   \   00000A   90....       MOV     DPTR,#debugCompId
   \   00000D   F0           MOVX    @DPTR,A
   1785          
   1786            return ( (byte)ZSuccess );
   \   00000E   7900         MOV     R1,#0x0
   \   000010   80..         SJMP    ?Subroutine23
   1787          }
   1788          #endif
   1789          
   1790          /***************************************************************************************************
   1791           * @fn      MT_Reset
   1792           *
   1793           * @brief
   1794           *
   1795           *   Reset/reprogram the device.
   1796           *
   1797           * @param   typID: 0=reset, 1=serial bootloader
   1798           *
   1799           * @return  void
   1800           *
   1801           * @MT SPI_CMD_SYS_RESET
   1802           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1803          void MT_Reset( byte typID )
   \                     MT_Reset:
   1804          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   1805            if ( typID )
   \   000005   E9           MOV     A,R1
   \   000006   C2AF         CLR     0xa8.7
   \   000008   6019         JZ      ??MT_Reset_0
   1806            {
   1807              // Jump to bootloader
   1808              BootLoader();
   \   00000A   90....       MOV     DPTR,#__Constant_53544159
   \   00000D   78..         MOV     R0,#?V0 + 0
   \   00000F   12....       LCALL   ?L_MOV_X
   \   000012   90E000       MOV     DPTR,#-0x2000
   \   000015   78..         MOV     R0,#?V0 + 0
   \   000017   12....       LCALL   ?L_MOV_TO_X
   \   00001A   75C9AB       MOV     0xc9,#-0x55
   \   00001D   75C95B       MOV     0xc9,#0x5b
   \                     ??MT_Reset_1:
   \   000020   00           NOP
   \   000021   80FD         SJMP    ??MT_Reset_1
   1809            }
   1810            else
   1811            {
   1812              // Restart this program
   1813              SystemReset();
   \                     ??MT_Reset_0:
   \   000023   75C9AB       MOV     0xc9,#-0x55
   \   000026   75C95B       MOV     0xc9,#0x5b
   \                     ??MT_Reset_2:
   \   000029   00           NOP
   \   00002A   80FD         SJMP    ??MT_Reset_2
   \   00002C                REQUIRE mboxMsg
   \   00002C                REQUIRE _A_IEN0
   \   00002C                REQUIRE WDCTL
   1814            }
   1815          }
   1816          
   1817          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
   1818          /***************************************************************************************************
   1819           * @fn      MT_SendErrorNotification
   1820           *
   1821           * @brief
   1822           *
   1823           *   Send Error Notofication Message to Test Tool.
   1824           *
   1825           * @param   byte err
   1826           *
   1827           * @return  void
   1828           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1829          void MT_SendErrorNotification( byte err )
   \                     MT_SendErrorNotification:
   1830          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   12....       LCALL   ?Subroutine3 & 0xFFFF
   1831            MT_BuildAndSendZToolResponse( (SPI_0DATA_MSG_LEN + 1),
   1832                                        (SPI_RESPONSE_BIT | SPI_CMD_SYS_RAM_WRITE),
   1833                                        1, &err );
   \                     ??CrossCallReturnLabel_9:
   \   00000E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000011   7C01         MOV     R4,#0x1
   \   000013   7A02         MOV     R2,#0x2
   \   000015   02....       LJMP    ?Subroutine24 & 0xFFFF
   1834          }
   1835          #endif
   1836          
   1837          /***************************************************************************************************
   1838           * @fn      MT_ReverseBytes
   1839           *
   1840           * @brief
   1841           *
   1842           *   Reverses bytes within an array
   1843           *
   1844           * @param   data - ptr to data buffer to reverse
   1845           * @param    len - number of bytes in buffer
   1846           *
   1847           * @return  void
   1848           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1849          void MT_ReverseBytes( byte *pData, byte len )
   \                     MT_ReverseBytes:
   1850          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FC           MOV     R4,A
   1851            byte i,j;
   1852            byte temp;
   1853          
   1854            for ( i = 0, j = len-1; len > 1; len-=2 ) {
   \   000007   7D00         MOV     R5,#0x0
   \   000009   74FF         MOV     A,#-0x1
   \   00000B   2C           ADD     A,R4
   \   00000C   F5..         MOV     ?V0 + 2,A
   \   00000E   802F         SJMP    ??MT_ReverseBytes_0
   1855              temp = pData[i];
   \                     ??MT_ReverseBytes_1:
   \   000010   8D..         MOV     ?V0 + 0,R5
   \   000012   EA           MOV     A,R2
   \   000013   25..         ADD     A,?V0 + 0
   \   000015   F8           MOV     R0,A
   \   000016   EB           MOV     A,R3
   \   000017   3400         ADDC    A,#0x0
   \   000019   F9           MOV     R1,A
   \   00001A   8882         MOV     DPL,R0
   \   00001C   8983         MOV     DPH,R1
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F5..         MOV     ?V0 + 3,A
   1856              pData[i++] = pData[j];
   \   000021   85....       MOV     ?V0 + 0,?V0 + 2
   \   000024   EA           MOV     A,R2
   \   000025   25..         ADD     A,?V0 + 0
   \   000027   FE           MOV     R6,A
   \   000028   EB           MOV     A,R3
   \   000029   3400         ADDC    A,#0x0
   \   00002B   FF           MOV     R7,A
   \   00002C   8E82         MOV     DPL,R6
   \   00002E   8F83         MOV     DPH,R7
   \   000030   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000033   0D           INC     R5
   1857              pData[j--] = temp;
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   E5..         MOV     A,?V0 + 3
   \   00003A   F0           MOVX    @DPTR,A
   \   00003B   15..         DEC     ?V0 + 2
   1858            }
   \   00003D   1C           DEC     R4
   \   00003E   1C           DEC     R4
   \                     ??MT_ReverseBytes_0:
   \   00003F   EC           MOV     A,R4
   \   000040   C3           CLR     C
   \   000041   9402         SUBB    A,#0x2
   \   000043   50CB         JNC     ??MT_ReverseBytes_1
   1859          }
   \   000045   02....       LJMP    ?Subroutine29 & 0xFFFF
   1860          
   1861          /***************************************************************************************************
   1862           * @fn      MT_SendSPIRespMsg
   1863           *
   1864           * @brief
   1865           *
   1866           *   This function is used to process messages in the queue
   1867           *
   1868           * @param   none
   1869           *
   1870           * @return  void
   1871           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1872          void MT_SendSPIRespMsg( byte ret, uint16 cmd_id, byte msgLen, byte respLen)
   \                     MT_SendSPIRespMsg:
   1873          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   85..82       MOV     DPL,?XSP + 0
   \   00000E   85..83       MOV     DPH,?XSP + 1
   \   000011   F0           MOVX    @DPTR,A
   \   000012   8A..         MOV     ?V0 + 4,R2
   \   000014   8B..         MOV     ?V0 + 5,R3
   \   000016   8C..         MOV     ?V0 + 0,R4
   \   000018   8D..         MOV     ?V0 + 1,R5
   1874            byte *msgPtr;
   1875          
   1876            msgPtr = osal_mem_alloc( msgLen );
   \   00001A                ; Setup parameters for call to function osal_mem_alloc
   \   00001A   EC           MOV     A,R4
   \   00001B   12....       LCALL   ?Subroutine15 & 0xFFFF
   1877            if ( msgPtr )
   \                     ??CrossCallReturnLabel_48:
   \   00001E   7001         JNZ     ??MT_SendSPIRespMsg_0
   \   000020   EF           MOV     A,R7
   \                     ??MT_SendSPIRespMsg_0:
   \   000021   6029         JZ      ??CrossCallReturnLabel_45
   1878            {
   1879          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
   1880              MT_BuildSPIMsg( (SPI_RESPONSE_BIT | cmd_id), msgPtr, respLen, &ret );
   \   000023                ; Setup parameters for call to function MT_BuildSPIMsg
   \   000023   85..82       MOV     DPL,?XSP + 0
   \   000026   85..83       MOV     DPH,?XSP + 1
   \   000029   8582..       MOV     ?V0 + 2,DPL
   \   00002C   8583..       MOV     ?V0 + 3,DPH
   \   00002F   78..         MOV     R0,#?V0 + 2
   \   000031   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000034   A9..         MOV     R1,?V0 + 1
   \   000036   EE           MOV     A,R6
   \   000037   FC           MOV     R4,A
   \   000038   EF           MOV     A,R7
   \   000039   FD           MOV     R5,A
   \   00003A   AA..         MOV     R2,?V0 + 4
   \   00003C   7410         MOV     A,#0x10
   \   00003E   45..         ORL     A,?V0 + 5
   \   000040   FB           MOV     R3,A
   \   000041   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000044   12....       LCALL   ?DEALLOC_XSTACK8
   1881              HalUARTWrite ( SPI_MGR_DEFAULT_PORT, msgPtr, msgLen );
   \   000047                ; Setup parameters for call to function HalUARTWrite
   \   000047   AC..         MOV     R4,?V0 + 0
   \   000049   12....       LCALL   ?Subroutine13 & 0xFFFF
   1882          #endif
   1883          
   1884              osal_mem_free( msgPtr );
   1885            }
   1886          }
   \                     ??CrossCallReturnLabel_45:
   \   00004C   02....       LJMP    ?Subroutine25 & 0xFFFF

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "1.00 (F8W1.4.3)">`:
   \   000000   312E3030     DB "1.00 (F8W1.4.3)"
   \            20284638
   \            57312E34
   \            2E332900

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "1.10 (F8W1.4.3)">`:
   \   000000   312E3130     DB "1.10 (F8W1.4.3)"
   \            20284638
   \            57312E34
   \            2E332900

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for MTVersionString>`:
   \   000000   ........     DW `?<Constant "1.00 (F8W1.4.3)">`, `?<Constant "1.10 (F8W1.4.3)">`

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_3e8>`:
   \   000000   E8030000     DD 1000

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_53544159>`:
   \   000000   59415453     DD 1398030681

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_TaskInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_TaskInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_IndReset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_IndReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_ProcessEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_ProcessEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_BuildSPIMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_BuildSPIMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_BuildAndSendZToolResponse?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_BuildAndSendZToolResponse

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_BuildAndSendZToolCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_BuildAndSendZToolCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_ProcessCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_ProcessCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_ProcessDebugMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_ProcessDebugMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_ProcessDebugStr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_ProcessDebugStr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_ProcessSetNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_ProcessSetNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_ProcessGetNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_ProcessGetNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_ProcessGetNvInfo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_ProcessGetNvInfo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_ProcessGetDeviceInfo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_ProcessGetDeviceInfo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_ProcessSerialCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_ProcessSerialCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MTProcessLedControl?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MTProcessLedControl

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MTProcessAppMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MTProcessAppMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MTProcessAppRspMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MTProcessAppRspMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_RAMRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_RAMRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_RAMWrite?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_RAMWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_SetDebugThreshold?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_SetDebugThreshold

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_Reset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_Reset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_SendErrorNotification?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_SendErrorNotification

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_ReverseBytes?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_ReverseBytes

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??MT_SendSPIRespMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_SendSPIRespMsg

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "1.00 (F8W1.4.3)">`:
   \   000000                DS 16
   \   000010                REQUIRE `?<Initializer for <Constant "1.00 (F8W1.4.3)">`
   \   000010                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "1.10 (F8W1.4.3)">`:
   \   000000                DS 16
   \   000010                REQUIRE `?<Initializer for <Constant "1.10 (F8W1.4.3)">`
   \   000010                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_3e8:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_3e8>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_53544159:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_53544159>`
   \   000004                REQUIRE __INIT_XDATA_I
   1887          
   1888          #endif  // MT_TASK
   1889          
   1890          /***************************************************************************************************
   1891          ***************************************************************************************************/

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     MTProcessAppMsg                    1      0     56
       -> afFindEndPointDesc            0      0     36
       -> osal_msg_allocate             0      0     36
       -> osal_memcpy                   0      0     42
       -> osal_msg_send                 0      0     36
     MTProcessAppRspMsg                 0      0     26
       -> MT_BuildAndSendZToolResponse
                                        0      0     24
     MTProcessLedControl                2      0     35
       -> HalLedSet                     4      0      0
     MT_BuildAndSendZToolCB             1      0     19
       -> osal_msg_allocate             0      0     32
       -> osal_memcpy                   0      0     38
       -> osal_msg_send                 0      0     32
     MT_BuildAndSendZToolResponse       0      0     55
       -> osal_mem_alloc                0      0     32
       -> MT_BuildSPIMsg                0      0     36
       -> HalUARTWrite                  0      0     32
       -> osal_mem_free                 0      0     32
     MT_BuildSPIMsg                     1      0     44
       -> osal_memcpy                   0      0     34
       -> SPIMgr_CalcFCS                0      0     28
     MT_IndReset                        1      0     13
       -> MT_BuildAndSendZToolResponse
                                        0      0     26
     MT_ProcessCommand                  1      0     24
       -> MT_ProcessSerialCommand       0      0     28
       -> MT_ProcessDebugMsg            0      0     28
       -> MT_ProcessDebugStr            0      0     28
       -> SPIMgr_CalcFCS                0      0     28
       -> HalUARTWrite                  0      0     28
       -> MTProcessAppRspMsg            0      0     28
       -> osal_msg_deallocate           0      0     28
     MT_ProcessDebugMsg                 1      0     41
       -> osal_msg_allocate             0      0     50
       -> MT_BuildSPIMsg                0      0     54
       -> HalUARTWrite                  0      0     50
       -> osal_msg_deallocate           0      0     50
     MT_ProcessDebugStr                 0      0     28
       -> osal_mem_alloc                0      0     24
       -> MT_BuildSPIMsg                0      0     28
       -> HalUARTWrite                  0      0     24
       -> osal_mem_free                 0      0     24
     MT_ProcessEvent                    0      0     10
       -> MT_SendErrorNotification      0      0     20
       -> MT_ProcessCommand             0      0     20
       -> osal_msg_receive              0      0     20
     MT_ProcessGetDeviceInfo            1      0     54
       -> osal_mem_alloc                0      0     30
       -> osal_nv_read                  0      0     38
       -> MT_ReverseBytes               0      0     30
       -> NLME_GetShortAddr             0      0     30
       -> AssocMakeList                 0      0     30
       -> osal_memset                   0      0     30
       -> osal_mem_free                 0      0     30
       -> MT_BuildAndSendZToolResponse
                                        0      0     34
       -> osal_mem_free                 0      0     30
     MT_ProcessGetNV                    1      0     55
       -> osal_nv_item_len              0      0     32
       -> osal_mem_alloc                0      0     32
       -> osal_memset                   0      0     32
       -> osal_nv_read                  0      0     40
       -> MT_BuildAndSendZToolResponse
                                        0      0     36
       -> osal_mem_free                 0      0     32
     MT_ProcessGetNvInfo                1      0     61
       -> osal_mem_alloc                0      0     44
       -> osal_memset                   0      0     44
       -> osal_nv_read                  0      0     52
       -> MT_ReverseBytes               0      0     44
       -> osal_nv_read                  0      0     52
       -> osal_nv_read                  0      0     52
       -> osal_nv_read                  0      0     52
       -> osal_nv_read                  0      0     52
       -> MT_BuildAndSendZToolResponse
                                        0      0     48
       -> osal_mem_free                 0      0     44
     MT_ProcessSerialCommand            1      0     53
       -> MT_RAMRead                    0      0     70
       -> MT_RAMWrite                   0      0     70
       -> MT_Reset                      0      0     70
       -> NLME_GetProtocolVersion       0      0     70
       -> osal_strlen                   0      0     70
       -> MT_BuildAndSendZToolResponse
                                        0      0     74
       -> MT_ReverseBytes               0      0     70
       -> ZMacSetReq                    0      0     70
       -> osal_nv_write                 0      0     78
       -> ZMacGetReq                    0      0     70
       -> MT_ReverseBytes               0      0     70
       -> osal_nv_item_len              0      0     74
       -> osal_nv_write                 0      0     78
       -> osal_nv_item_len              0      0     74
       -> osal_nv_write                 0      0     78
       -> osal_nv_item_len              0      0     74
       -> osal_nv_write                 0      0     78
       -> osal_nv_item_len              0      0     74
       -> osal_nv_write                 0      0     78
       -> MT_ProcessGetNvInfo           0      0     70
       -> MT_ProcessGetDeviceInfo       0      0     70
       -> MT_ProcessSetNV               0      0     70
       -> MT_ProcessGetNV               0      0     70
       -> osal_GetSystemClock           0      0     70
       -> OnBoard_SendKeys              0      0     70
       -> MTProcessAppMsg               0      0     70
       -> MTProcessLedControl           0      0     70
     MT_ProcessSetNV                    0      0     49
       -> osal_nv_item_len              0      0     24
       -> osal_nv_write                 0      0     28
     MT_RAMRead                         3      0     35
     MT_RAMWrite                        3      0     35
     MT_Reset                           0      0     47
     MT_ReverseBytes                    1      0     47
     MT_SendErrorNotification           1      0     23
       -> MT_BuildAndSendZToolResponse
                                        0      0     26
     MT_SendSPIRespMsg                  1      0     17
       -> osal_mem_alloc                0      0     30
       -> MT_BuildSPIMsg                0      0     34
       -> HalUARTWrite                  0      0     30
       -> osal_mem_free                 0      0     30
     MT_SetDebugThreshold               2      0      0
     MT_TaskInit                        2      0      0
       -> SPIMgr_Init                   4      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _A_IEN0                           1
     WDCTL                             1
     mboxMsg                           8
     MTVersionString                   4
     MT_TaskID                         1
     debugThreshold                    1
     debugCompId                       1
     save_cmd                          2
     longvar                           4
     temp_glob_ptr1                    2
     temp_glob_ptr2                    2
     MT_TaskInit                      24
     ?Subroutine23                     7
     MT_IndReset                      24
     ?Subroutine24                    16
     ?Subroutine2                     10
     ?Subroutine3                     16
     MT_ProcessEvent                  68
     MT_BuildSPIMsg                  124
     ?Subroutine25                    10
     MT_BuildAndSendZToolResponse     74
     ?Subroutine26                     8
     ?Subroutine13                    19
     ?Subroutine16                     6
     MT_BuildAndSendZToolCB          126
     ?Subroutine14                     8
     ?Subroutine28                     6
     MT_ProcessCommand               170
     ?Subroutine8                     12
     MT_ProcessDebugMsg              298
     ?Subroutine1                     23
     ?Subroutine22                    10
     ?Subroutine4                      9
     ?Subroutine11                     4
     ?Subroutine21                     7
     MT_ProcessDebugStr               91
     ?Subroutine29                     5
     ?Subroutine15                    16
     MT_ProcessSetNV                  49
     ?Subroutine12                    12
     MT_ProcessGetNV                 144
     ?Subroutine18                    14
     MT_ProcessGetNvInfo             439
     ?Subroutine19                    22
     ?Subroutine17                     8
     ?Subroutine5                      9
     MT_ProcessGetDeviceInfo         213
     ?Subroutine0                     16
     MT_ProcessSerialCommand        1011
     ?Subroutine10                     5
     ?Subroutine20                    16
     ?Subroutine6                     11
     ?Subroutine27                     8
     ?Subroutine9                     11
     ?Subroutine7                     11
     MTProcessLedControl             116
     MTProcessAppMsg                 187
     MTProcessAppRspMsg               30
     MT_RAMRead                       32
     MT_RAMWrite                      24
     MT_SetDebugThreshold             18
     MT_Reset                         44
     MT_SendErrorNotification         24
     MT_ReverseBytes                  72
     MT_SendSPIRespMsg                79
     ?<Initializer for <Constant "1.00 (F8W1.4.3)">
                                      16
     ?<Initializer for <Constant "1.10 (F8W1.4.3)">
                                      16
     ?<Initializer for MTVersionString>
                                       4
     ?<Initializer for __Constant_3e8>
                                       4
     ?<Initializer for __Constant_53544159>
                                       4
     ??MT_TaskInit?relay               6
     ??MT_IndReset?relay               6
     ??MT_ProcessEvent?relay           6
     ??MT_BuildSPIMsg?relay            6
     ??MT_BuildAndSendZToolResponse?relay
                                       6
     ??MT_BuildAndSendZToolCB?relay    6
     ??MT_ProcessCommand?relay         6
     ??MT_ProcessDebugMsg?relay        6
     ??MT_ProcessDebugStr?relay        6
     ??MT_ProcessSetNV?relay           6
     ??MT_ProcessGetNV?relay           6
     ??MT_ProcessGetNvInfo?relay       6
     ??MT_ProcessGetDeviceInfo?relay
                                       6
     ??MT_ProcessSerialCommand?relay
                                       6
     ??MTProcessLedControl?relay       6
     ??MTProcessAppMsg?relay           6
     ??MTProcessAppRspMsg?relay        6
     ??MT_RAMRead?relay                6
     ??MT_RAMWrite?relay               6
     ??MT_SetDebugThreshold?relay      6
     ??MT_Reset?relay                  6
     ??MT_SendErrorNotification?relay
                                       6
     ??MT_ReverseBytes?relay           6
     ??MT_SendSPIRespMsg?relay         6
     ?<Constant "1.00 (F8W1.4.3)">    16
     ?<Constant "1.10 (F8W1.4.3)">    16
     __Constant_3e8                    4
     __Constant_53544159               4

 
 3 816 bytes in segment BANKED_CODE
   144 bytes in segment BANK_RELAYS
     2 bytes in segment SFR_AN
     8 bytes in segment XDATA_AN
    44 bytes in segment XDATA_I
    44 bytes in segment XDATA_ID
    13 bytes in segment XDATA_Z
 
 3 996 bytes of CODE  memory (+  8 bytes shared)
     0 bytes of DATA  memory (+  2 bytes shared)
    49 bytes of XDATA memory (+ 16 bytes shared)

Errors: none
Warnings: none

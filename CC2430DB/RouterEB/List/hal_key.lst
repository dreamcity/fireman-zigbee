###############################################################################
#                                                                             #
# IAR 8051 C/C++ Compiler V7.30B/W32                    03/Jan/2013  17:11:00 #
# Copyright 2004-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components #
#                          \hal\target\CC2430EB\hal_key.c                     #
#    Command line       =  -f "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\..\..\..\Tools\C #
#                          C2430DB\f8wRouter.cfg" (-DCPU32MHZ                 #
#                          -DFORCE_MAC_NEAR -DROOT=__near_func                #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE -DRTR_NWK         #
#                          -DBLINK_LEDS "-DCONST=const __code"                #
#                          -DGENERIC=__generic) -f "C:\Texas                  #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wCo #
#                          nfig.cfg" (-DSECURE=0 -DDEFAULT_CHANLIST=0x0000080 #
#                          0 -DZDAPP_CONFIG_PAN_ID=0xFFFF                     #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3   #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=5 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-1.4.3-1.2.1\Components\hal\targ #
#                          et\CC2430EB\hal_key.c" -D CC2430EB -D AXD_ROUTER   #
#                          -D REFLECTOR -D ZTOOL_P1 -D MT_TASK -D             #
#                          xMT_ZDO_FUNC -D xLCD_SUPPORTED=DEBUG -lC           #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\RouterEB\List\"     #
#                          -lA "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Proje #
#                          cts\zstack\Samples\AXDApp\CC2430DB\RouterEB\List\" #
#                           --diag_suppress Pe001,Pa010 --diag_remark pe550   #
#                          -o "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projec #
#                          ts\zstack\Samples\AXDApp\CC2430DB\RouterEB\Obj\"   #
#                          -e --require_prototypes -z9 --no_code_motion       #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\SOURCE\" -I "C:\Texas      #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\Drivers\" -I "C:\Texas     #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\ZMAIN\TI2430DB\" -I  #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MT\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\HAL #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\HAL\TARGET\CC2430EB\" -I      #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas               #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\OSA #
#                          L\INCLUDE\" -I "C:\Texas                           #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\AF\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2. #
#                          1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\.. #
#                          \..\..\COMPONENTS\STACK\NWK\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\SEC\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\STACK\SYS\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\STA #
#                          CK\ZDO\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2 #
#                          .1\Projects\zstack\Samples\AXDApp\CC2430DB\..\..\. #
#                          .\..\..\COMPONENTS\ZMAC\F8W\" -I "C:\Texas         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\ZMA #
#                          C\" -I "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Pr #
#                          ojects\zstack\Samples\AXDApp\CC2430DB\..\..\..\..\ #
#                          ..\COMPONENTS\SERVICES\SADDR\" -I "C:\Texas        #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\SER #
#                          VICES\SDATA\" -I "C:\Texas                         #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \INCLUDE\" -I "C:\Texas Instruments\ZStack-1.4.3-1 #
#                          .2.1\Projects\zstack\Samples\AXDApp\CC2430DB\..\.. #
#                          \..\..\..\COMPONENTS\MAC\HIGH_LEVEL\" -I           #
#                          "C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\ #
#                          zstack\Samples\AXDApp\CC2430DB\..\..\..\..\..\COMP #
#                          ONENTS\MAC\LOW_LEVEL\SRF03\" -I "C:\Texas          #
#                          Instruments\ZStack-1.4.3-1.2.1\Projects\zstack\Sam #
#                          ples\AXDApp\CC2430DB\..\..\..\..\..\COMPONENTS\MAC #
#                          \LOW_LEVEL\SRF03\SINGLE_CHIP\" -I "C:\Program      #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\" -I "C:\Program       #
#                          Files\IAR Systems\Embedded Workbench 4.0           #
#                          Evaluation version\8051\INC\CLIB\"                 #
#    List file          =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\RouterEB\List\hal_ke #
#                          y.lst                                              #
#    Object file        =  C:\Texas Instruments\ZStack-1.4.3-1.2.1\Projects\z #
#                          stack\Samples\AXDApp\CC2430DB\RouterEB\Obj\hal_key #
#                          .r51                                               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-1.4.3-1.2.1\Components\hal\target\CC2430EB\hal_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2007-11-07 11:54:17 -0800 (Wed, 07 Nov 2007) $
      4            Revision:       $Revision: 15885 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 state of the previous poll and will only return a non-zero
     44                 value if the key state changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key state is not remembered.  This
     52                 means that KeyRead() will return the current state of the keys
     53                 (not a change in state of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high state to a low state.  This transition is typically clean.  The
     62                 duration of the low state is around 200ms.  When the signal returns
     63                 to the high state, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81           *                                            INCLUDES
     82           **************************************************************************************************/
     83          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x89
   \   unsigned char volatile __sfr P0IFG
   \                     P0IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8c
   \   unsigned char volatile __sfr PICTL
   \                     PICTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1
     84          #include "hal_defs.h"
     85          #include "hal_types.h"
     86          #include "hal_drivers.h"
     87          #include "hal_adc.h"
     88          #include "hal_key.h"
     89          #include "osal.h"
     90          
     91          /**************************************************************************************************
     92           *                                              MACROS
     93           **************************************************************************************************/
     94          
     95          /**************************************************************************************************
     96           *                                            CONSTANTS
     97           **************************************************************************************************/
     98          #define HAL_KEY_BIT0   0x01
     99          #define HAL_KEY_BIT1   0x02
    100          #define HAL_KEY_BIT2   0x04
    101          #define HAL_KEY_BIT3   0x08
    102          #define HAL_KEY_BIT4   0x10
    103          #define HAL_KEY_BIT5   0x20
    104          #define HAL_KEY_BIT6   0x40
    105          #define HAL_KEY_BIT7   0x80
    106          
    107          #define HAL_KEY_RISING_EDGE   0
    108          #define HAL_KEY_FALLING_EDGE  1
    109          
    110          #define HAL_KEY_PDUP2           0x80
    111          #define HAL_KEY_PDUP1           0x40
    112          #define HAL_KEY_PDUP0           0x20
    113          
    114          #define HAL_KEY_DEBOUNCE_VALUE  25
    115          #define HAL_KEY_POLLING_VALUE   100
    116          
    117          
    118          #if defined (HAL_BOARD_CC2430DB)
    119            #define HAL_KEY_SW_6_ENABLE
    120            #define HAL_KEY_SW_6_PORT     P0                      /* Port location of SW1 */
    121            #define HAL_KEY_SW_6_BIT      HAL_KEY_BIT1            /* Bit location of SW1 */
    122            #define HAL_KEY_SW_6_SEL      P0SEL                   /* Port Select Register for SW1 */
    123            #define HAL_KEY_SW_6_DIR      P0DIR                   /* Port Direction Register for SW1 */
    124            #define HAL_KEY_SW_6_IEN      IEN1                    /* Interrupt Enable Register for SW1 */
    125            #define HAL_KEY_SW_6_IENBIT   HAL_KEY_BIT5            /* Interrupt Enable bit for SW1 */
    126            #define HAL_KEY_SW_6_EDGE     HAL_KEY_RISING_EDGE     /* Type of interrupt for SW1 */
    127            #define HAL_KEY_SW_6_EDGEBIT  HAL_KEY_BIT0            /* EdgeType enable bit SW1 */
    128            #define HAL_KEY_SW_6_ICTL     PICTL                   /* Port Interrupt Control for SW1 */
    129            #define HAL_KEY_SW_6_ICTLBIT  HAL_KEY_BIT3            /* Interrupt enable bit for SW1 */
    130            #define HAL_KEY_SW_6_PXIFG    P0IFG                   /* Port Interrupt Flag for SW1 */
    131          
    132            #define HAL_KEY_JOYSTICK_ENABLE
    133            #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    134          
    135            #define HAL_KEY_SW_5_ENABLE   /* 2430DB - SW5 is enabled based on key interrupt enable or not - see config */
    136            #define HAL_KEY_SW_5_PORT     P2                      /* Port location of SW5 */
    137            #define HAL_KEY_SW_5_BIT      HAL_KEY_BIT0            /* Bit location of SW5 */
    138            #define HAL_KEY_SW_5_SEL      P2SEL                   /* Port Select Register for SW5 */
    139            #define HAL_KEY_SW_5_DIR      P2DIR                   /* Port Direction Register for SW5 */
    140            #define HAL_KEY_SW_5_INP      P2INP                   /* Port Input Mode Register for SW5 */
    141            #define HAL_KEY_SW_5_IEN      IEN2                    /* Interrupt Enable Register for SW5 */
    142            #define HAL_KEY_SW_5_IENBIT   HAL_KEY_BIT1            /* Interrupt Enable bit for SW5 */
    143            #define HAL_KEY_SW_5_EDGE     HAL_KEY_FALLING_EDGE    /* Type of interrupt for SW5 */
    144            #define HAL_KEY_SW_5_EDGEBIT  HAL_KEY_BIT2            /* EdgeType enable bit SW5 */
    145            #define HAL_KEY_SW_5_ICTL     PICTL                   /* Port Interrupt Control for SW5 */
    146            #define HAL_KEY_SW_5_ICTLBIT  HAL_KEY_BIT5            /* Interrupt enable bit for SW5 */
    147            #define HAL_KEY_SW_5_PXIFG    P2IFG                   /* Port Interrupt Flag for SW5 */
    148          
    149            #define HAL_KEY_P0INT_LOW_USED    HAL_KEY_SW_6_BIT    /* P0 can only be enabled/disabled as group of high or low nibble */
    150            #define HAL_KEY_POINT_HIGH_USED   0                   /* P0 can only be enabled/disabled as group of high or low nibble */
    151          #endif
    152          
    153          #if defined (HAL_BOARD_CC2430EB) || defined (HAL_BOARD_CC2430BB)
    154            #define HAL_KEY_SW_6_ENABLE
    155            #define HAL_KEY_SW_6_PORT     P0                      /* Port location of SW1 */
    156            #define HAL_KEY_SW_6_BIT      HAL_KEY_BIT1            /* Bit location of SW1 */
    157            #define HAL_KEY_SW_6_SEL      P0SEL                   /* Port Select Register for SW1 */
    158            #define HAL_KEY_SW_6_DIR      P0DIR                   /* Port Direction Register for SW1 */
    159            #define HAL_KEY_SW_6_IEN      IEN1                    /* Interrupt Enable Register for SW1 */
    160            #define HAL_KEY_SW_6_IENBIT   HAL_KEY_BIT5            /* Interrupt Enable bit for SW1 */
    161            #define HAL_KEY_SW_6_EDGE     HAL_KEY_RISING_EDGE     /* Type of interrupt for SW1 */
    162            #define HAL_KEY_SW_6_EDGEBIT  HAL_KEY_BIT0            /* EdgeType enable bit SW1 */
    163            #define HAL_KEY_SW_6_ICTL     PICTL                   /* Port Interrupt Control for SW1 */
    164            #define HAL_KEY_SW_6_ICTLBIT  HAL_KEY_BIT3            /* Interrupt enable bit for SW1 */
    165            #define HAL_KEY_SW_6_PXIFG    P0IFG                   /* Port Interrupt Flag for SW1 */
    166          
    167            #define HAL_KEY_P0INT_LOW_USED    HAL_KEY_SW_6_BIT    /* P0 can only be enabled/disabled as group of high or low nibble */
    168          #endif
    169          
    170          #if defined (HAL_BOARD_CC2430BB)
    171            #define HAL_KEY_POINT_HIGH_USED  0
    172          #endif
    173          
    174          #if defined (HAL_BOARD_CC2430EB)
    175            #define HAL_KEY_JOYSTICK_ENABLE
    176            #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    177          
    178            #define HAL_KEY_SW_5_ENABLE
    179            #define HAL_KEY_SW_5_PORT     P0                      /* Port location of SW5 */
    180            #define HAL_KEY_SW_5_BIT      HAL_KEY_BIT5            /* Bit location of SW5 */
    181            #define HAL_KEY_SW_5_SEL      P0SEL                   /* Port Select Register for SW5 */
    182            #define HAL_KEY_SW_5_DIR      P0DIR                   /* Port Direction Register for SW5 */
    183            #define HAL_KEY_SW_5_INP      P0INP                   /* Port Input Mode Register for SW5 */
    184            #define HAL_KEY_SW_5_IEN      IEN1                    /* Interrupt Enable Register for SW5 */
    185            #define HAL_KEY_SW_5_IENBIT   HAL_KEY_BIT5            /* Interrupt Enable bit for SW5 */
    186            #define HAL_KEY_SW_5_EDGE     HAL_KEY_RISING_EDGE     /* Type of interrupt for SW5 */
    187            #define HAL_KEY_SW_5_EDGEBIT  HAL_KEY_BIT2            /* EdgeType enable bit SW5 */
    188            #define HAL_KEY_SW_5_ICTL     PICTL                   /* Port Interrupt Control for SW5 */
    189            #define HAL_KEY_SW_5_ICTLBIT  HAL_KEY_BIT4            /* Interrupt enable bit for SW5 */
    190            #define HAL_KEY_SW_5_PXIFG    P0IFG                   /* Port Interrupt Flag for SW5 */
    191          
    192            #define HAL_KEY_POINT_HIGH_USED   HAL_KEY_SW_5_BIT    /* P0 can only be enabled/disabled as group of high or low nibble */
    193          #endif
    194          
    195          /**************************************************************************************************
    196           *                                            TYPEDEFS
    197           **************************************************************************************************/
    198          
    199          
    200          /**************************************************************************************************
    201           *                                        GLOBAL VARIABLES
    202           **************************************************************************************************/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    203          static uint8 halKeySavedKeys;     /* used to store previous key state in polling mode */
   \                     halKeySavedKeys:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    204          static halKeyCBack_t pHalKeyProcessFunction;
   \                     pHalKeyProcessFunction:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    205          bool Hal_KeyIntEnable;            /* interrupt enable/disable flag */
   \                     Hal_KeyIntEnable:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    206          uint8 halSaveIntKey;              /* used by ISR to save state of interrupt-driven keys */
   \                     halSaveIntKey:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    207          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    208          static uint8 HalKeyConfigured;
   \                     HalKeyConfigured:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    209          
    210          /**************************************************************************************************
    211           *                                        FUNCTIONS - Local
    212           **************************************************************************************************/
    213          void halProcessKeyInterrupt (void);
    214          
    215          
    216          /**************************************************************************************************
    217           *                                        FUNCTIONS - API
    218           **************************************************************************************************/
    219          /**************************************************************************************************
    220           * @fn      HalKeyInit
    221           *
    222           * @brief   Initilize Key Service
    223           *
    224           * @param   none
    225           *
    226           * @return  None
    227           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    228          void HalKeyInit( void )
   \                     HalKeyInit:
    229          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    230          #if (HAL_KEY == TRUE)
    231            /* Initialize previous key to 0 */
    232            halKeySavedKeys = 0;
   \   000004   E4           CLR     A
   \   000005   90....       MOV     DPTR,#halKeySavedKeys
   \   000008   F0           MOVX    @DPTR,A
    233          
    234          #if defined (HAL_KEY_SW_6_ENABLE)
    235            HAL_KEY_SW_6_SEL &= ~(HAL_KEY_SW_6_BIT);    /* Set pin function to GPIO */
   \   000009   53F3FD       ANL     0xf3,#0xfd
    236            HAL_KEY_SW_6_DIR &= ~(HAL_KEY_SW_6_BIT);    /* Set pin direction to Input */
   \   00000C   53FDFD       ANL     0xfd,#0xfd
    237          #endif
    238          
    239          #if defined (HAL_KEY_SW_5_ENABLE)
    240            HAL_KEY_SW_5_SEL &= ~(HAL_KEY_SW_5_BIT);    /* Set pin function to GPIO */
   \   00000F   53F3DF       ANL     0xf3,#0xdf
    241            HAL_KEY_SW_5_DIR &= ~(HAL_KEY_SW_5_BIT);    /* Set pin direction to Input */
   \   000012   53FDDF       ANL     0xfd,#0xdf
    242            HAL_KEY_SW_5_INP |= HAL_KEY_SW_5_BIT;       /* Set pin input mode to tri-state */
   \   000015   438F20       ORL     0x8f,#0x20
    243          #endif
    244          
    245            /* Initialize callback function */
    246            pHalKeyProcessFunction  = NULL;
   \   000018   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   F0           MOVX    @DPTR,A
    247          
    248            /* Start with key is not configured */
    249            HalKeyConfigured = FALSE;
   \   00001E   02....       LJMP    ?Subroutine2 & 0xFFFF
   \   000021                REQUIRE P0INP
   \   000021                REQUIRE P0SEL
   \   000021                REQUIRE P0DIR
    250          #endif /* HAL_KEY */
    251          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   90....       MOV     DPTR,#HalKeyConfigured
   \   000003   F0           MOVX    @DPTR,A
   \                     ??Subroutine2_0:
   \   000004   D083         POP     DPH
   \   000006   D082         POP     DPL
   \   000008   02....       LJMP    ?BRET
    252          
    253          /**************************************************************************************************
    254           * @fn      HalKeyConfig
    255           *
    256           * @brief   Configure the Key serivce
    257           *
    258           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    259           *          cback - pointer to the CallBack function
    260           *
    261           * @return  None
    262           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    263          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
   \                     HalKeyConfig:
    264          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    265          #if (HAL_KEY == TRUE)
    266            /* Enable/Disable Interrupt or */
    267            Hal_KeyIntEnable = interruptEnable;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000008   F0           MOVX    @DPTR,A
    268          
    269            /* Register the callback fucntion */
    270            pHalKeyProcessFunction = cback;
   \   000009   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00000C   EA           MOV     A,R2
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   A3           INC     DPTR
   \   00000F   EB           MOV     A,R3
   \   000010   F0           MOVX    @DPTR,A
    271          
    272            /* Determine if interrupt is enable or not */
    273            if (Hal_KeyIntEnable)
   \   000011   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000014   E0           MOVX    A,@DPTR
   \   000015   602C         JZ      ??HalKeyConfig_0
    274            {
    275          
    276              /*
    277                 Work around for CC2430DB when interrupt is enabled and SW5 (center joystick)
    278                 is used. This SW5 uses P2 which also has debug lines connected to it. This
    279                 causes contant interruption on P2INT_VECTOR. Disable the usage of P2 interrupt
    280                 will stop this problem.
    281              */
    282              #if defined (HAL_BOARD_CC2430DB)
    283                #undef HAL_KEY_SW_5_ENABLE                      /* Dis-allow SW5 when key interrupt is enable */
    284              #endif
    285          
    286          #if defined (HAL_KEY_SW_5_ENABLE)
    287              PICTL &= ~(HAL_KEY_SW_5_EDGEBIT);                 /* Set rising or falling edge */
   \   000017   538CFB       ANL     0x8c,#0xfb
    288            #if (HAL_KEY_SW_5_EDGE == HAL_KEY_FALLING_EDGE)
    289              PICTL |= HAL_KEY_SW_5_EDGEBIT;
    290            #endif
    291              HAL_KEY_SW_5_ICTL |= HAL_KEY_SW_5_ICTLBIT;        /* Set interrupt enable bit */
   \   00001A   438C10       ORL     0x8c,#0x10
    292              HAL_KEY_SW_5_IEN |= HAL_KEY_SW_5_IENBIT;
   \   00001D   D2BD         SETB    0xb8.5
    293              HAL_KEY_SW_5_PXIFG = ~(HAL_KEY_SW_5_BIT);        /* Clear any pending interrupts */
   \   00001F   7589DF       MOV     0x89,#-0x21
    294          #endif
    295          
    296          #if defined (HAL_KEY_SW_6_ENABLE)
    297              PICTL &= ~(HAL_KEY_SW_6_EDGEBIT);                 /* Set rising or falling edge */
   \   000022   538CFE       ANL     0x8c,#0xfe
    298            #if (HAL_KEY_SW_6_EDGE == HAL_KEY_FALLING_EDGE)
    299              PICTL |= HAL_KEY_SW_6_EDGEBIT;
    300            #endif
    301              HAL_KEY_SW_6_ICTL |= HAL_KEY_SW_6_ICTLBIT;        /* Set interrupt enable bit */
   \   000025   438C08       ORL     0x8c,#0x8
    302              HAL_KEY_SW_6_IEN |= HAL_KEY_SW_6_IENBIT;
   \   000028   D2BD         SETB    0xb8.5
    303              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT);        /* Clear any pending interrupts */
   \   00002A   7589FD       MOV     0x89,#-0x3
    304          #endif
    305          
    306              /* Do this only after the hal_key is configured - to work with sleep stuff */
    307              if (HalKeyConfigured == TRUE)
   \   00002D   90....       MOV     DPTR,#HalKeyConfigured
   \   000030   E0           MOVX    A,@DPTR
   \   000031   6401         XRL     A,#0x1
   \   000033   7028         JNZ     ??HalKeyConfig_1
    308              {
    309                osal_stop_timerEx( Hal_TaskID, HAL_KEY_EVENT);  /* Cancel polling if active */
   \   000035                ; Setup parameters for call to function osal_stop_timerEx
   \   000035   7A01         MOV     R2,#0x1
   \   000037   7B00         MOV     R3,#0x0
   \   000039   90....       MOV     DPTR,#Hal_TaskID
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F9           MOV     R1,A
   \   00003E   12....       LCALL   ??osal_stop_timerEx?relay
   \   000041   801A         SJMP    ??HalKeyConfig_1
    310              }
    311            }
    312            else    /* Interrupts NOT enabled */
    313            {
    314          
    315              /*
    316                 Work around for CC2430DB when interrupt is enabled and SW5 (center joystick)
    317                 is used. This SW5 uses P2 which also has debug lines connected to it. This
    318                 causes contant interruption on P2INT_VECTOR. Disable the usage of P2 interrupt
    319                 will stop this problem.
    320              */
    321              #if defined (HAL_BOARD_CC2430DB)
    322                #define HAL_KEY_SW_5_ENABLE                     /* Allow SW5 only when key interrupt is disable */
    323              #endif
    324          
    325          #if defined (HAL_KEY_SW_6_ENABLE)
    326              HAL_KEY_SW_6_ICTL &= ~(HAL_KEY_SW_6_ICTLBIT);     /* Clear interrupt enable bit */
   \                     ??HalKeyConfig_0:
   \   000043   538CF7       ANL     0x8c,#0xf7
    327              HAL_KEY_SW_6_IEN &= ~(HAL_KEY_SW_6_IENBIT);
   \   000046   C2BD         CLR     0xb8.5
    328          #endif
    329          
    330          #if defined (HAL_KEY_SW_5_ENABLE)
    331              HAL_KEY_SW_5_ICTL &= ~(HAL_KEY_SW_5_ICTLBIT);     /* Clear interrupt enable bit */
   \   000048   538CEF       ANL     0x8c,#0xef
    332              HAL_KEY_SW_5_IEN &= ~(HAL_KEY_SW_5_IENBIT);
   \   00004B   C2BD         CLR     0xb8.5
    333          #endif
    334              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_POLLING_VALUE);    /* Kick off polling */
   \   00004D                ; Setup parameters for call to function osal_start_timerEx
   \   00004D   7C64         MOV     R4,#0x64
   \   00004F   7D00         MOV     R5,#0x0
   \   000051   7A01         MOV     R2,#0x1
   \   000053   7B00         MOV     R3,#0x0
   \   000055   90....       MOV     DPTR,#Hal_TaskID
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F9           MOV     R1,A
   \   00005A   12....       LCALL   ??osal_start_timerEx?relay
    335            }
    336          
    337            /* Key now is configured */
    338            HalKeyConfigured = TRUE;
   \                     ??HalKeyConfig_1:
   \   00005D   7401         MOV     A,#0x1
   \   00005F   02....       LJMP    ?Subroutine2 & 0xFFFF
   \   000062                REQUIRE P0IFG
   \   000062                REQUIRE PICTL
   \   000062                REQUIRE _A_IEN1
    339          #endif /* HAL_KEY */
    340          }
    341          
    342          /**************************************************************************************************
    343           * @fn      HalKeyRead
    344           *
    345           * @brief   Read the current value of a key
    346           *
    347           * @param   None
    348           *
    349           * @return  keys - current keys status
    350           **************************************************************************************************/
    351          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    352          uint8 HalKeyRead ( void )
   \                     HalKeyRead:
    353          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    354          
    355            uint8 keys = 0;
   \   000005   7E00         MOV     R6,#0x0
    356          
    357          #if (HAL_KEY == TRUE)
    358          
    359          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    360            uint8 ksave0 = 0;
   \   000007   7F00         MOV     R7,#0x0
    361            uint8 ksave1;
    362            uint8 adc;
    363          #endif
    364          
    365          #if defined (HAL_KEY_SW_6_ENABLE)
    366            if (!(HAL_KEY_SW_6_PORT & HAL_KEY_SW_6_BIT))    /* Key is active low */
   \   000009   A281         MOV     C,0x80.1
   \   00000B   4002         JC      ??HalKeyRead_0
    367            {
    368              keys |= HAL_KEY_SW_6;
   \   00000D   7E20         MOV     R6,#0x20
    369            }
    370          #endif
    371          #if defined (HAL_KEY_SW_5_ENABLE)
    372            if (HAL_KEY_SW_5_PORT & HAL_KEY_SW_5_BIT)       /* Key is active high */
   \                     ??HalKeyRead_0:
   \   00000F   A285         MOV     C,0x80.5
   \   000011   5004         JNC     ??HalKeyRead_1
    373            {
    374              keys |= HAL_KEY_SW_5;
   \   000013   EE           MOV     A,R6
   \   000014   D2E2         SETB    0xE0 /* A   */.2
   \   000016   FE           MOV     R6,A
    375            }
    376          #endif
    377          
    378          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    379          /*
    380          *  The joystick control is encoded as an analog voltage.  Keep on reading
    381          *  the ADC until two consecutive key decisions are the same.
    382          */
    383          
    384            do
    385            {
    386              ksave1 = ksave0;    /* save previouse key reading */
   \                     ??HalKeyRead_1:
   \   000017   8F..         MOV     ?V0 + 0,R7
    387          
    388              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
   \   000019                ; Setup parameters for call to function HalAdcRead
   \   000019   12....       LCALL   ?Subroutine0 & 0xFFFF
    389          
    390              if  (CHVER == 0x01)
   \                     ??CrossCallReturnLabel_0:
   \   00001C   703D         JNZ     ??HalKeyRead_2
    391              {
    392                /* Rev B */
    393                if ((adc >= 90) && (adc <= 100))
   \   00001E   EA           MOV     A,R2
   \   00001F   C3           CLR     C
   \   000020   945A         SUBB    A,#0x5a
   \   000022   EA           MOV     A,R2
   \   000023   400B         JC      ??HalKeyRead_3
   \   000025   C3           CLR     C
   \   000026   9465         SUBB    A,#0x65
   \   000028   5050         JNC     ??HalKeyRead_4
    394                {
    395                   ksave0 |= HAL_KEY_UP;
   \                     ??HalKeyRead_5:
   \   00002A   EF           MOV     A,R7
   \   00002B   D2E0         SETB    0xE0 /* A   */.0
   \                     ??HalKeyRead_6:
   \   00002D   FF           MOV     R7,A
   \   00002E   804A         SJMP    ??HalKeyRead_4
    396                }
    397                else if ((adc >= 75) && (adc <= 85))
   \                     ??HalKeyRead_3:
   \   000030   C3           CLR     C
   \   000031   944B         SUBB    A,#0x4b
   \   000033   EA           MOV     A,R2
   \   000034   400A         JC      ??HalKeyRead_7
   \   000036   C3           CLR     C
   \   000037   9456         SUBB    A,#0x56
   \   000039   503F         JNC     ??HalKeyRead_4
    398                {
    399                  ksave0 |= HAL_KEY_RIGHT;
   \                     ??HalKeyRead_8:
   \   00003B   EF           MOV     A,R7
   \   00003C   D2E1         SETB    0xE0 /* A   */.1
   \   00003E   80ED         SJMP    ??HalKeyRead_6
    400                }
    401                else if ((adc >= 45) && (adc <= 55))
   \                     ??HalKeyRead_7:
   \   000040   C3           CLR     C
   \   000041   942D         SUBB    A,#0x2d
   \   000043   400B         JC      ??HalKeyRead_9
   \   000045   EA           MOV     A,R2
   \   000046   C3           CLR     C
   \   000047   9438         SUBB    A,#0x38
   \   000049   502F         JNC     ??HalKeyRead_4
    402                {
    403                  ksave0 |= HAL_KEY_LEFT;
   \                     ??HalKeyRead_10:
   \   00004B   EF           MOV     A,R7
   \   00004C   D2E3         SETB    0xE0 /* A   */.3
   \   00004E   80DD         SJMP    ??HalKeyRead_6
    404                }
    405                else if (adc <= 10)
   \                     ??HalKeyRead_9:
   \   000050   EA           MOV     A,R2
   \   000051   C3           CLR     C
   \   000052   940B         SUBB    A,#0xb
   \   000054   5024         JNC     ??HalKeyRead_4
    406                {
    407                  ksave0 |= HAL_KEY_DOWN;
   \   000056   EF           MOV     A,R7
   \   000057   D2E4         SETB    0xE0 /* A   */.4
   \   000059   80D2         SJMP    ??HalKeyRead_6
    408                }
    409                else if ((adc >= 101) && (adc <= 115))
    410                {
    411                }
    412              }
    413              else
    414              {
    415                 /* Rev C */
    416                if ((adc >= 90)  && (adc <= 104))
   \                     ??HalKeyRead_2:
   \   00005B   EA           MOV     A,R2
   \   00005C   C3           CLR     C
   \   00005D   945A         SUBB    A,#0x5a
   \   00005F   EA           MOV     A,R2
   \   000060   4007         JC      ??HalKeyRead_11
   \   000062   C3           CLR     C
   \   000063   9469         SUBB    A,#0x69
   \   000065   5013         JNC     ??HalKeyRead_4
   \   000067   80C1         SJMP    ??HalKeyRead_5
    417                {
    418                   ksave0 |= HAL_KEY_UP;
    419                }
    420                else if ((adc >= 75)  && (adc <= 89))
   \                     ??HalKeyRead_11:
   \   000069   C3           CLR     C
   \   00006A   944B         SUBB    A,#0x4b
   \   00006C   50CD         JNC     ??HalKeyRead_8
    421                {
    422                  ksave0 |= HAL_KEY_RIGHT;
    423                }
    424                else if ((adc >= 45)  && (adc <= 56))
   \   00006E   EA           MOV     A,R2
   \   00006F   C3           CLR     C
   \   000070   942D         SUBB    A,#0x2d
   \   000072   40DC         JC      ??HalKeyRead_9
   \   000074   EA           MOV     A,R2
   \   000075   C3           CLR     C
   \   000076   9439         SUBB    A,#0x39
   \   000078   40D1         JC      ??HalKeyRead_10
    425                {
    426                  ksave0 |= HAL_KEY_LEFT;
    427                }
    428                else if (adc <= 10)
    429                {
    430                  ksave0 |= HAL_KEY_DOWN;
    431                }
    432                else if ((adc >= 105) && (adc <= 121))
    433                {
    434                }
    435              }
    436          
    437            } while (ksave0 != ksave1);
   \                     ??HalKeyRead_4:
   \   00007A   E5..         MOV     A,?V0 + 0
   \   00007C   6F           XRL     A,R7
   \   00007D   7098         JNZ     ??HalKeyRead_1
    438          
    439            keys |= ksave0;
    440          
    441          #endif
    442          
    443          #endif /* HAL_KEY */
    444          
    445            return keys;
   \   00007F   EF           MOV     A,R7
   \   000080   4E           ORL     A,R6
   \   000081   F9           MOV     R1,A
   \   000082                REQUIRE ?Subroutine3
   \   000082                REQUIRE _A_P0
   \   000082                ; // Fall through to label ?Subroutine3
    446          
    447          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7A01         MOV     R2,#0x1
   \   000002   7906         MOV     R1,#0x6
   \   000004   12....       LCALL   ??HalAdcRead?relay
   \   000007   90DF60       MOV     DPTR,#-0x20a0
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   6401         XRL     A,#0x1
   \   00000D   22           RET
    448          
    449          
    450          /**************************************************************************************************
    451           * @fn      HalKeyPoll
    452           *
    453           * @brief   Called by hal_driver to poll the keys
    454           *
    455           * @param   None
    456           *
    457           * @return  None
    458           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    459          void HalKeyPoll (void)
   \                     HalKeyPoll:
    460          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    461          #if (HAL_KEY == TRUE)
    462          
    463            uint8 keys = 0;
   \   000005   75..00       MOV     ?V0 + 0,#0x0
    464          
    465          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    466            uint8 ksave0 = 0;
   \   000008   7E00         MOV     R6,#0x0
    467            uint8 ksave1;
    468            uint8 adc;
    469          #endif
    470          
    471            /*
    472            *  If interrupts are enabled, get the status of the interrupt-driven keys from 'halSaveIntKey'
    473            *  which is updated by the key ISR.  If Polling, read these keys directly.
    474            */
    475          #if defined (HAL_KEY_SW_6_ENABLE)
    476            if (!(HAL_KEY_SW_6_PORT & HAL_KEY_SW_6_BIT))    /* Key is active low */
   \   00000A   A281         MOV     C,0x80.1
   \   00000C   4003         JC      ??HalKeyPoll_0
    477            {
    478              keys |= HAL_KEY_SW_6;
   \   00000E   75..20       MOV     ?V0 + 0,#0x20
    479            }
    480          #endif
    481          #if defined (HAL_KEY_SW_5_ENABLE)
    482            if (HAL_KEY_SW_5_PORT & HAL_KEY_SW_5_BIT)       /* Key is active high */
   \                     ??HalKeyPoll_0:
   \   000011   A285         MOV     C,0x80.5
   \   000013   5006         JNC     ??HalKeyPoll_1
    483            {
    484              keys |= HAL_KEY_SW_5;
   \   000015   E5..         MOV     A,?V0 + 0
   \   000017   D2E2         SETB    0xE0 /* A   */.2
   \   000019   F5..         MOV     ?V0 + 0,A
    485            }
    486          #endif
    487          
    488          #if defined (HAL_KEY_JOYSTICK_ENABLE)
    489          /*
    490          *  The joystick control is encoded as an analog voltage.  Keep on reading
    491          *  the ADC until two consecutive key decisions are the same.
    492          */
    493          
    494            do
    495            {
    496              ksave1 = ksave0;    /* save previouse key reading */
   \                     ??HalKeyPoll_1:
   \   00001B   EE           MOV     A,R6
   \   00001C   FF           MOV     R7,A
    497          
    498              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
   \   00001D                ; Setup parameters for call to function HalAdcRead
   \   00001D   12....       LCALL   ?Subroutine0 & 0xFFFF
    499          
    500              if  (CHVER == 0x01)
   \                     ??CrossCallReturnLabel_1:
   \   000020   703D         JNZ     ??HalKeyPoll_2
    501              {
    502                /* Rev B */
    503                if ((adc >= 90) && (adc <= 100))
   \   000022   EA           MOV     A,R2
   \   000023   C3           CLR     C
   \   000024   945A         SUBB    A,#0x5a
   \   000026   EA           MOV     A,R2
   \   000027   400B         JC      ??HalKeyPoll_3
   \   000029   C3           CLR     C
   \   00002A   9465         SUBB    A,#0x65
   \   00002C   5050         JNC     ??HalKeyPoll_4
    504                {
    505                   ksave0 |= HAL_KEY_UP;
   \                     ??HalKeyPoll_5:
   \   00002E   EE           MOV     A,R6
   \   00002F   D2E0         SETB    0xE0 /* A   */.0
   \                     ??HalKeyPoll_6:
   \   000031   FE           MOV     R6,A
   \   000032   804A         SJMP    ??HalKeyPoll_4
    506                }
    507                else if ((adc >= 75) && (adc <= 85))
   \                     ??HalKeyPoll_3:
   \   000034   C3           CLR     C
   \   000035   944B         SUBB    A,#0x4b
   \   000037   EA           MOV     A,R2
   \   000038   400A         JC      ??HalKeyPoll_7
   \   00003A   C3           CLR     C
   \   00003B   9456         SUBB    A,#0x56
   \   00003D   503F         JNC     ??HalKeyPoll_4
    508                {
    509                  ksave0 |= HAL_KEY_RIGHT;
   \                     ??HalKeyPoll_8:
   \   00003F   EE           MOV     A,R6
   \   000040   D2E1         SETB    0xE0 /* A   */.1
   \   000042   80ED         SJMP    ??HalKeyPoll_6
    510                }
    511                else if ((adc >= 45) && (adc <= 55))
   \                     ??HalKeyPoll_7:
   \   000044   C3           CLR     C
   \   000045   942D         SUBB    A,#0x2d
   \   000047   400B         JC      ??HalKeyPoll_9
   \   000049   EA           MOV     A,R2
   \   00004A   C3           CLR     C
   \   00004B   9438         SUBB    A,#0x38
   \   00004D   502F         JNC     ??HalKeyPoll_4
    512                {
    513                  ksave0 |= HAL_KEY_LEFT;
   \                     ??HalKeyPoll_10:
   \   00004F   EE           MOV     A,R6
   \   000050   D2E3         SETB    0xE0 /* A   */.3
   \   000052   80DD         SJMP    ??HalKeyPoll_6
    514                }
    515                else if (adc <= 10)
   \                     ??HalKeyPoll_9:
   \   000054   EA           MOV     A,R2
   \   000055   C3           CLR     C
   \   000056   940B         SUBB    A,#0xb
   \   000058   5024         JNC     ??HalKeyPoll_4
    516                {
    517                  ksave0 |= HAL_KEY_DOWN;
   \   00005A   EE           MOV     A,R6
   \   00005B   D2E4         SETB    0xE0 /* A   */.4
   \   00005D   80D2         SJMP    ??HalKeyPoll_6
    518                }
    519                else if ((adc >= 101) && (adc <= 115))
    520                {
    521                }
    522              }
    523              else
    524              {
    525                 /* Rev C */
    526                if ((adc >= 90)  && (adc <= 104))
   \                     ??HalKeyPoll_2:
   \   00005F   EA           MOV     A,R2
   \   000060   C3           CLR     C
   \   000061   945A         SUBB    A,#0x5a
   \   000063   EA           MOV     A,R2
   \   000064   4007         JC      ??HalKeyPoll_11
   \   000066   C3           CLR     C
   \   000067   9469         SUBB    A,#0x69
   \   000069   5013         JNC     ??HalKeyPoll_4
   \   00006B   80C1         SJMP    ??HalKeyPoll_5
    527                {
    528                   ksave0 |= HAL_KEY_UP;
    529                }
    530                else if ((adc >= 75)  && (adc <= 89))
   \                     ??HalKeyPoll_11:
   \   00006D   C3           CLR     C
   \   00006E   944B         SUBB    A,#0x4b
   \   000070   50CD         JNC     ??HalKeyPoll_8
    531                {
    532                  ksave0 |= HAL_KEY_RIGHT;
    533                }
    534                else if ((adc >= 45)  && (adc <= 56))
   \   000072   EA           MOV     A,R2
   \   000073   C3           CLR     C
   \   000074   942D         SUBB    A,#0x2d
   \   000076   40DC         JC      ??HalKeyPoll_9
   \   000078   EA           MOV     A,R2
   \   000079   C3           CLR     C
   \   00007A   9439         SUBB    A,#0x39
   \   00007C   40D1         JC      ??HalKeyPoll_10
    535                {
    536                  ksave0 |= HAL_KEY_LEFT;
    537                }
    538                else if (adc <= 10)
    539                {
    540                  ksave0 |= HAL_KEY_DOWN;
    541                }
    542                else if ((adc >= 105) && (adc <= 121))
    543                {
    544                }
    545              }
    546          
    547          
    548            } while (ksave0 != ksave1);
   \                     ??HalKeyPoll_4:
   \   00007E   EF           MOV     A,R7
   \   00007F   6E           XRL     A,R6
   \   000080   7099         JNZ     ??HalKeyPoll_1
    549          
    550            keys |= ksave0;
   \   000082   EE           MOV     A,R6
   \   000083   42..         ORL     ?V0 + 0,A
    551          
    552          #endif
    553          
    554            /* Exit if polling and no keys have changed */
    555            if (!Hal_KeyIntEnable)
   \   000085   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000088   E0           MOVX    A,@DPTR
   \   000089   700B         JNZ     ??HalKeyPoll_12
    556            {
    557              if (keys == halKeySavedKeys)
   \   00008B   90....       MOV     DPTR,#halKeySavedKeys
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   65..         XRL     A,?V0 + 0
   \   000091   6023         JZ      ??HalKeyPoll_13
    558              {
    559                return;
    560              }
    561              halKeySavedKeys = keys;     /* Store the current keys for comparation next time */
   \   000093   E5..         MOV     A,?V0 + 0
   \   000095   F0           MOVX    @DPTR,A
    562            }
    563          
    564            /* Invoke Callback if new keys were depressed */
    565            if (keys && (pHalKeyProcessFunction))
   \                     ??HalKeyPoll_12:
   \   000096   E5..         MOV     A,?V0 + 0
   \   000098   601C         JZ      ??HalKeyPoll_13
   \   00009A   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   7002         JNZ     ??HalKeyPoll_14
   \   0000A0   A3           INC     DPTR
   \   0000A1   E0           MOVX    A,@DPTR
   \                     ??HalKeyPoll_14:
   \   0000A2   6012         JZ      ??HalKeyPoll_13
    566            {
    567              (pHalKeyProcessFunction) (keys, HAL_KEY_STATE_NORMAL);
   \   0000A4                ; Setup parameters for indirect call
   \   0000A4   7A00         MOV     R2,#0x0
   \   0000A6   A9..         MOV     R1,?V0 + 0
   \   0000A8   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   F8           MOV     R0,A
   \   0000AD   A3           INC     DPTR
   \   0000AE   E0           MOVX    A,@DPTR
   \   0000AF   F583         MOV     DPH,A
   \   0000B1   8882         MOV     DPL,R0
   \   0000B3   12....       LCALL   ?CALL_IND
   \                     ??HalKeyPoll_13:
   \   0000B6   02....       LJMP    ?Subroutine3 & 0xFFFF
   \   0000B9                REQUIRE _A_P0
    568            }
    569          
    570          #endif /* HAL_KEY */
    571          
    572          }
    573          
    574          
    575          /**************************************************************************************************
    576           * @fn      halProcessKeyInterrupt
    577           *
    578           * @brief   Checks to see if it's a valid key interrupt, saves interrupt driven key states for
    579           *          processing by HalKeyRead(), and debounces keys by scheduling HalKeyRead() 25ms later.
    580           *
    581           * @param
    582           *
    583           * @return
    584           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    585          void halProcessKeyInterrupt (void)
   \                     halProcessKeyInterrupt:
    586          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    587          
    588          #if (HAL_KEY == TRUE)
    589          
    590            bool    valid=FALSE;
   \   000004   7A00         MOV     R2,#0x0
    591          
    592          #if defined (HAL_KEY_SW_6_ENABLE)
    593            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)      /* Interrupt Flag has been set */
   \   000006   E589         MOV     A,0x89
   \   000008   A2E1         MOV     C,0xE0 /* A   */.1
   \   00000A   5004         JNC     ??halProcessKeyInterrupt_0
    594            {
    595              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT);    /* Clear Interrupt Flag */
   \   00000C   7589FD       MOV     0x89,#-0x3
    596              valid = TRUE;
   \   00000F   0A           INC     R2
    597            }
    598          #endif
    599          
    600          #if defined (HAL_KEY_SW_5_ENABLE)
    601            if (HAL_KEY_SW_5_PXIFG & HAL_KEY_SW_5_BIT)      /* Interrupt Flag has been set */
   \                     ??halProcessKeyInterrupt_0:
   \   000010   E589         MOV     A,0x89
   \   000012   A2E5         MOV     C,0xE0 /* A   */.5
   \   000014   5005         JNC     ??halProcessKeyInterrupt_1
    602            {
    603              HAL_KEY_SW_5_PXIFG = ~(HAL_KEY_SW_5_BIT);    /* Clear Interrupt Flag */
   \   000016   7589DF       MOV     0x89,#-0x21
    604              valid = TRUE;
   \   000019   8003         SJMP    ??halProcessKeyInterrupt_2
    605            }
    606          #endif
    607          
    608            if (valid)
   \                     ??halProcessKeyInterrupt_1:
   \   00001B   EA           MOV     A,R2
   \   00001C   6010         JZ      ??halProcessKeyInterrupt_3
    609            {
    610              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_DEBOUNCE_VALUE);
   \                     ??halProcessKeyInterrupt_2:
   \   00001E                ; Setup parameters for call to function osal_start_timerEx
   \   00001E   7C19         MOV     R4,#0x19
   \   000020   7D00         MOV     R5,#0x0
   \   000022   7A01         MOV     R2,#0x1
   \   000024   7B00         MOV     R3,#0x0
   \   000026   90....       MOV     DPTR,#Hal_TaskID
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F9           MOV     R1,A
   \   00002B   12....       LCALL   ??osal_start_timerEx?relay
    611            }
    612          #endif /* HAL_KEY */
    613          }
   \                     ??halProcessKeyInterrupt_3:
   \   00002E   80..         SJMP    ??Subroutine2_0
   \   000030                REQUIRE P0IFG
    614          
    615          /**************************************************************************************************
    616           * @fn      HalKeyEnterSleep
    617           *
    618           * @brief  - Get called to enter sleep mode
    619           *
    620           * @param
    621           *
    622           * @return
    623           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    624          void HalKeyEnterSleep ( void )
   \                     HalKeyEnterSleep:
    625          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    626            /* Sleep!!! Note that HAL_KEY_SW_5 is shared with CTS pin of RS-232.
    627             * It was set to tri-state during active state. It needs to be pulled-up.
    628             */
    629          #if defined (HAL_KEY_SW_5_ENABLE)
    630            HAL_KEY_SW_5_INP &= ~HAL_KEY_SW_5_BIT;       /* Set pin input mode to pull-up */
   \   000000   538FDF       ANL     0x8f,#0xdf
    631          #endif
    632          }
   \   000003   02....       LJMP    ?BRET
   \   000006                REQUIRE P0INP
    633          
    634          /**************************************************************************************************
    635           * @fn      HalKeyExitSleep
    636           *
    637           * @brief   - Get called when sleep is over
    638           *
    639           * @param
    640           *
    641           * @return  - return saved keys
    642           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    643          uint8 HalKeyExitSleep ( void )
   \                     HalKeyExitSleep:
    644          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    645            /* Wakeup!!! Note that HAL_KEY_SW_5 is shared with CTS pin of RS-232.
    646             * It was pulled up during sleep. It needs to be set to tri-state during active state.
    647             */
    648          #if defined (HAL_KEY_SW_5_ENABLE)
    649            HAL_KEY_SW_5_INP |= HAL_KEY_SW_5_BIT;       /* Set pin input mode to tri-state */
   \   000004   438F20       ORL     0x8f,#0x20
    650          #endif
    651          
    652            /* Wake up and read keys */
    653            return ( HalKeyRead () );
   \   000007                ; Setup parameters for call to function HalKeyRead
   \   000007   12....       LCALL   ??HalKeyRead?relay
   \   00000A   80..         SJMP    ??Subroutine2_0
   \   00000C                REQUIRE P0INP
    654          }
    655          
    656          /***************************************************************************************************
    657           *                                    INTERRUPT SERVICE ROUTINE
    658           ***************************************************************************************************/
    659          
    660          /**************************************************************************************************
    661           * @fn      halKeyPort0Isr
    662           *
    663           * @brief   Port0 ISR
    664           *
    665           * @param
    666           *
    667           * @return
    668           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    669          HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
   \                     halKeyPort0Isr:
    670          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    671            /* P0IF is cleared by HW for CHVER < REV_E */
    672          
    673            halProcessKeyInterrupt();
   \   000007                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000007   12....       LCALL   ?Subroutine1
    674          
    675            if( CHVER >= REV_E )
   \                     ??CrossCallReturnLabel_2:
   \   00000A   4005         JC      ??halKeyPort0Isr_0
    676            {
    677              /* Make sure that we clear all enabled, but unused P0IFG bits.
    678               * For P0 we can only enable or disable high or low nibble, not bit by
    679               * bit. For P1 and P2 enabling of single bits are possible, therefore
    680               * will not any unused pins generate interrupts on P1 or P2.
    681               * We could have checked for low and high nibble in P0, but this
    682               * isn't necessary as long as we only clear unused pin interrupts.
    683               */
    684              P0IFG = (HAL_KEY_P0INT_LOW_USED | HAL_KEY_POINT_HIGH_USED);
   \   00000C   758922       MOV     0x89,#0x22
    685              P0IF = 0;
   \   00000F   C2C5         CLR     0xc0.5
    686              CLEAR_SLEEP_MODE();
    687            }
    688          }
   \                     ??halKeyPort0Isr_0:
   \   000011                REQUIRE ?Subroutine4
   \   000011                REQUIRE P0IFG
   \   000011                REQUIRE _A_IRCON
   \   000011                ; // Fall through to label ?Subroutine4

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?INTERRUPT_LEAVE_XSP

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ??halProcessKeyInterrupt?relay
   \   000003   90DF60       MOV     DPTR,#-0x20a0
   \   000006   E0           MOVX    A,@DPTR
   \   000007   C3           CLR     C
   \   000008   9404         SUBB    A,#0x4
   \   00000A   22           RET
    689          
    690          /**************************************************************************************************
    691           * @fn      halKeyPort1Isr
    692           *
    693           * @brief   Port1 ISR
    694           *
    695           * @param
    696           *
    697           * @return
    698           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    699          HAL_ISR_FUNCTION( halKeyPort1Isr, P1INT_VECTOR )
   \                     halKeyPort1Isr:
    700          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    701            if( CHVER <= REV_D )
   \   000007   90DF60       MOV     DPTR,#-0x20a0
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   C3           CLR     C
   \   00000C   9404         SUBB    A,#0x4
   \   00000E   5002         JNC     ??halKeyPort1Isr_0
    702            {
    703              P1IF = 0;
   \   000010   C2EB         CLR     0xe8.3
    704            }
    705          
    706            halProcessKeyInterrupt();
   \                     ??halKeyPort1Isr_0:
   \   000012                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000012   12....       LCALL   ?Subroutine1
    707          
    708            if( CHVER >= REV_E )
   \                     ??CrossCallReturnLabel_3:
   \   000015   4002         JC      ??halKeyPort1Isr_1
    709            {
    710              P1IF = 0;
   \   000017   C2EB         CLR     0xe8.3
    711              CLEAR_SLEEP_MODE();
    712            }
    713          }
   \                     ??halKeyPort1Isr_1:
   \   000019   80..         SJMP    ?Subroutine4
   \   00001B                REQUIRE _A_IRCON2
    714          
    715          /**************************************************************************************************
    716           * @fn      halKeyPort2Isr
    717           *
    718           * @brief   Port2 ISR
    719           *
    720           * @param
    721           *
    722           * @return
    723           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    724          HAL_ISR_FUNCTION( halKeyPort2Isr, P2INT_VECTOR )
   \                     halKeyPort2Isr:
    725          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    726            if( CHVER <= REV_D )
   \   000007   90DF60       MOV     DPTR,#-0x20a0
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   C3           CLR     C
   \   00000C   9404         SUBB    A,#0x4
   \   00000E   5002         JNC     ??halKeyPort2Isr_0
    727            {
    728              P2IF = 0;
   \   000010   C2E8         CLR     0xe8.0
    729            }
    730          
    731            halProcessKeyInterrupt();
   \                     ??halKeyPort2Isr_0:
   \   000012                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000012   12....       LCALL   ?Subroutine1
    732          
    733            if( CHVER >= REV_E )
   \                     ??CrossCallReturnLabel_4:
   \   000015   4002         JC      ??halKeyPort2Isr_1
    734            {
    735              P2IF = 0;
   \   000017   C2E8         CLR     0xe8.0
    736              CLEAR_SLEEP_MODE();
    737            }
    738          }
   \                     ??halKeyPort2Isr_1:
   \   000019   80..         SJMP    ?Subroutine4
   \   00001B                REQUIRE _A_IRCON2

   \                                 In  segment INTVEC, offset 0x33, root
   \                     `??halKeyPort2Isr??INTVEC 51`:
   \   000033   02....       LJMP       (halKeyPort2Isr)

   \                                 In  segment INTVEC, offset 0x6b, root
   \                     `??halKeyPort0Isr??INTVEC 107`:
   \   00006B   02....       LJMP       (halKeyPort0Isr)

   \                                 In  segment INTVEC, offset 0x7b, root
   \                     `??halKeyPort1Isr??INTVEC 123`:
   \   00007B   02....       LJMP       (halKeyPort1Isr)

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halProcessKeyInterrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halProcessKeyInterrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyEnterSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyEnterSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyExitSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyExitSleep
    739          
    740          /**************************************************************************************************
    741          **************************************************************************************************/
    742          
    743          
    744          

   Maximum stack usage in bytes:

     Function                    ISTACK PSTACK XSTACK
     --------                    ------ ------ ------
     HalKeyConfig                    2      0      0
       -> osal_stop_timerEx          4      0      0
       -> osal_start_timerEx         4      0      0
     HalKeyEnterSleep                0      0      0
     HalKeyExitSleep                 2      0      0
       -> HalKeyRead                 4      0      0
     HalKeyInit                      2      0      0
     HalKeyPoll                      0      0      9
       -> HalAdcRead                 0      0     18
     HalKeyRead                      0      0      9
       -> HalAdcRead                 0      0     18
     halKeyPort0Isr                 15      0      0
       -> halProcessKeyInterrupt    30      0      0
     halKeyPort1Isr                 15      0      0
       -> halProcessKeyInterrupt    30      0      0
     halKeyPort2Isr                 15      0      0
       -> halProcessKeyInterrupt    30      0      0
     halProcessKeyInterrupt          2      0      0
       -> osal_start_timerEx         4      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _A_P0                             1
     P0IFG                             1
     PICTL                             1
     P0INP                             1
     _A_IEN1                           1
     _A_IRCON                          1
     _A_IRCON2                         1
     P0SEL                             1
     P0DIR                             1
     halKeySavedKeys                   1
     pHalKeyProcessFunction            2
     Hal_KeyIntEnable                  1
     halSaveIntKey                     1
     HalKeyConfigured                  1
     HalKeyInit                       33
     ?Subroutine2                     11
     HalKeyConfig                     98
     HalKeyRead                      130
     ?Subroutine3                      5
     ?Subroutine0                     14
     HalKeyPoll                      185
     halProcessKeyInterrupt           48
     HalKeyEnterSleep                  6
     HalKeyExitSleep                  12
     halKeyPort0Isr                   17
     ?Subroutine4                      5
     ?Subroutine1                     11
     halKeyPort1Isr                   27
     halKeyPort2Isr                   27
     ??halKeyPort2Isr??INTVEC 51       3
     ??halKeyPort0Isr??INTVEC 107      3
     ??halKeyPort1Isr??INTVEC 123      3
     ??HalKeyInit?relay                6
     ??HalKeyConfig?relay              6
     ??HalKeyRead?relay                6
     ??HalKeyPoll?relay                6
     ??halProcessKeyInterrupt?relay    6
     ??HalKeyEnterSleep?relay          6
     ??HalKeyExitSleep?relay           6

 
 542 bytes in segment BANKED_CODE
  42 bytes in segment BANK_RELAYS
   9 bytes in segment INTVEC
  87 bytes in segment NEAR_CODE
   9 bytes in segment SFR_AN
   6 bytes in segment XDATA_Z
 
 671 bytes of CODE  memory (+ 9 bytes shared)
   0 bytes of DATA  memory (+ 9 bytes shared)
   6 bytes of XDATA memory

Errors: none
Warnings: none
